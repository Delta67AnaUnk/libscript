
\chapter{Introdução}



Existem muitas situações onde é necessário ou interessante que haja
interação entre programas escritos em diferentes linguagens. Um caso
típico é o emprego de bibliotecas externas, como \emph{toolkits} gráficos,
APIs de acesso a banco de dados, ou até mesmo chamadas ao sistema
operacional. Outro cenário ainda envolve aplicações desenvolvidas
usando mais de uma linguagem de programação a fim de otimizar partes
onde o desempenho é crítico ou permitir extensibilidade através de
\emph{scripts} escritos pelo usuário.

Independentemente da finalidade, a comunicação entre programas escritos
em linguagens diferentes traz consigo uma série de questões de projeto,
não apenas no desenvolvimento das aplicações, mas das linguagens em
si. Há várias formas de se obter esse tipo de interoperabilidade,
desde tradução de código de uma linguagem para outra até o uso de
uma máquina virtual comum. Idealmente, entretanto, uma linguagem deve
prover uma interface de acesso externo (\emph{foreign language interface},
FLI) que permita ao programador receber e enviar tanto chamadas como
dados para outra linguagem~\cite{finne98haskellfli}. Entre os fatores
que devem ser levados em consideração no desenvolvimento de tal interface
estão as diferenças entre os sistemas de tipos, problemas de gerência
de memória (como coleta de lixo e acesso direto a ponteiros) e modelos
de concorrência. Além de lidar com diferenças semânticas, o projeto
de uma interface entre linguagens envolve questões pragmáticas como
o equilíbrio entre o isolamento seguro dos ambientes de execução,
o desempenho e a simplicidade da API resultante.

Pode-se observar nas implementações existentes de FLIs um número de
abordagens para estes problemas. De fato, FLIs de diferentes linguagens
(ou mesmo de diferentes revisões de uma mesma linguagem) tendem a
ser bastante distintas entre si. Ainda assim é possível traçar paralelos
entre as técnicas utilizadas, uma vez que os problemas fundamentais
que elas atacam são os mesmos.

Em função da popularidade da linguagem C e do suporte oferecido a
ela pelos sistemas operacionais mais utilizados, grande parte das
implementações de interfaces de acesso externo são, na prática, APIs
para C. Além disso, um modelo de interação entre linguagens que tem
se mostrado especialmente relevante na atualidade é o que se dá entre
linguagens compiladas tipadas estaticamente, como C, e linguagens
interpretadas tipadas dinamicamente, tipicamente chamadas de linguagens
de script, como defendido por Ousterhout~\cite{ousterhout98scripting}.
Estas duas categorias de linguagens possuem objetivos fundamentalmente
diferentes. Linguagens estaticamente tipadas são usualmente implementadas
visando alto desempenho e possuem um enfoque de mais baixo nível.
Em contraste, linguagens de script tendem a ser implementadas como
interpretadores ou máquinas virtuais e fazem uso extensivo de construções
de alto nível, tais como listas e hashes, como sendo tipos básicos.
Estas características complementares têm tornado popular o modelo
de programação baseado em duas linguagens, onde uma linguagem de mais
baixo nível é usada para o desenvolvimento de componentes que são
conectados através de uma linguagem de mais alto nível.


\section{Objetivo}

Este trabalho discute as principais questões envolvendo o projeto
de APIs para integração de ambientes de execução de linguagens de
script em aplicações C. Apresentamos os principais problemas enfrentados
na interação entre código executando em um ambiente com características
inerentemente dinâmicas como o de uma linguagem de script com código
C. Além de se tratar da classe de linguagens mais popular atualmente
para desenvolvimento multi-linguagem, características típicas de linguagens
de script como coleta de lixo e tipagem dinâmica, por não estarem
presentes em C, ilustram bem os problemas envolvendo a comunicação
de dados entre diferentes ambientes de programação. Linguagens com
tipagem estática podem apresentar necessidades de conversão de tipos
semelhantes, mas o problema tende a ser simplificado pela definição
de tipos equivalentes na API e inferência em tempo de compilação (vide
exemplos nas API de Ada e Fortran com C). Linguagens funcionais possuem
preocupações adicionais com efeitos colaterais no código C, mas isto
é equivalente ao problema de quebra do paradigma causada pelo tratamento
de entrada e saída que todas elas enfrentam.

Este estudo consiste de duas partes. Na primeira, realizamos a análise
em profundidade de um conjunto de APIs para C providas por quatro
linguagens de script -- especificamente, Python~\cite{vanrossum06ref},
Perl~\cite{wall00perl}, Ruby~\cite{thomas04ruby}, Lua~\cite{ierusalimschy06pil2}
-- além da provida pela linguagem Java~\cite{gosling00java}. Diferentemente
das demais, Java possui tipagem estática, mas assim como elas é baseada
em um modelo de máquina virtual, possui gerência automática de memória
e permite carga dinâmica de código. Isto nos permite observar também
como a tipagem afeta o projeto da API.

Na segunda parte, ilustramos as diferenças das APIs destas linguagens
e o impacto destas no código resultante de uma aplicação C através
de um estudo de caso. Realizamos uma comparação entre as APIs das
linguagens de script através de um exemplo concreto, de modo a colocar
implementações em cada uma das linguagens lado a lado.

O exemplo consiste de uma biblioteca genérica para scripting, chamada
LibScript. Esta biblioteca foi projetada para tornar aplicações extensíveis
através de scripting de uma forma independente de linguagem. Ela é
baseada em uma arquitetura de \emph{plugins}: bibliotecas dinâmicas
carregadas sob demanda por LibScript que encapsulam a interface com
as máquinas virtuais. A biblioteca principal provê uma API para scripting
independente de linguagem, permitindo a uma aplicação registrar as
suas funções e disparar scripts que utilizem estas funções. Esta biblioteca
então invoca o plugin da linguagem apropriada para rodar o script
(por exemplo, LibScript-Lua para código Lua). Assim, o código de cada
plugin permite observar de forma clara e isolada os procedimentos
adotados em cada linguagem para chamada de funções, registro de funções
C e conversão de dados entre os ambientes.


\section{Estrutura do texto}

O trabalho está organizado da seguinte forma. No Capítulo~\ref{cha:Intera=E7=E3o-entre-linguagens},
são discutidas as várias abordagens para interação entre código escrito
em diferentes linguagens de programação. Partindo de uma visão geral,
o foco se concentrará no método de interface externa mais comum nas
linguagens da atualidade: interfaces com a linguagem C. Discutiremos
os problemas comumente envolvidos na comunicação com código C e os
modelos de programação que surgiram com a popularização da sua integração
com linguagens de script. No Capítulo~\ref{cha:APIs-de-M=E1quinas}
são apresentadas em detalhe APIs para C de um conjunto de linguagens
de script. Ao discutir estas interfaces, as diferentes soluções empregadas
para os principais problemas envolvendo interação entre C e ambientes
dinâmicos são levantadas. O Capítulo~\ref{cha:Estudo-de-caso:} exercita
estas diferentes APIs através de um estudo de caso: uma biblioteca
baseada em plugins que oferece uma interface uniforme simplificada
para linguagens de script. Ao examinar a implementação de cada plugin,
podemos comparar as APIs de cada linguagem realizando operações equivalentes.
Finalmente, no Capítulo~\ref{cha:Considera=E7=F5es-Finais} são apresentadas
as conclusões do trabalho, bem como apontados caminhos para trabalhos
futuros.


\chapter{\label{cha:Intera=E7=E3o-entre-linguagens}Interação entre linguagens
de programação}

As abordagens aplicadas na interação entre diferentes linguagens de
programação variam bastante entre si, mas é possível identificar algumas
técnicas tipicamente utilizadas: tradução de linguagens, seja de uma
para outra ou de ambas para uma terceira; comunicação através de protocolo
ou linguagem intermediária; compartilhamento de um ambiente de execução
comum, seja de máquina virtual ou através de convenção de chamadas;
e interfaces de acesso externo.


\section{Tradução de código}

Permitir o uso de duas linguagens diferentes em um programa traduzindo
o código de uma delas para a outra minimiza o problema de comunicação
entre as partes do programa escritas em linguagens diferentes, uma
vez que o programa final utilizará um espaço único de dados. Em contrapartida,
ao ter de se descrever uma linguagem em termos de outra, a diferença
de semântica das construções pode se tornar um problema. Se a linguagem
de destino não possui construções oferecidas pela linguagem de origem,
simulá-las pode ser custoso.

Um exemplo típico de problema enfrentado em ferramentas de tradução
de código é a complexidade adicionada pela simulação de funções de
alta ordem e recursão final ao traduzir-se o código de linguagens
funcionais para outra que não possui estes recursos. Tarditi et al.~\cite{tarditi92mlc}
descrevem o desenvolvimento de um tradutor de Standard ML para ANSI
C. Medições evidenciaram o custo de adaptação destes recursos de ML
para C, resultando em código em média 2 vezes mais lento que o gerado
pelo compilador ML nativo. Em~\cite{tolmach98mlada}, são discutidos
desafios similares na tradução de ML para Ada: na solução adotada,
o processo possui um passo intermediário onde as construções de alta
ordem são {}``aplainadas'' para construções de primeira ordem envolvendo
registros, para que pudessem assim ser representados em Ada.

Além de problemas como este, diferenças na representação dos dados
ainda é algo a ser tratado no processo de tradução de uma linguagem
para outra. No caso particular de~C, as facilidades de baixo nível
para manipulação de memória permitem a descrição de estruturas de
dados de linguagens de mais alto nível sem maiores problemas. Isto
faz de~C uma candidata freqüente para uso como representação de baixo
nível portável. O compilador de Haskell GHC oferece, como alternativa
à geração de código nativo, geração de código C para uso com o GCC~\cite{jones93glasgow}.
Uma das vantagens deste recurso é permitir o \emph{bootstrapping}
do compilador em novas arquiteturas, dado que o próprio GHC é escrito
em Haskell. De fato, a ubiqüitude dos compiladores C faz com que a
linguagem seja utilizada também como \emph{lingua franca} entre diferentes
linguagens, como será visto na Seção~\ref{sub:Linguagens-intermedi=E1rias}.


\section{Compartilhamento de máquinas virtuais}

Outra abordagem para a interação entre linguagens envolve o uso de
um ambiente de execução comum, como uma máquina virtual. O código
das diferentes linguagens é compilado de modo a produzir representações
compatíveis entre si, de acordo com os tipos de dados oferecidos pelo
ambiente de execução. Diversas implementações utilizam a Java Virtual
Machine~\cite{lindholm99jvm} com essa finalidade. Jython~\cite{hugunin97python}
é uma implementação da linguagem Python que produz bytecodes Java.
SMLj~\cite{benton99interlanguage} é um compilador Standard ML que
gera bytecodes Java e permite acesso de classes e métodos Java a estruturas
e funções ML e vice-versa. O fato da Java Virtual Machine não ter
sido projetada para comportar diferentes linguagens de programação,
entretanto, transparece nas limitações apresentadas por estes projetos.
SMLj define extensões à linguagem ML para permitir acesso a construções
específicas de Java; Jython possui limitações ao realizar a interface
de Python com a API de reflexão e carga dinâmica de classes de Java.
Além disso, o conjunto de instruções da máquina virtual privilegia
operações que condizem com a semântica de Java, tornando, por exemplo,
implementações de \emph{arrays} com semântica diferente menos eficientes.

O .NET Framework~\cite{box02net} é um ambiente de execução baseado
em máquina virtual que vem sendo indicado pela Microsoft como plataforma
de programação preferencial em sistemas Windows. Apesar de com ele
ter sido introduzida a linguagem C\#~\cite{csharp06spec}, o ambiente
tem como um de seus objetivos oferecer suporte a múltiplas linguagens
-- evidenciado pelo próprio nome Common Language Runtime (CLR) --
em contraste com as limitações que o ambiente de Java impõe àqueles
que tentam utilizá-lo com outras linguagens. Todavia, adaptações às
linguagens continuam necessárias com o ambiente .NET: A versão .NET
de Visual Basic inclui alterações na linguagem de modo a tornar a
sua semântica mais similar à de C\#; um novo dialeto de C++, C++/CLI,
foi introduzido adaptando o modelo de gerenciamento de memória ao
do CLR~\cite{cppcli05spec}; de forma análoga, foi desenvolvido um
novo dialeto de ML chamado F\#, para, entre outros motivos, proporcionar
melhor integração com componentes .NET desenvolvidos em outras linguagens~\cite{syme06fsharp}.

Outra implementação de uma máquina virtual para múltiplas linguagens
vem sendo feita pelo projeto Parrot~\cite{randal04perl6}. O escopo
deste projeto é mais restrito, visando ser um \emph{back-end} comum
para linguagens dinâmicas como Perl e Python. O foco do projeto, entretanto,
está atualmente na implementação de Perl 6.

Um tipo de comunicação que pode ser considerado também uma forma de
ambiente de execução comum é a comunicação entre executáveis e bibliotecas
nativas através de convenções de chamada: regras para a passagem de
parâmetros na pilha de execução, uso de registradores e \emph{mangling}
de nomes. Este pode ser considerado o método de interação entre código
em diferentes linguagens de mais baixo nível. Convenções de chamada,
entretanto, são um recurso limitado de comunicação, já que assumem
tipos de dados com representação em memória idêntica nas duas linguagens.
Tal compatibilidade dificilmente ocorre a não ser que uma das linguagens
explicitamente considere este tipo de interação na sua definição:
o padrão de Ada, por exemplo, requer que as suas implementações sejam
compatíveis com as convenções de C, COBOL e Fortran~\cite{ada95manual}.
De forma similar, C++ permite especificar funções com linkagem compatível
com C, através da diretiva \texttt{extern \char`\"{}C\char`\"{}}.


\section{\label{sub:Modelos-de-objetos}Modelos de objetos independentes de
linguagem}

Adotar um modelo de tipos independente de linguagem é uma outra forma
de tratar as questões de interoperabilidade de dados entre linguagens.
Assim, na definição dos dados de uma aplicação, as suas interfaces
são definidas de forma neutra, tipicamente utilizando alguma linguagem
projetada especificamente para este fim (uma IDL, \emph{interface
description language}) enquanto as implementações são feitas nas linguagens
específicas. A arquitetura CORBA (\emph{Common Object Request Broker
Architecture})~\cite{omg02corba} é uma das principais representantes
deste modelo. A motivação principal para o desenvolvimento de CORBA
foi permitir o desenvolvimento de aplicações distribuídas em ambientes
heterogêneos; a heterogeneidade de linguagens foi um dos aspectos
levados em consideração.

Os desafios existentes ao projetar um modelo de dados ou objetos {}``independente
de linguagens'', entretanto, são parecidos com os de uma interface
entre duas linguagens quaisquer, já que esse modelo, por sua vez,
descreve também um sistema de tipos. Ao implementar \emph{bindings}
para algum destes modelos de objetos é necessário definir uma correspondência
entre os tipos definidos pelo modelo e os oferecidos pela linguagem
destino e prover a esta uma API para interação com o ambiente de execução
-- no caso de CORBA, com o ORB (\emph{Object Request Broker}). 

Se por um lado a tarefa pode ser facilitada pelo fato de o modelo
ter sido projetado visando interação com outras linguagens (diferentemente,
por exemplo, do sistema de tipos de C), por outro espera-se usualmente
um grau de transparência maior na representação dos dados. Por exemplo,
enquanto em uma aplicação integrando C++ e Python a distinção entre
objetos C++ e objetos Python é clara e a API Python define o limite
entre os dois universos, em uma aplicação desenvolvida utilizando
CORBA espera-se que, tanto em uma linguagem como em outra, a manipulação
dos objetos seja igual, sejam eles implementados em C++ ou Python.
Para isso, a solução adotada é o uso de \emph{stubs}, objetos que
dão uma aparência nativa uniforme aos dados, indepentemente da linguagem
em que foram implementados e, no caso de modelos distribuídos como
CORBA, da localização dos mesmos na rede. A correspondência entre
os ciclos de vida dos \emph{stubs} e dos objetos que eles representam
é outro fator que deve ser levado em consideração. Nos \emph{bindings}
Java, por exemplo, isto é realizado com o auxílio do coletor de lixo
da própria linguagem. Já em linguagens como C++ o controle das referências
é explícito.

Outras abordagens de mais alto nível têm sido propostas para a integração
de aplicações desenvolvidas em múltiplas linguagens. Linguagens de
coordenação como Linda~\cite{gelernter85linda} e Opus~\cite{chapman97opus}
definem mecanismos para troca de mensagens e um conjunto restrito
de construções para indicar o fluxo destas entre agentes implementados
em outras linguagens.


\section{\label{sub:Linguagens-intermedi=E1rias}C como linguagem intermediária}

O desejo de uma linguagem intermediária universal é antigo no mundo
da computação. Diversas propostas surgiram ao longo dos anos, desde
o projeto UNCOL~\cite{conway58uncol} às linguagens de sintaxe extensível
da década de 70~\cite{metzner79extensible} até os mais recentes
ambientes de máquina virtual como .NET. Na prática, as necessidades
que estes projetos visavam atender vêm sendo supridas ao longo dos
anos de forma mais pragmática, ainda que menos ideal, usando C. Dois
motivos fazem de C uma escolha comum como linguagem intermediária.
Primeiro, a sua característica de linguagem de {}``médio nível'',
ao permitir ao mesmo tempo independência de hardware e manipulação
direta de memória. Segundo, a grande disponibilidade de compiladores
C, alavancada pela proliferação dos sistemas Unix nas mais diferentes
arquiteturas. Assim, com o passar do tempo, oferecer uma interface
para interoperabilidade com outras linguagens passou a significar
oferecer uma interface para comunicação com código C. Isto é especialmente
verdadeiro para linguagens dinâmicas que oferecem recursos para extensibilidade
de aplicações. Não por acaso, estas são tipicamente implementadas
em C.

A disponibilidade de APIs para C oferecidas pelas diferentes linguagens
faz com que C seja bastante usada também como {}``ponte''. A integração
entre Python e Fortran se dá através de um módulo Python escrito em
C que acessa uma biblioteca Fortran, que por sua vez expõe funções
com convenção de chamada compatível com C~\cite{peterson01fortranpy}.
LunaticPython~\cite{niemeyer06lunaticpython} oferece pontes de Lua
para Python e de Python para Lua, implementadas através de um par
de módulos de extensão para cada linguagem de origem escritos em C.

Todavia, linguagens intermediárias genéricas continuam a ser propostas
como alternativas a C. C-\hspace{1pt}-~\cite{jones99cminusminus}
é um projeto que tenta superar as limitações de C enquanto linguagem
intermediária tornando mais explícita a representação em memória dos
tipos de dados e adicionando suporte a construções não facilmente
representáveis em C, como recursão final. Versões recentes da suíte
de compiladores GCC padronizaram uma linguagem intermediária para
comunicação entre os seus diversos \emph{back-ends} e \emph{front-ends}~\cite{dvorak05gcc}.


\section{\label{cha:Interfaces-com-C}Interfaces com C}

A linguagem C tem, na atualidade, um papel especial no mundo das linguagens
de programação. Além de ser bastante utilizada na implementação de
compiladores, interpretadores e máquinas virtuais (as principais implementações
de Perl, Python, Ruby, e Lua são apenas alguns exemplos), é também
usada em compiladores como formato de saída na geração de código portável
(dois exemplos notáveis são os compiladores GHC e SmartEiffel~\cite{collin97smalleiffel},
que geram C a partir de Haskell e Eiffel, respectivamente). Isto faz
com que a API para C seja um formato conveniente para uma interface
de acesso externo.

Na grande maioria dos casos, a representação interna de código produzida
por compiladores de outras linguagens não é compatível com C, seja
por diferenças em convenções de chamadas ou de nomes, ou por produzirem
código para execução em máquinas virtuais. Desta forma, para permitir
a um programa em C acessar este código, cabe à linguagem expor uma
biblioteca de funções C que realizem a tradução necessária. Em ambientes
de máquina virtual, esta biblioteca de funções normalmente é genérica,
oferecendo facilidades para comunicação com a própria máquina virtual.
Para linguagens estáticas, usualmente é necessário criar uma biblioteca
específica que realize a conversão das chamadas, como ocorre em interfaces
que expõem bibliotecas C++ para C. Um exemplo disto é QtC~\cite{kdebindings},
uma biblioteca de bindings C para o toolkit gráfico Qt, que é implementado
em C++.

Para linguagens não imperativas, há ainda o problema de código C potencialmente
gerar efeitos colaterais. Algum recurso para isolamento das chamadas
deve ser oferecido. No GHC, a construção para chamadas em C, \texttt{\_ccall\_},
é definida na mônada de IO; no adendo do padrão Haskell 98, a diretiva
\texttt{ccall} foi integrada, mas o uso da mônada é opcional, cabendo
ao programador garantir que funções que não a utilizem sejam puras%
\footnote{Diversas convenções de chamada são definidas (\texttt{stdcall}, \texttt{cplusplus},
\texttt{jvm}, \texttt{dotnet}) mas \texttt{ccall} é a única declarada
como obrigatória pelo documento.%
}.

Outra possível fonte de incompatibilidade entre linguagens que deve
ser tratada quando estas interagem é a diferença entre modelos de
concorrência. C, em particular, não define construções de concorrência,
sendo estas implementadas através de bibliotecas. Ao mesmo tempo que
isto traz grande flexibilidade à linguagem, implica também em problemas
de portabilidade para linguagens que dependam da disponibilidade de
mecanismos de concorrência em C compatíveis com os modelos que elas
utilizam.

Por exemplo, APIs entre C e Java devem levar em conta o modelo de
\emph{multithreading} preemptivo adotado por Java. A JNI (\emph{Java
Native Interface})~\cite{liang99jni} define funções para controlar
exclusão mútua entre dados compartilhados entre as duas linguagens.
O programador deve tomar o cuidado de buscar o equilíbrio entre o
tempo gasto bloqueando a máquina virtual acessando dados compartilhados
e o tempo gasto realizando cópia de dados entre os ambientes para
reduzir o compartilhamento. Outra situação em que o modelo de concorrência
da linguagem demanda cuidados por parte do programador na integração
com C ocorre no uso de co-rotinas em Lua. A combinação de dois recursos
de Lua, multitarefa cooperativa com múltiplas pilhas de execução e
a capacidade de alternar entre chamadas a funções Lua e C em uma pilha,
traz consigo uma limitação: uma co-rotina não pode executar a operação
de \emph{yield} caso haja uma função C na sua pilha, uma vez que não
há uma forma portável de alternar entre múltiplas pilhas em C~\cite{moura04colua}.

Uma das motivações mais freqüentes para integração com código C é
o uso de bibliotecas externas. Expor uma biblioteca C através da FLI
para acesso em uma linguagem pode incorrer no registro de centenas
de funções. É comum definir também tipos de dados que dêem às estruturas
definidas pela biblioteca uma aparência mais nativa, como por exemplo
converter funções C que registram \emph{callbacks} em métodos Ruby
que aceitam blocos de código como parâmetro. Essas inicializações
e adaptações são usualmente definidas em uma biblioteca de \emph{bindings},
que serve de ponte entre a linguagem e a biblioteca C encapsulando
a interação com a FLI.

Os padrões que ocorrem na produção de bindings são tão comuns que
deram origem a programas que visam automatizar o processo. Estes geradores
de bindings costumam trabalhar a partir de alguma representação preparada
para o seu uso, já que analisar os cabeçalhos C pode-se mostrar insuficiente:
por exemplo, o programa muitas vezes não seria capaz de interpretar
a intenção de uma construção como \texttt{int{*}{*}}. SWIG~\cite{beazley96swig}
é uma ferramenta multi-linguagem para geração de bindings de bibliotecas
C e C++ popular que utiliza um formato próprio para descrição de interfaces.
FLIs podem ainda utilizar geradores de \emph{stubs} para poupar o
programador de escrever código C repetitivo ou não portável. Java
possui um gerador de cabeçalhos C contendo os protótipos dos métodos
nativos a serem implementados. Pyrex~\cite{ewing06pyrex} é um gerador
de módulos C para Python a partir de uma sintaxe baseada na própria
linguagem Python. Outro exemplo é toLua++~\cite{manzur06tolua},
uma ferramenta para integrar código C e C++ a Lua, que gera stubs
a partir de arquivos de cabeçalhos C preparados para uso pelo programa,
podendo conter anotações que auxiliem o processo de conversão.


\section{Linguagens de script}

Um modelo de interação entre linguagens que tem se mostrado especialmente
relevante na atualidade é o que se dá entre linguagens compiladas
tipadas estaticamente, como C e C++, e linguagens interpretadas tipadas
dinamicamente, como Perl e Python. Em~\cite{ousterhout98scripting},
Ousterhout categoriza estes dois grupos como \emph{linguagens de programação
de sistemas} e \emph{linguagens de script}.

Estas duas categorias de linguagens possuem objetivos fundamentalmente
diferentes. Linguagens de programação de sistemas surgiram como alternativa
ao assembly no desenvolvimento de aplicações, tendo como principais
características a tipagem estática, o que facilita a compreensão das
estruturas de dados de sistemas grandes, e a implementação através
de compiladores, devido a preocupações com o desempenho. Em contraste,
linguagens de script são tipadas dinamicamente e implementadas como
interpretadores ou máquinas virtuais. A tipagem dinâmica e o uso extensivo
de construções de alto nível como tipos básicos, como listas e hashes,
traz maior flexibilidade na interação entre componentes; em linguagens
estáticas, o sistema de tipos impõe restrições a estas interações,
muitas vezes exigindo que o programador escreva interfaces de adaptação,
o que torna o reuso de componentes mais difícil.

Ousterhout aponta que, num modelo integrando estes dois tipos de linguagens,
a tendência é que linguagens de programação de sistemas não sejam
mais usadas para escrever aplicações inteiras, mas passem a ser usadas
para a implementação de componentes, que por sua vez são conectados
através de código escrito com linguagens de script. A conveniência
oferecida por linguagens interpretadas de alto nível permite prototipagem
rápida e encoraja o reuso de componentes.


\subsection{Linguagens extensíveis e de extensão}

Com a popularização de linguagens de script, o modelo de desenvolvimento
baseado em duas linguagens, passou a ser encarado de duas formas:
além do modelo onde a linguagem de script tem função acessória, onde
scripts escritos pelo usuário permitem customizações de aplicações,
há também um modelo onde a linguagem de script desempenha um papel
mais central na execução. Exemplos típicos são aplicações gráficas
onde a interface é descrita por linguagens de script controlando componentes
implementados em C e jogos onde a lógica é descrita em scripts e a
\emph{engine} de execução é implementada em linguagens de mais baixo
nível.

Nestes cenários, existe claramente uma distinção entre uma camada
de mais baixo nível onde desempenho é um fator crítico e outra de
alto nível que se caracteriza por operações de coordenação de elementos
da camada inferior. Linguagens de script deixam de ser apenas um mecanismo
de extensão: a aplicação em si é escrita usando a linguagem de script
e bibliotecas escritas em linguagens de mais baixo nível são carregadas
por esta como módulos de extensão.

Faz sentido então, ao discutirmos interação entre linguagens, fazermos
a distinção entre \emph{linguagens extensíveis} e \emph{linguagens
de extensão}. Linguagens extensíveis são aquelas que podem ser estendidas
através de módulos externos implementados em outras linguagens. Linguagens
de extensão são aquelas cujo ambiente de execução pode ser embutido
em uma aplicação, permitindo assim usá-las para estender a aplicação.
Tipicamente, linguagens de script podem ser usadas, com maior ou menor
grau de conveniência, como linguagens extensíveis e linguagens de
extensão. O foco da linguagem em um ou outro cenário tende a se refletir
no projeto de sua FLI, como veremos na comparação entre as APIs de
diferentes linguagens ao longo do Capítulo \ref{cha:APIs-de-M=E1quinas}.

Outra observação interessante é que, enquanto em um modelo a linguagem
de script serve como linguagem de extensão para a linguagem de baixo
nível em que a aplicação é escrita, no outro modelo ocorre o contrário:
podemos encarar módulos de extensão escritos utilizando a FLI como
uma forma de estender a linguagem de script usando C como linguagem
de extensão. Desta forma, o conjunto de funcionalidades providas por
uma API entre C e uma linguagem de script tende a ser simétrico nos
dois sentidos caso se queira permitir tanto extensibilidade da linguagem
como o seu uso como linguagem de extensão.


\subsection{Tcl}

A integração de programas desenvolvidos em linguagens de programação
de sistemas coordenados através de linguagens de script é prática
comum há bastante tempo. Shell scripting em sistemas Unix é provavelmente
o exemplo mais célebre, onde construções como pipes (que conectam
a saída de um processo à entrada de outro) permitem realizar tarefas
combinando uma série de programas implementados em outras linguagens,
ou mesmo outros scripts.

Aplicações gráficas interativas não se encaixam bem a este modelo
de programabilidade. A partir desta observação, Ousterhout identificou
a necessidade de mover a linguagem de coordenação para \emph{dentro}
das aplicações, criando a linguagem Tcl \cite{ousterhout94tcl}, que
adaptou o modelo de interação promovido por linguagens de shell para
a manipulação de funções de uma aplicação.

No modelo de Tcl, a linguagem de script é implementada como uma biblioteca
e é embutida em uma aplicação escrita em uma linguagem de mais baixo
nível, como C. Estruturas de dados da aplicação são expostas ao ambiente
de script como objetos manipuláveis; em contrapartida, a aplicação
pode disparar funções na linguagem de script e acessar os seus dados.

Quatro objetivos principais foram destacados no projeto original de
Tcl \cite{ousterhout90tcl}: foco como linguagem para comandos (voltada
para escrever programas curtos); extensibilidade; simplicidade na
implementação; e interface simples com aplicações C. Desde já observamos
os princípios que hoje são entendidos como os fundamentos de linguagens
extensíveis e de extensão: extensibilidade foi listada como objetivo
explicitamente; os dois últimos objetivos (e o último em particular)
demonstram o foco de Tcl como linguagem de extensão.

Tendo em vista simplificar a interação com código C, Tcl utiliza strings
como o tipo único de dados (conforme o contexto, strings podem ser
interpretadas como por exemplo listas, números ou blocos de código
Tcl). A API da linguagem, então, realiza a comunicação entre código
C e o interpretador Tcl através de strings C. A influência do modelo
de interação entre programas em shell scripting transparece na forma
como código C se comunica com funções Tcl: parâmetros são recebidos
em C a partir de Tcl usando um inteiro e um array C de strings, como
nos parâmetros da função \texttt{main} de C. Uma função C a ser exposta
para o interpretador Tcl deve seguir a seguinte assinatura:

\begin{lyxcode}
{\small typedef~int~({*}Tcl\_CmdProc)~(ClientData~c,~Tcl\_Interp~{*}i,}~\\
~{\small ~~~~~~~~~~~~~~~~~~~~~~~~~~~int~argc,~char{*}~argv{[}{]});}{\small \par}
\end{lyxcode}


Chamadas a Tcl a partir de C são feitas enviando uma string de código
Tcl para execução:

\begin{lyxcode}
{\small int~Tcl\_Eval(Tcl\_Interp~{*}i,~char{*}~cmd);}{\small \par}
\end{lyxcode}


O valor de retorno indica o sucesso ou erro da função, e a string
de retorno do código Tcl pode ser obtida em \texttt{i->result}. Embora
simples, esta abordagem possui algumas limitações significativas:
a conversão constante de strings afeta o desempenho negativamente;
além disso, a API limitada a strings faz com que código C tenha que
realizar uma série de conversões explicitamente, mesmo em operações
tão básicas quanto passar um inteiro como parâmetro.

Com o passar dos anos, outras linguagens de script apresentaram propostas
diferentes para interação com código C. Além disso, o minimalismo
de Tcl, que se mostrou uma vantagem da linguagem enquanto linguagem
de extensão, faz com que ela pareça limitada frente a linguagens como
Python, que provêem uma base mais completa enquanto linguagem extensível.
As linguagens de script foram além do primeiro objetivo de Tcl (foco
como linguagem de comandos, para programas curtos). Assim, Tcl gradualmente
perdeu espaço como linguagem de script. Neste trabalho, nosso foco
irá se concentrar em APIs modernas de linguagens de script populares
na atualidade.

De fato, versões mais recentes de Tcl adotam um modelo de dados similar
ao de linguagens de script mais modernas \cite{welch95tcl}, abandonando
a manipulação puramente por strings ao definir um tipo C \texttt{Tcl\_Obj}
que corresponde a um valor Tcl. Esta nova API, assim, não é muito
diferente da API de Python, que também possui um tipo C \texttt{PyObject},
que será discutido na Seção \ref{sub:Dados-Python}. Embora estas
mudanças resolvam alguns dos problemas de desempenho da versão original
de Tcl, elas trazem também outros problemas: por questões de compatibilidade,
objetos carregam ainda a representação do dado como string; além disso,
contagem de referências passa a ser uma preocupação (também compartilhada
pela API de Python -- o problema é discutido na Seção \ref{sub:Python-GC}). 

A importância histórica de Tcl, entretanto, é inegável. Embora aplicações
programáveis já existissem bem antes do seu surgimento, tipicamente
usando pequenas linguagens criadas especificamente para a aplicação,
foi o conceito introduzido por Tcl de implementar linguagens de script
como bibliotecas para C que impulsionou fortemente o desenvolvimento
de aplicações extensíveis.


\chapter{\label{cha:APIs-de-M=E1quinas}APIs de linguagens de script}

Interfaces providas por linguagens de script são usualmente compreendidas
como {}``APIs de extensão'': elas servem para estender a máquina
virtual com recursos não oferecidos por esta, ou ainda para estender
uma aplicação externa com os recursos oferecidos pelo ambiente de
execução da linguagem, embutindo-o nesta aplicação. O primeiro cenário
é o utilizado no modelo de programação onde a coordenação de alto
nível é realizada em uma linguagem interpretada e módulos compilados
em linguagens como C e C++ são usados para acesso a bibliotecas externas
ou implementação de partes onde o desempenho é crítico. O segundo
cenário, via de regra, irá englobar também o primeiro, ao expor à
máquina virtual embutida extensões que a permitam comunicar-se com
a aplicação hospedeira.

Ambos os cenários envolvem os mesmos problemas gerais: transferência
de dados entre uma linguagem e outra, incluindo como permitir à linguagem
de script manipular estruturas declaradas em C e vice-versa; tratar
a diferença entre os modelos de gerência de memória, mais especificamente
a interação entre a coleta de lixo na máquina virtual e a desalocação
explícita em C; a chamada de funções declaradas pela linguagem de
script a partir de C; e o registro de funções C para que possam ser
invocadas a partir de scripts. As seções seguintes discutem as principais
questões envolvidas na comunicação entre código C e de linguagens
de script, e apresentam as abordagens empregadas pelas APIs de Python,
Ruby, Java, Lua e Perl no tratamento destas questões. Cada seção conclui
com uma comparação onde as diferentes características apresentadas
na exposição de cada linguagem são revistas lado a lado e assim postas
em perspectiva.


\section{Transferência de dados\label{sec:Dados}}

O principal complicador na interação entre linguagens de programação
não é a diferença de sintaxe ou semântica das construções de fluxo
de controle, mas a representação dos dados. Na comunicação entre código
escrito em duas linguagens diferentes, dados trafegam de várias formas:
como parâmetros, atributos de objetos, elementos de estruturas de
dados, etc.

Freqüentemente, o formato como estes dados são representados difere.
Nestes casos, há três alternativas para realizar a transferência de
dados entre as duas linguagens. A mais simples é expor o dado à linguagem
de destino como uma entidade opaca. A linguagem de destino recebe
apenas algum tipo de \emph{handle} que permite identificar unicamente
o dado em operações requisitadas posteriormente. Esta abordagem é
útil, por exemplo, se uma linguagem está apenas armazenando os dados
para a outra, a fim de aproveitar estruturas de dados de mais alto
nível que a linguagem ofereça. 

Outra abordagem envolve realizar algum tipo de conversão dos dados
do sistema de tipos de uma linguagem para o da outra. A duplicação
que ocorre na conversão limita a aplicabilidade deste método, restringindo
o seu uso tipicamente para tipos numéricos e, em menor grau, strings.
Finalmente, a linguagem de origem pode explicitamente oferecer facilidades
na linguagem de destino para a manipulação destes dados, ou seja,
uma linguagem oferecer uma API para a outra. A diferença entre esta
abordagem e a primeira é que, enquanto naquela o conteúdo do dado
se mantém opaco, nesta a própria API define uma forma de manipular
o seu conteúdo.

C, por ser orientada à manipulação de ponteiros e estruturas, possui
um conjunto pequeno de tipos básicos. Além disso, C é bastante liberal
em relação à representação interna dos tipos estruturados, cabendo
às diferentes plataformas definirem interfaces binárias (\emph{application
binary interfaces}, ABIs). Assim, mesmo em casos onde é possível li\-gar
código C diretamente utilizando tipos básicos compatíveis e convenções
de chamada apropriadas (como em Free Pascal ou em diversos compiladores
Fortran), uma biblioteca de \emph{bindings} é usualmente necessária
para tornar mais conveniente a manipulação de tipos mais complexos.

Até nos tipos numéricos fundamentais, há vários cuidados que devem
ser tomados. Algumas linguagens, como Smalltalk e Ruby, realizam conversão
automática de inteiros para {}``inteiros grandes'' (\emph{bignums}).
Em Ruby, particularmente, os inteiros primitivos têm 1 bit a menos
de precisão do que o tamanho de palavra da máquina. Pode haver ainda
a necessidade de conversão de \emph{endianness} e formato de números
de ponto flutuante.

Para tipos como strings, o tamanho dos valores traz ainda preocupações
com desempenho. Em diversos casos a representação interna usada para
strings é a mesma que a usada em C, então uma opção é simplesmente
passar ao código C um ponteiro para o endereço onde a string está
armazenada, o que evita a cópia de dados, sob risco de permitir ao
programa C modificar o conteúdo da string. Expor ao código C ponteiros
para endereços de memória dentro do ambiente de execução da outra
linguagem pode trazer ainda problemas de concorrência, caso o ambiente
em questão utilize múltiplas \emph{threads}.

Ao expor ao código C dados de tipos estruturados, a conversão para
um tipo de dado nativo de C, em muitos casos, não é uma opção. Além
da questão da quantidade de dados, tipos estruturados em C são definidos
estaticamente, não servindo assim para representar convenientemente
dados de estruturas dinâmicas, como objetos que podem ganhar ou perder
atributos e até mesmo mudar de classe em tempo de execução. Mesmo
em linguagens com tipos estáticos, como Java, a cópia de objetos não
costuma ser uma opção interessante em função do volume de dados. A
cópia de objetos estruturados costuma se restringir a operações específicas
como manipulação de arrays de elementos primitivos.

A alternativa para permitir que código C opere sobre dados estruturados,
então, é fornecer a ele uma API que exponha, em forma de funções,
as operações definidas sobre os tipos em questão. Isto evita também
a necessidade de controlar a consistência entre duas cópias de uma
mesma estrutura. Problemas de consistência, entretanto, podem ocorrer
caso a API permita ao código C armazenar ponteiros para objetos da
linguagem -- isto torna necessário ao programador gerenciar explicitamente
a sincronia entre os ponteiros e o ciclo de vida dos objetos, que
podem estar sujeitos a coleta de lixo. A Seção~\ref{sec:Coleta-de-lixo}
discute esta questão em mais detalhe.


\subsection{Python\label{sub:Dados-Python}}

Todos os valores na máquina virtual de Python são representados como
objetos, mapeados para a API de C como a estrutura \texttt{PyObject}~\cite{vanrossum06extpy}.
Tipos mais específicos como \texttt{PyStringObject}, \texttt{PyBooleanObject}
e \texttt{PyListObject} são \texttt{PyObject}s por equivalência estrutural,
isto é, podem ser convertidos através de um \emph{cast} C. Refletindo
o modelo de tipagem dinâmica de Python, as funções da API usam \texttt{PyObject{*}}
como tipo sempre que se referem a objetos Python, mesmo quando são
projetadas para atuar sobre valores Python de tipos mais específicos,
como por exemplo a função \texttt{PyString\_Size}, que retorna o tamanho
de uma string. Cada tipo específico possui uma função de verificação
na API, como \texttt{PyNumber\_Check} e \texttt{PyDict\_Check}.

Python é uma linguagem fortemente tipada: cada objeto é amarrado a
um tipo. Tipos são representados por estruturas \texttt{PyTypeObject},
que também são estruturalmente equivalentes a \texttt{PyObject}. Cada
tipo Python possui um \texttt{PyTypeObject} pré-definido na API, como
\texttt{PyString\_Type}, \texttt{PyBoolean\_Type} e \texttt{PyList\_Type}.
\texttt{PyObject\_TypeCheck} compara o tipo de um \texttt{PyObject}
a um \texttt{PyTypeObject} passado como parâmetro.

Para a conversão de dados de C para Python, a linguagem oferece uma
série de funções que recebem valores de tipos primitivos de C como
parâmetro, como \texttt{PyString\_FromString\-AndSize} e \texttt{PyFloat\_FromDouble}.
Cada uma destas funções retorna ao código C um ponteiro para um novo
objeto \texttt{PyObject}. Strings passadas são copiadas por Python.
O exemplo a seguir ilustra a criação um objeto Python através da conversão
de um valor C:

\begin{lyxcode}
{\footnotesize PyObject{*}~s~=~PyString\_FromString(\char`\"{}hello\char`\"{});}{\footnotesize \par}
\end{lyxcode}


Os dois exemplos abaixo, equivalentes, ilustram a verificação de tipo
através da API, primeiro através de uma função de conveniência, e
depois explicitamente, comparando o tipo da string Python com \texttt{PyString\_Type}:

\begin{lyxcode}
{\footnotesize if~(PyString\_Check(s))~printf(\char`\"{}Sim.\textbackslash{}n\char`\"{});}{\footnotesize \par}

{\footnotesize if~(PyObject\_TypeCheck(s,~PyString\_Type))~printf(\char`\"{}Sim.\textbackslash{}n\char`\"{});}{\footnotesize \par}
\end{lyxcode}


Para o retorno de dados de Python para C, um conjunto complementar
de funções é oferecido, mapeando os tipos básicos de Python de volta
a tipos de C. Alguns exemplos destas funções que recebem um ponteiro
para um \texttt{PyObject} como parâmetro e retornam o dado correspondente
em C são \texttt{PyLong\_\-AsUnsignedLong} e \texttt{PyString\_\-AsStringAndSize}.
Diferentemente das funções de entrada, nas fun\-ções de saída não
há cópia de strings: as strings retornadas são ponteiros para a área
armazenada internamente por Python. A documentação recomenda não modificar
o conteúdo da string exceto no caso de esta área de memória haver
sido retornada por uma chamada a \texttt{PyString\_\-FromStringAndSize(NULL,}
\emph{tamanho}\texttt{)}~\cite{vanrossum06api}. Desta forma, é possível
alocar uma string para armazenamento em Python e preenchê-la posteriormente
através de código C, como no exemplo a seguir:

\begin{lyxcode}
\emph{\footnotesize /{*}~alocando~uma~string~não-inicializada~em~Python~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~obj~=~PyString\_FromStringAndSize(NULL,~51);}{\footnotesize \par}

\emph{\footnotesize /{*}~obtendo~o~ponteiro~para~a~área~de~memória~da~string~{*}/}{\footnotesize \par}

{\footnotesize char{*}~s~=~PyString\_AsString(obj);}{\footnotesize \par}

\emph{\footnotesize /{*}~Agora,~podemos~preencher~a~string~em~C.~Um~exemplo~qualquer:~{*}/}{\footnotesize \par}

{\footnotesize for~(int~i~=~0;~i~<~5;~i++,~s+=10)}{\footnotesize \par}

~{\footnotesize ~~snprintf(s,~11,~\char`\"{}{[}\%-8d{]}\char`\"{},~random());}{\footnotesize \par}
\end{lyxcode}


Para alguns de seus tipos básicos que não possuem correspondente direto
em ANSI C 89, Python define tipos em C equivalentes: \texttt{Py\_UNICODE}
e \texttt{Py\_complex}. Estes tipos foram adicionados com o objetivo
de expor a representação interna dos dados usada por Python aos módulos
para manipulação numérica ou de texto Unicode implementados em C,
evitando conversões freqüentes de e para \texttt{PyObject}. 

Python oferece ainda algumas versões de funções de conversão para
C implementadas como macros sem a verificação de tipo, assumindo que
o \texttt{PyObject} passado será compatível, oferecendo melhor desempenho
às custas de segurança. Estas funções podem ser identificadas pelos
nomes em maiúsculas. Entre as macros de conversão oferecidas estão
\texttt{PyString\_\-AS\_STRING}, \texttt{PyInt\_\-AS\_LONG} e \texttt{PyUnicode\_\-AS\_\-UNICODE}.

Além de funções para conversão de tipos entre Python e C, a API de
Python oferece ainda algumas funções de conversão entre tipos de Python.
Estas funções recebem um \texttt{PyObject} como parâmetro e retornam
um novo \texttt{PyObject} com o resultado da conversão, e são equivalentes
a funções Python que realizam estas conversões (na verdade chamadas
a tipos \texttt{PyTypeObject} que respondem ao método \texttt{\_\_call\_\_}).
Por exemplo, a função \texttt{PyObject\_Str} é equivalente à função
Python \texttt{str}. 

Em Python, objetos são armazenados em módulos, que são espaços de
nomes declarados globalmente, ou como atributos de objetos. Variáveis
são armazenadas em um \emph{ambiente}, representado como um dicionário.
Funções como \texttt{PyRun\_File} recebem, entre seus parâmetros,
um dicionário de variáveis globais e outro de variáveis locais. O
conjunto de variáveis e funções globais é representado como o dicionário
do módulo \texttt{\_\_main\_\_}. Objetos \emph{built-in} são acessíveis
através do módulo \texttt{\_\_builtin\_\_}. Por exemplo, para obter
o objeto \texttt{str}, obtemos inicialmente uma referência ao módulo
\texttt{\_\_builtin\_\_} com a função \texttt{PyImport\_AddModule}
e em seguida o dicionário do módulo com a função \texttt{PyModule\_GetDict}. 

\begin{lyxcode}
{\footnotesize PyObject{*}~builtins\_module~=~PyImport\_AddModule(\char`\"{}\_\_builtin\_\_\char`\"{});}{\footnotesize \par}

{\footnotesize PyObject{*}~builtins~=~PyModule\_GetDict(builtins\_module);}{\footnotesize \par}

{\footnotesize PyObject{*}~str~=~PyDict\_GetItemString(builtins,~\char`\"{}str\char`\"{});}{\footnotesize \par}
\end{lyxcode}


Em Python, \texttt{str} é um objeto chamável, que atua como a função
de conversão para strings. Assim, uma vez que obtivemos uma referência
para o \texttt{PyObject} correspondente a \texttt{str}, a chamada
seguinte equivale a chamar \texttt{PyObject\_Str} sobre um objeto
Python qualquer \texttt{obj}:

\begin{lyxcode}
\emph{\footnotesize /{*}~Esta~é~uma~função~vararg~que~recebe~como~argumentos~adicionais}{\footnotesize \par}

~\emph{\footnotesize ~~uma~lista~terminada~em~NULL~de~PyObjects~a~serem~passados~à}{\footnotesize \par}

~\emph{\footnotesize ~~função~Python~indicada~no~primeiro~argumento.~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~result~=~PyObject\_CallFunctionObjArgs(str,~obj,~NULL);}{\footnotesize \par}
\end{lyxcode}


O armazenamento de dados de C no espaço de objetos de Python pode
ser feito de duas formas. Uma maneira é criar um objeto do tipo \texttt{CObject}
encapsulando um ponteiro C qualquer, construindo assim um valor opaco
para Python. As funções de construção deste objetos deste tipo permitem
associar ao dado uma função C a ser chamada quando o \texttt{CObject}
for desalocado. Segundo a documentação de Python, \texttt{CObject}s
têm como objetivo principal permitir a passagem de dados em C de um
módulo de extensão para outro~\cite{vanrossum06api}.

A outra forma é declarar novos tipos Python através de estruturas
em C. Em~C, um tipo Python é descrito em duas partes: um tipo \emph{struct,}
a partir do qual instâncias do tipo serão produzidas, e uma instância
da struct \texttt{PyTypeObject}, que descreverá o tipo para Python.
O exemplo a seguir ilustra a criação de um novo tipo Python em C.
Inicialmente, temos \texttt{point}, que será o tipo~C das instâncias
dos objetos:

\begin{lyxcode}
{\footnotesize typedef~struct~\{}{\footnotesize \par}

~{\footnotesize ~~PyObject\_HEAD}{\footnotesize \par}

~{\footnotesize ~~int~x,~y;~}{\footnotesize \par}

{\footnotesize \}~point;}{\footnotesize \par}
\end{lyxcode}


A macro \texttt{PyObject\_HEAD} garante equivalência estrutural com
\texttt{PyObject}. Quando funções retornarem o objeto ao código C
como um \texttt{PyObject{*}}, este pode ser convertido de volta para
\texttt{point} via cast, dando assim acesso aos atributos \texttt{x}
e \texttt{y}. Definiremos também uma função que opera sobre objetos
deste tipo:

\begin{lyxcode}
{\footnotesize PyObject{*}~point\_distance(point{*}~p)~\{}{\footnotesize \par}

~{\footnotesize ~~~return~PyFloat\_FromDouble(~sqrt(p->x{*}p->x~+~p->y{*}p->y)~);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


A função é definida com tipo de retorno \texttt{PyObject}{*} para
que possa ser registrada na máquina virtual de Python. Para associar
a função ao tipo Python, iremos inicialmente armazená-la em um array
de estruturas \texttt{PyMethodDef}, que listará os métodos do tipo:

\begin{lyxcode}
{\footnotesize static~PyMethodDef~point\_methods{[}{]}~=~\{}{\footnotesize \par}

~{\footnotesize ~~\{~\char`\"{}distance\char`\"{},~(PyCFunction)~point\_distance,~METH\_NOARGS~\},}{\footnotesize \par}

~{\footnotesize ~~\{~NULL~\}}{\footnotesize \par}

{\footnotesize \};}{\footnotesize \par}
\end{lyxcode}


Para que os atributos do tipo sejam visíveis a partir de Python, precisamos
implementar uma rotina de acesso, que recebe o objeto e o nome do
atributo acessado. A sua implementação é dada a seguir:

\begin{lyxcode}
{\footnotesize PyObject{*}~point\_getattr(PyObject{*}~self,~char{*}~name)~\{}{\footnotesize \par}

~{\footnotesize ~~if~(strcmp(name,~\char`\"{}x\char`\"{})~==~0)}{\footnotesize \par}

~{\footnotesize ~~~~~return~PyInt\_FromLong(((point{*})self)->x);}{\footnotesize \par}

~{\footnotesize ~~else~if~(strcmp(name,~\char`\"{}y\char`\"{})~==~0)}{\footnotesize \par}

~{\footnotesize ~~~~~return~PyInt\_FromLong(((point{*})self)->y);}{\footnotesize \par}

~{\footnotesize ~~else}{\footnotesize \par}

~{\footnotesize ~~~~~return~Py\_FindMethod(point\_methods,~self,~name);~}{\footnotesize \par}

{\footnotesize \}~}{\footnotesize \par}
\end{lyxcode}


Uma vez registrada na descrição do tipo, esta função será responsável
por retornar os seus atributos e métodos. Assim, podemos expor ao
ambiente Python atributos armazenados na struct C. A função \texttt{Py\_FindMethod}
localiza uma função no array passado como parâmetro e a retorna como
um método%
\footnote{O registro de funções Python será discutido em detalhe na Seção~\ref{sub:Python-Registro}.%
}.

Finalmente, definiremos \texttt{point\_type}, que será o \texttt{PyTypeObject}
que descreve o tipo Python relativo a eles%
\footnote{Para maior brevidade, apresentamos o exemplo usando a sintaxe para
descrição de structs de C99, evitando-nos de listar os elementos a
serem inicializados com \texttt{NULL}, já que a struct \texttt{PyTypeObject}
possui 54 campos ao todo.%
}:

\begin{lyxcode}
{\footnotesize static~PyTypeObject~point\_type~=~\{}{\footnotesize \par}

~{\footnotesize ~~PyObject\_HEAD\_INIT(NULL)}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~O~nome~da~classe~{*}/}{\footnotesize \par}

~{\footnotesize ~~.tp\_name~=~\char`\"{}point\char`\"{},}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~O~tamanho~da~área~de~memória~a~ser~alocada~{*}/}{\footnotesize \par}

~{\footnotesize ~~.tp\_basicsize~=~sizeof(point),}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~A~função~de~acesso~a~atributos~{*}/}{\footnotesize \par}

~{\footnotesize ~~.tp\_getattr~=~point\_getattr,}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Classe~não~requer~tratamentos~especiais~{*}/}{\footnotesize \par}

~{\footnotesize ~~.tp\_flags~=~Py\_TPFLAGS\_DEFAULT}{\footnotesize \par}

{\footnotesize \};}{\footnotesize \par}
\end{lyxcode}


Novamente, uma macro foi usada no início da definição do tipo para
garantir equivalência estrutural. \texttt{PyTypeObject} possui vários
outros campos, mas os manteremos como \texttt{NULL} de modo que sejam
preenchidos com valores default quando da construção do tipo em tempo
de execução. O tipo \texttt{PyTypeObject} contém uma série de campos
que permitem descrever o comportamento do tipo declarado. No campo
\texttt{tp\_getattr} de \texttt{point\_type}, especificamos que a
função C a ser usada para tratar acesso a atributos será \texttt{point\_getattr}.
Especificamos \texttt{Py\_TPFLAGS\_DEFAULT} no campo de flags para
indicar uma classe de comportamento padrão, sem a necessidade de tratamentos
especiais como verificação de ciclos na coleta de lixo.

Embora a representação em memória de objetos Python do tipo definido
pelo usuário sejam instâncias de \texttt{point}, para criar um novo
objeto não basta alocar uma instância da struct \texttt{point} e usá-la
como \texttt{PyObject} via cast. É preciso inicializar o objeto para
que este seja registrado no mecanismo de coleta de lixo e tenha os
campos de seu cabeçalho \texttt{PyObject} devidamente inicializados.
A alocação em C de novos objetos de um tipo definido pelo usuário
deve ser feita através da macro \texttt{PyObject\_New}, que recebe
como parâmetros o tipo da struct a ser alocada e o \texttt{PyTypeObject}
correspondente ao tipo. Antes de alocar objetos do tipo em C, deve-se
completar a inicialização de \texttt{point\_type} em tempo de execução.
A documentação recomenda inicializar em tempo de execução a função
padrão de construção de objetos, \texttt{PyType\_GenericNew}, por
razões de portabilidade~\cite{vanrossum06extpy}. Finalmente, o preenchimento
dos campos não definidos na declaração da struct é feita pela função
\texttt{PyType\_Ready}.

\begin{lyxcode}
{\footnotesize point\_type.tp\_new~=~PyType\_GenericNew;}{\footnotesize \par}

{\footnotesize if~(PyType\_Ready(\&point\_type)~<~0)~return;}{\footnotesize \par}
\end{lyxcode}
A partir daí, instâncias podem ser criadas com \texttt{PyObject\_New},
como no exemplo abaixo:

\begin{lyxcode}
\emph{\footnotesize /{*}~Cria~uma~instância~{*}/}{\footnotesize \par}

{\footnotesize point{*}~a\_point~=~PyObject\_New(point,~\&point\_type);}{\footnotesize \par}

{\footnotesize a\_point->x~=~100;~a\_point->y~=~200;}{\footnotesize \par}

\emph{\footnotesize /{*}~Armazena~a~instância~na~global~Python}~{\footnotesize P}\emph{\footnotesize ,}{\footnotesize \par}

~\emph{\footnotesize ~~assume~que~o~dicionário~de~globais~já~foi~armazenado~em}~{\footnotesize globals}~\emph{\footnotesize {*}/}{\footnotesize \par}

{\footnotesize PyDict\_SetItemString(globals,~\char`\"{}P\char`\"{},~(PyObject{*})~a\_point);}{\footnotesize \par}
\end{lyxcode}
Uma vez declarado em C, este valor pode ser usado em Python:

\begin{lyxcode}
{\footnotesize print~'P.x~=~'~+~str(P.x)}{\footnotesize \par}

{\footnotesize print~'P.y~=~'~+~str(P.y)}{\footnotesize \par}

{\footnotesize print~'d~~~=~'~+~str(P.distance())}{\footnotesize \par}
\end{lyxcode}


A API de Python possui um grande número de funções para manipulação
de tipos pré-definidos da linguagem. \emph{Tuplas} merecem menção
especial no que tange à transferência de dados entre Python e C, pois
são usadas em diversos contextos: na passagem de parâmetros em chamadas
a funções Python a partir de C, no recebimento dos parâmetros de entrada
em funções C e também na passagem e recebimento de múltiplos valores
de retorno, como será visto nas Seções~\ref{sub:Python-Chamada}
e~\ref{sub:Python-Registro}.

Como tuplas são usadas com freqüência como {}``ponte'' entre Python
e C, a API possui uma função de conveniência, \texttt{PyArg\_ParseTuple},
que evita que o acesso aos elementos da tupla e a verificação dos
seus tipos seja feita item a item pelo programador. Trata-se de uma
função C \emph{vararg} que recebe como parâmetros a tupla, uma string
indicando os tipos dos parâmetros esperados e os endereços onde os
valores, convertidos para tipos C, devem ser armazenados. A função
define uma sintaxe para os indicadores de tipo especificados na string
passada e os tipos C correspondentes. Por exemplo: \texttt{\char`\"{}s\#\char`\"{}}
indica que a tupla deve conter um objeto Python de tipo \texttt{string}
ou \texttt{Unicode} e que dois parâmetros devem ser passados à função
C, de tipos \texttt{const char{*}{*}} e \texttt{int{*}}, que irão
retornar o ponteiro para a string e o seu tamanho. Em um exemplo mais
elaborado, \texttt{\char`\"{}iiO!|(dd)\char`\"{}} indica que a função
espera dois endereços de inteiros~(\texttt{\char`\"{}ii\char`\"{}}),
seguido do endereço de um ponteiro \texttt{PyObject~}(\texttt{\char`\"{}O\char`\"{}})
e de um objeto \texttt{PyTypeObject} a ser usado na verificação do
tipo do objeto recebido~(\texttt{\char`\"{}!\char`\"{}}) e opcionalmente~(\texttt{\char`\"{}|\char`\"{}}),
dois endereços de valores \texttt{double} passados via Python através
de uma outra tupla~(\texttt{\char`\"{}(dd)\char`\"{}}).

De forma similar, a API de Python possui a função \texttt{Py\_BuildValue},
que permite a construção de objetos estruturados, como tuplas, listas
e dicionários, em uma só chamada. Esta função é freqüentemente usada
tanto para a construção da tupla de parâmetros ao chamar funções como
para valores de retorno. A sintaxe da string de parâmetros é similar
à de \texttt{PyArg\_ParseTuple}, mas possui um conjunto diferente
de indicadores de tipo, além de permitir descrever listas e dicionários.
Por exemplo, a seguinte chamada cria uma lista contendo um inteiro,
um número de ponto flutuante e um dicionário contendo um elemento
de chave string e valor inteiro:

\begin{lyxcode}
{\footnotesize PyObject{*}~lista~=~Py\_BuildValue(\char`\"{}{[}id\{si\}{]}\char`\"{},~123,~12.30,~\char`\"{}foo\char`\"{},~1234);}{\footnotesize \par}
\end{lyxcode}
Isto equivale à seguinte construção em Python:

\begin{lyxcode}
{\footnotesize lista~=~{[}123,~12.30,~\{\char`\"{}foo\char`\"{}:~1234\}{]}}{\footnotesize \par}
\end{lyxcode}

\subsection{Ruby\label{sub:Ruby-dados}}

Para a comunicação de dados entre Ruby e C, a API de Ruby define um
tipo de dados em C chamado \texttt{VALUE}, que representa um objeto
Ruby. \texttt{VALUE} pode representar tanto uma referência para um
objeto (isto é, um ponteiro para a \emph{heap} de Ruby) como um valor
imediato. Em particular, as constantes \texttt{Qtrue}, \texttt{Qfalse}
e \texttt{Qnil} são definidas como valores imediatos, permitindo a
comparação destas em C usando o operador \texttt{==}.

Para a verificação de tipos, Ruby disponibiliza as macros \texttt{Check\_Type}
e \texttt{TYPE}. \texttt{Check\_Type} permite comparar o tipo de valores
a constantes que descrevem os tipos básicos de Ruby como \texttt{T\_OBJECT}
e \texttt{T\_STRING}. \texttt{TYPE} retorna a constante relativa ao
tipo de um valor passado. Para a verificação da classe de um objeto,
devemos usar \texttt{rb\_class\_of}.

Para a transferência de valores numéricos, a conversão entre C e Ruby
é feita através de macros como \texttt{INT2NUM} e de funções como
\texttt{rb\_float\_new}, que recebem ou retornam \texttt{VALUE}s.

Para a passagem de strings para Ruby a partir de C, são oferecidas
as funções \texttt{rb\_str\_new}, que recebe um ponteiro e um argumento
numérico de tamanho, de modo a permitir a passagem de strings contendo
caracteres nulos, e \texttt{rb\_str\_new2}, que assume uma string
padrão de C, com o caracter nulo como terminador. Estas funções fazem
uma cópia da string C para o espaço de Ruby. \texttt{VALUE}s que apontam
para strings de Ruby permitem acessar e alterar o seu conteúdo através
do \emph{cast} \texttt{RSTRING(uma\_string)->ptr}. Todavia, a API
recomenda o uso da macro \texttt{StringValue}, que retorna o próprio
\texttt{VALUE} passado caso este seja uma string, ou um novo \texttt{VALUE}
da classe \texttt{String} produzido através do método de conversão
\texttt{to\_s} aplicado ao objeto passado (ou ainda causa uma exceção
\texttt{TypeError} caso a conversão não seja possível).

\begin{lyxcode}
{\footnotesize void~mostra\_valor(VALUE~obj)~\{}{\footnotesize \par}

~{\footnotesize ~~const~char{*}~s;}{\footnotesize \par}

~{\footnotesize ~~if~(TYPE(obj)~==~T\_STRING)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Faria~um~acesso~ilegal~se~TYPE(obj)~!=~T\_STRING~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~s~=~RSTRING(obj)->ptr;}{\footnotesize \par}

~{\footnotesize ~~\}~else~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Funciona~para~qualquer~tipo~que~aceite~obj.to\_s,}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~dispara~uma~exceção~em~caso~contrário~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~s~=~StringValue(obj);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Valor:~\%s\textbackslash{}n\char`\"{},~s);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Sob a justificativa de aumentar o desempenho no acesso, alguns outros
tipos de Ruby como \texttt{Array}, \texttt{Hash} e \texttt{File} permitem
acesso de baixo nível aos membros das estruturas utilizadas na implementação
dos objetos. Por exemplo, \texttt{RARRAY(um\_array)->len} permite
ler o tamanho de um array diretamente. A recomendação da API é utilizar
este tipo de acesso somente para leitura, já que a alteração destes
valores pode facilmente tornar o estado interno dos objetos inconsistente.

Para o armazenamento de dados de C no espaço de objetos de Ruby, a
API oferece uma macro, \texttt{Data\_Wrap\_Struct}, que recebe um
ponteiro C e cria um objeto Ruby que encapsula este ponteiro. O ponteiro
pode ser acessado a partir de código C usando \texttt{Data\_Get\_Struct},
mas não a partir de Ruby. Em \texttt{Data\_Wrap\_Struct} é passada
também uma função C a ser executada quando o objeto for coletado.
Por exemplo, criemos uma classe \texttt{Point}, similar ao tipo definido
em Python na seção anterior. Inicialmente definiremos um tipo~C:

\begin{lyxcode}
\label{struct-point}{\footnotesize typedef~struct~\{}{\footnotesize \par}

~{\footnotesize ~~int~x,~y;}{\footnotesize \par}

{\footnotesize \}~point;}{\footnotesize \par}
\end{lyxcode}


Funções de alocação (\texttt{point\_alloc}) e desalocação (\texttt{point\_free})
para a classe \texttt{Point} são dadas a seguir:

\begin{lyxcode}
{\footnotesize void~point\_free(void{*}~p)~\{}{\footnotesize \par}

~{\footnotesize ~~free(p);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}

~~\\
{\footnotesize VALUE~point\_alloc(VALUE~point\_class)~\{}{\footnotesize \par}

~{\footnotesize ~~point{*}~p~=~malloc(sizeof(point));}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~O~segundo~argumento~é~a~função~de~marcação~para~coleta~de~lixo}{\footnotesize \par}

~\emph{\footnotesize ~~~~~(NULL~aqui~pois~o~tipo~não~armazena~VALUEs),~cf.~Seção~\ref{sub:Ruby-GC}~{*}/}{\footnotesize \par}

~{\footnotesize ~~return~Data\_Wrap\_Struct(point\_class,~NULL,~point\_free,~p);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Note que \texttt{Data\_Wrap\_Struct} faz uso de um \texttt{VALUE}
que representa a classe \texttt{Point} em Ruby. Classes são criadas
em C com a função \texttt{rb\_define\_class}. Esta função recebe uma
string C com o nome da nova classe e um \texttt{VALUE} a ser usado
como superclasse (como por exemplo a constante \texttt{rb\_cObject},
que representa a classe Ruby \texttt{Object}) e retorna um \texttt{VALUE}
representando a nova classe. Para classes como \texttt{Point}, cujas
instâncias irão conter dados de C, é possível registrar uma função
C responsável por realizar a alocação de memória das instâncias usando
a função \texttt{rb\_define\_alloc\_func}. A criação da classe e o
registro da função de alocação, então, se dão da seguinte forma:

\begin{lyxcode}
{\footnotesize VALUE~point\_class~=~rb\_define\_class(\char`\"{}Point\char`\"{},~rb\_cObject);}{\footnotesize \par}

{\footnotesize rb\_define\_alloc\_func(point\_class,~point\_alloc);}{\footnotesize \par}
\end{lyxcode}


Como em código Ruby, a declaração de atributos de objetos é feita
no método \texttt{initialize}, que pode ser implementado em C:

\begin{lyxcode}
{\footnotesize VALUE~point\_initialize(VALUE~self,~VALUE~x,~VALUE~y)~\{}{\footnotesize \par}

~{\footnotesize ~~point{*}~p;}{\footnotesize \par}

~{\footnotesize ~~Data\_Get\_Struct(self,~point,~p);}{\footnotesize \par}

~{\footnotesize ~~p->x~=~NUM2INT(x);}{\footnotesize \par}

~{\footnotesize ~~p->y~=~NUM2INT(y);}{\footnotesize \par}

~{\footnotesize ~~return~self;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


O método é registrado na classe em tempo de execução com a função
\texttt{rb\_define\_method} (o registro de funções C em Ruby será
discutido em detalhe na Seção~\ref{sub:Ruby-Registro}).

\begin{lyxcode}
{\footnotesize rb\_define\_method(point\_class,~\char`\"{}initialize\char`\"{},~point\_initialize,~2);}{\footnotesize \par}
\end{lyxcode}


Para que a cópia de objetos através dos métodos Ruby \texttt{dup}
e \texttt{clone} trate corretamente os dados armazenados via C, é
preciso ainda registrar o método \texttt{initialize\_copy}. Uma possível
implementação em C é dada abaixo:

\begin{lyxcode}
{\footnotesize VALUE~point\_initialize\_copy(VALUE~copy,~VALUE~orig)~\{}{\footnotesize \par}

~{\footnotesize ~~point{*}~p\_copy;}{\footnotesize \par}

~{\footnotesize ~~point{*}~p\_orig;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Ruby~pode~chamar~esta~função~com~o~mesmo~objeto~nos~dois}{\footnotesize \par}

~\emph{\footnotesize ~~~~~parâmetros;~nesse~caso,~ignore~a~chamada~e~retorne~o~objeto~{*}/}{\footnotesize \par}

~{\footnotesize ~~if~(copy~==~orig)~return~copy;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obter~os~ponteiros~armazenados~nos~objetos~{*}/}{\footnotesize \par}

~{\footnotesize ~~Data\_Get\_Struct(orig,~point,~p\_orig);}{\footnotesize \par}

~{\footnotesize ~~Data\_Get\_Struct(copy,~point,~p\_copy);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Cópia~da~{}``parte~C''~do~objeto~{*}/}{\footnotesize \par}

~{\footnotesize ~~p\_copy->x~=~p\_orig->x;}{\footnotesize \par}

~{\footnotesize ~~p\_copy->y~=~p\_orig->y;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorna~a~cópia~{*}/}{\footnotesize \par}

~{\footnotesize ~~return~copy;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Completemos o exemplo com uma função C implementando o método \texttt{distance}
como feito na seção anterior para Python:

\begin{lyxcode}
{\footnotesize VALUE~point\_distance(VALUE~self)~\{}{\footnotesize \par}

~{\footnotesize ~~point{*}~p;}{\footnotesize \par}

~{\footnotesize ~~Data\_Get\_Struct(self,~point,~p);}{\footnotesize \par}

~{\footnotesize ~~return~rb\_float\_new(~sqrt(p->x{*}p->x~+~p->y{*}p->y))~);~}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
Estas funções também são registradas como métodos de \texttt{Point}:

\begin{lyxcode}
{\footnotesize rb\_define\_method(point\_class,~\char`\"{}initialize\_copy\char`\"{},}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~point\_initialize\_copy,~1);}{\footnotesize \par}

{\footnotesize rb\_define\_method(point\_class,~\char`\"{}distance\char`\"{},~point\_distance,~0);}{\footnotesize \par}
\end{lyxcode}


A função \texttt{rb\_class\_new\_instance} produz novos objetos Ruby
que são instâncias da classe, recebendo um array C de \texttt{VALUE}s
a ser passados na inicialização e o \texttt{VALUE} da classe. 

O acesso a variáveis Ruby se dá através da família de funções \texttt{rb\_}{*}\texttt{\_get},
que retornam os \texttt{VALUE}s relativos a atributos de objetos ou
classes, variáveis globais e constantes. Para cada uma destas há uma
função \texttt{rb\_}{*}\texttt{\_set} análoga%
\footnote{Constantes podem ser criadas com o valor \texttt{Qundef} e terem o
seu valor definido posteriormente com \texttt{rb\_const\_set}, porém
uma única vez.%
}. As funções \texttt{rb\_iv\_get} e \texttt{rb\_ivar\_get}, por exemplo,
obtêm atributos de objetos (\emph{instance variables}). A primeira
forma usa strings C como nomes, a segunda usa \texttt{ID}s, identificadores
que substituem strings internalizadas na tabela de símbolos de Ruby,
que podem ser obtidos usando a função \texttt{rb\_intern}. De fato,
\texttt{ID}s correspondem ao tipo \emph{símbolo} de Ruby, que na prática
são strings imutáveis. O seguinte exemplo obtém o valor de uma variável
global \texttt{g} e a atribui ao campo \texttt{c} de um objeto, e
depois altera o valor da variável global para zero:

\begin{lyxcode}
\emph{\footnotesize /{*}~Obtém~variável~global~{*}/}{\footnotesize \par}

{\footnotesize VALUE~g~=~rb\_gv\_get(\char`\"{}g\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~Atribui~ao~campo~c~do~objeto~obj~{*}/}{\footnotesize \par}

{\footnotesize VALUE~obj~=~rb\_gv\_get(\char`\"{}obj\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~Equivale~a:~rb\_ivar\_set(obj,~rb\_intern(\char`\"{}c\char`\"{}),~g);~{*}/}{\footnotesize \par}

{\footnotesize rb\_iv\_set(obj,~\char`\"{}c\char`\"{},~g);}{\footnotesize \par}

\emph{\footnotesize /{*}~Zera~a~variável~global~{*}/}{\footnotesize \par}

{\footnotesize rb\_gv\_set(\char`\"{}g\char`\"{},~INT2NUM(0));}{\footnotesize \par}
\end{lyxcode}


\texttt{ID}s nunca são coletados: observamos que a tabela de símbolos
não é zerada mesmo com \texttt{ruby\_finalize}. Assim, uma aplicação
C que oferece uma interface para scripting criando ambientes supostamente
isolados, com \texttt{ruby\_init} e \texttt{ruby\_finalize} cercando
cada execução de script, pode ter o seu consumo de memória aumentado
indefinidamente à medida que os scripts criam símbolos.


\subsection{Java\label{sub:Dados-Java}}

A JNI define no cabeçalho \texttt{jni.h} tipos em C equivalentes a
cada um dos tipos primitivos de Java (\texttt{jint} para \texttt{int},
\texttt{jfloat} para \texttt{float}, e assim por diante). Os {}``tipos
de referências'', como classes e objetos, são expostos a C como referências
opacas, instâncias de \texttt{jobject}. Strings e arrays também são
objetos em Java e são portanto expostos como instâncias de \texttt{jobject}.
Entretanto, a JNI define como conveniência alguns tipos em C que agem
como {}``subtipos'' de \texttt{jobject}: \texttt{jclass}, \texttt{jstring},
\texttt{jthrowable}, \texttt{jarray}, \texttt{jobjectArray}, além
de um tipo array para cada tipo primitivo (\texttt{jbooleanArray},
\texttt{jbyteArray}, etc.). O tipo \texttt{jvalue} é uma \emph{union}
dos tipos primitivos e de referências. O valor C \texttt{NULL} equivale
a \texttt{null} em Java.

Diferentes métodos são utilizados para a leitura de tipos primitivos,
strings, arrays e outros objetos. A leitura do conteúdo de uma \texttt{jstring}
em C requer a conversão do formato interno usado por Java, UTF-16.
A API oferece uma função utilitária que aloca uma string contendo
a representação do texto em UTF-8 (formato compatível com ASCII),
\texttt{GetStringUTFChars}. Esta string deve ser posteriormente desalocada
com \texttt{ReleaseString\-UTFChars}. A função \texttt{GetStringChars}
permite acesso direto à string em formato UTF-16; ela possui um parâmetro
de saída que indica se a string retornada é o \emph{buffer} interno
da JVM ou uma cópia. Ao mesmo tempo que isto permite ao código C evitar
duplicação da string nos casos onde deseja-se modificá-la e a JVM
tenha optado por retornar uma cópia, tal parâmetro expõe na API questões
de baixo nível da gerência de strings na JVM. Alternativamente, as
funções \texttt{GetStringRegion} e \texttt{GetStringUTFRegion} realizam
a cópia da string para um buffer pré-alocado pelo programador. \texttt{GetStringCritical}
permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
cuidados especiais em relação à coleta de lixo, discutidos na Seção~\ref{sub:Coleta-Java}.

Arrays de elementos primitivos são tratados de forma similar a strings,
diferentemente de arrays de objetos%
\footnote{Arrays multi-dimensionais são considerados {}``arrays de arrays''
e, portanto, são também arrays de objetos.%
}. Há funções para realizar a cópia de arrays (\texttt{Get}/\texttt{Set}\emph{{[}tip}\texttt{\emph{o{]}}}\texttt{\-ArrayRegion}),
funções que retornam ponteiros para o array podendo ou não realizar
cópias, de forma análoga a \texttt{GetStringChars} (\texttt{Get}/\texttt{Release}\emph{{[}tipo{]}}\texttt{ArrayElements})
e que podem acessar o buffer interno da JVM diretamente, como em \texttt{GetStringCritical}
(\texttt{Get}/\texttt{Release\-PrimitiveArrayCritical}). Para arrays
de objetos, não é possível obter um ponteiro para o buffer interno
do array, mas somente acessar e modificar os seus elementos um a um,
sob forma de referências \texttt{jobject}, com \texttt{Get}/\texttt{SetObjectArrayElement}.

A obtenção de valores de atributos se dá através de funções como \texttt{GetObjectField}
e \texttt{GetStaticField}, que retornam referências do tipo \texttt{jobject}.
Para cada um dos tipos primitivos existe uma chamada equivalente,
como \texttt{GetIntField} e \texttt{GetStaticIntField}. Assim como
Ruby, a API de Java define um tipo~C específico para evitar o uso
freqüente de strings C na descrição de campos. Todavia, enquanto Ruby
utiliza \texttt{ID}s que são simplesmente strings internalizadas,
em Java os identificadores de campo, do tipo \texttt{jfieldID}, contêm
informação de tipo e são específicos para o campo de uma determinada
classe. Estes valores são obtidos com uma chamada a \texttt{GetFieldID},
que recebe entre seus parâmetros uma string chamada de {}``descritor
de campo JNI'' com uma sintaxe especial. Por exemplo, o tipo Java
\texttt{int{[}{]}{[}{]}} é descrito com \texttt{\char`\"{}{[}{[}I\char`\"{}}
e o tipo \texttt{java.lang.String} como \texttt{\char`\"{}Ljava/lang/String;\char`\"{}}%
\footnote{Este é outro ponto onde detalhes da implementação transparecem na
API. Não por coincidência, esta sintaxe é a mesma usada na representação
interna de tipos em \emph{bytecodes} da JVM.%
}. É possível ainda obter um \texttt{jfieldID} a partir de um objeto
\texttt{java.lang.reflect.Field} usando a função \texttt{FromReflectedField}.

As chamadas à JNI têm o formato \texttt{({*}J)->}\emph{função}\texttt{(J,}
...\texttt{)}: funções da JNI são acessadas através de ponteiros para
função armazenados em uma tabela apontada pela estrutura \texttt{JNIEnv},
que por sua vez é propagada nas chamadas. O objetivo destes dois níveis
de indireção é desacoplar a ligação das chamadas no código C e a biblioteca
que implementa a JNI, permitindo ligar o código em tempo de execução
a diferentes implementações da JVM~\cite{stepanian05inliningjava}.

%
\begin{figure}
\begin{lyxcode}
{\footnotesize public~class~ExemploJNI~\{}{\footnotesize \par}

~{\footnotesize ~~private~String{[}{]}~elementos~=~\{~\char`\"{}Terra\char`\"{},~\char`\"{}Ar\char`\"{},~\char`\"{}Fogo\char`\"{},~\char`\"{}Agua\char`\"{}~\};}{\footnotesize \par}

~{\tiny }{\tiny \par}

~\emph{\footnotesize ~~/{*}~Declaração~do~método~implementado~externamente~{*}/}{\footnotesize \par}

~{\footnotesize ~~private~native~void~segundoElemento();}{\footnotesize \par}

~{\tiny ~}{\tiny \par}

~{\footnotesize ~~public~static~void~main(String{[}{]}~args)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Cria~uma~instância~e~invoca~o~método~nativo~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~new~ExemploJNI().segundoElemento();}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\tiny }{\tiny \par}

~{\footnotesize ~~static~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Carrega~o~código~externo~na~JVM~que}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~implementará~o~método~segundoElemento~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~System.loadLibrary(\char`\"{}ExemploJNI\char`\"{});}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}

\caption{\label{cap:Classe-Java}Classe Java contendo um método implementado
externamente}
\end{figure}


%
\begin{figure}[tb]
\begin{lyxcode}
{\footnotesize \#include~<jni.h>}{\footnotesize \par}

{\footnotesize \#include~<stdio.h>}{\footnotesize \par}

{\footnotesize \#include~\char`\"{}ExemploJNI.h\char`\"{}}{\footnotesize \par}

~{\tiny }{\tiny \par}

{\footnotesize JNIEXPORT~void~JNICALL}{\footnotesize \par}

{\footnotesize Java\_ExemploJNI\_segundoElemento(JNIEnv{*}~J,~jobject~this)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obter~a~classe~de~this:~ExemploJNI~{*}/}{\footnotesize \par}

~{\footnotesize ~~jclass~classe~=~({*}J)->GetObjectClass(J,~this);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obter~o~campo~ExemploJNI.elementos,~de~tipo~String{[}{]}~{*}/}{\footnotesize \par}

~{\footnotesize ~~jfieldID~elemsID~=~({*}J)->GetFieldID(J,~classe,}{\footnotesize \par}

~{\footnotesize ~~~~~\char`\"{}elementos\char`\"{},~\char`\"{}{[}Ljava/lang/String;\char`\"{});}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obter~o~conteúdo~do~campo~ExemploJNI.elementos~{*}/}{\footnotesize \par}

~{\footnotesize ~~jarray~elems~=~({*}J)->GetObjectField(J,~this,~elemsID);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~elems\_1~=~elementos{[}1{]}~{*}/}{\footnotesize \par}

~{\footnotesize ~~jstring~elems\_1~=~({*}J)->GetObjectArrayElement(J,~elems,~1);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~obter~representação~de~elems\_1~como~uma~string~C~{*}/}{\footnotesize \par}

~{\footnotesize ~~const~char{*}~elems\_1\_c~=~({*}J)->GetStringUTFChars(J,~elems\_1,~NULL);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~exibir~a~string~{*}/}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}\%s\textbackslash{}n\char`\"{},~elems\_1\_c);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~liberar~memória~da~string~{*}/}{\footnotesize \par}

~{\footnotesize ~~({*}J)->ReleaseStringUTFChars(J,~elems\_1,~elems\_1\_c);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}

\caption{\label{cap:Acesso-JNI}Código C implementando um método Java}
\end{figure}


O acesso a atributos Java em código C é ilustrado através do seguinte
exemplo. Inicialmente, na Figura~\ref{cap:Classe-Java}, é implementada
uma classe Java que possui um atributo privado, o array \texttt{elementos},
e define uma função, \texttt{segundoElemento}, a ser implementada
em C%
\footnote{Os detalhes sobre a declaração e registro de funções implementadas
em C serão discutidos na Seção \ref{sub:Java-Registro}.%
}.

A implementação de \texttt{segundoElemento} é mostrada na Fig.~\ref{cap:Acesso-JNI},
mostrando a seqüência de chamadas até obter em C o elemento do array
Java. Para acessar o atributo \texttt{elementos}, a função deve obter
o identificador do campo. Para tal, devemos inicialmente obter uma
referência da classe atual com \texttt{GetObjectClass} a partir da
referência ao objeto (\texttt{this}) passada como parâmetro à função.
De posse da referência da classe (\texttt{classe}), obtemos o identificador
do campo com \texttt{GetFieldID}. O conteúdo do campo é então obtido
com \texttt{GetObjectField}: uma referência para o array. Com este,
o elemento do array é obtido com \texttt{GetObjectArrayElement}. Uma
cópia do elemento, convertido para uma string C codificada em UTF-8,
é retornada com \texttt{GetStringUTFChars}. Como discutido anteriormente,
após o uso, a string deve ser liberada com \texttt{ReleaseStringUTFChars}.

A manipulação de objetos do tipo \texttt{Class} também é feita através
de funções específicas. Não é possível criar classes Java através
da API C, mas é possível carregar classes em tempo de execução usando
a função \texttt{DefineClass}, que recebe um buffer contendo a representação
de uma classe Java pré-compilada. Referências do tipo \texttt{jclass}
podem ser obtidas através do nome da classe usando \texttt{FindClass},
que utiliza uma sintaxe de descritores de classe similar à de descritor
de campos usada por \texttt{GetFieldID}%
\footnote{Tanto em descritores de classe como de campo, \texttt{\char`\"{}{[}Ljava/lang/String;\char`\"{}}
representam \texttt{String{[}{]}}. Para o tipo \texttt{String}, entretanto,
\texttt{\char`\"{}Ljava/lang/String;\char`\"{}} é o descritor de campo
e \texttt{\char`\"{}java/lang/String\char`\"{}} o de classe.%
}.

Para a atribuição de valores de C que podem ser convertidos para tipos
primitivos de Java, a JNI possui funções como \texttt{SetIntField}
e \texttt{SetFloatArrayRegion}. Para os demais tipos, não há uma provisão
específica para o armazenamento de dados de C no espaço de objetos
de Java. Nestes casos, a documentação sugere o armazenamento de ponteiros
em tipos numéricos~\cite{liang99jni}, apesar dos problemas de portabilidade
em que tal abordagem incorre.


\subsection{Lua\label{sub:Lua-dados}}

A API de Lua define uma abordagem diferente para a manipulação de
dados em C: não são expostos ao código C ponteiros ou \emph{handles}
para objetos Lua. As operações são definidas em termos de índices
de uma pilha virtual. Assim, a transferência de dados de C para Lua
se dá através de funções que recebem tipos de C, os convertem para
valores Lua e os empilham, como \texttt{lua\_pushboolean}, \texttt{lua\_pushinteger}
e \texttt{lua\_pushlstring}. Diversas operações da API operam sobre
o valor no topo da pilha, como por exemplo \texttt{lua\_setglobal}%
\footnote{Funções da API que operam sobre um estado de execução Lua recebem
um parâmetro inicial (nos exemplos, chamado de \texttt{L}) indicando
o estado a que se referem. Isto será discutido mais adiante, na Seção
\ref{sub:Lua-Registro}.%
}:

\begin{lyxcode}
{\footnotesize lua\_pushinteger(L,~123);~~}~\emph{\footnotesize /{*}~Insere~o~número~123~na~pilha~{*}/}{\footnotesize \par}

{\footnotesize lua\_setglobal(L,~\char`\"{}foo\char`\"{});~~}~\emph{\footnotesize /{*}~Atribui~o~número~123~na~global}~{\footnotesize foo}~\emph{\footnotesize {*}/}{\footnotesize \par}
\end{lyxcode}


A maioria das funções de consulta, entretanto, permitem especificar
um índice qualquer da pilha (com valores positivos para indexação
a partir da base e negativos para índices a partir do topo).

A conversão de dados de Lua para C é feita através de funções como
\texttt{lua\_tonumber} e \texttt{lua\_tolstring}, que recebem um índice
da pilha, convertem o valor no índice para o tipo Lua especificado
se necessário, e retornam o valor convertido para o tipo~C equivalente.
Números têm o tipo~C \texttt{lua\_Number}, que corresponde a \texttt{double}
por padrão mas é um parâmetro na compilação de Lua. Strings, em particular,
são objetos imutáveis e têm sua representação internalizada: duas
strings de conteúdo idêntico compartilham a mesma representação interna.

Assim, diferentemente de linguagens como Python e Ruby, não é possível
modificar o conteúdo de uma string Lua através de C via a sua representação
em memória como um \texttt{char{*}}. Para tornar mais eficiente a
construção em etapas de strings Lua a partir de C, a biblioteca auxiliar
define um tipo~C \texttt{luaL\_Buffer} e funções como \texttt{luaL\_addstring}
e \texttt{luaL\_addvalue}, que permitem a construção de uma string
em etapas até que ela possa ser finalmente convertida para uma string
Lua com \texttt{luaL\_pushresult}. Assim, evitam-se consecutivas operações
de concatenação de string através da API de Lua.

Lua define dois tipos de dados específicos para o armazenamento de
dados para C, \emph{full userdata} e \emph{light userdata}. \emph{Full
userdata} descrevem blocos de memória gerenciados por Lua e utilizados
por código C. Eles existem em Lua como objetos opacos, e são criados
por \texttt{lua\_newuserdata}, que insere o novo objeto na pilha de
Lua e retorna a C um ponteiro com a área de memória do tamanho requisitado.
Objetos do tipo \emph{light userdata}, criados através de \texttt{lua\_pushlightuserdata},
permitem armazenar ponteiros de C em Lua; a alocação e gerência do
bloco de memória ficam a cargo do código C. O seguinte exemplo ilustra
o uso de userdata, assumindo a mesma struct \texttt{point} definida
na página~\pageref{struct-point}. O userdata é criado da seguinte
forma:

\begin{lyxcode}
\emph{\footnotesize /{*}~Cria~o~full~userdata~e~o~insere~na~pilha~e~retorna}{\footnotesize \par}

~\emph{\footnotesize ~~o~ponteiro~para~C.~A~memória~é~alocada~por~Lua.~{*}/}{\footnotesize \par}

{\footnotesize point{*}~full\_p~=~(point{*})~lua\_newuserdata(L,~sizeof(point));}{\footnotesize \par}

\emph{\footnotesize /{*}~Utilizamos~então~o~ponteiro~em~C...~{*}/}{\footnotesize \par}

{\footnotesize full\_p->x~=~100;~full\_p->y~=~200;}{\footnotesize \par}

\emph{\footnotesize /{*}~Atribui~o~objeto~à~variável~global~Lua}~{\footnotesize Ponto}~\emph{\footnotesize {*}/}{\footnotesize \par}

{\footnotesize lua\_setglobal(L,~\char`\"{}Ponto\char`\"{});}{\footnotesize \par}
\end{lyxcode}
A seguir, o acesso:

\begin{lyxcode}
\emph{\footnotesize /{*}~Empilha~a~global~Ponto~{*}/}{\footnotesize \par}

{\footnotesize lua\_getglobal(L,~\char`\"{}Ponto\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~Obtém~o~ponteiro~C~do~userdata~no~topo~da~pilha~(posição~-1)~{*}/}{\footnotesize \par}

{\footnotesize point{*}~p~=~(point{*})~lua\_touserdata(L,~-1);}{\footnotesize \par}

{\footnotesize printf(\char`\"{}(\%d,\%d)\textbackslash{}n\char`\"{},~p->x,~p->y);}{\footnotesize \par}

\emph{\footnotesize /{*}~Restaura~a~pilha~à~posição~original,~removendo~o~item.}{\footnotesize \par}

~\emph{\footnotesize ~~Ele~não~será~coletado~pois~está~associado~à~variável~global.~{*}/}{\footnotesize \par}

{\footnotesize lua\_pop(L,~1);}{\footnotesize \par}
\end{lyxcode}


Assumindo que a global \texttt{Ponto} é a única referência para este
bloco, para liberá-lo basta sobrescrevermos \texttt{Ponto}, por exemplo,
com \texttt{nil}; a memória do full userdata poderá então ser liberada
pelo coletor de lixo, como a de qualquer valor Lua sem referências.

\begin{lyxcode}
{\footnotesize lua\_pushnil(L);}{\footnotesize \par}

{\footnotesize lua\_setglobal(L,~\char`\"{}Ponto\char`\"{});}{\footnotesize \par}
\end{lyxcode}


A área de armazenamento da pilha não se ajusta dinamicamente e as
funções da API não realizam controle de \emph{overflow}. Assim, o
programador é responsável por controlar o tamanho da pilha, através
da função \texttt{lua\_checkstack}. Na prática, o tamanho da pilha
só irá crescer na ocorrência de laços empilhando elementos, já que
seqüências típicas de operações tendem a empilhar valores e desempilhá-los
em seguida.

Tabelas são o único tipo para construção de estruturas de dados em
Lua. Lua oferece uma API completa para manipulação de tabelas a partir
de C. Tabelas podem ser criadas com \texttt{lua\_newtable} ou \texttt{lua\_createtable};
a segunda forma permite pré-alocar memória para os elementos da tabela.
As funções \texttt{lua\_gettable} e \texttt{lua\_settable} implementam
a semântica de leitura e atribuição de campos em uma tabela em Lua,
incluindo a possível chamada a metamétodos; para chamadas sem a invocação
de metamétodos existem as funções \texttt{lua\_rawget} e \texttt{lua\_rawset},
equivalentes a \texttt{rawget} e \texttt{rawset} em Lua (além das
variantes \texttt{lua\_rawgeti} e \texttt{lua\_rawseti} para conveniência).
Há ainda a função \texttt{lua\_next}, equivalente à função Lua \texttt{next},
que permite percorrer os elementos de uma tabela. Um exemplo de manipulação
de tabelas é dado a seguir:

\begin{lyxcode}
\emph{\footnotesize /{*}~tabela{[}\char`\"{}chave\char`\"{}{]}~=~12345,~em~C:~{*}/}{\footnotesize \par}

{\footnotesize lua\_getglobal(L,~\char`\"{}tabela\char`\"{});}{\footnotesize \par}

{\footnotesize lua\_pushstring(L,~\char`\"{}chave\char`\"{});}{\footnotesize \par}

{\footnotesize lua\_pushinteger(L,~12345);}{\footnotesize \par}

\emph{\footnotesize /{*}~lua\_settable~insere~o~item~no~topo~da~pilha}{\footnotesize \par}

~\emph{\footnotesize ~~~na~tabela~especificada~como~argumento,}{\footnotesize \par}

~\emph{\footnotesize ~~usando~como~chave~o~elemento~logo~abaixo~do~topo:~{*}/}{\footnotesize \par}

{\footnotesize lua\_settable(L,~-3);}{\footnotesize \par}
\end{lyxcode}


Diversos conceitos de Lua são representados através de tabelas --
ambiente global, metatabelas, registro -- e são assim tratados em
C usando as funções da API para manipulação de tabelas. A tabela do
ambiente global da \emph{thread} em execução pode ser acessada através
de um índice especial da pilha virtual, \texttt{LUA\_GLOBALSINDEX}.
Pode-se ainda definir uma tabela de ambiente da função, indexada em
\texttt{LUA\_ENVIRONINDEX}, para isolar dados a serem compartilhados
internamente em funções de módulos escritos em C. Exemplificando,
o ambiente global pode ser manipulado como uma tabela desta forma:

\begin{lyxcode}
{\footnotesize lua\_pushstring(L,~\char`\"{}Ponto\char`\"{});}{\footnotesize \par}

{\footnotesize lua\_gettable(L,~LUA\_GLOBALSINDEX);}{\footnotesize \par}
\end{lyxcode}
Isto é equivalente a:

\begin{lyxcode}
{\footnotesize lua\_getglobal(L,~\char`\"{}Ponto\char`\"{});}{\footnotesize \par}
\end{lyxcode}

\subsection{Perl\label{sub:Perl-Dados}}

Os processos de estender e embutir Perl são bastante distintos. Para
extensões, Perl oferece uma linguagem para descrição de interfaces
chamada XS. Ao invés de isolar o acesso às estruturas internas de
Perl através de uma API pública, a abordagem proposta é encapsular
o processo de geração de código \emph{wrapper} para a comunicação
entre funções escritas em C e as estruturas internas de Perl usando
interfaces escritas em XS. Arquivos \texttt{.xs} contêm código C acompanhado
de anotações que simplificam o tratamento dos parâmetros de entrada
e saída. Estes são alimentados ao pré-processador \texttt{xsubpp},
que geram então o código usando a API oferecida pela biblioteca de
Perl. Esta biblioteca oferece acesso de baixo nível ao funcionamento
do interpretador, permitindo, por exemplo, manipular o ponteiro da
sua pilha interna. O objetivo de XS é ocultar ao desenvolvedor de
extensões estes detalhes.

Para embutir o interpretador Perl em uma aplicação, a biblioteca que
a implementa oferece algumas funções que permitem disparar um interpretador.
Na API de mais alto nível, pode-se construir um array de parâmetros
a serem passados para o interpretador de forma equivalente às opções
do interpretador Perl de linha de comando, inclusive usando a opção
\texttt{\char`\"{}-e\char`\"{}} para executar trechos de código.

Os tipos de variáveis Perl são mapeados para structs em C: \texttt{SV}
para escalares, \texttt{AV} para arrays, \texttt{HV} para hashes.
Estes valores C são melhor entendidos como \emph{containers} para
valores Perl: uma variável escalar em Perl tem um \texttt{SV} associado
a si; todavia, pode-se criar em C um \texttt{SV} que não esteja associado
a nenhum nome de variável Perl.

Os \emph{typedefs} \texttt{IV}, \texttt{UV}, \texttt{NV} e \texttt{PV}
representam valores C correspondentes aos tipos primitivos de Perl,
e correspondem, respectivamente, a inteiros com e sem sinal, valores
de ponto flutuante e strings. Estes valores podem ser copiados para
\texttt{SV}s. Referências Perl são representadas como \texttt{RV},
e também são um tipo de \texttt{SV}. Há ainda o tipo \texttt{GV},
capaz de referenciar qualquer tipo representável em uma variável Perl.

Variáveis do espaço de Perl são acessadas com \texttt{get\_sv}, \texttt{get\_av}
e \texttt{get\_hv}. Estas funções recebem uma string C com o nome
da variável (possivelmente qualificado da forma \texttt{\char`\"{}pacote::variavel\char`\"{}}).
O conteúdo de valores escalares é convertido de volta para um tipo~C
com as macros \texttt{Sv}{*}: \texttt{SvIV} retorna um inteiro, \texttt{SvPV}
retorna um \texttt{char{*}} e o comprimento da string no segundo parâmetro,
etc. O seguinte código C exibe o conteúdo da variável Perl \texttt{\$a},
assumindo que ela contenha um valor inteiro:

\begin{lyxcode}
{\footnotesize printf(\char`\"{}a~=~\%d\textbackslash{}n\char`\"{},~SvIV(get\_sv(\char`\"{}a\char`\"{},~FALSE)));}{\footnotesize \par}
\end{lyxcode}


A flag passada como segundo parâmetro de \texttt{get\_sv}/\texttt{av}/\texttt{hv}
indica se a variável deve ser criada se o nome passado não corresponder
a uma variável existente. Passar um nome inexistente e usar \texttt{TRUE}
no segundo parâmetro é uma forma conveniente de criar uma nova variável
acessível no espaço de C já realizando o \emph{binding} desta no espaço
de Perl.

\begin{lyxcode}
\emph{\footnotesize /{*}~Cria~uma~variável~do~tipo~array,}{\footnotesize \par}

~\emph{\footnotesize ~~acessível~em~Perl~como~a~global~@arr~e~em~C~como~o~AV{*}~arr~{*}/}{\footnotesize \par}

{\footnotesize AV{*}~arr~=~get\_av(\char`\"{}arr\char`\"{},~TRUE);}{\footnotesize \par}
\end{lyxcode}


Um \texttt{SV} pode ser criado em C com as funções \texttt{newSV}{*}:
\texttt{newSViv} gera um novo \texttt{SV} armazenando um inteiro com
sinal; \texttt{newSVpv} a partir de uma string, e assim por diante.
A função \texttt{newSV} permite criar um \texttt{SV} com área de memória
não inicializada, acessível através da função \texttt{SvPVX}, permitindo
assim criar escalares com valores arbitrários gerenciados por código
C. Usando o mesmo exemplo da struct \texttt{point} das seções anteriores,
podemos armazenar um objeto C em um valor Perl da seguinte forma:

\begin{lyxcode}
\emph{\footnotesize /{*}~Aloca~um~SV~não~inicializado~do~tamanho~de~um}~{\footnotesize point}~\emph{\footnotesize {*}/}{\footnotesize \par}

{\footnotesize SV{*}~v~=~newSV(sizeof(point));}{\footnotesize \par}

\emph{\footnotesize /{*}~Obtém~o~ponteiro~para~a~área~de~memória~do}~{\footnotesize SV}~\emph{\footnotesize {*}/}{\footnotesize \par}

{\footnotesize point{*}~p~=~(point{*})~SvPVX(v);}{\footnotesize \par}

\emph{\footnotesize /{*}~Manipula~o}~{\footnotesize point}~\emph{\footnotesize em~C.~Quando~v~for~retornado~para~Perl,}{\footnotesize \par}

\emph{\footnotesize ele~será~uma~variável~opaca~(seu~conteúdo~não~será~acessível}{\footnotesize \par}

\emph{\footnotesize via~Perl).~{*}/}{\footnotesize \par}

{\footnotesize p->x~=~100;~p->y~=~200;}{\footnotesize \par}
\end{lyxcode}


Valores são atribuídos a \texttt{SV}s usando as funções \texttt{sv\_set}{*}:
\texttt{sv\_setiv}, \texttt{sv\_setpv}, etc. As funções para manipulação
de strings possuem variantes como \texttt{newSVpvn} e \texttt{sv\_setpvf},
que permitem especificar o comprimento da string ou realizar formatação
como em \texttt{sprintf}. Para strings, há ainda funções \texttt{sv\_cat}{*},
que atuam como \texttt{sv\_set}{*} mas concatenam o valor dado ao
conteúdo atual da string ao invés de substituí-lo. A função \texttt{sv\_setsv}
copia o valor de um \texttt{SV} para outro. O \texttt{SV} criado no
exemplo anterior pode ser atribuído para uma variável global da seguinte
forma:

\begin{lyxcode}
\emph{\footnotesize /{*}~Obtém~o~SV~da~variável~global}~{\footnotesize \$ponto}~\emph{\footnotesize {*}/}{\footnotesize \par}

{\footnotesize SV{*}~ponto~=~get\_sv(\char`\"{}ponto\char`\"{},~TRUE);}{\footnotesize \par}

\emph{\footnotesize /{*}~Atribui~o~valor~de~v~para~ponto~{*}/}{\footnotesize \par}

{\footnotesize sv\_setsv(ponto,~v);}{\footnotesize \par}
\end{lyxcode}


O tipo dos dados armazenados em \texttt{SV}s é verificado com as macros
\texttt{SvIOK} para inteiros, \texttt{SvNOK} para valores de ponto
flutuante e \texttt{SvPOK} para strings. Estas funções retornam sucesso
se o escalar é conversível para o tipo especificado -- as variantes
\texttt{SvIOKp}, \texttt{SvNOKp}, \texttt{SvPOKp} verificam se o valor
armazenado no \texttt{SV} é realmente do tipo.

Arrays e hashes são criados com \texttt{newAV} e \texttt{newHV}. Arrays
podem ser populados com um array C de ponteiros para \texttt{SV} através
de \texttt{av\_make}. Operações como \texttt{av\_fetch}, \texttt{av\_pop},
\texttt{hv\_fetch} e \texttt{hv\_exists} permitem operar sobre elementos
das estruturas. Em \texttt{av\_fetch} e \texttt{hv\_fetch}, o tipo
de retorno é \texttt{SV{*}{*}}, para diferenciar o retorno de um elemento
existente que aponta para \texttt{NULL} de um elemento não encontrado.
No exemplo a seguir, criaremos um array Perl contendo os 10 primeiros
elementos da série de Fibonacci:

\begin{lyxcode}
\emph{\footnotesize /{*}~Cria~um~novo~array.~{*}/}{\footnotesize \par}

{\footnotesize AV{*}~a~=~newAV();}{\footnotesize \par}

\emph{\footnotesize /{*}~Armazena~dois~valores,~0~e~1,~nas~primeiras~posições~do~array.~{*}/}{\footnotesize \par}

{\footnotesize av\_push(a,~newSViv(0));}{\footnotesize \par}

{\footnotesize av\_push(a,~newSViv(1));}{\footnotesize \par}

{\footnotesize for~(int~i~=~2;~i~<~10;~i++)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obviamente~seria~mais~eficiente~armazenar~os~valores~em}{\footnotesize \par}

~\emph{\footnotesize ~~~~~variáveis~temporárias~em~C,~mas~obtenhamos~os~dois~últimos}{\footnotesize \par}

~\emph{\footnotesize ~~~~~valores~da~seqüência~de~volta~do~array~Perl~para~fins~de}{\footnotesize \par}

~\emph{\footnotesize ~~~~~ilustração:~{*}/}{\footnotesize \par}

~{\footnotesize ~~SV{*}{*}~penultimo\_sv~=~av\_fetch(a,~i-2,~FALSE);}{\footnotesize \par}

~{\footnotesize ~~SV{*}{*}~ultimo\_sv~=~av\_fetch(a,~i-1,~FALSE);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obtém~os~inteiros~armazenados~nos~SVs~{*}/}{\footnotesize \par}

~{\footnotesize ~~int~penultimo~=~SvIV({*}penultimo\_sv);}{\footnotesize \par}

~{\footnotesize ~~int~ultimo~=~SvIV({*}ultimo\_sv);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Cria~um~novo~SV~e~o~insere~no~final~do~array~{*}/}{\footnotesize \par}

~{\footnotesize ~~av\_push(a,~newSViv(~penultimo~+~ultimo~)~);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Uma vez criado este \texttt{AV}, entretanto, não há uma forma de associá-lo
a uma variável Perl. Seu conteúdo deve ser copiado item a item. Para
que este seja acessível a partir de Perl, deveríamos tê-lo criado
com \texttt{get\_av}, e não \texttt{newAV}. A utilidade de \texttt{AV}s
não associados a variáveis está na passagem de parâmetros na chamada
de funções e como valores de retorno.

Algumas funções para manipulação de hashes expõem os pares chave/valor
como ponteiros \texttt{HE}. As macros \texttt{HeSVKEY} e \texttt{HeVAL}
permitem extrair a chave e valor de um \texttt{HE}. A seguinte função
exibe em C os elementos de uma hash Perl:

\begin{lyxcode}
{\footnotesize void~imprime\_hash(HV{*}~hash)~\{}{\footnotesize \par}

~{\footnotesize ~~HE{*}~item;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Cada~HV~mantém~o~seu~controle~interno~de~iteração~{*}/}{\footnotesize \par}

~{\footnotesize ~~hv\_iterinit(hash);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obtém~o~próximo~par~chave/valor~da~iteração~{*}/}{\footnotesize \par}

~{\footnotesize ~~while~(~(item~=~hv\_iternext(hash))~)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Obtém~a~representação~string~dos~escalares}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~representando~chave~e~valor~do~item~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~char{*}~chave~=~SvPV\_nolen(HeSVKEY(item));}{\footnotesize \par}

~{\footnotesize ~~~~~char{*}~valor~=~SvPV\_nolen(HeVAL(item));}{\footnotesize \par}

~{\footnotesize ~~~~~printf(\char`\"{}\%s~=>~\%s\textbackslash{}n\char`\"{},~chave,~valor);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Cuidados especiais devem ser tomados ao utilizar os valores \texttt{undef},
\texttt{true} e \texttt{false} em arrays e hashes, embora Perl exponha
estas constantes na API de C (\texttt{PL\_sv\_undef}, \texttt{PL\_sv\_true},
\texttt{PL\_sv\_false}). A constante \texttt{PL\_sv\_undef} é usada
internamente na implementação de \texttt{AV}s e \texttt{HV}s, e a
atualização de valores em \texttt{HV}s ocorre \emph{in-place}, o que
gera problemas ao atualizar elementos contendo estas constantes. A
documentação recomenda gerar cópias destes valores ao usá-los em estruturas
\texttt{AV} e \texttt{HV}~\cite{okamoto06perlguts}.

Referências Perl são criadas com \texttt{newRV\_inc} e \texttt{newRV\_noinc},
que recebem um ponteiro para \texttt{SV}, \texttt{AV} ou \texttt{HV}
como parâmetro (as duas funções diferem entre si no que tange à contagem
de referências, que será abordada na Seção~\ref{sub:Perl-GC}). O
valor apontado por uma referência é obtido com \texttt{SvRV}. O retorno
desta macro deve ser convertido via \emph{cast} para o tipo apropriado
(\texttt{IV}, \texttt{PV}, \texttt{AV}, etc.), que pode ser verificado
com \texttt{SvTYPE}. 

Diversas funções da API têm tipo de parâmetros ou retorno declarados
como \texttt{SV} quando na verdade aceitam \texttt{AV}s ou \texttt{HV}s;
isto é análogo ao conceito de \emph{contextos} de Perl, onde um mesmo
valor pode ser tratado como lista (array ou hash) ou escalar dependendo
da expressão onde ele é inserido~\cite{marquess06perlcall}. Em código
Perl, o contexto em que uma função está executando pode ser verificado
com \texttt{wantarray}. Em~C, o contexto pode ser verificado com
a macro \texttt{GIMME\_V}, que retorna \texttt{G\_VOID}, \texttt{G\_SCALAR}
ou \texttt{G\_ARRAY}.


\subsection{Comparação}

O conjunto básico de funções para manipulação de dados nas cinco linguagens
discutidas é similar: todas elas possuem funções para converter valores
da linguagem para tipos básicos de C e vice-versa. Todas oferecem
ainda funções para a manipulação dos seus tipos estruturados fundamentais
(tabelas em Lua, arrays em Java, arrays e hashes em Ruby e Perl, listas
e dicionários em Python). Python, em particular, define uma API extensa
de funções para operações sobre as suas classes \emph{built-in}; a
maioria destas operações poderia ser realizada usando a API genérica
de invocação de métodos, mas são oferecidas diretamente em C como
conveniência.

Lua ganha destaque por possuir, com o seu modelo de pilha, a API para
manipulação de dados mais simples e ortogonal dentre as estudadas.
Entretanto, muitas vezes o código resultante perde em legibilidade
quando os índices da pilha são pouco óbvios. É comum ver código C
usando a API de Lua comentado linha a linha, para evitar que o programador
tenha que simular mentalmente o funcionamento da pilha ao ler o programa.

Em Java, a tipagem estática reduz muito a necessidade de conversões
de dados explícitas no código C. Por outro lado, o tratamento de \emph{multi-threading}
complica o acesso a tipos como strings e arrays.

Um ponto negativo na API de Ruby é a exposição de detalhes de implementação
dos campos da struct que descreve o seu tipo fundamental \texttt{VALUE}.
Isto restringe a flexibilidade da implementação da linguagem e é uma
prática de programação pouco segura. Perl também expõe grande parte
de suas estruturas internas; não de forma tão direta quanto Ruby,
mas através de macros. Tais macros, entretanto, assumem a aderência
a protocolos tão estritos de uso que na prática também limitam largamente
as possiblidades de alterações na implementação (um exemplo é a seqüência
para chamada de funções, que será apresentada na Seção~\ref{sub:Perl-call}).

A criação de dados que contêm estruturas C armazenados pela linguagem
de script é uma tarefa fácil em Perl, Ruby e Lua: Perl permite criar
\texttt{SV}s contendo blocos de memória arbitrários para uso em C;
Ruby disponibiliza a macro \texttt{Data\_Wrap\_Struct} que gera um
objeto Ruby que encapsula uma estrutura C; Lua define um tipo básico
na linguagem especialmente para este fim. Já em Python, o processo
é trabalhoso. Criar uma classe Python a partir de C envolve declarar
partes dela estaticamente e outras partes dinamicamente, sendo usualmente
necessário definir três estruturas C diferentes. Em Java, não é possível
criar novos tipos a partir de C, apenas carregar classes.

Outra tarefa comum ao interagir com C é a necessidade de armazenar
ponteiros no espaço de dados da linguagem de script. Python, Lua e
Perl oferecem recursos para fazer isto de forma direta: criando um
objeto \texttt{PyCObject} em Python; um light userdata em Lua; ou
armazenando o ponteiro na área de dados de um \texttt{SV} em Perl.
Em Java e Ruby, a alternativa é converter os ponteiros e armazená-los
como números. De fato, isto ocorre internamente na implementação de
Ruby, e as limitações de portabilidade desta abordagem são evidenciados
pelo fato de que a compilação de Ruby falha se \texttt{sizeof(void{*})
!= sizeof(long)}.

Outro aspecto que merece nota é a preocupação em não poluir o espaço
de nomes de~C. Python, Java e Lua definem todas as suas funções e
tipos C com prefixos que visam evitar conflitos com nomes definidos
pela aplicação. Já Perl e Ruby definem nomes de forma desorganizada,
o que ocasionalmente causa problemas%
\footnote{Por exemplo, conflitos deste tipo ocorreram nos bindings Ruby do sistema
de controle de versão Subversion em plataformas Win32 (\url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}).%
}. Perl possui opções para desabilitar uma série de macros e forçar
um prefixo comum em suas funções, mas este recurso é incompleto e
usá-lo prejudica a funcionalidade dos seus cabeçalhos%
\footnote{No estudo de caso apresentado no Capítulo \ref{cha:Estudo-de-caso:},
ao utilizar a API de Perl procuramos utilizar somente as versões com
prefixo \texttt{Perl\_} das funções da API, mas diversas macros só
estão disponíveis nas versões sem o prefixo.%
}.


\section{Coleta de lixo\label{sec:Coleta-de-lixo}}

A partir do momento em que código C ganha acesso a referências a dados
armazenados no espaço de armazenamento de outra linguagem, sejam ponteiros
ou identificadores, o programador deve levar em consideração as diferenças
entre os modelos de gerência de memória envolvidos, já que código
executado na outra linguagem pode liberar o dado. Por exemplo, o programa
C pode desalocar o objeto referenciado em um dado da linguagem de
script, ou a linguagem de script pode remover um elemento de uma estrutura
fazendo com que ele seja coletado. Em princípio, esta tarefa de manter
a consistência entre os dois ambientes não é diferente da gerência
de memória realizada normalmente pelo programador em C. Entretanto,
a interação com algumas linguagens adiciona um complicador: os mecanismos
de coleta de lixo realizam liberação de dados da memória de forma
implícita. O princípio fundamental da coleta de lixo dita que um objeto
não é coletado caso haja algum elemento (variável, estrutura de dados)
apontando para ele. Todavia, o mesmo não vale para o ambiente C: a
presença de um ponteiro apontando para um objeto não garante que ele
não será coletado, uma vez que o coletor de lixo não gerencia os ponteiros
do código~C.

É preciso, então, indicar a partir do código~C que os dados que continuam
acessíveis por ele não devem ser coletados. De forma complementar,
ao transferir o controle de objetos~C para o domínio da outra linguagem
-- por exemplo, para armazená-los em uma estrutura de dados desta
-- é necessário indicar à linguagem como desalocar a memória da estrutura
quando o coletor de lixo detectar que ela não está mais em uso. A
forma como a API irá fornecer estas funcionalidades depende não só
do projeto da API para C, mas também do modelo de coleta de lixo empregado
pela implementação da linguagem.


\subsection{Python\label{sub:Python-GC}}

A máquina virtual de Python possui um coletor de lixo baseado em contagem
de referências. Como a API de Python retorna ao código C ponteiros
a \texttt{PyObject}s, o programador deve ter o cuidado de garantir
que eles se mantenham válidos. Para isto, é necessário incrementar
e decrementar o contador de referências do objeto apontado conforme
deseja-se manter a validade dos ponteiros em código C.

De maneira geral, uma vez que código C deseja reter um \texttt{PyObject{*}},
ele deve utilizar a macro \texttt{Py\_INCREF} para incrementar a sua
contagem de referências e assim impedi-lo de ser coletado. Uma vez
que o valor não seja mais necessário, decrementa-se a contagem similarmente
com \texttt{Py\_DECREF}. Python trabalha com o conceito de \emph{{}``propriedade
de referências''} para definir quando o programador deve incrementar
ou decrementar o contador de referências retornadas pelas funções
da API. A maior parte das funções da API que retornam ponteiros a
\texttt{PyObject}s \emph{transferem} referências para o chamador;
a referência passa então a ser sua responsabilidade -- ele pode passá-la
adiante ou terá o dever de decrementá-la com \texttt{Py\_DECREF} assim
que não precisar mais usá-la (o código C pode guardar referências
que sejam de sua propriedade em suas estruturas de dados; elas continuarão
válidas mesmo após o retorno da função, até serem explicitamente decrementadas).
Outras funções \emph{emprestam} referências; o código que recebe uma
referência deste tipo não precisa decrementá-la ao terminar de utilizá-la,
mas a validade do objeto está atrelada à validade da referência no
objeto que a retornou ao código C. Por exemplo, \texttt{PyList\_GetItem}
empresta uma referência a um elemento da lista. O ponteiro retornado
continuará válido enquanto este item continuar contido na lista. Pode-se
obter a {}``propriedade'' de uma referência emprestada incrementando
a contagem do objeto com \texttt{Py\_INCREF}: a validade do ponteiro
passa a ser independente do objeto \emph{container} que o retornou,
mas o código C passa a ser responsável por decrementar a referência
posteriormente com \texttt{Py\_DECREF}.

Para referências de objetos passadas de código C de volta para Python,
há dois casos na API em que funções \emph{{}``roubam''} referências,
isto é, em que a referência deixa de pertencer à função C chamadora:
\texttt{PyList\_SetItem} e \texttt{PyTuple\_SetItem}. A referência
passada, que pertencia ao chamador, passa então a pertencer à lista
ou tupla. No contexto do chamador, ele passa a ser uma referência
emprestada, que não precisa mais ser decrementada. O objetivo disto
é permitir chamadas de função aninhadas onde, por exemplo, o parâmetro
de \texttt{PyList\_SetItem} é uma chamada que gera um novo objeto
a ser armazenado na lista. Assim, evita-se que o programador tenha
que armazenar um ponteiro para o objeto apenas para decrementar a
sua referência posteriormente.

%
\begin{figure}[tb]
\begin{lyxcode}
{\footnotesize void~bug(PyObject{*}~list)~\{}{\footnotesize \par}

~{\footnotesize ~~PyObject{*}~item~=~PyList\_GetItem(list,~0);}{\footnotesize \par}

~{\footnotesize ~~if~(!item)~return;}{\footnotesize \par}

~{\footnotesize ~~PyList\_SetItem(list,~1,~PyInt\_FromLong(0L));}{\footnotesize \par}

~{\footnotesize ~~PyObject\_Print(item,~stdout,~0);~/{*}~BUG!~{*}/}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
\begin{center}\textbf{\footnotesize (a)} {\footnotesize Acesso possivelmente
inválido em} \texttt{\footnotesize PyObject\_Print}\end{center}{\footnotesize \par}

\begin{lyxcode}
{\footnotesize void~no\_bug(PyObject{*}~list)~\{}{\footnotesize \par}

~{\footnotesize ~~PyObject{*}~item~=~PyList\_GetItem(list,~0);}{\footnotesize \par}

~{\footnotesize ~~if~(!item)~return;}{\footnotesize \par}

~{\footnotesize ~~Py\_INCREF(item);}{\footnotesize \par}

~{\footnotesize ~~PyList\_SetItem(list,~1,~PyInt\_FromLong(0L));}{\footnotesize \par}

~{\footnotesize ~~PyObject\_Print(item,~stdout,~0);}{\footnotesize \par}

~{\footnotesize ~~Py\_DECREF(item);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
\begin{center}{\footnotesize (b)} \texttt{\footnotesize item} {\footnotesize é
garantidamente válido em} \texttt{\footnotesize PyObject\_Print} {\footnotesize }\end{center}{\footnotesize \par}


\caption{\label{cap:python-gc}Acesso possivelmente inválido a uma referência
a um \texttt{PyObject} em código C}
\end{figure}


A interação com o contador de referências pode ser bastante sutil.
O exemplo da Figura~\ref{cap:python-gc}, extraído da documentação
de Python~\cite{vanrossum06extpy}, demonstra que uma referência
pode ser invalidada por código aparentemente não relacionado%
\footnote{De fato, a documentação informa que versões antigas de Python continham
variantes deste \emph{bug} em alguns de seus módulos.%
}. À primeira vista, a inclusão de um elemento em \texttt{list{[}1{]}}
parece não afetar a referência \texttt{item}, que corresponde a \texttt{list{[}0{]}}.
Todavia, a inclusão de \texttt{list{[}1{]}} pode haver removido da
lista um elemento que se encontrava nesta posição. Caso a lista fosse
a última referência válida para o elemento, este poderia ser coletado.
A coleta do objeto pode invocar o seu método finalizador \texttt{\_\_del\_\_},
que pode rodar código Python arbitrário. Se este código remove o elemento
da posição 0 de \texttt{list} e isto causar a sua coleta, a referência
\texttt{item} passa a ser inválida, porque \texttt{PyList\_GetItem}
retorna uma referência emprestada.

Ao implementar funções em C que retornam referências a \texttt{PyObject}s,
o mesmo cuidado de definir a política de tempo de vida da referência
deve ser tomado. Para retornar uma referência nova, pode ser necessário
incrementar a contagem do objeto. Isto se manifesta, por exemplo,
na forma correta de uma função C retornar o valor \texttt{None}, que
envolve chamar \texttt{Py\_INCREF(Py\_none)}%
\footnote{Este padrão é tão comum que a seqüência \texttt{Py\_INCREF(Py\_none);
return Py\_none;} foi encapsulada na macro \texttt{Py\_RETURN\_NONE}.%
}. Mesmo objetos Python representando números devem ter a sua contagem
de referências controlada pelo programador C. 

Para que o código C possa realizar operações de finalização sobre
os dados armazenados em um tipo Python definido em C, é possível definir
uma função de desalocação no campo \texttt{tp\_dealloc} da estrutura
\texttt{PyTypeObject} que descreve o tipo. Esta função é normalmente
responsável por liberar recursos alocados via código C (arquivos abertos,
ponteiros para áreas de memória não acessíveis por Python, etc.) e
decrementar referências a outros objetos Python mantidas pelo objeto.

Ao desalocar estruturas de dados como listas pode-se provocar uma
cadeia arbitrariamente grande de desalocações, à medida que cada elemento
desencadeia a desalocação do próximo elemento da estrutura. Isto dispara
a função de desalocação recursivamente e poderia facilmente causar
estouro da pilha de C. Para contornar este problema, Python inclui
um par de macros, \texttt{Py\_TRASHCAN\_SAFE\_BEGIN} e \texttt{Py\_TRASHCAN\_SAFE\_END},
que controla o número de níveis de recursão aceitos. A cada execução
de \texttt{Py\_TRASHCAN\_SAFE\_BEGIN} um contador interno é incrementado.
Enquanto este contador não atingir o valor limite definido na constante
\texttt{PyTrash\_UNWIND\_LEVEL} (50 por padrão), a função executa
normalmente. Quando o limite é atingido, \texttt{Py\_TRASHCAN\_SAFE\_BEGIN}
armazena o objeto em uma lista interna e salta diretamente para \texttt{Py\_TRASHCAN\_SAFE\_END},
evitando desalocar o objeto e entrar em recursão novamente. Ao final
de cada nível da recursão, a macro \texttt{Py\_TRASHCAN\_SAFE\_END}
decrementa o contador. Quando o contador chega a zero, \texttt{Py\_TRASHCAN\_SAFE\_END}
dispara novamente \texttt{tp\_dealloc} sobre os elementos armazenados
na lista interna, reiniciando assim a recursão sobre a estrutura.
Assim, uma cadeia de $n$ desalocações é quebrada em $n/$\texttt{PyTrash\_UNWIND\_LEVEL}
cadeias, nenhuma excedendo \texttt{PyTrash\_UNWIND\_LEVEL} níveis
de recursão na pilha de C. As implementações dos principais tipos
estruturados de Python, como listas, tuplas e dicionários, fazem uso
deste mecanismo.

O modelo de coleta de lixo utilizando contagem de referências traz
consigo preocupações sobre referências circulares: uma cadeia de objetos
que mantêm referências entre si mantém a contagem de cada um dos seus
elementos acima de zero, mesmo que eles não sejam alcançáveis a partir
de nenhum outro objeto. Python inclui um detector de ciclos, mas cuidados
especiais devem ser tomadas para que tipos implementados em C se comportem
corretamente caso possam gerar ciclos. Deve-se implementar uma função
para percorrer referências contidas no objeto e uma função que decremente
a contagem destas referências. Estas funções devem ser registradas
nos campos \texttt{tp\_traverse} e \texttt{tp\_clear} da estrutura
\texttt{PyTypeObject}. A função \texttt{tp\_clear} deve ter o cuidado
de zerar o valor de seus campos \texttt{PyObject{*}} para \texttt{NULL}
antes de decrementar cada referência, uma vez que a operação de decremento
pode iniciar a desalocação do objeto e disparar uma chamada a \texttt{tp\_traverse}
que, devido ao ciclo, retorne ao objeto anterior. O tipo deve ser,
então, identificado com a flag \texttt{Py\_TPFLAGS\_HAVE\_GC} no campo
\texttt{tp\_flags} de \texttt{PyTypeObject}.

Além disso, a implementação de objetos Python que suportem coleta
cíclica em C implica ainda em outros cuidados. Objetos devem ser alocados
com \texttt{PyObject\_GC\_New} ou \texttt{PyObject\_GC\_NewVar} ao
invés da funções usuais \texttt{PyObject\_New} e \texttt{PyObject\_NewVar}.
Durante a construção do objeto, após os campos a serem visitados por
\texttt{tp\_traverse} terem sido preenchidos, é necessário ainda chamar
uma função de notificação \texttt{PyObject\_GC\_Track} e durante a
desalocação, antes de invalidar os campos do objeto, chamar \texttt{PyObject\_GC\_UnTrack}.
Para objetos que necessitem do mecanismo de \emph{{}``trashcan''}
para evitar estouro de pilha, é ainda preciso tomar o cuidado de desmarcar
o objeto com \texttt{PyObject\_GC\_UnTrack} antes de entrar no bloco
\texttt{Py\_TRASHCAN\_SAFE\_BEGIN}/\texttt{END}.



Apesar de oferecer um mecanismo de detecção de ciclos, Python é incapaz
de coletar ciclos cujos objetos contenham finalizadores implementados
em Python (métodos \texttt{\_\_del\_\_}); a única forma de acessar
estes objetos é então através da lista \texttt{garbage} no módulo
\texttt{gc}. Este módulo (acessível a partir de C através de chamadas
de função Python via API) oferece uma interface com o coletor de lixo,
incluindo funções como \texttt{enable} e \texttt{disable}, para ativar
e desativar o coletor de lixo; \texttt{collect}, para executar uma
coleta; \texttt{get\_objects}, que retorna uma lista contendo todos
os objetos controlados pelo coletor (exceto a própria lista); \texttt{get\_referrers}
e \texttt{get\_referents}, que retornam a lista de objetos que referenciam
ou são referenciados por um dado objeto -- estas listas são obtidas
percorrendo objetos com a função \texttt{tp\_traverse}, o que pode
não apontar para todos os objetos realmente alcançáveis, ou ainda
retornar objetos em estado inválido (como objetos em ciclos ainda
não coletados ou objetos ainda não totalmente construídos) e assim
devem ser usadas apenas para fins de depuração.


\subsection{Ruby\label{sub:Ruby-GC}}

Ruby utiliza um coletor de lixo \emph{mark-and-sweep}~\cite{wilson92gc}.
Esta técnica evita o problema de referências cíclicas enfrentado por
Python, bastando que os objetos válidos possam ser corretamente indicados
como alcançáveis.

Objetos alcançáveis a partir do espaço de objetos de Ruby -- atribuídos
a uma variável global Ruby ou inseridos em alguma estrutura de dados
alcançável em Ruby -- não estarão sujeitos à coleta de lixo. Além
destes, temos ainda os objetos retornados por Ruby para o espaço de
C, já que muitas funções de API retornam \texttt{VALUE}s. A documentação
alerta que, para armazenar objetos Ruby em C, seja em variáveis globais
ou estruturas de dados, é necessário notificar à máquina virtual que
o \texttt{VALUE} não deve ser coletado usando a função \texttt{rb\_global\_variable}~\cite{thomas04ruby}
(Embora a documentação não informe, é possível desmarcar um valor
global com \texttt{rb\_gc\_unregister\_address}).

Objetos de escopo local a uma função C, entretanto, não precisam ser
notificados. A forma como Ruby garante a validade de \texttt{VALUE}s
locais é bastante peculiar: ao realizar a fase de marcação, o coletor
de lixo varre a pilha de C em busca de valores que se pareçam com
endereços de \texttt{VALUE}s, isto é, seqüências numéricas que correspondam
a endereços de \texttt{VALUE}s válidos. Estes endereços podem ser
identificados pois objetos são sempre alocados dentro de \emph{heaps}
mantidas pelo interpretador Ruby. Cada \texttt{VALUE} encontrado na
pilha é então marcado. Isto garante que nenhum \texttt{VALUE} localmente
alcançável por código C seja invalidado, mas pode gerar {}``falsos
positivos'' evitando que dados que poderiam ser coletados o sejam.

Apesar da conveniência para o programador, tal abordagem é extremamente
não-portável. A implementação do coletor de lixo em Ruby 1.8.2 possui
\texttt{\#ifdef}s para IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC,
Atari ST, AIX, MS-DOS, Human68k, Windows CE, SPARC e Motorola 68000.
Além disso, o coletor força a descarga dos registradores para a pilha
usando \texttt{setjmp}, para evitar que variáveis do tipo \texttt{VALUE}
que tenham sido otimizadas pelo compilador deixem de ser verificadas.

Conforme visto na Seção~\ref{sub:Ruby-dados}, objetos Ruby criados
com \texttt{Data\_Wrap\_Struct} contêm structs C, que podem conter
referências a \texttt{VALUE}s Ruby. A struct encapsulada, entretanto,
é opaca para o universo Ruby. Então, para garantir que estes \texttt{VALUE}s
sejam marcados como alcançáveis durante a coleta de lixo é necessário
fazer isto via código C. \texttt{Data\_Wrap\_Struct} recebe, além
da struct a encapsular, dois ponteiros, um para uma função de marcação
e outra para uma função de desalocação. Quando o coletor de lixo visita
o objeto na fase de marcação, ele invoca a função registrada, que
deve chamar \texttt{rb\_gc\_mark} em cada um dos \texttt{VALUE}s armazenados
na \emph{struct} do objeto, informando assim que os objetos são alcançáveis.
Quando um objeto encapsulado via \texttt{Data\_}{*}\texttt{\_Struct}
for dado como não alcançável, a função de desalocação registrada é
chamada. Para estruturas que não armazenam outros \texttt{VALUE}s,
pode-se definir a função de marcação como \texttt{NULL} e a de desalocação
como \texttt{free}.

Ruby possui um módulo \texttt{GC} que disponibiliza funções para ativar
e desativar o coletor (\texttt{GC.enable} e \texttt{GC.disable}),
bem como disparar uma coleta imediatamente (\texttt{GC.start}). Na
API em C há funções equivalentes: \texttt{rb\_gc\_enable}, \texttt{rb\_gc\_disable}
e \texttt{rb\_gc\_start}. A API de C inclui ainda uma função que insere
um objeto imediatamente na lista de objetos a serem reciclados pelo
alocador de memória de Ruby, \texttt{rb\_gc\_force\_recycle}. Esta
função deve ser usada com cuidado, já que se houverem outras referências
apontando ao objeto elas passarão a apontar para outro objeto quando
a área de memória for reutilizada pelo alocador de Ruby.

Ruby oferece ainda como conveniência para o programador C alguns \emph{wrappers}
para as funções \texttt{malloc} e \texttt{realloc} que interagem com
o coletor de lixo, forçando a execução do coletor durante alocações
grandes%
\footnote{O limite para definir {}``grande'' se ajusta de acordo com o funcionamento
do coletor e com as alocações realizadas anteriormente.%
} ou em situações de pouca memória disponível.


\subsection{Java\label{sub:Coleta-Java}}

Assim como Python e Ruby, a API de Java retorna referências a objetos
da máquina virtual que podem ser armazenados em variáveis C. A JNI
define três tipos de referências, \emph{locais}, \emph{globais} e
\emph{globais fracas}, para auxiliar no controle do tempo de vida
destas e a sua interação com o coletor de lixo.

Referências locais são retornadas pela maioria das funções da JNI
e são válidas até o retorno da função C que a obteve. Não é necessário
desalocar explicitamente uma referência local: durante a execução
de uma função C, a JVM mantém uma lista de referências locais passadas
à função e libera todas elas quando o controle retorna à máquina virtual.
Isto faz com que, de maneira geral, o programador não precise se preocupar
com o coletor de lixo enquanto manipula valores retornados durante
uma função. Por outro lado, em código que pode utilizar uma grande
quantidade de referências locais é mais eficiente desalocar referências
locais explicitamente, usando \texttt{DeleteLocalRef}. A partir da
versão 1.2 de Java, funções foram adicionadas para permitir a gerência
de referências locais em blocos. \texttt{PushLocalFrame} e \texttt{PopLocalFrame}
permitem criar escopos aninhados de referências locais, que são desalocados
de uma só vez. \texttt{PushLocalFrame} recebe ainda um parâmetro indicando
um número de \emph{slots} a serem pré-alocados, como otimização. Esse
valor pode ser configurado também com \texttt{EnsureLocalCapacity}.

Referências globais são geradas a partir de referências locais usando
\texttt{NewGlobalRef}. Referências deste tipo mantêm-se válidas até
serem explicitamente desalocadas com \texttt{Delete\-GlobalRef}.
Uma referência global impede o objeto de ser coletado, podendo assim,
ser utilizada para armazenar objetos Java no espaço de C além da duração
de uma função, por exemplo, em variáveis globais ou estáticas.

A Figura~\ref{cap:JNI-global-ref} mostra um exemplo do tipo de gerência
de referências necessário quando se tem um laço criando referências
temporárias sobre um número arbitrário de objetos.

No exemplo, a função \texttt{Java\_Exemplo\_concatArray} (equivalente,
portanto, ao método \texttt{concatArray} de uma classe \texttt{Exemplo})
converte os elementos de um array para strings usando \texttt{Object.toString}
e os concatena usando \texttt{String.concat}. Note que, como o número
de vezes que o laço executa depende do tamanho do array passado, deve-se
evitar que o número de referências cresça em cada iteração. Para isso,
as opções seriam ou usar \texttt{Push}/\texttt{PopLocalFrame}, ou
destruir as referências uma a uma com \texttt{DeleteLocalRef}. Se
usássemos \texttt{Push}/\texttt{PopLocalFrame} no exemplo, teríamos
que manter a string concatenada até o momento em uma referência global.
Além disso, esta referência teria que ser destruída e recriada a cada
iteração, já que strings são imutáveis em Java. Como o número de locais
é pequeno, é mais conveniente neste caso controlá-las explicitamente
com \texttt{DeleteLocalRef} do que recorrer a referências globais. 

\texttt{PopLocalFrame} permite, através de um parâmetro adicional,
transferir uma referência local do conjunto que está sendo desempilhado
para o escopo exterior de referências locais, criando assim uma nova
referência. Para o exemplo da Figura~\ref{cap:JNI-global-ref}, isto
ainda não evitaria a necessidade de liberar referências locais explicitamente
a cada iteração do laço, já que cada \texttt{PopLocalFrame} criaria
uma referência local nova.

%
\begin{figure}[tb]
\begin{lyxcode}
{\footnotesize static~jmethodID~concat~=~NULL,~toString~=~NULL;}{\footnotesize \par}



\emph{\footnotesize /{*}~Fazer~o~caching~de~jmethodIDs~em~código~C~é~uma~técnica~comum.}{\footnotesize \par}

~\emph{\footnotesize ~~Vale~lembrar~que~jmethodIDs~não~são~objetos~Java,~e~portanto}{\footnotesize \par}

~\emph{\footnotesize ~~não~estão~sujeitos~a~coleta~de~lixo.~{*}/}{\footnotesize \par}

{\footnotesize void~cache\_ids(JNIEnv{*}~J)~\{}{\footnotesize \par}

~{\footnotesize ~jclass~cls~=~({*}J)->FindClass(J,~\char`\"{}java/lang/String\char`\"{});}{\footnotesize \par}

~{\footnotesize ~concat~=~({*}J)->GetMethodID(J,~cls,~\char`\"{}concat\char`\"{},}{\footnotesize \par}

~{\footnotesize ~~~~\char`\"{}(Ljava/lang/String;)Ljava/lang/String;\char`\"{});}{\footnotesize \par}

~{\footnotesize ~cls~=~({*}J)->FindClass(J,~\char`\"{}java/lang/Object\char`\"{});}{\footnotesize \par}

~{\footnotesize ~toString~=~({*}J)->GetMethodID(J,~cls,~\char`\"{}toString\char`\"{},}{\footnotesize \par}

~{\footnotesize ~~~~\char`\"{}()Ljava/lang/String;\char`\"{});}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}

~{\footnotesize }{\footnotesize \par}

{\footnotesize JNIEXPORT~jstring~JNICALL}{\footnotesize \par}

{\footnotesize Java\_Exemplo\_concatArray(JNIEnv{*}~J,~jobject~this,~jobjectArray~a)~\{}{\footnotesize \par}

~{\footnotesize ~~if~(!concat)~cache\_ids(J);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~s~=~\char`\"{}\char`\"{}~{*}/}{\footnotesize \par}

~{\footnotesize ~~jstring~s~=~({*}J)->NewString(J,~NULL,~0);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~len~=~a.length~{*}/}{\footnotesize \par}

~{\footnotesize ~~int~len~=~({*}J)->GetArrayLength(J,~a);}{\footnotesize \par}

~{\footnotesize ~~for~(int~i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~~~~~\emph{\footnotesize /{*}~o~=~a{[}i{]}~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~jobject~o~=~({*}J)->GetObjectArrayElement(J,~a,~i);}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~os~=~o.toString()~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~jstring~os~=~({*}J)->CallObjectMethod(J,~o,~toString);}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~s2~=~s.concat(os)~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~jstring~s2~=~({*}J)->CallObjectMethod(J,~s,~concat,~os);}{\footnotesize \par}

~{\footnotesize ~~~~~({*}J)->DeleteLocalRef(J,~s);}{\footnotesize \par}

~{\footnotesize ~~~~~({*}J)->DeleteLocalRef(J,~o);}{\footnotesize \par}

~{\footnotesize ~~~~~({*}J)->DeleteLocalRef(J,~os);}{\footnotesize \par}

~{\footnotesize ~~~~~s~=~s2;}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~return~s;~}{\footnotesize \par}

{\footnotesize \}~}{\footnotesize \par}
\end{lyxcode}

\caption{\label{cap:JNI-global-ref}Rotina para concatenar os elementos de
um array representados como strings.}
\end{figure}


A partir da versão 1.2, a JNI inclui referências globais fracas, com
o objetivo de oferecer uma forma simplificada das referências fracas
de Java (\texttt{java.lang.ref}) -- um objeto que esteja sendo apontado
apenas por referências globais fracas pode ser coletado. Originalmente,
a API incluiu a função \texttt{IsSameObject} como forma de verificar
a validade de uma referência fraca, mas evidentemente este método
é insuficiente: como Java é \emph{multi-threaded}, o coletor de lixo
pode invalidar a referência entre o teste e a instrução seguinte no
código~C. A documentação revisada avisa sobre esta limitação e recomenda
o uso de referências globais, além de alertar sobre comportamentos
indefinidos nas relações entre referências globais fracas em C e os
tipos de referências fracas definidos em Java~\cite{jni1503spec}.

Além desta, outras questões surgem a partir da combinação do modelo
\emph{multi-threaded} de Java com a exposição de referências a objetos
da máquina virtual ao código C. Para reduzir o volume de cópia de
dados entre Java e C, a JNI oferece algumas funções que retornam e
liberam ponteiros para a representação interna de strings e arrays
de tipos pri\-mi\-ti\-vos: \texttt{Get}/\texttt{ReleaseStringCritical}
e \texttt{Get}/\texttt{ReleasePrimitiveArrayCritical}. O uso destas
funções, porém, possui importantes restrições. A API especifica que,
uma vez obtido um ponteiro através destas funções, o código~C não
deve chamar outras funções da JNI ou realizar chamadas que possam
bloquear a thread atual e fazer com que ela espere por outra thread
Java, sob o risco de causar um \emph{deadlock}. Recomenda-se não manter
blocos de memória bloqueados usando estas funções por muito tempo
já que uma das técnicas possíveis para a implementação desta {}``região
crítica'' consiste em desabilitar o coletor de lixo da JVM. É importante
notar ainda que referências locais e o ponteiro para o ambiente JNI
passado para funções nativas são válidos apenas na thread onde foram
criados; referências globais podem ser compartilhadas entre threads.

Além do mecanismo de referências fracas fornecido pelas classes do
pacote \texttt{java.lang.\-ref}, a única forma oferecida por Java
para interagir de maneira mais direta com o coletor de lixo é através
da chamada \texttt{System.gc()}, que solicita à máquina virtual que
dispare tão logo quanto possível a thread de coleta para que esta
desaloque objetos não alcançáveis. Não há uma função C equivalente
na JNI, mas este método pode ser invocado a partir de~C com \texttt{CallStaticVoidMethod}.


\subsection{Lua\label{sub:Lua-GC}}

Por não retornar referências explícitas a objetos Lua ao código C,
a interação do código nativo com o coletor de lixo é bastante simplificada.
Operações sobre objetos Lua são sempre especificadas através de índices
da pilha virtual. Assim, a máquina virtual mantém o controle sobre
quais os objetos são acessíveis a partir de C em qualquer dado momento. 

Embora ponteiros para objetos não sejam manipulados na API, algumas
funções retornam ponteiros para estruturas gerenciadas por Lua: \texttt{lua\_newuserdata},
\texttt{lua\_to}{*}\texttt{string} e \texttt{lua\_touserdata}. A validade
dos ponteiros retornados por estas funções é dependente do tempo de
vida do objeto correspondente a eles; para strings em particular,
o ponteiro retornado só é garantidamente válido enquanto a string
estiver na pilha. Lua oferece ainda a função \texttt{lua\_topointer},
que permite obter ponteiros para alguns tipos de objetos (\emph{userdata},
tabelas, \emph{threads} e funções), mas somente com o objetivo de
obter informação para depuração, já que não é possível converter o
ponteiro de volta para um valor Lua. 

O conteúdo da pilha virtual é zerado quando a função C retorna o controle
à máquina virtual de Lua. Dessa forma, não é possível reter ponteiros
retornados por Lua para uso posterior em variáveis globais ou estruturas
de C. Por outro lado, a API oferece um mecanismo para armazenar valores
Lua em uma localização conhecida por código C que não pode ser alterada
via código Lua: o \emph{registro}. O registro é uma tabela disponibilizada
pela API de Lua para o armazenamento de valores Lua a partir de C;
esta tabela não é normalmente acessível a partir de Lua. Como a tabela
que implementa o registro é parte do \emph{root set} do coletor de
lixo, a inclusão de um objeto nesta tabela o impede de ser coletado,
mantendo-o no registro até que seja explicitamente removido via código
C.

Usando o registro, uma forma possível de descrever dados do espaço
de Lua em estruturas de dados em C é armazenar os dados no registro
e armazenar os índices usados na estrutura C. A biblioteca auxiliar
de Lua encapsula tal idioma através de duas funções, \texttt{luaL\_ref}
e \texttt{luaL\_unref}. A função \texttt{luaL\_ref} associa o valor
Lua passado a uma chave numérica inteira no registro, e retorna este
número. Este valor então ser visto como um \emph{handle} de alto nível
para o objeto: o código C pode armazená-lo em variáveis ou estruturas
e utilizá-lo para referenciar o objeto através do campo no registro.
A função \texttt{luaL\_unref} remove o valor Lua do registro e libera
o índice para reuso. Para o bom funcionamento deste mecanismo, chaves
inteiras não devem ser utilizadas diretamente pelo programador para
armazenar dados no registro.

A API permite associar a objetos do tipo \emph{full userdata} uma
função de desalocação, \texttt{\_\_gc}, na sua metatabela. Quando
presente, esta função será tipicamente implementada em C, realizando
a finalização de recursos. Por exemplo, o metamétodo \texttt{\_\_gc}
de objetos retornados pela função Lua \texttt{io.open} é uma função
C que fecha o descritor de arquivo correspondente com a função C \texttt{fclose}. 

A princípio, o fato de que é possível obter e modificar a metatabela
de um userdata via código Lua pode parecer problemático, já que pode-se
substituir o seu finalizador em \texttt{\_\_gc}. Entretanto, funções
de coleta implementadas em C tipicamente validam o userdata recebido
verificando o seu {}``tipo'', identificado através da metatabela.
Assim, mesmo que código Lua manipule a metatabela, uma função de coleta
implementada em C que use \texttt{luaL\_checkudata} não será levada
a operar sobre um \emph{userdata} de tipo incorreto. Para impedir
o código Lua de alterar a função de coleta de um objeto \emph{userdata},
pode-se atribuir um valor qualquer, como \texttt{false}, ao campo
\texttt{\_\_metatable} da metatabela, que passa a ser retornado no
lugar da metatabela, tornando a metatabela em si inacessível.

Outro recurso relacionado à gerência de memória oferecido por Lua
é a possibilidade de configurar, em tempo de execução, a função de
alocação de memória a ser usada pela máquina virtual. Na criação de
um novo estado Lua, passa-se como parâmetro uma função de alocação
que deve oferecer funcionalidade similar às funções C \texttt{free}
e \texttt{realloc}, dependendo se o tamanho de bloco passado for igual
ou maior do que zero. 

Lua oferece uma interface com o coletor de lixo através das funções
\texttt{lua\_gc} em C e \texttt{collectgarbage} em Lua. O coletor
de Lua implementa \emph{mark-and-sweep} incremental e permite ao programador
configurar parâmetros relacionados aos intervalos de coleta, bem como
ativar, desativar, disparar ciclos completos e executar passos do
coletor.


\subsection{Perl\label{sub:Perl-GC}}

Como Python, Perl realiza coleta de lixo baseada em contagem de referências.
A API provê funções para o controle explícito da contagem: \texttt{SvREFCNT\_inc}
e \texttt{SvREFCNT\_dec} para incremento e decremento e um \emph{getter},
\texttt{SvREFCNT}. Outra forma de alterar a contagem de referências
de um valor é atribuindo-o a uma referência Perl com \texttt{newRV\_inc}.
A contagem do valor referenciado será incrementada, fazendo com que
-- salvo tenha sua contagem alterada explicitamente -- este se mantenha
válido enquanto for referenciado pelo \texttt{RV}. É importante notar,
porém, que as funções da API que criam valores, como \texttt{newSViv},
inicializam os seus contadores de referências com 1. Isto tem o efeito
de que se um valor é criado em uma função C, armazenado em um \texttt{RV}
com \texttt{newRV\_inc} e esta referência é retornada a Perl, o valor
nunca será coletado, pois o seu contador não retornará a 0 quando
a referência for destruída. A forma correta, então, é usar \texttt{newRV\_noinc}
para \texttt{RV}s contendo valores recém-criados e \texttt{newRV\_inc}
quando um \texttt{RV} deve manter válido um valor já existente.

A inicialização da contagem de referências em 1 garante que valores
criados continuarão válidos durante a execução de uma função C sem
que seja necessário armazenar o valor no espaço de Perl. Estes valores
podem também ser armazenados em variáveis globais e estruturas de
dados de C e se manterão válidos até que a sua contagem de referências
seja decrementada. Para valores cujo tempo de vida é restrito a uma
função, a API de Perl define o conceito de valores {}``mortais''
como uma forma de permitir desalocar todos os valores temporários
de uma função de uma só vez. Um \texttt{SV}, \texttt{AV} ou \texttt{HV}
pode ser criado com \texttt{sv\_newmortal} ou, mais comumente, convertido
para mortal com \texttt{sv\_2mortal}. Na prática, marcar um valor
como mortal corresponde a indicar que ele deve ter a sua contagem
de referências decrementada na chamada da macro \texttt{FREETMPS}
ao término da função, conforme será visto na Seção~\ref{sub:Perl-call}.
Algumas funções da API retornam valores mortais: por exemplo, \texttt{hv\_delete}
remove um elemento de uma hash e, caso a flag \texttt{G\_DISCARD}
não seja passada, retorna o elemento removido como um \texttt{SV}
mortal.

A API de Perl não possui facilidades de interface com o coletor de
lixo, mas possui algumas funções para auxílio em depuração que reportam
informações sobre o estado da coleta de lixo. A função \texttt{sv\_report\_used}
exibe o conteúdo de todos os \texttt{SV}s do interpretador. O módulo
\texttt{Devel::Peek} permite examinar a partir de Perl o conteúdo
de valores (contagem de referências, \emph{flags}, etc.) -- a partir
de C, estas informações estão disponíveis diretamente já que as estruturas
não são opacas.


\subsection{Comparação}

Coleta de lixo tem por objetivo isolar, na medida do possível, o programador
da gerência de memória. Desta forma, idealmente uma API deveria também
ser tão independente quanto possível do algoritmo de coleta de lixo
utilizado pela implementação da máquina virtual. Perl e Python realizam
coleta de lixo baseada em contagem de referências, e isto transparece
nas operações de incremento e decremento de referências freqüentemente
necessárias durante o uso de suas APIs.

Ruby utiliza um contador de referências baseado em mark-and-sweep.
A sua API consegue abstrair bem este fato para a manipulação de objetos
nativos Ruby, mas a implementação do coletor é evidente na criação
de tipos Ruby em C, onde precisamos declarar uma função de marcação
quando temos estruturas C que guardam referências para objetos Ruby.
A API de Lua vai além ao isolar-se da implementação do coletor de
lixo utilizado: o único ponto da API onde o emprego de um coletor
de lixo incremental é aparente é na rotina de interação direta com
o coletor, \texttt{lua\_gc}, onde pode-se configurar parâmetros deste.

Das cinco linguagens, a única cuja API abstrai totalmente a implementação
do coletor de lixo é Java. A única operação de interface com o coletor
que a linguagem provê, \texttt{System.gc()}, não recebe parâmetros
e não especifica como ou quando a coleta deve ser feita%
\footnote{A documentação é propositalmente vaga, dizendo apenas que este método
\emph{{}``suggests that the Java Virtual Machine expend effort toward
recycling unused objects''} .%
}. De fato, as várias implementações da JVM utilizam algoritmos diferentes
para coleta de lixo.

Na manipulação de dados através da API, Lua e Ruby são as linguagens
que menos demandam do programador preocupações com gerência de referências.
Ruby mantém o controle das referências retornadas a funções C varrendo
a pilha de C durante a coleta de lixo, detectando a presença de referências
armazenadas em variáveis locais. Lua evita o problema como um todo,
mantendo seus objetos na pilha virtual e não retornando referências
a eles ao código C.

O problema de referências armazenadas em variáveis locais de uma função
é tratado por Perl e Java de forma semelhante, definindo dois tipos
de referências, globais e locais (referências locais são chamadas
de {}``variáveis mortais'' em Perl). Referências locais têm gerência
implícita (salvo alguns casos, como discutido na Seção~\ref{sub:Coleta-Java}).
As funções da API de Java retornam referências locais por padrão,
que podem ser convertidas para globais com \texttt{NewGlobalRef}.
Em Perl ocorre o contrário, e as referências globais são convertidas
para locais com \texttt{sv\_2mortal}. O modelo de Java é mais interessante,
pois normalmente são usadas mais variáveis de escopo local do que
global. Valores armazenados globalmente têm sempre alguma forma de
gerência explícita associada a si, mesmo em Ruby e Lua, através de
\texttt{rb\_global\_variable} e \texttt{luaL\_ref}/\texttt{luaL\_unref}.


\section{Chamada de funções a partir de C}

A API deve prover uma forma de invocar a partir de C funções a serem
executadas pela linguagem de script. Isto envolve a passagem de dados
entre estes dois {}``espaços'', conforme visto na Seção~\ref{sec:Dados}
e as implicações que isto traz sobre o tempo de vida dos objetos,
abordadas na Seção~\ref{sec:Coleta-de-lixo}. Devido à tipagem estática
de C, não é possível usar uma sintaxe transparente para chamada de
funções registradas em tempo de execução. É necessário então que a
API defina funções para realizar chamadas na linguagem de script.

Nesta seção serão discutidas as facilidades oferecidas por cada API
para a invocação de funções para execução na máquina virtual. As principais
questões envolvidas são como referenciar a função a ser chamada, como
passar argumentos a ela e como obter o valor de retorno, incluindo
formas de notificação no caso de erros. Para fins de ilustração, será
apresentado em cada linguagem um exemplo de chamada de uma função
simples. Assume-se que tenha sido definida no espaço de cada linguagem
de script uma função \texttt{teste}, que recebe um inteiro e uma string
como parâmetros e retorna um inteiro como resultado. Para maior brevidade,
a verificação de erros será omitida nos exemplos.


\subsection{Python\label{sub:Python-Chamada}}



Para chamar uma função Python a partir de C, deve-se inicialmente
obter um ponteiro para o \texttt{PyObject} correspondente à função,
como visto na Seção~\ref{sub:Dados-Python}. Além de funções implementadas
em Python e funções C registradas a partir da API, qualquer tipo de
dado que implemente o método \texttt{\_\_call\_\_} (ou declare uma
função no campo \texttt{tp\_call} de sua estrutura \texttt{PyTypeObject})
pode ser chamado como uma função.



A API de Python oferece diversas funções para realização de chamadas
a partir de C. A função mais geral, \texttt{PyObject\_Call}, recebe
como parâmetros o objeto a ser chamado, uma tupla Python contendo
os parâmetros a serem passados e opcionalmente um dicionário de argumentos
\emph{keyword}. Como conveniência, outras funções permitem passar
os argumentos de outras formas. Por exemplo, \texttt{PyObject\_CallFunction}
encapsula a chamada a \texttt{Py\_BuildValue} (vista na Seção~\ref{sub:Dados-Python}),
aceitando diretamente a string de formato desta e os valores a serem
convertidos. \texttt{PyObject\_CallFunctionObjArgs} é uma função \emph{vararg}
que aceita uma seqüência de ponteiros para \texttt{PyObject}s.



Existem também funções de conveniência para a invocação de métodos.
A função \texttt{PyObject\_CallMethod} é uma variante de \texttt{PyObject\_CallFunction}
que recebe como parâmetros um \texttt{PyObject} e uma string C contendo
o nome do método. Assim, por exemplo, as duas formas abaixo são equivalentes
à chamada Python {\footnotesize }\texttt{ret = uma\_string.split(\char`\"{}
\char`\"{})}:

\begin{lyxcode}
\emph{\footnotesize /{*}~\char`\"{}s\char`\"{}~indica~que~o~parâmetro~seguinte~é~do~tipo~string.~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~ret~=~PyObject\_CallMethod(uma\_string,~\char`\"{}split\char`\"{},~\char`\"{}s\char`\"{},~\char`\"{}~\char`\"{});}~\\
~{\footnotesize }~\\
{\footnotesize PyObject{*}~split~=~PyObject\_GetAttrString(uma\_string,~\char`\"{}split\char`\"{});}{\footnotesize \par}

{\footnotesize PyObject{*}~ret~=~PyObject\_CallFunction(split,~\char`\"{}s\char`\"{},~\char`\"{}~\char`\"{});}{\footnotesize \par}
\end{lyxcode}


É interessante notar que quando um método é chamado como função, o
argumento \texttt{self} não é passado explicitamente. 



O valor de retorno em todas as funções de chamada é um ponteiro para
\texttt{PyObject}. Assim como ocorre em código Python, quando funções
Python retornam múltiplos valores, estes são encapsulados em uma tupla.
Para funções que não retornam valor, as funções~C devem retornar
\texttt{Py\_None}. Em caso de erro na chamada, as funções retornam
\texttt{NULL}. A ocorrência de exceções pode então ser verificada
com a função \texttt{PyErr\_Occurred}.



Uma forma típica para chamar uma função Python \texttt{teste}, incluindo
a obtenção da função e a conversão dos valores de entrada e saída
entre Python e C, é exibida a seguir:

\begin{lyxcode}
{\footnotesize PyObject{*}~globals~=~PyModule\_GetDict(PyImport\_AddModule(\char`\"{}\_\_main\_\_\char`\"{}));}{\footnotesize \par}

{\footnotesize PyObject{*}~teste~=~PyDict\_GetItemString(globals,~\char`\"{}teste\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~\char`\"{}si\char`\"{}~indica~que~seguem~parâmetros~string~e~inteiro~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~obj\_result~=~PyObject\_CallFunction(teste,~\char`\"{}si\char`\"{},~\char`\"{}entrada\char`\"{},~2);}{\footnotesize \par}

\emph{\footnotesize /{*}~Converte~o~valor~para~C~{*}/}{\footnotesize \par}

{\footnotesize long~result~=~PyInt\_AsLong(obj\_result);}{\footnotesize \par}

\emph{\footnotesize /{*}~Libera~o~PyObject~temporário~retornado.~{*}/}{\footnotesize \par}

{\footnotesize Py\_DECREF(obj\_result);}{\footnotesize \par}
\end{lyxcode}


Uma função global é obtida através do dicionário do módulo \texttt{\_\_main\_\_}.
A conversão dos dados de entrada de C para Python é feita através
da string de formato recebida por \texttt{PyObject\_CallFunction}.
Esta chamada equivale a \texttt{obj\_result = teste(\char`\"{}entrada\char`\"{},
2)} em Python. O valor de saída é retornado como uma nova referência
a um objeto Python e, desta forma, precisa ter a contagem de referências
decrementada após o seu uso. As funções \texttt{PyImport\_AddModule},
\texttt{PyModule\_GetDict} e \texttt{PyDict\_GetItemString} retornam
referências emprestadas, portanto a contagem de referências dos \texttt{PyObject}s
retornados por elas não precisam ser decrementadas após o seu uso.
Todavia, após a chamada da função Python, não há garantia de que os
ponteiros \texttt{globals} e \texttt{teste} ainda apontem para objetos
válidos -- precisaríamos ter incrementado a sua contagem de referências
caso quiséssemos usá-los novamente.


\subsection{Ruby\label{sub:Ruby-Chamada}}



Como métodos não são valores de primeira classe em Ruby, eles não
são representados como \texttt{VALUE}s na sua API de C. Para a chamada
de métodos Ruby em C, a API oferece a função \texttt{rb\_funcall}
e algumas variantes. Em comum, todas recebem como parâmetro o \texttt{VALUE}
indicando ao objeto sobre o qual o método se refere, um \texttt{ID}
referente à string internalizada contendo o nome do método e um inteiro
informando o número de argumentos. 



Como em Python, as funções da API para invocação de métodos diferem
na forma como os argumentos são passados. Por exemplo, a função \texttt{rb\_funcall}
recebe os argumentos na forma de \texttt{VALUE}s passados como varargs
C; \texttt{rb\_funcall2} recebe um array C de \texttt{VALUE}s; \texttt{rb\_apply}
recebe um \texttt{VALUE} que deve ser um array Ruby contendo os parâmetros.
Todas elas retornam um \texttt{VALUE} como parâmetro. Assim como em
código Ruby, múltiplos valores de retorno são representados como um
array Ruby.



Todas as rotinas de chamada de função na API se referem a métodos,
precisando assim especificar um objeto sobre o qual o método deve
ser aplicado. Funções globais em Ruby são definidas como métodos do
módulo \texttt{Kernel}, que é incluído pela classe \texttt{Object}
e são, assim, acessíveis a partir de qualquer objeto, incluindo \texttt{nil}.
Desta forma, pode-se invocar funções globais passando a constante
C \texttt{Qnil} como o objeto alvo do método.



A seguir, é apresentada a forma típica para chamar em C uma função
global Ruby \texttt{teste}, novamente incluindo a conversão dos valores
de entrada e saída entre C e o interpretador.

\begin{lyxcode}
{\footnotesize ID~teste~=~rb\_intern(\char`\"{}teste\char`\"{});}{\footnotesize \par}

{\footnotesize VALUE~val\_result~=~rb\_funcall(Qnil,~teste,~2,}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~rb\_str\_new2(\char`\"{}entrada\char`\"{}),~INT2NUM(2));}{\footnotesize \par}

{\footnotesize long~result~=~NUM2LONG(val\_result);}{\footnotesize \par}
\end{lyxcode}


Diferentemente de Python, não é necessário obter uma referência para
a função, bastando passar o nome desta na forma de \texttt{ID} e o
objeto a que ela se refere (no caso, \texttt{Qnil}, indicando uma
função global). A conversão dos dados de entrada de C para Ruby é
feita através da função \texttt{rb\_str\_new2} e da macro \texttt{INT2NUM},
que criam \texttt{VALUE}s.



Conforme discutido na Seção~\ref{sub:Ruby-GC}, o controle da validade
de \texttt{VALUE}s é feito implicitamente. Assim, pode-se fazer a
chamada de funções que criam \texttt{VALUE}s diretamente na passagem
de parâmetros de \texttt{rb\_funcall}. De fato, as três linhas acima
poderiam ter sido condensadas, passando a chamada \texttt{rb\_funcall}
como parâmetro para \texttt{NUM2LONG} e a chamada \texttt{rb\_intern}
como segundo parâmetro de \texttt{rb\_funcall}, tendo sido separadas
apenas para maior legibilidade.



Um tipo de dados que possui um tratamento um tanto irregular em Ruby
é o de blocos de código. A sintaxe em Ruby para a declaração de blocos
é especial: blocos só podem ser definidos como o último argumento
de uma chamada de método. Assim, eles não são valores de primeira
classe, não podendo ser, por exemplo, declarados em uma atribuição
a variável. Eles podem, no entanto, ser promovidos a valores de primeira
classe, na forma de objetos da classe \texttt{Proc}. Isto pode ser
feito de duas formas: explicitamente, passando um bloco para o método
\texttt{Proc.new}, ou implicitamente, quando o bloco for passado para
um método que declara um último parâmetro formal precedido de \texttt{\&}.
Esta variável conterá o bloco convertido para um \texttt{Proc}. Na
chamada de funções que esperam blocos, \texttt{\&} converte o \texttt{Proc}
para um bloco. Objetos \texttt{Proc} podem ser manipulados através
da API de C como qualquer outro objeto Ruby, mas não há correspondente
na API de C para a funcionalidade do operador \texttt{\&} em chamadas
de função.

O status especial dos blocos de código complica a sua manipulação
a partir de código~C, e em particular a invocação de métodos que
os esperam como parâmetro. Digamos que queremos invocar o seguinte
método Ruby a partir de~C:

\begin{lyxcode}
{\footnotesize def~uma\_funcao\_ruby()}{\footnotesize \par}

~{\footnotesize ~~print(\char`\"{}uma\_funcao\_ruby~vai~invocar~o~bloco.\textbackslash{}n\char`\"{})}{\footnotesize \par}

~{\footnotesize ~~yield}{\footnotesize \par}

~{\footnotesize ~~print(\char`\"{}uma\_funcao\_ruby~encerrou.\textbackslash{}n\char`\"{})}{\footnotesize \par}

~{\footnotesize ~~return~42}{\footnotesize \par}

{\footnotesize end}{\footnotesize \par}
\end{lyxcode}


A função espera que um bloco de código seja passado para que seja
invocado via o comando \texttt{yield}. Como vamos invocar a função
a partir de C, queremos também passar código C como um bloco, representado
na seguinte função: 

\begin{lyxcode}
{\footnotesize VALUE~um\_bloco\_C()~\{}{\footnotesize \par}

~{\footnotesize ~~fprintf(stderr,~\char`\"{}um\_bloco\_C~está~rodando.\textbackslash{}n\char`\"{});}{\footnotesize \par}

{\footnotesize \}~}{\footnotesize \par}
\end{lyxcode}


A conversão de objetos \texttt{Proc} para blocos proporcionada pelo
operador \texttt{\&} em Ruby não possui equivalente na API C. Assim,
\texttt{rb\_funcall} não é capaz de passar \texttt{Proc}s para funções
que aceitam blocos. A forma intuitiva de fazer a chamada de funções
Ruby a partir de C, neste caso, então, não funciona:

\begin{lyxcode}
{\footnotesize ID~uma\_funcao\_ruby~=~rb\_intern(\char`\"{}uma\_funcao\_ruby\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~O~segundo~parâmetro~é~um~argumento~adicional~a~ser}{\footnotesize \par}

~\emph{\footnotesize ~~opcionalmente~passado~na~invocação~de~um~Proc~{*}/}{\footnotesize \par}

{\footnotesize VALUE~um\_proc~=~rb\_proc\_new(um\_bloco\_C,~Qnil);}{\footnotesize \par}

\emph{\footnotesize /{*}~Não~funciona!~Um~Proc~não~é~um~bloco~de~código.~{*}/}{\footnotesize \par}

{\footnotesize VALUE~resultado~=~rb\_funcall(Qnil,~uma\_funcao\_ruby,~1,~um\_proc);}{\footnotesize \par}
\end{lyxcode}


As únicas formas de invocar um método Ruby passando um bloco de código
são através de \texttt{rb\_eval\_string} e \texttt{rb\_iterate}. A
primeira abordagem, além do custo de desempenho causado pelo \emph{parsing}
da string de código, tem a inconveniência de exigir o uso de variáveis
temporárias para que se possa obter os valores de retorno de volta
ao espaço de C. No modelo usando \texttt{rb\_eval\_string}, a função
C que atuará como bloco deve ser declarada no espaço de Ruby. Há duas
alternativas de como fazer isto: registrando o método em Ruby e invocando-o
em um bloco \emph{wrapper} declarado na string de código Ruby:

\begin{lyxcode}
\emph{\footnotesize /{*}~Declara~uma~função~global~com~0~parâmetros~de~entrada~{*}/}{\footnotesize \par}

{\footnotesize rb\_define\_global\_function(\char`\"{}um\_bloco\_C\char`\"{},~um\_bloco\_C,~0);}{\footnotesize \par}

{\footnotesize rb\_eval\_string(\char`\"{}\$resultado~=~uma\_funcao\_ruby~\{~um\_bloco\_C()~\}\char`\"{});}{\footnotesize \par}

{\footnotesize VALUE~resultado~=~rb\_gv\_get(\char`\"{}\$resultado\char`\"{});}{\footnotesize \par}
\end{lyxcode}
Ou encapsulando a função em um objeto \texttt{Proc} a partir de C
com \texttt{rb\_proc\_new} e então usando a notação \texttt{\&} na
string de código Ruby avaliada:

\begin{lyxcode}
{\footnotesize VALUE~um\_proc~=~rb\_proc\_new(um\_bloco\_C,~Qnil);}{\footnotesize \par}

{\footnotesize rb\_gv\_set(\char`\"{}\$um\_proc\char`\"{},~um\_proc);}{\footnotesize \par}

{\footnotesize rb\_eval\_string(\char`\"{}\$resultado~=~uma\_funcao\_ruby(\&\$um\_proc)\char`\"{});}{\footnotesize \par}

{\footnotesize VALUE~resultado~=~rb\_gv\_get(\char`\"{}\$resultado\char`\"{});}{\footnotesize \par}
\end{lyxcode}


A segunda abordagem explora o fato de que a única função da API de
C capaz de produzir blocos de código diretamente é \texttt{rb\_iterate}.
Esta função recebe dois ponteiros de função, um para a função a ser
invocada e outro para a função que atuará como o bloco de código;
chamadas a \texttt{yield} dentro da primeira função invocarão a segunda.
O bloco pode quebrar o fluxo de execução com \texttt{rb\_iter\_break}.
Passando como {}``função de iteração'' para \texttt{rb\_iterate}
uma função \emph{wrapper} que simplesmente chama o método Ruby desejado
com \texttt{rb\_funcall}, é possível simular uma chamada a \texttt{rb\_funcall}
que recebe uma função~C como bloco de código.

\begin{lyxcode}
{\footnotesize VALUE~chama\_uma\_funcao\_ruby()~\{}{\footnotesize \par}

~{\footnotesize ~~ID~uma\_funcao\_ruby~=~rb\_intern(\char`\"{}uma\_funcao\_ruby\char`\"{});}{\footnotesize \par}

~{\footnotesize ~~return~rb\_funcall(Qnil,~uma\_funcao\_ruby,~0);}{\footnotesize \par}

{\footnotesize \}~}{\footnotesize \par}

{\footnotesize ...}{\footnotesize \par}

\emph{\footnotesize /{*}~Os~argumentos~Qnil~indicam~que~não~há~parâmetros}{\footnotesize \par}

~\emph{\footnotesize ~~nem~para~a~função~nem~para~o~bloco~{*}/}{\footnotesize \par}

{\footnotesize VALUE~resultado~=~rb\_iterate(chama\_uma\_funcao\_ruby,~Qnil,}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~um\_bloco\_C,~Qnil);}{\footnotesize \par}
\end{lyxcode}


Note que nenhum argumento é passado em \texttt{rb\_funcall} -- a função
\texttt{rb\_iterate} define \texttt{um\_bloco\_C} como sendo o {}``bloco
de código atual'' e esta definição é herdada implicitamente por \texttt{rb\_funcall}.

Para o caso comum de realizar iterações sobre o método \texttt{each}
de coleções, Ruby oferece uma função \emph{wrapper} \texttt{rb\_each}.
Esta função foi projetada para ser passada como primeiro argumento
de \texttt{rb\_iterate}. Funções C executando como bloco de código
podem quebrar o fluxo de execução com \texttt{rb\_iter\_break}. O
mecanismo de \emph{yield}, tanto para código C quanto para chamadas
nativas em Ruby, é implementado usando as funções C \texttt{setjmp}
e \texttt{longjmp}.



Para o correto tratamento de erros, funções C que realizam chamadas
a funções Ruby devem ser encapsuladas em uma chamada \texttt{rb\_protect}
ou em uma de suas variantes, \texttt{rb\_ensure} e \texttt{rb\_rescue}.
Esta função captura exceções disparadas por código Ruby (ou código
C usando \texttt{rb\_raise}). Caso o programa não use \texttt{rb\_protect},
exceções em Ruby resultarão em erros fatais.


\subsection{Java\label{sub:Java-Chamada}}



De forma similar ao acesso a atributos, na chamada de métodos Java
a partir de C deve-se inicialmente obter um identificador para o método,
do tipo \texttt{jmethodID}. Estes identificadores são tipicamente
obtidos com a função \texttt{GetMethodID}, que recebe como parâmetros
a classe (instância de \texttt{jclass}) e duas strings, uma com o
nome do método e outra com a assinatura do método. A sintaxe que descreve
assinaturas de métodos é similar à de descritores de campos discutida
na Seção~\ref{sub:Dados-Java}. Parâmetros são listados entre parênteses,
seguidos do tipo de retorno. Por exemplo, \texttt{\char`\"{}({[}Ljava/lang/String;II)V\char`\"{}}
indica uma função com parâmetros \texttt{String{[}{]}, int, int} e
retorno \texttt{void}. Alternativamente ao uso de \texttt{GetMethodID},
a partir de Java 1.2 é possível obter um \texttt{jmethodID} correspondente
a um método aplicando a função \texttt{FromReflectedMethod} sobre
um objeto Java do tipo \texttt{Method} -- isto é, um método reificado
através da API de reflexão de Java.



Uma vez obtido o \texttt{jmethodID}, um método pode ser invocado através
de alguma das 90 funções da família \texttt{Call}{*}\texttt{Method}{*}.
Os nomes das funções seguem a forma

\begin{lyxcode}
{\footnotesize Call}\textrm{\emph{\footnotesize {[}tipo{]}{[}retorno}}\emph{\footnotesize {]}}{\footnotesize Method}\textrm{\emph{\footnotesize {[}argumentos{]}}}{\footnotesize \par}
\end{lyxcode}


O \emph{{[}tipo{]}} pode ser \texttt{Static} para funções estáticas,
passando na chamada uma \texttt{jclass} como parâmetro; \texttt{Nonvirtual}
para invocar implementações de um método em uma classe específica
sobre um determinado objeto, passando uma \texttt{jclass} e um \texttt{jobject}
como parâmetros; ou omitido para métodos de instância, passando o
\texttt{jobject} sobre o qual o método será aplicado. O tipo de retorno
é indicado em \emph{{[}retorno{]}}: \texttt{Void}, \texttt{Object},
\texttt{Int}, etc.



Os argumentos do método podem ser passados de três formas: como \emph{varargs},
como um array C de \texttt{jvalue}s, ou propagando uma \texttt{va\_list}
recebida. Por exemplo, na forma mais simples, um método de instância
sem retorno e sem parâmetros é invocado com \texttt{CallVoidMethod}.
Já \texttt{CallStaticIntMethodA} chama um método estático que retorna
um \texttt{jint} com a lista de parâmetros passada em um array de
\texttt{jvalue}s. Como Java é uma linguagem estaticamente tipada,
não é preciso especificar o número ou o tipo dos parâmetros passados
nas funções de chamada de métodos. Estas informações já estão especificadas
nos \texttt{jmethodID}s.



É importante notar que, ao obter identificadores de métodos e campos
fazendo a resolução a partir do \texttt{jobject} recebido na variável
\texttt{this} e do nome do método ou campo, com \texttt{GetObjectClass}
e \texttt{GetFieldID}, estamos efetivamente resolvendo nomes através
de escopo dinâmico. Isto implica que, por exemplo, caso um método
\texttt{Pai.metodo} implementado em C acesse um atributo privado \texttt{umAtributo}
e uma subclasse \texttt{Filho} também defina um atributo privado \texttt{umAtributo},
a chamada a esse método em uma instância \texttt{f} de \texttt{Filho}
acabaria por acessar \texttt{Filho.umAtributo} e não \texttt{Pai.umAtributo}.
Este comportamento é diferente do que ocorreria se \texttt{Pai.metodo}
fosse implementado em Java, onde o \emph{binding} de membros privados
é definido lexicamente. Para garantir à implementação em C de \texttt{Pai.metodo}
que o atributo \texttt{umAtributo} acessado é realmente \texttt{Pai.umAtributo},
deve-se armazenar no espaço de C o identificador do campo obtido a
partir da \texttt{jclass} de \texttt{Pai} -- obtida, por exemplo,
em uma função \texttt{static native}.



O código C pode verificar a ocorrência de exceções através de \texttt{ExceptionCheck}
e optar por tratá-la, obtendo uma referência local da exceção com
\texttt{ExceptionOccurred} e posteriormente zerando-a com \texttt{ExceptionClear},
ou então mantê-la ativa de modo que seja propagada ao código Java.



Para realizar o exemplo da função \texttt{teste}, já que Java não
possui funções globais, vamos assumir que \texttt{teste} é um método
estático de uma classe chamada \texttt{Exemplo} e que estamos rodando
o código C a seguir em um contexto onde possuímos uma referência a
um ambiente de execução Java chamado \texttt{J} (este ponteiro, do
tipo \texttt{JNIEnv}, será discutido na Seção~\ref{sub:Java-Registro}).

\begin{lyxcode}
{\footnotesize jclass~exemplo~=~({*}J)->FindClass(J,~\char`\"{}Exemplo\char`\"{});}{\footnotesize \par}

{\footnotesize jmethodID~teste~=~({*}J)->GetStaticMethodID(J,~exemplo,}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~\char`\"{}teste\char`\"{},~\char`\"{}(Ljava/lang/String;I)I\char`\"{});}{\footnotesize \par}

{\footnotesize jstring~entrada~=~({*}J)->NewStringUTF(J,~\char`\"{}entrada\char`\"{});}{\footnotesize \par}

{\footnotesize long~retorno~=~({*}J)->CallStaticIntMethod(J,~exemplo,~teste,}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~entrada,~(jint)2);}{\footnotesize \par}
\end{lyxcode}


Inicialmente, é obtida uma referência à classe \texttt{Exemplo}, a
partir da qual requisitamos o identificador do método desejado, baseado
no seu nome e assinatura. Como em Ruby, a string passada como parâmetro
deve ser convertida para um tipo da máquina virtual. Já para o segundo
argumento e para o valor de retorno, exploramos o fato de que o tipo
\texttt{jint}, correspondente ao tipo Java \texttt{int} (inteiro de
32 bits), é compatível com o tipo \texttt{long} de C (inteiro de pelo
menos 32 bits). Todas estas funções da API retornam referências locais,
que serão liberadas automaticamente ao final da função C onde as chamadas
à API foram feitas.


\subsection{Lua\label{sub:Lua-chamada}}

Tanto em funções C disparadas por Lua como em chamadas de funções
Lua realizadas a partir de código C, os parâmetros de entrada e os
valores de retorno são passados através da pilha virtual apresentada
na Seção~\ref{sub:Lua-dados}.



Para chamar uma função Lua a partir de C, devemos inicalmente empilhar
o objeto Lua referente a ela: para funções globais, obtendo-a com
\texttt{lua\_getglobal}, para funções armazenadas em tabelas, com
\texttt{lua\_gettable}. A seguir, empilhamos os seus parâmetros e
então invocamos \texttt{lua\_call} ou \texttt{lua\_pcall}, indicando
quantos valores da pilha devem ser passados como parâmetro. A diferença
entre as duas funções está no tratamento de erros: \texttt{lua\_call}
propaga os erros sinalizados, usando \texttt{longjmp}; \texttt{lua\_pcall}
captura os erros, retornando um código de \emph{status} e a mensagem
de erro na pilha.



No caso de execução sem erros, a pilha conterá os valores de retorno
da função chamada. O número de valores de retorno pode ser explicitamente
requisitado na chamada de \texttt{lua\_call} ou \texttt{lua\_pcall},
ou ser definido em tempo de execução, requisitando o valor especial
\texttt{LUA\_MULTRET}. Se um número de valores de retorno for solicitado
e este não for passado pela função chamada, o número de valores será
ajustado adicionando elementos \texttt{nil} ou descartando valores
em excesso. Para chamadas com \texttt{LUA\_MULTRET}, todos os valores
são empilhados. Nesse caso, a única forma de descobrir quantos valores
foram retornados é comparando o tamanho da pilha antes e depois da
chamada.

A função \texttt{lua\_cpcall} permite chamar funções C realizando
captura de erros de forma similar a \texttt{lua\_pcall} sem precisar
registrá-las como valores Lua. Esta funcionalidade é similar à oferecida
por \texttt{rb\_protect} em Ruby. Ruby, todavia, não oferece função
análoga a \texttt{lua\_pcall}, sendo às vezes necessário encapsular
a chamada de funções Ruby em funções~C que obedeçam à assinatura
esperada por \texttt{rb\_protect}.



Lua não possui distinção entre funções e métodos, mas possui açúcar
sintático que permite invocar funções armazenadas em tabelas com uma
sintaxe de chamada de métodos: \texttt{t:m(x)} significa \texttt{t.m(t,x)}.
Todavia, não há na API de C uma chamada específica para replicar esta
abreviação. Para funções armazenadas em tabelas, a função deve ser
obtida com \texttt{lua\_gettable} e a tabela deve ser empilhada explicitamente
juntamente com os demais parâmetros.



O exemplo da chamada da função \texttt{teste} demonstra a disciplina
de pilha adotada na API de Lua. Similarmente ao exemplo de Java na
Seção~\ref{sub:Java-Chamada}, iremos assumir a existência de um
ponteiro \texttt{L} do tipo \texttt{lua\_State}, que será explicado
mais adiante na Seção~\ref{sub:Lua-Registro}. 

\begin{lyxcode}
{\footnotesize lua\_getglobal(L,~\char`\"{}teste\char`\"{});~~~~~~~~~~}~\emph{\footnotesize /{*}~Empilha~a~função~teste~{*}/}{\footnotesize \par}

{\footnotesize lua\_pushstring(L,~\char`\"{}entrada\char`\"{});~~~~~~~}~\emph{\footnotesize /{*}~Empilha~a~string~\char`\"{}entrada\char`\"{}~{*}/}{\footnotesize \par}

{\footnotesize lua\_pushinteger(L,~2);~~~~~~~~~~~~~~}~\emph{\footnotesize /{*}~Empilha~o~número~2~{*}/}{\footnotesize \par}

{\footnotesize lua\_call(L,~2,~1);~~~~~~~~~~~~~~}~\emph{\footnotesize /{*}~Chama~a~função~com~2~parâmetros,}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e~espera~1~como~retorno~{*}/}{\footnotesize \par}

{\footnotesize long~retorno~=~lua\_tointeger(L,~-1);}~\emph{\footnotesize /{*}~Obtém~o~resultado~no}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~topo~da~pilha~(-1)~{*}/}{\footnotesize \par}

{\footnotesize lua\_pop(L,~1);~~~~~~~~~~~~~~~~~~~~~~}~\emph{\footnotesize /{*}~Remove-o~da~pilha~{*}/}{\footnotesize \par}
\end{lyxcode}


Com \texttt{lua\_getglobal}, é empilhada a função global \texttt{teste}.
Em seguida, os dois argumentos de entrada são empilhados. A função
é então invocada com \texttt{lua\_call}, indicando dois parâmetros
de entrada e um de saída. O valor de retorno, no topo da pilha (índice~$-1$)
é convertido para C com \texttt{lua\_tointeger}. Esta última função
não remove o valor da pilha: para retorná-la ao seu estado inicial,
precisamos removê-lo explicitamente com \texttt{lua\_pop}. Como em
nenhum momento a API retorna ponteiros para objetos Lua, não há preocupações
com coleta de lixo.


\subsection{Perl\label{sub:Perl-call}}



A chamada de funções Perl a partir de C se dá através de uma disciplina
de pilha, como em Lua. Parâmetros de entrada são especificados através
de operações de empilhamento e valores de retorno são obtidos na pilha
após a chamada da função. As funções \texttt{call\_sv}, \texttt{call\_pv}
e \texttt{call\_method} variam apenas na forma como a função a ser
chamada é especificada: através de um \texttt{SV}, de uma string C
ou de uma string C descrevendo o nome de um método de algum objeto
ou classe inserido na pilha. A função \texttt{call\_argv}, como conveniência,
recebe como um argumento adicional um array C contendo strings C representando
parâmetros a serem empilhados. Todas retornam o número de valores
de retorno disponíveis na pilha.



As funções \texttt{call\_}{*} possuem um argumento de flags a serem
passadas que indicam a forma que a função deve ser chamada e como
tratar os parâmetros de entrada e valores de retorno. \texttt{G\_VOID},
\texttt{G\_SCALAR} e \texttt{G\_ARRAY} especificam o contexto como
a função deve ser chamada. Em contextos escalares, por exemplo, somente
um escalar é retornado na pilha; se a função chamada retornar uma
lista, somente o último elemento desta estará disponível na pilha.
\texttt{G\_DISCARD} indica que os valores de retorno devem ser automaticamente
descartados; \texttt{G\_NOARGS} indica que o array padrão de parâmetros
\texttt{@\_} não deve ser construído%
\footnote{Isto tem o efeito colateral de que a função chamada herda o valor
de \texttt{@\_} da função chamadora.%
}.



O precedimento para verificação de erros depende do contexto e das
flags passadas, que afetam como situações de erro são reportadas no
valor de retorno das funções \texttt{call\_}{*} e nos valores retornados
na pilha. A flag \texttt{G\_EVAL} encapsula a chamada em um bloco
\texttt{eval}, capturando erros. Assim, a ocorrência de erros pode
ser verificada através da macro \texttt{ERRSV}, que retorna o \texttt{SV}
contendo a mensagem de erro. Acrescentando a flag \texttt{G\_KEEPERR},
mensagens de erro não sobrescrevem a variável especial \texttt{\$@},
mas são concatenadas a ela, acumulando seqüências de erros em níveis
de chamada diferentes. 



Uma série de macros descrevem um protocolo para a chamada de funções
e a manipulação de parâmetros de entrada e saída. As principais serão
explicadas a seguir, na apresentação da versão Perl da chamada da
função \texttt{teste}:

\begin{lyxcode}
{\footnotesize dSP;}{\footnotesize \par}

{\footnotesize ENTER;}{\footnotesize \par}

{\footnotesize SAVETMPS;}{\footnotesize \par}

{\footnotesize PUSHMARK(SP);}{\footnotesize \par}

{\footnotesize XPUSHs(sv\_2mortal(newSVpv(\char`\"{}entrada\char`\"{},~0)));}{\footnotesize \par}

{\footnotesize XPUSHs(sv\_2mortal(newSViv(2)));}{\footnotesize \par}

{\footnotesize PUTBACK;}{\footnotesize \par}

{\footnotesize call\_pv(\char`\"{}teste\char`\"{},~G\_SCALAR);}{\footnotesize \par}

{\footnotesize SPAGAIN;}{\footnotesize \par}

{\footnotesize long~result~=~POPl;}{\footnotesize \par}

{\footnotesize PUTBACK;}{\footnotesize \par}

{\footnotesize FREETMPS;}{\footnotesize \par}

{\footnotesize LEAVE;}{\footnotesize \par}
\end{lyxcode}


Inicialmente \texttt{dSP} declara uma cópia local do ponteiro da pilha
de Perl. Em seguida, \texttt{ENTER} e \texttt{SAVETMPS} criam um escopo
para valores mortais. \texttt{PUSHMARK} inicia a contagem de parâmetros
a serem passados para a função. Estes parâmetros são então empilhados
com \texttt{XPUSHs}. Os valores criados com \texttt{newSVpv} e \texttt{newSViv}
são convertidos para valores mortais com \texttt{sv\_2mortal}, para
que não tenham que ter sua contagem de referências decrementada explicitamente
após a chamada da função. \texttt{PUTBACK} encerra a contagem de parâmetros.
É feita então a chamada da função global Perl \texttt{teste}, em contexto
escalar, com \texttt{call\_pv}.



Após o retorno desta função, a memória da pilha de Perl pode ter sido
realocada, mudando o endereço do ponteiro de pilha obtido inicialmente
com \texttt{dSP}. Para certificar-se que o seu valor está correto,
deve-se chamar \texttt{SPAGAIN} após funções \texttt{call\_}{*}. A
função \texttt{POPl} desempilha um valor e o converte para \texttt{long}
(há funções similares para outros tipos, como \texttt{POPs} para \texttt{SV}s
e \texttt{POPpx} para strings). Estas operações desempilham valores
atualizando a cópia local do ponteiro de pilha. Assim, \texttt{PUTBACK}
deve ser chamado novamente para atualizar o ponteiro global. Finalmente,
\texttt{FREETMPS} e \texttt{LEAVE} decrementam a contagem de referências
dos valores mortais. 


\subsection{Comparação}

Em Python, Lua e Perl, funções podem ser acessadas como objetos da
linguagem e invocadas. Em Ruby e Java, a API define tipos especiais
usados para referenciar métodos. Como na manipulação de dados, Python
oferece uma API extensa, com diversas funções de conveniência permitindo
passar argumentos como tuplas Python, objetos Python passados como
\emph{varargs}, valores C a serem convertidos pela função de chamada,
etc. Java também oferece um grande número de funções para invocação
de métodos e, devido à tipagem estática da linguagem, os parâmetros
de entrada podem ser passados como \emph{varargs} de forma direta,
sem precisar especificar a forma como a conversão deles deve ser realizada.
Ruby também oferece algumas variantes de funções de chamada.

Lua, em contraste, separa a rotina da chamada da função da passagem
dos parâmetros, que é feita anteriormente através da pilha. Isto é
uma solução bastante simples, mas o código resultante é menos claro
que as chamadas equivalentes em linguagens como Ruby e Python. Perl
também faz chamadas de função utilizando um modelo de pilha, mas ao
contrário de Lua o seu uso é demasiadamente complexo, por exigir um
protocolo de macros que expõem o funcionamento interno do interpretador.
Outro complicador é o tratamento de valores de retorno, pois estes
variam de comportamento conforme o contexto Perl em que a função é
chamada.

Em Lua e Python, a ocorrência de erros pode ser verificada com o valor
de retorno da função. De modo parecido, Perl permite detectar erros
na chamada mais recente verificando uma variável especial; em Java,
isto é feito chamando uma função da API. Somente o tratamento de erros
em Ruby é mais convoluto, pois estranhamente a API oferece uma função
que permite invocar funções C em modo protegido, mas não uma equivalente
que permita chamar funções Ruby. Torna-se necessário escrever uma
função \emph{wrapper} nestes casos, o que será ilustrado na Seção~\ref{sub:Captura-de-erros}.


\section{Registro de funções C}

Para permitir a invocação de funções C a partir de código da linguagem
de script, a API deve fornecer uma forma de registrar estas funções
no ambiente de execução. Em linguagens de tipagem estática, como Java,
para que seja possível chamar funções externas usando uma sintaxe
igual à de funções nativas, o conjunto de funções externas deve ser
declarado \emph{a priori} de alguma forma. Já em linguagens com tipagem
dinâmica, como é o caso de Python, Lua, Ruby e Perl, as funções podem
ser usadas diretamente, bastando que sejam definidas em algum momento
da execução antes de sua chamada. Assim, pode-se declarar as funções
externas em tempo de execução através de código C usando a API da
linguagem de script.

Também nesta seção, a apresentação de cada linguagem encerrará com
um exemplo. Uma função C que, assim como nos exemplos da seção anterior,
recebe um inteiro e uma string e retorna um inteiro, será registrada.
Apresentaremos também, para cada linguagem, a forma de registrar a
função como a global%
\footnote{Ou no caso de Java, método estático.%
} \texttt{teste} de modo que ela possa ser invocada diretamente a partir
da linguagem ou através da API.


\subsection{Python\label{sub:Python-Registro}}



Python não possui um tipo {}``função'' propriamente dito declarável
em C. Métodos de classes, no entanto, são objetos e possuem um tipo
específico, que pode ser verificado com a função \texttt{PyMethod\_Check}.
Tipicamente, métodos são criados passando-se um array de estruturas
\texttt{PyMethodDef}. Estas estruturas são compostas do nome da função,
o ponteiro da função C, um vetor de flags e uma string de documentação.
As flags são usadas para indicar a convenção adotada para os parâmetros
de entrada na função C. As flags mais comuns são: \texttt{METH\_NOARGS},
usada para funções Python que não recebem parâmetros, indicando que
a função C deve receber um único ponteiro para \texttt{PyObject},
que irá conter o \texttt{self} do método; \texttt{METH\_VARARGS},
para funções que recebem como segundo parâmetro uma tupla Python que
conterá um número variável de parâmetros passados de Python para C;
e \texttt{METH\_KEYWORDS}, para indicar que a função C recebe ainda
como terceiro parâmetro um dicionário contendo os argumentos \emph{keywords}
passados à função.



De posse destas informações, funções da API que operam sobre arrays
de \texttt{PyMethodDef} podem criar e associar objetos do tipo método
no espaço de Python. \texttt{Py\_InitModule}, por exemplo, inicializa
um módulo com funções de um array de \texttt{PyMethodDef}. Similarmente,
os métodos de uma classe implementada em C podem ser dados no campo
\texttt{tp\_methods} da estrutura \texttt{PyTypeObject} relativa à
classe.



Funções C registradas em Python devem retornar um ponteiro para \texttt{PyObject},
ou \texttt{NULL} em caso de erro (opcionalmente declarando uma exceção
com \texttt{PyErr\_SetString} ou \texttt{PyErr\_SetObject}). Funções
que não retornam valores devem retornar o objeto pré-definido \texttt{Py\_None},
lembrando das questões de contagem de referência de valores retornados
discutidas na Seção~\ref{sub:Python-GC}.



Embora métodos sejam usualmente criados em C usando estruturas \texttt{PyMethodDef},
é possível ainda criar um objeto do tipo método explicitamente a partir
de C com a função \texttt{PyMethod\_New}, passando como parâmetro
um objeto Python {}``chamável'' e o objeto ou classe a que ele deve
se referir. Como visto na Seção~\ref{sub:Python-Chamada}, objetos
Python podem ser tornados {}``chamáveis'' implementando um método
\texttt{\_\_call\_\_} em Python ou associando uma função C ao campo
\texttt{tp\_call} do seu \texttt{PyTypeObject} correspondente.



Uma implementação simples de uma função C que pode ser registrada
em Python como a função global \texttt{teste} é dada a seguir:

\begin{lyxcode}
{\footnotesize PyObject{*}~teste\_py(PyObject{*}~self,~PyObject{*}~args)~\{}{\footnotesize \par}

~{\footnotesize ~~char{*}~entrada;~long~n;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Em~caso~de~erro~nos~argumentos,~PyArg\_ParseTuple}{\footnotesize \par}

~\emph{\footnotesize ~~~~~gera~uma~exceção~apropriada~automaticamente~{*}/}{\footnotesize \par}

~{\footnotesize ~~if~(!PyArg\_ParseTuple(args,~\char`\"{}sl\char`\"{},~\&entrada,~\&n))}{\footnotesize \par}

~{\footnotesize ~~~~~return~NULL;}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Recebi:~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~{\footnotesize ~~return~PyInt\_FromLong(42);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Como os argumentos são recebidos em uma tupla no segundo parâmetro,
a assinatura de função empregada corresponde à flag \texttt{METH\_VARARGS}.
Os parâmetros de entrada são convertidos para C e verificados com
\texttt{PyArg\_ParseTuple}. O valor de retorno é convertido do tipo
nativo C para um \texttt{PyObject} com \texttt{PyInt\_FromLong}, gerando
uma nova referência.



A API de Python é projetada primariamente para o desenvolvimento de
módulos de extensão para a linguagem. Embora existam diversas funções
para registrar métodos em classes e inicializar módulos com listas
de funções, não há uma forma direta para registrar funções globais
na máquina virtual. Uma maneira possível é usando a rotina utilitária
para lookup de métodos \texttt{Py\_FindMethod} e inserindo o método
retornado no dicionário do módulo global \texttt{\_\_main\_\_}:

\begin{lyxcode}
{\footnotesize PyObject{*}~globals~=~PyModule\_GetDict(PyImport\_AddModule(\char`\"{}\_\_main\_\_\char`\"{}));}{\footnotesize \par}

{\footnotesize static~PyMethodDef~teste\_def{[}{]}~=~\{}{\footnotesize \par}

~{\footnotesize ~~\{~\char`\"{}teste\char`\"{},~(PyCFunction)~teste\_py,~METH\_VARARGS,~\char`\"{}um~teste\char`\"{}~\},}{\footnotesize \par}

~{\footnotesize ~~\{~NULL~\}}{\footnotesize \par}

{\footnotesize \};}{\footnotesize \par}

{\footnotesize PyObject{*}~teste\_obj~=~Py\_FindMethod(teste\_def,~NULL,~\char`\"{}teste\char`\"{});}{\footnotesize \par}

{\footnotesize PyDict\_SetItemString(globals,~\char`\"{}teste\char`\"{},~teste\_obj);}{\footnotesize \par}
\end{lyxcode}


Note que foi passado \texttt{NULL} para \texttt{Py\_FindMethod}, indicando
que não há um objeto do qual o método faz parte. O argumento \texttt{self}
recebido pela função C \texttt{teste\_py} será também \texttt{NULL}
e pode ser ignorado. O array \texttt{teste\_def} foi declarado \texttt{static}
para garantir que o \texttt{PyMethodDef} continuará válido enquanto
a função global estiver registrada, pois na criação de \texttt{teste\_obj}
um ponteiro para ele é armazenado internamente no objeto criado.


\subsection{Ruby\label{sub:Ruby-Registro}}



Para que funções C possam ser chamadas a partir de Ruby, elas devem
ser declaradas como métodos de alguma classe ou módulo, ou ainda como
uma função global. Para isto, passa-se um ponteiro de uma função C
e o número de argumentos que a função espera para uma das funções
apropriadas da API de Ruby: \texttt{rb\_define\_method}, \texttt{rb\_define\_module\_function},
\texttt{rb\_define\_global\_function} ou \texttt{rb\_define\_singleton\-\_method}.
O número de parâmetros passado indica a assinatura esperada para a
função~C. Ruby suporta explicitamente funções C com até 15 argumentos;
como alternativa, os valores especiais -1 e -2 indicam, respectivamente,
que a função C irá receber os parâmetros na forma de um array C de
\texttt{VALUE}s ou na forma de um \texttt{VALUE} correspondente a
um array Ruby.

De forma que lembra a função \texttt{PyArg\_ParseTuple} discutida
na Seção~\ref{sub:Dados-Python}, Ruby possui uma função projetada
para simplificar o processamento dos valores de entrada em funções~C:
\texttt{rb\_scan\_args}. Esta função pode ser usada quando os parâmetros
de entrada são recebidos em um array Ruby. Como \texttt{PyArg\_ParseTuple},
ela é uma função vararg que recebe uma string de formato indicando
o número de parâmetros a serem coletados. Por outro lado, ela não
realiza verificação de tipo dos argumentos. A string de formato permite
indicar o número mínimo e máximo de parâmetros aceitos e se os parâmetros
excedentes devem ser coletados em um array Ruby.



Uma vez declarada no espaço de objetos de Ruby, uma função C pode
ser chamada como qualquer outro método. A função C pode verificar
se o código Ruby lhe passou um bloco de código através da função \texttt{rb\_block\_given\_p}.
O bloco pode então ser invocado com \texttt{rb\_yield}, que recebe
um \texttt{VALUE} como argumento. Para passar múltiplos argumentos
para \texttt{rb\_yield}, deve-se passar um array Ruby. Para obter
um \texttt{VALUE} do tipo \texttt{Proc} produzido a partir do bloco
de código recebido é preciso usar \texttt{rb\_scan\_args}, que possui
funcionalidade similar à do operador \texttt{\&} em declarações de
funções Ruby.



Funções C implementado métodos Ruby devem sempre retornar um \texttt{VALUE}
(\texttt{Qnil} quando não há retorno). Funções que retornam múltiplos
valores devem fazê-lo através de um array Ruby.



Dando continuidade à série de exemplos, a função global Ruby \texttt{teste}
pode ser implementada da seguinte forma em C:

\begin{lyxcode}
{\footnotesize VALUE~teste\_rb(VALUE~self,~VALUE~val\_entrada,~VALUE~val\_n)~\{}{\footnotesize \par}

~{\footnotesize ~~char{*}~entrada~=~StringValuePtr(val\_entrada);}{\footnotesize \par}

~{\footnotesize ~~long~n~=~NUM2INT(val\_n);}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Recebi:~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~{\footnotesize ~~return~INT2NUM(42);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


A conversão dos \texttt{VALUE}s de entrada é feita com as macros \texttt{StringValuePtr}
e \texttt{NUM2INT}. Não há código explícito para tratamento de erros
na conversão pois estas macros disparam exceções que saem da função
via \texttt{longjmp} caso a conversão não seja possível. Para a saída,
é produzido um \texttt{VALUE} com a macro \texttt{INT2NUM}. O primeiro
parâmetro de entrada é necessário segundo a convenção de assinaturas
de função da API, mas para funções globais ele deve ser ignorado.



Como Ruby oferece uma função na API para a definição de funções globais,
o registro de \texttt{teste} é bastante simples:

\begin{lyxcode}
{\footnotesize rb\_define\_global\_function(\char`\"{}teste\char`\"{},~teste\_rb,~2);~}{\footnotesize \par}
\end{lyxcode}
É indicado o nome da função no espaço de Ruby, a função C correspondente
e o número de parâmetros que ela espera (não incluindo o parâmetro
\texttt{self}).


\subsection{Java\label{sub:Java-Registro}}



Métodos declarados em Java que não são implementados na própria linguagem
devem ser declarados através de um protótipo incluindo o modificador
\texttt{native}. Assim, \texttt{native} não se refere a uma implementação
nativa em Java, mas ao código do método ter sido compilado com código
nativo do ambiente de execução, em oposição a \emph{bytecodes} da
máquina virtual. A implementação do método, usualmente encapsulada
em uma biblioteca dinâmica C, deve ser carregada antes de sua execução
usando a chamada \texttt{System.loadLibrary} em Java, usualmente em
um bloco \texttt{static} da classe correspondente. Para cada método
\texttt{native}, uma função C correspondente deve ser definida na
biblioteca carregada.

O utilitário \texttt{javah} gera arquivos de cabeçalho C a partir
de classes Java, com os protótipos de funções C no formato especificado
pela JNI. Este formato especifica não apenas a assinatura dos parâmetros
de entrada e tipo de retorno, mas também o nome da função, para que
o \emph{loader} realize a ligação entre a função C e o método Java
na máquina virtual. As funções devem se chamar \texttt{Java\_}\emph{{[}nome
da classe}\texttt{\emph{{]}}}\texttt{\_}\emph{{[}nome do método{]}}.
No caso de sobrecarga de funções, um sufixo é adicionado indicando
o tipo dos parâmetros de entrada (por exemplo, \texttt{Java\_Classe\_metodo\_\_DI}
para a versão de \texttt{Classe.metodo} que aceita um \texttt{double}
e um \texttt{int} como parâmetros).

Os parâmetros de entrada da função são um ponteiro para \texttt{JNIEnv},
que representa uma thread da JVM, um \texttt{jobject} representando
o objeto sobre o qual o método é aplicado (ou uma \texttt{jclass}
para métodos estáticos) e os demais parâmetros do método Java em suas
representações C, discutidas na Seção~\ref{sub:Dados-Java}. Como
o tipos dos parâmetros passados são definidos estaticamente tanto
em Java como em C, não é preciso realizar a verificação dos tipos
dos dados recebidos no código C. A assinatura das funções que implementam
métodos, especificados nos arquivos de cabeçalho gerados pela ferramenta
\texttt{javah}, já declaram os tipos corretos.

O tipo de retorno corresponde ao tipo~C equivalente ao tipo de retorno
do método Java. Valores representados com tipos de referência podem
ser retornados tanto com referências locais como globais. Além de
tratar ou propagar erros como discutido na Seção~\ref{sub:Java-Chamada},
funções C podem também gerar exceções com \texttt{Throw} e \texttt{ThrowNew}
e retornar imediatamente. O valor de retorno será ignorado quando
a exceção for capturada no código Java.



Como o modo de expor à máquina virtual de Java funções implementadas
em C é diferente do empregado nas linguagens vistas anteriormente,
iniciaremos pela forma de declarar a função para o espaço de Java,
para só então mostrar a implementação de \texttt{teste} em C. Na classe
em Java, declaramos um método \texttt{native}:

\begin{lyxcode}
{\footnotesize public~class~Exemplo~\{}{\footnotesize \par}

~{\footnotesize ~~static~native~int~teste(String~entrada,~int~n);}{\footnotesize \par}

~\emph{\footnotesize ~~//~...demais~membros~da~classe}{\footnotesize \par}

~{\footnotesize ~~static~\{}{\footnotesize \par}

~{\footnotesize ~~~~~System.loadLibrary(\char`\"{}Exemplo\char`\"{});}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Após compilar esta classe podemos passá-la para o comando \texttt{javah},
que gerará um arquivo de cabeçalho C. Este arquivo conterá o nome
e assinatura da função C que a JVM irá procurar na biblioteca que
será carregada por \texttt{System.loadLibrary}%
\footnote{O parâmetro passado no código Java é usado como base na construção
de um nome dependente de plataforma. Em sistemas Unix, por exemplo,
o comando \texttt{System.loadLibrary(\char`\"{}Exemplo\char`\"{})}
carrega o arquivo \texttt{libExemplo.so}.%
}. Esta biblioteca deve implementar funções relativas aos métodos declarados
como \texttt{native}.

Abaixo, é dada uma implementação em C, usando o cabeçalho gerado por
\texttt{javah}, para o método \texttt{teste}:

\begin{lyxcode}
{\footnotesize \#include~<jni.h>}{\footnotesize \par}

{\footnotesize \#include~<stdio.h>}{\footnotesize \par}

\emph{\footnotesize /{*}~Cabeçalho~gerado~por~javah~{*}/}{\footnotesize \par}

{\footnotesize \#include~\char`\"{}Exemplo.h\char`\"{}~}{\footnotesize \par}

~{\footnotesize }~\\
{\footnotesize JNIEXPORT~jint~JNICALL}{\footnotesize \par}

{\footnotesize Java\_Exemplo\_teste(JNIEnv{*}~J,~jclass~c,~jstring~obj\_entrada,~jint~n)~\{}{\footnotesize \par}

~{\footnotesize ~~const~char{*}~entrada~=~({*}J)->GetStringUTFChars(J,~obj\_entrada,~NULL);}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Recebi~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~{\footnotesize ~~({*}J)->ReleaseStringUTFChars(J,~obj\_entrada,~entrada);}{\footnotesize \par}

~{\footnotesize ~~return~42;}{\footnotesize \par}

{\footnotesize \}~}{\footnotesize \par}
\end{lyxcode}


\texttt{JNIEXPORT} e \texttt{JNICALL} são macros definidas em \texttt{jni.h}
para dar maior portabilidade ao código C resultante. Como o método
foi declarado como \texttt{static} em Java, uma referência para a
classe é recebida como parâmetro para a função. Os demais parâmetros
correspondem aos parâmetros do método Java, e são dados nos tipos
equivalentes da JNI. Conforme discutido na Seção~\ref{sub:Dados-Java},
a JNI dá tratamentos diferentes para tipos de referência e tipos imediatos.
Desta forma, somente o parâmetro \texttt{obj\_entrada} precisa ser
convertido para C; tanto \texttt{n} como o valor de retorno podem
ser usados diretamente como tipos básicos de C.

A string obtida com \texttt{GetStringUTFChars} é convertida para UTF-8
a partir da representação Unicode interna de Java. O mesmo ponteiro
pode ser retornado pela JVM a diferentes threads que solicitem a mesma
string. Deste modo, o código C deve notificar a sua liberação explicitamente
com \texttt{ReleaseStringUTFChars}.


\subsection{Lua\label{sub:Lua-Registro}}

Funções C expostas ao espaço de Lua devem ter o tipo \texttt{lua\_CFunction},
recebendo como único parâmetro um ponteiro para uma variável do tipo
\texttt{lua\_State} e retornando um \texttt{int}. Um \texttt{lua\_State}
encapsula todo o estado da máquina virtual de Lua; múltiplos estados
Lua podem ser mantidos em paralelo. Todas as funções da API \emph{core}
de Lua recebem um \texttt{lua\_State} como primeiro parâmetro, exceto
\texttt{lua\_newstate}, que cria um \texttt{lua\_State} novo.



Ao início da função C, os argumentos passados a ela encontram-se inseridos
na pilha virtual. Como em funções Lua, não há verificação sobre o
número de argumentos passados para uma função C invocada a partir
de Lua ou através da API. O código C pode verificar o número de argumentos
passados inspecionando o tamanho da pilha recebida.



A biblioteca auxiliar provê ainda funções para verificar de forma
mais conveniente o tipo dos argumentos passados. Funções da família
\texttt{luaL\_check}{*} (\texttt{luaL\_checkint}, \texttt{luaL\_check\-string},
etc.) verificam o tipo de elementos da pilha e os retornam, sinalizando
erro caso o tipo do elemento não seja o requisitado. As funções \texttt{luaL\_opt}{*}
se comportam de forma similar, permitindo ainda indicar um valor padrão
caso o elemento esteja ausente ou seja \texttt{nil}. 



Valores de retorno também são passados pela função C de volta para
Lua através da pilha virtual. O valor inteiro retornado da função
C indica quantos elementos da pilha devem ser retornados à função
chamadora. Os demais valores da pilha são descartados.



Uma função C do tipo \texttt{lua\_CFunction} pode ser passada para
o espaço de Lua através da função \texttt{lua\_pushcfunction}. Lua
possui também algumas funções de conveniência para registrar um conjunto
de funções C de uma só vez. Do mesmo modo que ocorre no uso de arrays
\texttt{PyMethodDef} em Python, a função \texttt{luaL\_register} registra
uma lista de funções, recebendo um array de estruturas \texttt{luaL\_Reg}
contendo nomes e ponteiros de função.



A função C implementando a função de exemplo \texttt{teste} é dada
a seguir:

\begin{lyxcode}
{\footnotesize int~teste\_lua(lua\_State{*}~L)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obtém~o~primeiro~parâmetro~{*}/}{\footnotesize \par}

~{\footnotesize ~~const~char{*}~entrada~=~luaL\_checkstring(L,~1);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Obtém~o~segundo~parâmetro~{*}/}{\footnotesize \par}

~{\footnotesize ~~long~n~=~luaL\_checkinteger(L,~2);}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Recebi~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Empilha~o~valor~de~retorno~{*}/}{\footnotesize \par}

~{\footnotesize ~~lua\_pushinteger(L,~42);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorna~um~valor,~do~topo~da~pilha~{*}/}{\footnotesize \par}

~{\footnotesize ~~return~1;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
A função tem assinatura idêntica à definição de \texttt{lua\_CFunction}.
Os parâmetros de entrada são obtidos das posições 1 e 2 da pilha e
os seus tipos são verificados usando as funções da biblioteca auxiliar
\texttt{luaL\_checkstring} e \texttt{luaL\_checkinteger}. Estas funções
sinalizam erro em caso de falha na conversão, causando um \texttt{longjmp}
como em Ruby.

O tipo da string obtida é \texttt{const char{*}}, pois ela aponta
um bloco de memória gerenciado pela máquina virtual. Em Lua, no entanto,
não é preciso notificar a liberação da string explicitamente, pois
esta permanece válida enquanto o valor estiver na pilha. Como as funções
\texttt{luaL\_check}{*} não desempilham os parâmetros e a pilha é
esvaziada implicitamente ao final da função C, a string C obtida permanecerá
válida ao longo da função.

Ao fim da função \texttt{teste\_lua}, o valor de retorno para Lua
é empilhado usando \texttt{lua\_push\-integer}. O valor de retorno
da função em C, \texttt{1}, indica à máquina virtual que há um único
valor de saída a ser obtido da pilha e usado como retorno da função
em Lua.



A função é registrada em Lua criando um objeto Lua do tipo \texttt{function}
a partir da função C e armazenando este objeto em uma variável global.
Isto poderia ser feito com \texttt{lua\_pushcclosure} e \texttt{lua\_setglobal},
mas o arquivo de cabeçalho \texttt{lua.h} possui uma macro que encapsula
estas duas chamadas. Assim, a função pode ser registrada simplesmente
com:

\begin{lyxcode}
{\footnotesize lua\_register(L,~\char`\"{}teste\char`\"{},~teste\_lua);}{\footnotesize \par}
\end{lyxcode}


Usando a função \texttt{lua\_pushcclosure}, é possível associar a
uma função C valores Lua que serão acessíveis à função sempre que
esta for chamada, de forma similar a variáveis locais \texttt{static}
C. Este recurso provê uma funcionalidade similar às \emph{closures}
de Lua, porém mais limitado: os valores associados são privados às
funções C, enquanto em Lua duas \emph{closures} definidas num mesmo
escopo terão acesso às mesmas variáveis, isto é, alterações nos valores
em uma afetarão a outra. Esta forma restrita, porém, já permite a
implementação em C de {}``funções com estado'', como iteradores
e geradores. Uma vez registrada no espaço de Lua, funções C passam
a ser vistos como valores do tipo \texttt{function}, de forma igual
a funções Lua. De fato, \texttt{lua\_pushcfunction} é um caso particular
de \texttt{lua\_pushcclosure} onde nenhum valor Lua é associado à
função.


\subsection{Perl\label{sub:Perl-registro}}



Como discutido na Seção~\ref{sub:Perl-Dados}, a interface entre
Perl e C foi projetada tendo em mente que a ligação entre as funções
C e o interpretador Perl é feita através de código gerado a partir
de uma descrição feita em uma linguagem de mais alto nível, XS. Código~XS
consiste de declarações de assinaturas de função com uma sintaxe especial,
indicando regras para conversão dos parâmetros de entrada e saída,
e código C descrevendo a implementação das funções. XS é projetada
para o desenvolvimento de extensões Perl incluindo funções implementadas
em C: o resultado final da compilação do código gerado pelas ferramentas~XS
(\texttt{h2xs}, \texttt{xsubpp}) são código C e Perl que juntos descrevem
um pacote Perl (um conjunto de variáveis e funções armazenados sob
um \emph{namespace} comum).



Existe uma API pública para manipulação de dados Perl no código C,
mas esta consiste basicamente das estruturas internas da implementação
do interpretador expostas para uso pelo pré-processador XS, acrescida
de macros para maior conveniência do programador. De fato, Perl não
expõe uma API documentada para o registro de funções~\cite{okamoto06perlapi}.
Assim, não é prático para uma aplicação embutir um interpretador Perl
e expor a ele um conjunto de funções C usando apenas código C. A saída
é criar uma extensão Perl usando XS que expõe funções da aplicação
e importar o pacote resultante no interpretador embutido. O emprego
desta abordagem foi observada nos plugins para scripting Perl de diversas
aplicações %
\footnote{Vim (\url{http://www.vim.org}), Gimp (\url{http://search.cpan.org/search?mode=dist&query=gimp})
e Gaim (\url{http://gaim.sourceforge.net}) são algumas aplicações
que implementam plugins Perl através de extensões XS. No plugin de
Xchat (\url{http://www.xchat.org}), não há arquivos \texttt{.xs},
mas os fontes \texttt{.c} incluem funções declaradas com a API não
documentada e o código Perl equivalente ao arquivo \texttt{.pm} gerado
por \texttt{xsubpp} declarado como uma string C avaliada com \texttt{eval\_pv},
dando a entender que o plugin foi implementado como uma extensão usando
XS e depois convertido para um único arquivo-fonte C.%
}.



O utilitário \texttt{h2xs} gera um diretório contendo o esqueleto
de um módulo Perl: um script gerador de Makefiles, arquivos \texttt{.xs}
e \texttt{.pm} a serem acrescidos de código XS e Perl, além de arquivos
auxiliares. Retomando o exemplo da função teste, ela seria declarada
da seguinte forma em XS:

\begin{lyxcode}
{\footnotesize long~teste(entrada,~n)}{\footnotesize \par}

~{\footnotesize ~~~~~~~char{*}~entrada}{\footnotesize \par}

~{\footnotesize ~~~~~~~int~n}{\footnotesize \par}

~{\footnotesize ~~~~~~~CODE:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~printf(\char`\"{}Recebi~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~RETVAL~=~42;}{\footnotesize \par}

~{\footnotesize ~~~~~~~OUTPUT:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~RETVAL~}{\footnotesize \par}
\end{lyxcode}


O arquivo \texttt{.xs} é convertido para \texttt{.c} com \texttt{xsubpp}.
O código C para a conversão dos parâmetros de entrada e saída é gerado
automaticamente. Em alguns casos, entretanto, precisamos manipular
os valores da pilha de Perl explicitamente, como descrito na Seção~\ref{sub:Perl-Dados}.
Em funções vararg, por exemplo, os argumentos adicionais devem ser
acessados diretamente na pilha. O código para registrar as funções
do módulo também é gerado automaticamente.



XS cria uma variável \texttt{RETVAL} automaticamente para armazenamento
do valor de retorno em código C. O conteúdo desta variável é convertido
para um valor Perl pelo código C gerado. Para que funções que retornam
arrays possam operar corretamente em contextos escalares, deve-se
verificar o contexto em que a função é chamada com \texttt{GIMME\_V}
e então retornar um \texttt{SV} ou \texttt{AV} conforme o caso. A
função, nestes casos, deve ser declarada com tipo de retorno \texttt{SV{*}},
fazendo com que os valores de C devam ser convertidos para \texttt{SV}s
Perl explicitamente. A documentação alerta que, para o caso de \texttt{AV}s,
deve-se declarar o valor de retorno como variável mortal%
\footnote{Este comportamento é descrito na documentação como \emph{{}``an unfixable
bug (fixing it would break lots of existing CPAN modules)''} \cite{roehrich06perlxs}. %
}.

Uma vez compilada a extensão usando os Makefiles gerados por \texttt{h2xs},
esta pode ser carregada e usada a partir de Perl:

\begin{lyxcode}
{\footnotesize use~Teste;}{\footnotesize \par}

{\footnotesize \$ret~=~Teste::teste(\char`\"{}entrada\char`\"{},~2);}{\footnotesize \par}

{\footnotesize print~\$ret~.~\char`\"{}\textbackslash{}n\char`\"{};}{\footnotesize \par}
\end{lyxcode}


Para expor funções de uma aplicação C a um interpretador Perl embutido
nela, devemos criar uma extensão que encapsula estas funções usando
XS, ligar a extensão à aplicação e carregá-la. A carga é feita passando
para o interpretador durante a sua inicialização uma função C contendo
chamadas \texttt{newXS}. O módulo Perl \texttt{ExtUtils::Embed} possui
uma rotina \texttt{xsinit} para gerar o código C desta função. Na
prática, gerar o código da função com \texttt{xsinit} é a melhor abordagem,
já que a inicialização depende de rotinas não documentadas (o exemplo
de função de inicialização incluído na documentação de Perl~\cite{maceachern06perlembed}
está desatualizado).


\subsection{Comparação}

Python e Ruby oferecem ao programador várias opções de assinaturas
de função~C reconhecidas pela API, o que é prático, uma vez que pode-se
escolher assim diferentes representações em C para os parâmetros de
entrada (agregados em um array, recebidos um a um, etc.) conforme
o seu uso na função. Lua oferece apenas uma assinatura de função possível
para funções C a serem registradas na máquina virtual, mas isto é
apropriado para o modelo de pilha usado por sua API.

Em Java, as assinaturas de função são criadas através da ferramenta
\texttt{javah} -- devido à tipagem estática, os tipos dos parâmetros
de entrada passados por Java são convertidos automaticamente pela
JNI, o que é bastante conveniente uma vez que evita operações explícitas
de conversão e verificação de tipos na função. Por terem tipagem dinâmica,
as demais linguagens oferecem funções na API específicas para realizar
estas verificações. As assinaturas de função em Perl são criadas apenas
através da ferramenta XS, mas diferentemente de Java elas não são
expostas ao programador. Isto traz a inconveniência de termos que
pré-processar o código C como uma extensão XS mesmo quando estamos
embutindo Perl em uma aplicação.

O registro de funções em Ruby e Lua é simples. Em Lua, em particular,
trata-se de uma atribuição igual à de qualquer outro objeto. Já em
Python, existem recursos para o registro de funções em lote, usando
arrays \texttt{PyMethodDef} (Lua oferece recurso similar com \texttt{luaL\_register}),
mas não há uma forma simples de registrar uma única função. Tanto
em Java como em Perl o registro de funções é feito de forma implícita,
e em nenhuma das duas APIs há funções para registrar novas funções
C durante a execução do programa.


\chapter{\label{cha:Estudo-de-caso:}Estudo de caso: LibScript}

Nos capítulos anteriores, foram discutidas as principais questões
envolvendo interfaces de linguagens para C e a forma como estas questões
são tratadas pelas linguagens abordadas neste estudo. Neste capítulo,
realizaremos uma comparação entre as APIs através de um exemplo concreto,
de modo a colocar implementações em cada uma das linguagens lado a
lado. O exemplo consiste em uma biblioteca genérica para scripting,
chamada LibScript, e uma série de plugins que realizam a interface
com as diferentes linguagens de script.


\section{LibScript}

LibScript é uma biblioteca projetada para tornar aplicações extensíveis
através de scripting de uma forma independente de linguagem. Ela é
baseada em uma arquitetura de \emph{plugins}, de modo a desacoplar
a aplicação dos ambientes de execução providos pelas diversas linguagens.
A biblioteca principal provê uma API para scripting independente de
linguagem, permitindo a uma aplicação registrar as suas funções e
disparar scripts que utilizem estas funções. Esta biblioteca então
invoca o plugin da linguagem apropriada para rodar o script (por exemplo,
LibScript-Python para código Python). Desta forma, o desenvolvedor
da aplicação permite ao seu usuário utilizar diferentes linguagens
para scripting sem adicionar todas elas como dependências do programa.

A biblioteca principal disponibiliza recursos para o registro de funções
C por parte da aplicação e para a chamada destas funções por parte
dos plugins (permitindo aos scripts acessar as funções), além de funções
para a transferência de dados entre as duas partes. É possível também
invocar funções implementadas nas máquinas virtuais embutidas nos
plugins, possibilitando assim que scripts escritos em diferentes linguagens
possam interagir.


\subsection{Arquitetura de LibScript}

%
\begin{figure}
\begin{center}\includegraphics[%
  width=1\columnwidth,
  keepaspectratio]{figura1.eps}\end{center}


\caption{\label{cap:Vis=E3o-geral}Visão geral da arquitetura de LibScript}
\end{figure}


LibScript é composta de uma biblioteca dinâmica principal, \texttt{libscript},
e \emph{plugins} para diferentes linguagens (Figura~\ref{cap:Vis=E3o-geral}).
A biblioteca principal é ligada a uma aplicação, e expõe a ela uma
API de scripting independente de linguagem, que permite executar arquivos,
strings de código e invocar funções. Esta biblioteca é uma fina camada
que encaminha estas operações para os plugins, que são bibliotecas
dinâmicas auxiliares, carregadas em tempo de execução pela biblioteca
principal. Estes plugins embutem os ambientes de execução das linguagens
de script.

A aplicação pode registrar funções C na biblioteca principal (ilustrado
pela função \texttt{c\_fun} na figura) e solicitar a ela que execute
scripts que registram funções nas diferentes linguagens. Todavia,
a aplicação não interage diretamente com os plugins. Quando a biblioteca
principal recebe código a ser executado em uma determinada linguagem,
ela carrega o plugin adeqüado (caso este ainda não esteja carregado)
e encaminha o código. O plugin irá executar o script em sua máquina
virtual, o que pode registrar nela novas funções (ilustrado pelas
funções \texttt{py\_fun}, \texttt{r\_fun}, \texttt{l\_fun} e \texttt{pl\_fun}
na figura).

A biblioteca principal decide qual plugin carregar através de um identificador
que especifica qual a linguagem do código a ser executado. Este identificador
pode ser obtido a partir da extensão de arquivo de um script carregado,
da linha de identificação {}``\texttt{\#!}'' no início do script%
\footnote{A linha {}``\texttt{\#!}'' é usada apenas para detectar a linguagem
em que o script é escrito. Por exemplo, uma linha \texttt{\#!/usr/bin/perl
-w} indicará a carga do plugin \texttt{libscript-perl}, mas o interpretador
Perl em \texttt{/usr/bin} não é usado e nem a flag \texttt{-w} passada
é considerada.%
} ou mesmo passado explicitamente pela aplicação.

%
\begin{figure}
\begin{center}\includegraphics[%
  width=1\columnwidth,
  keepaspectratio]{figura2.eps}\end{center}


\caption{\label{cap:Ambientes-virtuais}Ambientes virtuais em LibScript}
\end{figure}


Funções são registradas em LibScript em um \emph{ambiente virtual}.
A aplicação pode criar um ou mais ambientes na biblioteca principal,
identificando-os com um nome. Um ambiente virtual ganha em cada plugin
uma estrutura de dados específica da linguagem (classe, módulo, etc.)
que o representará. No exemplo da Figura~\ref{cap:Ambientes-virtuais}
temos dois ambientes virtuais criados pela aplicação na biblioteca
principal, \texttt{X} e \texttt{Y}. Em cada um destes ambientes, a
aplicação registrou uma função C com o nome \texttt{c\_fun} (que podem
ou não corresponder à mesma função C). Scripts foram executados nestes
ambientes, o que causou a carga dos plugins. No exemplo, estes scripts
registraram algumas funções (\texttt{X.py\_fn}, \texttt{Y.py\_fn},
\texttt{X\#r\_fun}, etc.).

À parte da função para criação de ambientes virtuais, todas as demais
funções da API de LibScript recebem como parâmetro um ambiente virtual
sobre a qual elas devem operar. Isto indica em qual estrutura de C
devem ser armazenadas mensagens de erro e valores de retorno. No caso
de linguagens que permitem múltiplos estados de execução independentes,
como Lua e Perl, isto indica também em qual estado o script deve executar.

Quando um script declara uma função no ambiente virtual, esta função
passa a ser acessível através da API de LibScript. Por exemplo, no
plugin Lua, o ambiente virtual é representado por uma tabela com o
nome do ambiente; uma vez que um método Ruby~\texttt{r} é declarado
na classe \texttt{X}, esta função passa a poder ser invocada por C
(através da API de LibScript) ou pelos outros plugins. Assim, por
exemplo, embora na tabela Lua que implementa o ambiente virtual \texttt{X}
só conste a função \texttt{l\_fun}, scripts Lua podem invocar as demais
funções através do ambiente virtual, como \texttt{X.c\_fun} e \texttt{X.r\_fun}.
Estas chamadas serão tratadas pela biblioteca principal e resolvidas
por ela, no caso de funções C como \texttt{X.c\_fun}, ou repassadas
para o plugin apropriado, como no caso de \texttt{X.r\_fun}, realizando
a chamada no plugin Ruby e passando os valores de retorno para o plugin
Lua. A biblioteca principal localiza a função a ser executada consultando
os plugins, conforme será explicado na Seção~\ref{sub:A-API-de-plugins}.

Na implementação dos plugins, utilizamos recursos oferecidos pelas
linguagens para tratar acessos a elementos inexistentes nas estruturas,
capturando estes acessos e repassando-os para a biblioteca principal.
Estes recursos serão discutidos na Seção~\ref{sub:Resolu=E7=E3o-de-fun=E7=F5es}.


\subsection{\label{sec:A-Camada-Independente}A API da biblioteca principal}

A API oferecida por LibScript isola a aplicação das diferentes APIs
oferecidas pelas linguagens de script. Não se trata apenas de adicionar
uma camada de indireção entre as chamadas, o que seria apropriado
apenas para os recursos que são comuns a todas elas, como inicialização
e chamadas de função. A questão principal aí são os vários recursos
particulares a cada linguagem. Uma abordagem pouco prática seria definir
a API como a união dos conjuntos de recursos de todas as linguagens
a ser suportadas (oferecer recursos de manipulação de seqüências para
mapear este recurso de Python, recursos de manipulação de tabelas
para Lua, e assim por diante). Este caminho traria vários problemas:
a API seria complexa e provavelmente precisaria ser estendida a cada
nova linguagem introduzida; mesmo para mapeamentos que aparentemente
poderiam ser reaproveitados (por exemplo, mapear \emph{hashes} de
Python e tabelas de Lua para uma mesma API de \emph{arrays} associativos)
há o problema de sutis variações de semântica entre as implementações
dos recursos nas diferentes linguagens. Além disso, bindings de aplicações
poderiam oferecer funcionalidades disponíveis apenas para uma linguagem,
indo contra a proposta de independência de linguagem de LibScript.

Outra abordagem é, ao invés de expor a API da linguagem à aplicação,
expor apenas uma API de funções da aplicação para a linguagem e manter
as estruturas de dados e recursos desta restrito ao domínio que será
invocado. A aplicação interage com a máquina virtual enviando strings
de código a ser executado e obtém resultados de volta quando o script
passa parâmetros ao chamar funções da aplicação. Esta abordagem é
proposta em~\cite{thomas02ltn004} e utiliza o que, por exemplo,
Python chama de {}``very high level layer''~\cite{vanrossum06extpy,vanrossum06ref}.
Oferecer uma primitiva para a execução de uma string de código é algo
básico em linguagens voltadas a script -- \texttt{luaL\_loadstring}
em Lua, \texttt{PyRun\_SimpleString} em Python, \texttt{rb\_eval\_string}
em Ruby , \texttt{perl\_eval\_sv} em Perl~\cite{maceachern06perlembed}.

%
\begin{figure}
\includegraphics[%
  width=1\columnwidth,
  keepaspectratio]{figura3.eps}


\caption{\label{fig:API-para-execu=E7=E3o}API para execução de código em
LibScript}
\end{figure}


LibScript adota esta abordagem mais minimalista para sua API: não
são oferecidas operações específicas para manipulação de estruturas
de dados, apenas para a \emph{execução de strings} -- \texttt{script\_run}
(e a função de conveniência \texttt{script\_run\_file}, que lê um
arquivo e o envia para \texttt{script\_run}) -- e \emph{chamadas de
função} com tipos básicos (números e strings) -- \texttt{script\_call}.
Operações sobre dados mais complexos de tipos específicos de cada
linguagem, quando necessárias, podem ser encapsuladas em funções implementadas
nas linguagens de script. Pode-se ainda referenciar objetos da linguagem
a partir de C armazenando-as em estruturas na linguagem de script
e retornando a C índices numéricos destas estruturas, servindo como
\emph{handles} de alto nível para os objetos.

A Figura~\ref{fig:API-para-execu=E7=E3o} ilustra a interação entre
a aplicação, a biblioteca principal e os plugins em relação a estas
duas operações fundamentais, simbolizadas pelas funções \texttt{script\_run}
e \texttt{script\_call}. Para a execução de strings, a biblioteca
principal recebe da aplicação a entrada e repassa o código a ser executado
para o plugin apropriado. Em \texttt{script\_run}, são passadas duas
strings, uma identificando a linguagem e outra contendo o código;
em \texttt{script\_run\_file}, um nome de arquivo%
\footnote{Para código executado com \texttt{script\_run\_file}, a linguagem
é automaticamente detectada como discutido na seção anterior.%
}. O exemplo a seguir declara um ambiente virtual, registra uma função
C chamada \texttt{hello} e a invoca a partir de código Lua:

\begin{lyxcode}
{\footnotesize script\_env{*}~env~=~script\_init(\char`\"{}exemplo\char`\"{});}{\footnotesize \par}

{\footnotesize script\_new\_function(env,~hello,~\char`\"{}hello\char`\"{});}{\footnotesize \par}

{\footnotesize script\_run(env,~\char`\"{}lua\char`\"{},~\char`\"{}exemplo.hello()\char`\"{});}{\footnotesize \par}
\end{lyxcode}


O ambiente virtual é declarado com a função \texttt{script\_init},
que recebe o nome que identificará o ambiente e retorna um identificador
do tipo \texttt{script\_env}, um ponteiro opaco que representa um
ambiente virtual. A função C é registrada usando a função \texttt{script\_new\_\-function},
que recebe como parâmetros o ambiente, a função a ser registrada e
o nome que a função terá no ambiente virtual. No código Lua, a função
é acessada como um elemento \texttt{hello} (nome registrado da função)
da tabela global \texttt{exemplo} (nome do ambiente virtual).

Para a chamada de funções, a aplicação deve passar os parâmetros de
entrada (a forma será discutida mais adiante), e chamar \texttt{script\_call},
indicando o nome de uma função registrada no ambiente virtual. A mesma
função \texttt{script\_call} é usada pelos plugins quando eles desejam
invocar funções do ambiente virtual registradas em C ou implementadas
por outros plugins.

Por este motivo, procuramos usar uma API para transferência de dados
genérica, a ser usada tanto na entrada como na saída de dados, tanto
na comunicação entre a aplicação e a biblioteca principal como entre
a biblioteca principal e os plugins. Optamos por uma abordagem similar
às empregadas em Lua (Seção~\ref{sub:Lua-chamada}) e Perl (Seção~\ref{sub:Perl-call})
para o envio de dados na passagem de parâmetros e obtenção de valores
de retorno, usando um buffer interno como área de transferência. Diferentemente
destas linguagens, entretanto, passamos índices para os parâmetros
explicitamente ao invés de empregar uma disciplina de pilha. As funções
\texttt{script\_}\{\texttt{get},\texttt{put}\}\_\{\texttt{string},\texttt{int},\texttt{double},\texttt{bool}\}
são usadas na entrada e saída de valores. As funções \texttt{script\_put\_}{*}
armazenam valores no buffer interno e \texttt{script\_get\_}{*} os
removem. Uma chamada a uma função \texttt{teste} passando uma string
e um inteiro como parâmetros e obtendo um inteiro como resultado é
realizada da seguinte forma:

\begin{lyxcode}
{\footnotesize script\_put\_string(env,~0,~\char`\"{}entrada\char`\"{});}~\emph{\footnotesize /{*}~índice~0:~\char`\"{}entrada\char`\"{}~{*}/}{\footnotesize \par}

{\footnotesize script\_put\_int(env,~1,~2);~~~~~~~~~~~}~\emph{\footnotesize /{*}~índice~1:~2~{*}/}{\footnotesize \par}

{\footnotesize script\_call(env,~\char`\"{}teste\char`\"{});}{\footnotesize \par}

{\footnotesize resultado~=~script\_get\_int(env,~0);~~}~\emph{\footnotesize /{*}~retorna~índice~0~{*}/}{\footnotesize \par}
\end{lyxcode}


Chamadas de função são disponibilizadas como uma operação primitiva
pois elas permitem um grau mínimo de interoperabilidade de forma independente
de linguagem. Dois objetivos são atingidos desta forma. O primeiro
é que assim programas C embutindo LibScript podem acessar a funcionalidade
de scripts carregados sem precisar incluir no seu código strings de
texto em alguma linguagem específica, por exemplo, inserindo em seu
código uma chamada a uma função de \emph{callback} a ser definida
via script. Note que no exemplo acima, não é especificada a linguagem
em que a função \texttt{teste} é implementada. Se a chamada fosse
feita via execução de string de código, isto atrelaria a aplicação
a pelo menos uma linguagem de script. Usando \texttt{script\_run\_file}
e \texttt{script\_call}, pode-se implementar uma aplicação extensível
sem especificar explicitamente a linguagem de script a ser usada.
O segundo objetivo é permitir que os próprios plugins possam invocar
funções definidas em outros plugins. De qualquer forma, necessariamente
teríamos que prover aos plugins uma função de chamada, para que eles
pudessem invocar as funções C registradas em LibScript. Tornar a função
de chamada genérica o suficiente para que possa invocar também funções
implementadas nos próprios plugins não torna, então, a API da biblioteca
principal mais complexa.

O buffer de LibScript foi projetado para ser usado apenas como uma
área de transferência temporária entre a biblioteca principal e os
plugins, e não como uma facilidade geral para armazenamento e manipulação
de dados. Assim, a sua API é voltada para a inserção e remoção seqüencial
de elementos. Por exemplo, a inserção de um elemento na posição 0
automaticamente zera o buffer, evitando em muitos casos a necessidade
de usar a função \texttt{script\_reset\_buffer}, que realiza tal operação
explicitamente.

Funções C registradas com \texttt{script\_new\_function} devem receber
o ambiente virtual como parâmetro e retornar um código de erro. As
funções \texttt{script\_get\_}{*} e \texttt{script\_put\_}{*} são
usadas para receber parâmetros e retornar valores ao implementar funções
que podem ser chamadas via LibScript, da mesma forma que são usadas
para passar parâmetros e obter valores de retorno ao realizar chamadas
com \texttt{script\_call}.

\begin{lyxcode}
{\footnotesize script\_err~teste\_lua(script\_env{*}~env)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Entrada,~índice~0:~string~{*}/}{\footnotesize \par}

~{\footnotesize ~~char{*}~entrada~=~script\_get\_string(env,~0);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Entrada,~índice~1:~inteiro~{*}/}{\footnotesize \par}

~{\footnotesize ~~int~n~=~script\_get\_int(env,~1);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Sai~da~função~com~erro~se~algum~script\_get\_{*}~falhou~{*}/}{\footnotesize \par}

~{\footnotesize ~~SCRIPT\_CHECK\_INPUTS(env);}{\footnotesize \par}

~{\footnotesize ~~printf(\char`\"{}Recebi~\%s~e~\%ld~\textbackslash{}n\char`\"{},~entrada,~n);}{\footnotesize \par}

~{\footnotesize ~~free(entrada);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorno,~índice~0:~inteiro~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_put\_int(env,~0,~42);}{\footnotesize \par}

~{\footnotesize ~~return~SCRIPT\_OK;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Em LibScript as strings retornadas por \texttt{script\_get\_string}
pertencem à função chamadora, sendo responsabilidade dela desalocar
a memória, diferentemente do que ocorre nas funções similares das
APIs das linguagens discutidas neste trabalho. Tal decisão foi tomada
devido ao caráter temporário do buffer de LibScript: retornar ao chamador
um ponteiro para uma string cuja validade seria restrita até a próxima
chamada da API seria algo pouco intuitivo, e na prática forçaria freqüentemente
o programador a fazer uma cópia da string.


\subsection{A API de plugins\label{sub:A-API-de-plugins}}

Um plugin que embute uma linguagem de script deve implementar quatro
operações: \texttt{init}, \texttt{run}, \texttt{call} e \texttt{done}.
A biblioteca principal espera que a biblioteca dinâmica que implementa
o plugin de uma linguagem exporte quatro funções, com nomes do tipo
\texttt{script\_plugin\_}\emph{{[}operação{]}}\texttt{\_}\emph{{[}linguagem{]}}.

A função \texttt{script\_plugin\_init\_}\emph{{[}linguagem{]}} é responsável
pela inicialização de um plugin, e é chamada pela função \texttt{script\_init}
da biblioteca principal. Na inicialização de um plugin, a biblioteca
principal passa à função \texttt{script\_plugin\_init\_}\emph{{[}linguagem{]}}
um ponteiro \texttt{script\_env} e recebe um \texttt{script\_plugin\_state},
que é um tipo opaco que é sempre passado de volta ao plugin nas demais
chamadas. Cada plugin define a sua representação interna para \texttt{script\_plugin\_state}.
Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente
LibScript devem ser armazenados de modo a ser posteriormente acessíveis
a partir deste handle. Na Seção~\ref{sub:Representa=E7=E3o-de-estados}
discutiremos como cada plugin representa o ambiente e o seu estado
interno em \texttt{script\_plugin\_state}.

A função \texttt{script\_plugin\_run\_}\emph{{[}linguagem{]}} é invocada
por \texttt{script\_run}. Ela recebe uma string contendo código da
linguagem de script, executa este código na máquina virtual e retorna
um valor de status indicando sucesso ou a ocorrência de erros de compilação
ou execução. No caso de erros, os plugins devem capturar exceções
disparadas pela máquina virtual e retornar a constante \texttt{SCRIPT\_ERRLANGRUN}.
Caso seja possível obter da linguagem uma mensagem de erro, esta pode
ser propagada usando a função \texttt{script\_set\_error\_message}
da biblioteca principal. A mensagem armazenada por ela poderá ser
posteriormente consultada pela aplicação com a função \texttt{script\_error\_message}.

A função \texttt{script\_plugin\_call\_}\emph{{[}linguagem{]}} é usada
por \texttt{script\_call}, e é responsável por realizar chamadas a
funções implementadas na linguagem embutida pelo plugin. Se a função
foi definida no plugin, isto é, se uma função com o nome solicitado
foi registrada na estrutura de dados que descreve o ambiente na máquina
virtual, ela será executada, e o sucesso ou falha da execução será
reportado de forma igual a \texttt{script\_plugin\_run\_}\emph{{[}linguagem{]}}.
Caso a função solicitada não tenha sido definida na máquina virtual,
\texttt{script\_plugin\_call\_}\emph{\-{[}linguagem{]}} deve retornar
a constante \texttt{SCRIPT\_ERRFNUNDEF}. Parâmetros de entrada e valores
de retorno são passados através do buffer de parâmetros, usando as
mesmas funções \texttt{script\_get\_{*}} e \texttt{script\_put\_{*}}
da biblioteca principal que são usadas para a passagem de dados entre
a aplicação e a biblioteca principal.

A implementação da função \texttt{script\_call} na biblioteca principal
faz uso deste comportamento dos plugins para invocar funções de modo
independente de linguagem. Inicialmente, ela tenta encontrar uma função
solicitada na lista de funções C registradas. Caso não haja uma função
C no ambiente virtual com este nome, \texttt{script\_call} tenta localizar
a função nos plugins carregados, chamando a função com \texttt{script\_plugin\_call\_}\emph{{[}linguagem{]}}
em cada plugin, e tentando o próximo a cada vez que recebe \texttt{SCRIPT\_ERRFNUNDEF}.

Finalmente, a função \texttt{script\_plugin\_done\_}\emph{{[}linguagem{]}}
é chamada por \texttt{script\_done} quando um ambiente virtual é encerrado.
Dependendo da representação interna usada no plugin, a finalização
de um estado pode ou não implicar na finalização da máquina virtual.
Preferencialmente, esta função deve remover a estrutura que descreve
o ambiente virtual, mas, como veremos na Seção~\ref{sub:Encerramento-de-estados},
isto nem sempre é possível.


\section{Implementação dos plugins\label{sec:Implementa=E7=E3o-dos-plugins}}

Nesta seção discutiremos os principais aspectos envolvidos na implementação
dos plugins desenvolvidos neste estudo de caso. Implementamos plugins
para as linguagens Python, Ruby, Lua e Perl. Apresentaremos aqui como
é feita a representação dos estados virtuais em cada plugin (Seção~\ref{sub:Representa=E7=E3o-de-estados}),
questões envolvendo o encerramento de estados (Seção~\ref{sub:Encerramento-de-estados}),
passagem de parâmetros entre a biblioteca principal e os plugins (Seção~\ref{sub:Passagem-de-par=E2metros}),
como a chamada de funções a partir de scripts é tratada pelos plugins
(Seção~\ref{sub:Resolu=E7=E3o-de-fun=E7=F5es}) e a captura de erros
(Seção~\ref{sub:Captura-de-erros}).


\subsection{Representação de estados\label{sub:Representa=E7=E3o-de-estados}}

O design de LibScript permite que plugins mantenham múltiplos estados
de execução independentes. Idealmente estes estados seriam totalmente
isolados entre si, como por exemplo diferentes instâncias da máquina
virtual, oferecendo maior segurança ao ambiente de execução dos scripts.
Todavia, as linguagens oferecem diferentes graus de isolamento possível
entre estados independentes. Lua e Perl permitem múltiplas instâncias
isoladas do ambiente de execução de forma simples, uma vez que as
chamadas à API incluem um identificador de estado%
\footnote{O recurso de múltiplos estados independentes é opcional em Perl, selecionado
durante a compilação da biblioteca do interpretador.%
}. Já linguagens que mantêm estado de forma estática, como Python e
Ruby, não permitem trabalhar com múltiplos estados isolados facilmente%
\footnote{O modelo de threads de Python oferece uma forma de alternar entre
estados na máquina virtual obtendo objetos \texttt{PyThreadState}
através da chamada \texttt{Py\_NewInterpreter}, mas isto pode causar
problemas quando módulos de extensão escritos em C utilizam variáveis
globais estáticas ou quando módulos manipulam o seu próprio dicionário,
que é compartilhado entre estados. A documentação diz, desde 1999,
que {}``\emph{This is a hard-to-fix bug that will be addressed in
a future release.}''~\cite{vanrossum99api,vanrossum06api}%
}. Nas linguagens que não permitem múltiplas instâncias da máquina
virtual, podemos definir apenas espaços de nomes separados para os
ambientes virtuais LibScript, que compartilham um único estado global
de execução dentro do plugin. À representação de um estado de execução
relativo a um ambiente virtual LibScript dentro de um plugin damos
o nome de \emph{estado virtual}, que pode ou não corresponder a um
estado de execução isolado.

Como comentado na seção anterior, a função \texttt{script\_plugin\_init\_}\emph{lin\-gua\-gem}
retorna à biblioteca principal um \texttt{script\_plugin\_state},
que é a representação opaca do seu estado virtual. O conteúdo desta
representação varia de linguagem para linguagem, mas o princípio básico
é que dois dados devem estar disponíveis a partir deste valor: uma
referência para o ambiente virtual LibScript, recebido como parâmetro
para \texttt{script\_plugin\_init\_}\emph{lin\-gua\-gem}, para que
o plugin possa fazer chamadas à biblioteca principal, e um identificador
que permita ao plugin acessar a estrutura de dados que representa
na linguagem o espaço de nome de funções acessíveis via LibScript.
No plugin Lua, esta estrutura é uma tabela; em Python, um módulo;
em Ruby, uma classe; e em Perl, um pacote.

Em LibScript-Lua, estados são implementados como \texttt{lua\_State}s
(Seção~\ref{sub:Lua-Registro}). Desta forma, scripts executados
em um ambiente são plenamente isolados dos demais ambientes. Por exemplo,
a alteração do valor de uma variável global em um ambiente não afeta
os demais. De fato, o \texttt{script\_plugin\_state} retornado pelo
plugin Lua é simplesmente o \texttt{lua\_State} convertido via cast.
O ponteiro para o ambiente LibScript é armazenado em Lua no registro,
da seguinte forma:

\begin{lyxcode}
\emph{\footnotesize /{*}~Empilha~o~índice~{*}/}{\footnotesize \par}

{\footnotesize lua\_pushstring(L,~\char`\"{}LibScript.env\char`\"{});}{\footnotesize \par}

\emph{\footnotesize /{*}~Empilha~o~ambiente~LibScript~{*}/}{\footnotesize \par}

{\footnotesize lua\_pushlightuserdata(L,~env);}{\footnotesize \par}

\emph{\footnotesize /{*}~registro{[}\char`\"{}LibScript.env\char`\"{}{]}~=~env~{*}/}{\footnotesize \par}

{\footnotesize lua\_settable(L,~LUA\_REGISTRYINDEX);}{\footnotesize \par}
\end{lyxcode}


O plugin cria neste \texttt{lua\_State} uma tabela que representará
o ambiente virtual para scripts Lua. Esta tabela é armazenada no \texttt{lua\_State}
como uma variável global com o nome do ambiente virtual.

Em LibScript-Perl os estados são isolados como em Lua. Cada estado
criado inicializa uma nova instância de \texttt{PerlInterpreter}.
Neste interpretador, é criado um pacote que será a representação do
ambiente visível a partir de código Perl. O tipo \texttt{script\_plugin\_state},
então, é um \emph{typedef} para \texttt{PerlInterpreter}{*}.

Como discutido na Seção~\ref{sub:Perl-registro}, a implementação
de funções C exportadas para um interpretador Perl é feita escrevendo
um módulo de extensão usando o pré-processador XS, e a forma de obter
comunicação no sentido Perl$\rightarrow$C em uma máquina virtual
embutida é ligando um módulo de extensão juntamente com a máquina
virtual. Assim, parte do plugin LibScript-Perl é implementado como
um módulo XS, exposto na máquina virtual embutida como o pacote Perl
\texttt{LibScript}. Durante a inicialização de um estado virtual,
o ponteiro para o ambiente virtual LibScript é armazenado neste pacote,
na variável \texttt{\$LibScript::env}. O pacote que representa o ambiente
virtual é criado pela função \texttt{script\_plugin\_init\_perl},
executando a string de código \texttt{\char`\"{}package} \emph{{[}ambiente{]}}\texttt{;\char`\"{}}
com a função \texttt{Perl\_eval\_pv}.

Como Python não dispõe de facilidades para disparar múltiplas máquinas
virtuais plenamente isoladas, o plugin Python implementa estados virtuais
apenas como módulos separados, compartilhando um mesmo estado global.
Durante a inicialização de um estado, é criado um módulo Python com
o nome do ambiente. O seguinte trecho da função \texttt{script\_plugin\_init\_python}
exibe a seqüência onde o módulo é criado e importado:

\begin{lyxcode}
\emph{\footnotesize /{*}~Obtém~o~nome~do~ambiente~{*}/}{\footnotesize \par}

{\footnotesize char{*}~namespace~=~script\_namespace(env);}{\footnotesize \par}

\emph{\footnotesize /{*}~Cria~o~módulo.~O~primeiro~parâmetro~é~o~nome~do~módulo,~o~segundo}{\footnotesize \par}

~\emph{\footnotesize ~~a~lista~de~métodos~do~módulo,~que~será~inicialmente~vazio.~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~module~=~Py\_InitModule3(namespace,~NULL);}{\footnotesize \par}

\emph{\footnotesize /{*}~Obtém~dicionário~de~globais~{*}/}{\footnotesize \par}

{\footnotesize PyObject{*}~globals~=~PyModule\_GetDict(PyImport\_AddModule(\char`\"{}\_\_builtin\_\_\char`\"{}));}{\footnotesize \par}

\emph{\footnotesize /{*}~Atribui~o~módulo~à~variável~global~com~o~seu~nome.~{*}/}{\footnotesize \par}

{\footnotesize PyDict\_SetItemString(globals,~namespace,~module);}{\footnotesize \par}
\end{lyxcode}


O tipo \texttt{script\_plugin\_state} é um \emph{typedef} para \texttt{PyObject{*}}.
O objeto retornado pela função de inicialização é o dicionário de
elementos do módulo, obtido com \texttt{PyModule\_GetDict\-(module)}.
Neste dicionário, armazenamos o ponteiro do ambiente virtual como
o atributo privado \texttt{\_\_env}.

De forma similar, em Ruby estados virtuais são implementados como
classes que compartilham um mesmo estado global, já que Ruby também
não permite múltiplos ambientes de execução isolados. Na função de
inicialização \texttt{script\_plugin\_init\_ruby}, uma classe com
o nome do ambiente virtual é criada usando a função \texttt{rb\_define\_class}.
O ponteiro do ambiente virtual é armazenado em uma constante da classe
como um número. O \texttt{VALUE} referente à classe é retornado como
o \texttt{script\_plugin\_state}.

\begin{lyxcode}
{\footnotesize VALUE~state;}{\footnotesize \par}

\emph{\footnotesize /{*}~...~(inicialização~do~interpretador~omitida)~...~{*}/}{\footnotesize \par}

\emph{\footnotesize /{*}~class\_name~é~o~nome~do~ambiente~virtual,}{\footnotesize \par}

~\emph{\footnotesize ~~com~a~inicial~convertida~para~maiúsculas,}{\footnotesize \par}

~\emph{\footnotesize ~~respeitando~a~convenção~de~nomes~de~classe~Ruby~{*}/}{\footnotesize \par}

{\footnotesize state~=~rb\_define\_class(class\_name,~rb\_cObject);}{\footnotesize \par}

\emph{\footnotesize /{*}~Isto~assume~que~void{*}~cabe~em~um~long~{*}/}{\footnotesize \par}

{\footnotesize rb\_const\_set(state,~rb\_intern(\char`\"{}@@LibScriptEnv\char`\"{}),~INT2NUM((long)env));~~~~}{\footnotesize \par}

\emph{\footnotesize /{*}~...~{*}/}{\footnotesize \par}

{\footnotesize return~(script\_plugin\_state)~state;}{\footnotesize \par}
\end{lyxcode}

\subsection{Encerramento de estados\label{sub:Encerramento-de-estados}}

Como Lua e Perl representam estados de forma independente, o encerramento
de um estado nestes plugins é simples: a estrutura da linguagem que
encapsula o ambiente completo de execução é encerrada. A implementação
da função de finalização no plugin Lua é a seguinte:

\begin{lyxcode}
{\footnotesize void~script\_plugin\_done\_lua(script\_plugin\_state~state)~\{}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~Em~Lua,~um~state~é~um~lua\_State~{*}/}{\footnotesize \par}

~{\footnotesize ~~lua\_State{*}~L~=~(lua\_State{*})~state;}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~Encerra~o~estado.~Não~afeta~outros~ambientes.~{*}/}{\footnotesize \par}

~{\footnotesize ~~lua\_close(L);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Em Perl, o processo, embora um tanto mais elaborado, é essencialmente
similar:

\begin{lyxcode}
{\footnotesize void~script\_plugin\_done\_perl(script\_perl\_state{*}~state)~\{}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~Algumas~macros~assumem~que~o~ponteiro~do~interpretador}{\footnotesize \par}

~\emph{\footnotesize ~~~~~se~chama~my\_perl.~{*}/}{\footnotesize \par}

~{\footnotesize ~~PerlInterpreter{*}~my\_perl~=~(PerlInterpreter{*})~state;}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~Algumas~operações~atuam~sobre~o~{}``estado~atual'',}{\footnotesize \par}

~\emph{\footnotesize ~~~~~então~a~macro~PERL\_SET\_CONTEXT~deve~ser~usada~para}{\footnotesize \par}

~\emph{\footnotesize ~~~~~alternar~o~interpretador~ativo~{*}/}{\footnotesize \par}

~{\footnotesize ~~PERL\_SET\_CONTEXT(my\_perl);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Esta~flag~deve~ser~ativada~para~que~a~limpeza~do}{\footnotesize \par}

~\emph{\footnotesize ~~~~~ambiente~seja~completa,~o~que~é~necessário~quando}{\footnotesize \par}

~\emph{\footnotesize ~~~~~pode~haver~mais~de~um~interpretador~ativo~{*}/}{\footnotesize \par}

~{\footnotesize ~~PL\_perl\_destruct\_level~=~1;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Encerramento~do~interpretador~{*}/}{\footnotesize \par}

~{\footnotesize ~~perl\_destruct(my\_perl);}{\footnotesize \par}

~{\footnotesize ~~perl\_free(my\_perl);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Em Python e Ruby, o plugin precisa manter o controle do número de
estados ativos para desalocar a máquina virtual somente quando este
chegar a zero. Além disso, tanto em Ruby como em Python não há recursos
nas APIs (ou nas linguagens, de fato) para remover, respectivamente,
classes ou módulos. Em Ruby, poderíamos atribuir \texttt{nil} à constante
que representa a classe que descreve o ambiente virtual, mas depois
disso não é possível definir uma nova classe em seu lugar: tanto \texttt{rb\_define\_class}
via C como \texttt{class} \emph{{[}Nome{]}} via Ruby geram um erro
indicando que o valor já foi definido com outro tipo. Como Ruby possui
classes abertas, uma construção \texttt{class} \emph{{[}Nome{]}} para
um \emph{{[}Nome{]}} já existente é entendida como a continuação da
descrição da classe, e não como a redefinição de \emph{{[}Nome{]}}.
Python, por sua vez, não disponibiliza recursos na API para a descarga
de módulos, mas permite atribuir \texttt{None} à global referente
ao módulo. O módulo pode ser importado novamente, mas a mesma instância
dele, armazenada internamente por Python, será retornada. A seguinte
sessão interativa de linha de comando permite observar este comportamento,
que ocorre tanto diretamente em Python como via a API de C:

\begin{lyxcode}
{\footnotesize >\,{}>\,{}>~import~sys}{\footnotesize \par}

{\footnotesize >\,{}>\,{}>~sys.foo~=~\char`\"{}hello\char`\"{}}{\footnotesize \par}

{\footnotesize >\,{}>\,{}>~sys.foo}{\footnotesize \par}

{\footnotesize 'hello'}{\footnotesize \par}

{\footnotesize >\,{}>\,{}>~sys~=~None}{\footnotesize \par}

{\footnotesize >\,{}>\,{}>~import~sys}{\footnotesize \par}

{\footnotesize >\,{}>\,{}>~sys.foo}{\footnotesize \par}

{\footnotesize 'hello'~}{\footnotesize \par}
\end{lyxcode}


Assim, as estruturas de dados referentes aos estados LibScript não
são encerrados nos plugins Python e Ruby. Esta é a implementação da
rotina de encerramento no plugin Ruby:

\begin{lyxcode}
{\footnotesize void~script\_plugin\_done\_ruby(script\_ruby\_state~state)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Decrementa~o~contador~de~estados,}{\footnotesize \par}

~\emph{\footnotesize ~~~~~uma~variável~global}~{\footnotesize static}~\emph{\footnotesize do~plugin.~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_ruby\_state\_count-{}-;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Finaliza~o~interpretador~se~este~for~o~último~estado.~{*}/}{\footnotesize \par}

~{\footnotesize ~~if~(script\_ruby\_state\_count~==~0)}{\footnotesize \par}

~{\footnotesize ~~~~~ruby\_finalize();}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
A implementação no plugin Python é basicamente igual:

\begin{lyxcode}
{\footnotesize void~script\_plugin\_done\_python(script\_python\_state~state)~\{}{\footnotesize \par}

~{\footnotesize ~~script\_python\_state\_count-{}-;}{\footnotesize \par}

~{\footnotesize ~~if~(script\_python\_state\_count~==~0)}{\footnotesize \par}

~{\footnotesize ~~~~~Py\_Finalize();}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}

\subsection{Passagem de parâmetros\label{sub:Passagem-de-par=E2metros}}

A transferência de dados entre a biblioteca principal e os plugins
é concentrada em duas operações: uma para passar o conteúdo do buffer
de parâmetros de LibScript para o espaço de dados da máquina virtual
e outra para realizar a operação inversa. A primeira é usada na passagem
de parâmetros de entrada quando funções da linguagem de script são
chamadas por C e para a obtenção dos valores de retorno quando a linguagem
de script faz chamadas que são tratadas por C. A segunda operação,
de forma complementar, é usada para os valores de retorno quando C
chama a linguagem de script e para os parâmetros de entrada quando
uma chamada feita pela linguagem de script é tratada por código C.

Na implementação do plugin LibScript-Lua, a função \texttt{script\_\-lua\_\-stack\_\-to\_\-buffer}
converte o conteúdo da pilha de Lua para o buffer de parâmetros de
LibScript. A função do plugin responsável por invocar funções Lua
a partir de C, \texttt{script\_\-plugin\_\-call\_\-lua}, usa a
função \texttt{script\_\-lua\_\-stack\_\-to\_\-buffer} para armazenar
no buffer LibScript os valores de retorno da função Lua invocada,
já que estes são retornados na pilha virtual. Quando o código Lua
chama funções implementadas em C ou em outro plugin, \texttt{script\_\-lua\_\-stack\_\-to\_\-buffer}
é usada para converter os parâmetros de entrada da função, também
recebidos na pilha virtual. A seguir, vemos a implementação desta
função:

\begin{lyxcode}
{\footnotesize static~void~script\_lua\_stack\_to\_buffer(script\_env{*}~env,~lua\_State~{*}L)~\{}{\footnotesize \par}

~{\footnotesize ~~int~nargs;~int~i;~}{\footnotesize \par}

~{\footnotesize ~}~\emph{\footnotesize /{*}~Número~de~elementos~na~pilha~de~Lua~{*}/}{\footnotesize \par}

~{\footnotesize ~~nargs~=~lua\_gettop(L);}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}~\emph{\footnotesize /{*}~Esvazia~o~buffer~LibScript~{*}/}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~1;~i~<=~nargs;~i++)~\{}{\footnotesize \par}

~{\footnotesize ~~~~}~\emph{\footnotesize /{*}~Verifica~o~tipo~Lua~do~elemento~na~posição~i~da~pilha}{\footnotesize \par}

~\emph{\footnotesize ~~~~~e~para~cada~tipo,~converte~o~elemento~e~o~armazena~no~buffer~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~switch(lua\_type(L,~i))~\{~}{\footnotesize \par}

~{\footnotesize ~~~~~case~LUA\_TNUMBER:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_double(env,~i-1,~lua\_tonumber(L,~i));~break;~}{\footnotesize \par}

~{\footnotesize ~~~~~case~LUA\_TSTRING:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_string(env,~i-1,~lua\_tostring(L,~i));~break;}{\footnotesize \par}

~{\footnotesize ~~~~~case~LUA\_TBOOLEAN:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_bool(env,~i-1,~lua\_toboolean(L,~i));~break;}{\footnotesize \par}

~{\footnotesize ~~~~~default:}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~/{*}~Tipos~não~tratados~são~substituídos~por~zero.~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_double(env,~i-1,~0);}{\footnotesize \par}

~{\footnotesize ~~~~~\}}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Assumimos em LibScript strings no formato de C: a função \texttt{script\_put\_string}
copia a string passada até o primeiro \texttt{'\textbackslash{}0'}.
Assim, ao obter strings de linguagens que permitem conteúdo arbitrário,
estas serão truncadas caso contenham \texttt{'\textbackslash{}0'}.
Por isso, no plugin Lua usamos diretamente a função \texttt{lua\_tostring},
e não a função mais geral \texttt{lua\_tolstring} (que retorna também
o tamanho do buffer). Esta decisão de projeto coincide com o objetivo
explicado anteriormente de restringirmos a API da biblioteca principal
a recursos disponíveis em todas as linguagens.

Os valores de tipos desconhecidos são substituídos pelo valor zero,
o que mantém a posição dos demais valores na lista de argumentos.
Optamos por não sinalizar erro nesta situação para evitar aqui a geração
de exceções, o que complicaria a exposição. A captura e propagação
de erros serão vistas na Seção~\ref{sub:Captura-de-erros}.

A segunda função de transferência de dados de LibScript-Lua, \texttt{script\_lua\_buffer\_to\_stack},
obtém os valores do buffer LibScript e os insere na pilha virtual
de Lua. Esta função é usada para passar os parâmetros de entrada para
Lua em \texttt{script\_plugin\_call\_lua} e para passar para Lua os
valores obtidos pelo retorno da função \texttt{script\_call}, que
é invocada internamente pelo plugin quando Lua invoca uma função C.

\begin{lyxcode}
{\footnotesize static~int~script\_lua\_buffer\_to\_stack(script\_env{*}~env,~lua\_State~{*}L)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;~char{*}~s;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Número~de~elementos~no~buffer~{*}/}{\footnotesize \par}

~{\footnotesize ~~int~len~=~script\_buffer\_len(env);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Verifica~o~tipo~do~elemento~na~posição~i~do~buffer~{*}/}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~e~para~cada~tipo,~o~obtém~e~o~insere~na~pilha~de~Lua~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~type~=~script\_get\_type(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~switch~(type)~\{}{\footnotesize \par}

~{\footnotesize ~~~~~case~SCRIPT\_DOUBLE:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~lua\_pushnumber(L,~script\_get\_double(env,~i));~break;}{\footnotesize \par}

~{\footnotesize ~~~~~case~SCRIPT\_STRING:}{\footnotesize \par}

~{\footnotesize ~~~~~~~}~\emph{\footnotesize /{*}~A~string~pertence~ao~chamador.~{*}/}~

~{\footnotesize ~~~~~~~~s~=~script\_get\_string(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~~~~lua\_pushstring(L,~s);}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~/{*}~Libera~a~string,}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~~~~já~que~Lua~armazena~sua~própria~cópia.~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~~~~free(s);}{\footnotesize \par}

~{\footnotesize ~~~~~~~~break;}{\footnotesize \par}

~{\footnotesize ~~~~~case~SCRIPT\_BOOL:}{\footnotesize \par}

~{\footnotesize ~~~~~~~~lua\_pushboolean(L,~script\_get\_bool(env,~i));~break;}{\footnotesize \par}

~{\footnotesize ~~~~~\}}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~return~len;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Em LibScript-Python, não foi possível concentrar as operações de transferência
de dados em apenas duas funções. Cada operação teve que ser dividida
em duas partes. A conversão de dados enviados de Python para o buffer
de LibScript foi divida nas funções \texttt{script\_python\_put\_object}
e \texttt{script\_python\_tuple\_to\_buffer}. A primeira função converte
um único valor Python e o insere na posição solicitada no buffer:

\begin{lyxcode}
{\footnotesize static~void~script\_python\_put\_object(script\_env{*}~env,~int~i,~PyObject{*}~o)~\{}{\footnotesize \par}

~{\footnotesize ~~if~(PyString\_Check(o))}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_string(env,~i,~PyString\_AS\_STRING(o));}{\footnotesize \par}

~{\footnotesize ~~else~if~(PyInt\_Check(o))}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_int(env,~i,~PyInt\_AS\_LONG(o));}{\footnotesize \par}

~{\footnotesize ~~else~if~(PyLong\_Check(o))}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_double(env,~i,~PyLong\_AsDouble(o));}{\footnotesize \par}

~{\footnotesize ~~else~if~(PyFloat\_Check(o))}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_double(env,~i,~PyFloat\_AS\_DOUBLE(o));}{\footnotesize \par}

~{\footnotesize ~~else~if~(PyBool\_Check(o))}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_bool(env,~i,~o~==~Py\_True~?~1~:~0);}{\footnotesize \par}

~{\footnotesize ~~else}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_int(env,~i,~0);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


É importante notar que os tipos Python \texttt{PyInt} e \texttt{PyLong}
não correspondem aos tipos C \texttt{int} e \texttt{long}: \texttt{PyInt}
é o tipo inteiro correspondente ao tamanho da palavra da máquina (análogo
a \texttt{int}), mas \texttt{PyLong} é um inteiro de precisão arbitrária.
Em LibScript, representamos \texttt{PyLong}s como \texttt{double}s.
A API de LibScript oferece a função \texttt{script\_put\_int} como
conveniência, mas internamente, como ocorre por exemplo em Lua, todos
os números são armazenados como \texttt{double}s.

A segunda função, \texttt{script\_python\_tuple\_to\_buffer}, insere
os elementos de uma tupla no buffer:

\begin{lyxcode}
{\footnotesize static~void~script\_python\_tuple\_to\_buffer(script\_env{*}~env,~PyObject{*}~tuple)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Número~de~elementos~da~tupla~{*}/}{\footnotesize \par}

~{\footnotesize ~~int~len~=~PyTuple\_GET\_SIZE(tuple);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Esvazia~o~buffer~LibScript~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Obtém~elemento~da~tupla~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~PyObject{*}~o~=~PyTuple\_GET\_ITEM(tuple,~i);}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Insere-o~no~buffer.~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~script\_python\_put\_object(env,~i,~o);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


A operação inversa, de transferência de dados do buffer LibScript
para Python, também é implementada em duas funções, uma tratando objetos
individualmente e outra tratando tuplas. A função \texttt{script\_get\_object}
converte um elemento do buffer para um \texttt{PyObject} equivalente:

\begin{lyxcode}
{\footnotesize static~PyObject{*}~script\_python\_get\_object(script\_env{*}~env,~int~i)~\{}{\footnotesize \par}

~{\footnotesize ~~PyObject{*}~ret;~char{*}~s;}{\footnotesize \par}

~{\footnotesize ~~switch~(script\_get\_type(env,~i))~\{}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_DOUBLE:}{\footnotesize \par}

~{\footnotesize ~~~~~return~PyFloat\_FromDouble(script\_get\_double(env,~i));}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_STRING:}{\footnotesize \par}

~{\footnotesize ~~~~~s~=~script\_get\_string(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~PyObject{*}~ret~=~PyString\_FromString(s);}{\footnotesize \par}

~{\footnotesize ~~~~~free(s);}{\footnotesize \par}

~{\footnotesize ~~~~~return~ret;}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_BOOL:}{\footnotesize \par}

~{\footnotesize ~~~~~return~PyBool\_FromLong(script\_get\_bool(env,~i));}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


A função \texttt{script\_python\_buffer\_to\_tuple} gera uma tupla
contendo todos os elementos do buffer LibScript:

\begin{lyxcode}
{\footnotesize static~PyObject{*}~script\_python\_buffer\_to\_tuple(script\_env{*}~env)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~{\footnotesize ~~int~len~=~script\_buffer\_len(env);}{\footnotesize \par}

~{\footnotesize ~~PyObject{*}~ret~=~PyTuple\_New(len);}{\footnotesize \par}

~{\footnotesize ~~for(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~{\footnotesize ~~~~~PyObject{*}~o~=~script\_python\_get\_object(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~PyTuple\_SetItem(ret,~i,~o);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~return~ret;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Assim, estes dois pares de funções realizam funções equivalentes às
que \texttt{script\_lua\_\-stack\_to\_buffer} e \texttt{script\_lua\_buffer\_to\_stack}
exercem no plugin Lua. Elas foram separadas em duas partes em função
do modelo de retorno de valores em funções Python: no caso de múltiplos
valores de retorno, eles são retornados como uma tupla; para valores
simples, eles são passados diretamente. Isto é evidenciado no seguinte
trecho da função \texttt{script\_plugin\_call\_python}:

\begin{lyxcode}
{\footnotesize PyObject~{*}ret,~{*}args;}{\footnotesize \par}

\emph{\footnotesize /{*}~...~{*}/}{\footnotesize \par}

\emph{\footnotesize /{*}~Obtém~o~parâmetros~de~entrada~{*}/}{\footnotesize \par}

{\footnotesize args~=~script\_python\_buffer\_to\_tuple(env);}{\footnotesize \par}

\emph{\footnotesize /{*}~Chama~uma~função~Python~{*}/}{\footnotesize \par}

{\footnotesize ret~=~PyEval\_CallObject(func,~args);}{\footnotesize \par}

\emph{\footnotesize /{*}~...~{*}/}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~a~função~não~retornou~valor~{*}/}{\footnotesize \par}

{\footnotesize if~(ret~==~Py\_None)}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Apenas~zere~o~buffer~LibScript~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~retornou~uma~tupla~{*}/}{\footnotesize \par}

{\footnotesize else~if~(PyTuple\_Check(ret))}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Insira~seus~elementos~no~buffer~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_python\_tuple\_to\_buffer(env,~ret);}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~retornou~outro~tipo~de~objeto~{*}/}{\footnotesize \par}

{\footnotesize else}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Insira-o~como~único~elemento~{*}/}{\footnotesize \par}

~{\footnotesize ~~script\_python\_put\_object(env,~0,~ret);}{\footnotesize \par}
\end{lyxcode}


No tratador de chamadas a funções externas do plugin, a comunicação
no sentido inverso emprega uma lógica similar:

\begin{lyxcode}
\emph{\footnotesize /{*}~Obtém~o~parâmetros~de~entrada~{*}/}{\footnotesize \par}

{\footnotesize script\_python\_tuple\_to\_buffer(env,~args);}{\footnotesize \par}

\emph{\footnotesize /{*}~Chama~um~função~via~LibScript~{*}/}{\footnotesize \par}

{\footnotesize err~=~script\_call(env,~fn\_name);}{\footnotesize \par}

{\footnotesize /{*}~...~{*}/}{\footnotesize \par}

{\footnotesize switch(script\_buffer\_len(env))~\{}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~a~função~não~retornou~valor~{*}/}{\footnotesize \par}

{\footnotesize case~0:}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorne~o~valor~Python~'None'~{*}/}{\footnotesize \par}

~{\footnotesize ~~Py\_RETURN\_NONE;}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~retornou~um~único~valor~{*}/}{\footnotesize \par}

{\footnotesize case~1:}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Converta~e~retorne-o~{*}/}{\footnotesize \par}

~{\footnotesize ~~return~script\_python\_get\_object(env,~0);}{\footnotesize \par}

\emph{\footnotesize /{*}~Se~retornou~mais~de~um~valor~{*}/}{\footnotesize \par}

{\footnotesize default:}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorne-os~em~uma~tupla~{*}/}{\footnotesize \par}

~{\footnotesize ~~return~script\_python\_buffer\_to\_tuple(env);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Assim como em Python, funções em Ruby retornam múltiplos valores encapsulando-os
em um tipo agregado. Desta forma, as operações de transferências de
dados de LibScript-Ruby também são divididas em pares de funções,
uma convertendo um valor do buffer, e outra operando sobre um array
Ruby. A função análoga a \texttt{script\_python\_put\_object} é \texttt{script\_ruby\_put\_value}:

\begin{lyxcode}
{\footnotesize static~void~script\_ruby\_put\_value(script\_env{*}~env,~int~i,~VALUE~arg)~\{}{\footnotesize \par}

~{\footnotesize ~~switch~(TYPE(arg))~\{}{\footnotesize \par}

~{\footnotesize ~~case~T\_FLOAT:}{\footnotesize \par}

~{\footnotesize ~~case~T\_FIXNUM:}{\footnotesize \par}

~{\footnotesize ~~case~T\_BIGNUM:}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_double(env,~i,~NUM2DBL(arg));~break;}{\footnotesize \par}

~{\footnotesize ~~case~T\_STRING:}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_string(env,~i,~StringValuePtr(arg));~break;}{\footnotesize \par}

~{\footnotesize ~~case~T\_TRUE:}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_bool(env,~i,~1);~break;}{\footnotesize \par}

~{\footnotesize ~~case~T\_FALSE:}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_bool(env,~i,~0);~break;}{\footnotesize \par}

~{\footnotesize ~~default:}{\footnotesize \par}

~{\footnotesize ~~~~~script\_put\_int(env,~i,~0);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Aqui, alguns problemas da API de Ruby são aparentes. Além da inconsistência
na nomenclatura das funções de conversão de objetos, o significado
do valor retornado pela macro \texttt{TYPE} só pode ser compreendido
através da representação interna de \texttt{VALUE}s na implementação
de Ruby, e não através da hierarquia de tipos dos objetos da linguagem.
As classes que têm tratamento especial na estrutura interna de \texttt{VALUE}s
possuem constantes associadas a si, como \texttt{T\_FLOAT} e \texttt{T\_STRING};
as demais são identificados apenas como \texttt{T\_OBJECT}s. O uso
de \texttt{T\_TRUE} e \texttt{T\_FALSE} pode dar a entender que alguns
valores específicos também retornam resultados especiais para \texttt{TYPE}.
De fato, estes valores são definidos como \texttt{VALUE}s que não
correspondem a índices da heap de objetos de Ruby e são tratados de
forma especial na implementação. Do ponto de vista de código Ruby,
entretanto, esta classificação dos valores \texttt{true} e \texttt{false}
em tipos separados na API C é justificada definindo-os como \emph{singletons}
das classes \texttt{TrueClass} e \texttt{FalseClass}, abordagem provavelmente
influenciada por Smalltalk. Porém, diferentemente de Smalltalk, onde
\texttt{True} e \texttt{False} são subclasses de \texttt{Boolean},
em Ruby \texttt{TrueClass} e \texttt{FalseClass} são subclasses diretas
de \texttt{Object}. Isto traz a inconveniência de que verificar se
um tipo é um valor booleano incorre sempre em dois testes.

Assim como LibScript-Python tem uma função para armazenar no buffer
os elementos de uma tupla, LibScript-Ruby possui uma função para armazenar
os elementos de um array:

\begin{lyxcode}
{\footnotesize static~void~script\_ruby\_array\_to\_buffer(script\_env{*}~env,~VALUE~array)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~{\footnotesize ~~int~len~=~RARRAY(array)->len;}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~{\footnotesize ~~~~~VALUE~o~=~rb\_ary\_entry(array,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~script\_ruby\_put\_value(env,~i,~o);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
Ruby não possui uma função na API C para retornar o tamanho de um
array; ao invés disso, a estrutura interna do \texttt{VALUE} é exposta
através da macro \texttt{RARRAY} (que apenas encapsula um cast). 

As operações para conversão de valores do buffer LibScript para Ruby
também são similares às implementadas no plugin Python. Novamente,
onde em Python há uma função para manipulação de tuplas, temos em
Ruby uma função que opera sobre arrays:

\begin{lyxcode}
{\footnotesize static~VALUE~script\_ruby\_get\_value(script\_env{*}~env,~int~i)~\{}{\footnotesize \par}

~{\footnotesize ~~VALUE~ret;~char{*}~s;}{\footnotesize \par}

~{\footnotesize ~~switch~(script\_get\_type(env,~i))~\{}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_DOUBLE:}{\footnotesize \par}

~{\footnotesize ~~~~~return~rb\_float\_new(script\_get\_double(env,~i));}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_STRING:}{\footnotesize \par}

~{\footnotesize ~~~~~s~=~script\_get\_string(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~ret~=~rb\_str\_new2(s);}{\footnotesize \par}

~{\footnotesize ~~~~~free(s);}{\footnotesize \par}

~{\footnotesize ~~~~~return~ret;}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_BOOL:}{\footnotesize \par}

~{\footnotesize ~~~~~return~script\_get\_bool(env,~i)~?~Qtrue~:~Qfalse;}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}

~{\footnotesize }~\\
{\footnotesize static~VALUE~script\_ruby\_buffer\_to\_array(script\_env{*}~env)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~{\footnotesize ~~int~len~=~script\_buffer\_len(env);}{\footnotesize \par}

~{\footnotesize ~~VALUE~ret~=~rb\_ary\_new2(len);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~{\footnotesize ~~~~~VALUE~o~=~script\_ruby\_get\_value(env,~i);}{\footnotesize \par}

~{\footnotesize ~~~~~rb\_ary\_store(ret,~i,~o);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~return~ret;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


De forma similar ao plugin Python, a implementação da chamada de funções
Ruby a partir de LibScript usa a função \texttt{script\_ruby\_buffer\_to\_array}
para converter os parâmetros de entrada e as funções \texttt{script\_ruby\_put\_value}
ou \texttt{script\_ruby\_array\_to\_buffer} para converter o valor
de retorno, dependendo se a função retornou um ou mais valores (ou
mais precisamente, se a função retornou ou não um array). Em chamadas
de funções LibScript a partir de Ruby, os parâmetros de entrada são
convertidos com \texttt{script\_ruby\_array\_to\_buffer} e os valores
de retorno com \texttt{script\_ruby\_get\_value} ou \texttt{script\_ruby\_buffer\_to\_array}.

No plugin Perl, temos três funções: a transferência de dados da pilha
para o buffer LibScript pôde ser implementada em uma única função
como em Lua, mas a transferência no sentido oposto teve que ser dividida
em duas funções, como em Python e Ruby. Esta assimetria vem do fato
de que o tratamento de valores de retorno é encapsulado pelo pré-processador
XS através da variável especial \texttt{RETVAL}; assim, nesta situação
não podemos manipular a pilha diretamente, mas apenas passar \texttt{SV}s
como valores de saída. 

A transferência de dados da pilha de Perl para o buffer LibScript
é razoavelmente simples:

\begin{lyxcode}
{\footnotesize void~script\_perl\_stack\_to\_buffer(pTHX\_~int~ax,~script\_env{*}~env,}{\footnotesize \par}

~{\footnotesize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~int~count,~int~offset)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~count;~i++)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Obtém~um~ponteiro~para~o~SV~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~SV{*}~o~=~ST(offset+i);}{\footnotesize \par}

~{\footnotesize ~~~~~if~(SvIOK(o))}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_int(env,~i,~SvIV(o));}{\footnotesize \par}

~{\footnotesize ~~~~~else~if~(SvNOK(o))}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_double(env,~i,~SvNV(o));}{\footnotesize \par}

~{\footnotesize ~~~~~else~if~(SvPOK(o))}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_string(env,~i,~SvPV\_nolen(o));}{\footnotesize \par}

~{\footnotesize ~~~~~else}{\footnotesize \par}

~{\footnotesize ~~~~~~~~script\_put\_int(env,~i,~0);}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Os parâmetros de entrada desta função merecem comentário. Inicialmente,
temos a macro \texttt{pTHX\_}. Esta macro foi adicionada à API quando
Perl passou a permitir múltiplos interpretadores simultâneos por processo:
as funções da API foram transformadas em macros que encapsulam a passagem
deste primeiro parâmetro. Por exemplo, a função \texttt{eval\_sv}
pode ser chamada como \texttt{Perl\_eval\_sv}, passando a macro \texttt{aTHX\_}
como parâmetro inicial. De maneira geral o uso destas macros fica
implícito, mas ao escrever funções que usam a API de Perl torna-se
necessário usar a macro \texttt{pTHX\_} na declaração%
\footnote{A macro \texttt{pTHX\_} é usada sem a vírgula separando-a do argumento
seguinte. Quando ela é o único argumento, deve-se usar \texttt{pTHX}.%
}, para propagar a informação de estado do interpretador através de
chamadas de função, e \texttt{aTHX\_} nas chamadas.

Outro sintoma de que a API de Perl foi projetada mais para uso interno
do pré-processador XS do que para manipulação direta transparece no
segundo argumento, \texttt{ax}. Algumas macros assumem a existência
deste valor, que não é propagado via \texttt{pTHX\_}, mas é declarado
implicitamente quando funções são encapsuladas via XS. A API parece
assumir que uma função XS não irá invocar outra função C que também
use a API. Tivemos então que propagar esta variável (que é citada
na documentação, mas apenas como \emph{\char`\"{}the 'ax' variable\char`\"{}~}\cite{okamoto06perlapi},
sem explicações do seu propósito).

Os outros dois parâmetros, \texttt{count} e \texttt{offset}, são necessários
devido às diferentes formas que as informações que eles representam
são obtidas nos dois contextos onde esta função é usada. Nos outros
plugins, podemos obter a quantidade de elementos de entrada de forma
uniforme (consultando o número de elementos da tupla em Python, por
exemplo). Em Perl, nas duas situações onde a função é chamada, o número
de elementos a serem lidos da pilha deve ser obtido de formas diferentes,
e por isso o passamos como parâmetro \texttt{count}. Na rotina chamadora
de funções LibScript, implementada no arquivo XS, o tamanho da pilha
é obtido através de uma variável especial, \texttt{items}. Já na chamada
de funções Perl, o valor de \texttt{count} é obtido como retorno da
função que realiza a invocação, \texttt{Perl\_call\_pv}. 

A posição inicial da pilha a partir da qual devemos obter os elementos
(\texttt{offset}) também varia. Dentro da função XS, os parâmetros
de entrada começam a partir da posição 2, pois LibScript passa o ponteiro
do ambiente e o nome da função nos dois primeiros argumentos. Na chamada
de funções Perl, o valor de \texttt{offset} é zero pois, como visto
no protocolo de chamada de funções Perl discutido na Seção~\ref{sub:Perl-call},
a base da pilha é ajustada após a chamada da função pela macro \texttt{SPAGAIN}. 

A conversão de valores do buffer LibScript para a pilha de Perl é
dada em duas funções, uma que gera um único \texttt{SV} e outra que
empilha todos os elementos:

\begin{lyxcode}
{\footnotesize SV{*}~script\_perl\_get\_sv(pTHX\_~script\_env{*}~env,~int~i)~\{}{\footnotesize \par}

~{\footnotesize ~~switch~(script\_get\_type(env,~i))~\{}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_DOUBLE:~return~newSVnv(script\_get\_double(env,~i));}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~0~indica~que~o~tamanho~da~string~deve~ser~calculado~por~Perl.~{*}/}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_STRING:~return~newSVpv(script\_get\_string(env,~i),~0);}{\footnotesize \par}

~{\footnotesize ~~case~SCRIPT\_BOOL:~return~newSViv(script\_get\_bool(env,~i));}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}

~{\footnotesize ~}~\\
{\footnotesize SV{*}{*}~script\_perl\_buffer\_to\_stack(pTHX\_~SV{*}{*}~sp,~script\_env{*}~env)~\{}{\footnotesize \par}

~{\footnotesize ~~int~i;}{\footnotesize \par}

~{\footnotesize ~~int~len~=~script\_buffer\_len(env);}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)~\{}{\footnotesize \par}

~{\footnotesize ~~~~~XPUSHs(sv\_2mortal(script\_perl\_get\_sv(aTHX\_~env,~i)));}{\footnotesize \par}

~{\footnotesize ~~\}}{\footnotesize \par}

~{\footnotesize ~~return~sp;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Novamente, uma variável criada internamente por Perl teve que ser
propagada explicitamente: \texttt{sp}, o \emph{stack pointer}. Esta
variável é referenciada internamente pela macro \texttt{xPUSHs}. Além
disso, como \texttt{XPUSHs} pode redimensionar a pilha, precisamos
retornar o valor atualizado de \texttt{sp} de volta para o chamador.
No mais, a geração de \texttt{SV}s, o registro destes como variáveis
mortais e o seu empilhamento ocorre da forma usual, já apresentada
na Seção~\ref{sub:Perl-call}.

Assim como nos demais plugins, a passagem de parâmetros de entrada
em LibScript-Perl, tanto para a chamada de funções Perl como de funções
via LibScript, é feita chamando a função de conversão que opera sobre
o buffer como um todo: na chamada de funções Perl usamos \texttt{script\_perl\_buffer\_to\_stack}
e na de funções via LibScript, \texttt{script\_perl\_stack\_to\_buffer}.
Para tratar os valores de retorno de funções Perl, pudemos utilizar
diretamente a função \texttt{script\_perl\_stack\_to\_buffer}, de
forma similar à realizada em LibScript-Lua. Para o retorno de funções
chamadas via LibScript, porém, precisamos lidar com a variável especial
\texttt{RETVAL} de XS e com os diferentes contextos de chamada de
Perl. O trecho abaixo ilustra o tratamento de valores de retorno neste
caso:

\begin{lyxcode}
{\footnotesize err~=~script\_call(env,~function\_name);}{\footnotesize \par}

\emph{\footnotesize /{*}~...~(tratamento~de~erro~omitido)~...~{*}/}{\footnotesize \par}

{\footnotesize switch~(GIMME\_V)~\{}{\footnotesize \par}

{\footnotesize case~G\_SCALAR:}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retorna~o~primeiro~item~do~buffer~{*}/}{\footnotesize \par}

~{\footnotesize ~~RETVAL~=~script\_perl\_get\_sv(aTHX\_~env,~0);}{\footnotesize \par}

~{\footnotesize ~~break;}{\footnotesize \par}

{\footnotesize case~G\_ARRAY:}{\footnotesize \par}

~{\footnotesize ~~len~=~script\_buffer\_len(env);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Cria~um~array~{*}/}{\footnotesize \par}

~{\footnotesize ~~RETVAL~=~(SV{*})newAV();}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Arrays~retornados~devem~ser~marcados~como~mortais~{*}/}{\footnotesize \par}

~{\footnotesize ~~sv\_2mortal((SV{*})RETVAL);}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Insere~o~conteúdo~do~buffer~no~array~{*}/}{\footnotesize \par}

~{\footnotesize ~~for~(i~=~0;~i~<~len;~i++)}{\footnotesize \par}

~{\footnotesize ~~~~~av\_push((AV{*})RETVAL,~script\_perl\_get\_sv(aTHX\_~env,~i));}{\footnotesize \par}

~{\footnotesize ~~break;}{\footnotesize \par}

{\footnotesize case~G\_VOID:}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~O~valor~de~retorno~é~descartado~em~contextos~void.~{*}/}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Retornamos~então~a~constante~Perl~undef.~{*}/}{\footnotesize \par}

~{\footnotesize ~~RETVAL~=~\&PL\_sv\_undef;}{\footnotesize \par}

~{\footnotesize ~~break;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}

\subsection{\label{sub:Resolu=E7=E3o-de-fun=E7=F5es}Chamada de funções}

Nos plugins de LibScript, funções implementadas externamente (em C
ou outros plugins) são localizadas somente no momento em que elas
são chamadas. O objetivo aqui, além de otimizar o tempo de inicialização
e consumo de memória no ambiente de execução da linguagem de script
(ao evitar a declaração de funções que não serão utilizadas), é permitir
a localização de funções declaradas após a inicialização do ambiente.
Para permitir esta resolução de funções de forma dinâmica, é preciso
capturar o acesso a elementos inexistentes na estrutura que descreve
o ambiente virtual no plugin e encaminhar a chamada à biblioteca principal
via \texttt{script\_call}. Ao comparar as abordagens empregadas em
cada plugin para obter tal comportamento, podemos avaliar alguns recursos
de meta-programação oferecidos por cada linguagem e a sua disponibilidade
através das suas APIs.

Como vimos na Seção~\ref{sub:Representa=E7=E3o-de-estados}, em Lua,
durante a inicialização do plugin, é criada uma tabela armazenada
em uma variável global com o nome do ambiente. Funções são inseridas
dinamicamente nesta tabela através da metatabela associada a ela logo
após a sua criação em \texttt{script\_plugin\_init\_lua}. O campo
\texttt{\_\_index} da metatabela aponta para uma função~C interna
ao plugin, \texttt{script\_lua\_}\-\texttt{make\_caller}, que é então
invocada sempre que um elemento inexistente for solicitado na tabela.
A função \texttt{script\_lua\_make\_caller} cria uma \emph{closure}~C,
que consiste de outra função~C interna ao plugin (\texttt{script\_lua\_caller})
e o nome da função solicitada. Esta closure é associada à entrada
da tabela do ambiente. Assim, chamadas a funções implementadas externamente
serão resolvidas por \texttt{script\_lua\_caller}, que as passará
adiante para \texttt{script\_call}.

No plugin Python, ao chamar uma função no módulo do ambiente virtual,
o \emph{callback} \texttt{\_\_getattro} do módulo, definido como a
função interna \texttt{script\_python\_get}, é chamado. Esta função
procura uma entrada no dicionário do módulo e, caso não a encontre,
cria um objeto do tipo \texttt{script\_python\_object}, e o retorna
como resultado de \texttt{\_\_getattro}. Este tipo de dado é declarado
no plugin como uma classe Python, cujas instâncias contêm um ponteiro
para o ambiente virtual e uma string C com o nome da função que eles
representam. Estes objetos possuem o seu \emph{callback} \texttt{\_\_call}
definido como \texttt{script\_python\_caller}, uma função que, assim
como \texttt{script\_lua\_caller}, converte os parâmetros recebidos
para o buffer de LibScript, invoca \texttt{script\_call} e converte
os valores de retorno de volta a Python. Assim, objetos deste tipo
são \emph{functors}, e se comportam de forma similar à \emph{closure}
definida no plugin Lua.

A resolução de funções sob demanda em Ruby é implementada utilizando
o método \texttt{method\_missing}, que é um fallback definido pela
linguagem, chamado sempre que um método inexistente é invocado em
uma classe. Diferentemente de \texttt{\_\_getattro} em Python e \texttt{\_\_index}
em Lua, que são tratadores de acesso a atributos e portanto precisam
retornar um objeto que é chamado em um passo seguinte, o método \texttt{method\_missing}
trata chamadas diretamente. Assim, ao ser invocado, \texttt{method\_missing}
recebe o nome do método solicitado e os parâmetros passados e os encaminha
para a função \texttt{script\_call}.

No plugin Perl, como em Lua e Python, também há uma função C responsável
por realizar a a invocação de \texttt{script\_call} e a conversão
de parâmetros e valores de retorno. Esta função, \texttt{script\_perl\_caller},
para que possa ser exposta ao interpretador Perl, é implementada em
um módulo XS. Uma vez carregado o módulo, a função é visível em Perl
como a função \texttt{LibScript::caller}. A resolução dinâmica de
funções do pacote Perl que representa o ambiente virtual LibScript
é feita usando a função \texttt{AUTOLOAD} de Perl, que se comporta
como \texttt{method\_missing} em Ruby, capturando chamadas a funções
inexistentes. Na função de inicialização do plugin, código Perl é
executado para carregar o módulo de extensão, inicializar o pacote
do ambiente e inserir nele uma função \texttt{AUTOLOAD} que chamará
\texttt{LibScript::caller}:

\begin{lyxcode}
{\footnotesize snprintf(code,~LEN\_CODE,}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Inicializa~o~módulo~de~extensão~{*}/}{\footnotesize \par}

~{\footnotesize ~~\char`\"{}bootstrap~LibScript;\char`\"{}}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Declara~o~pacote~do~ambiente~{*}/}{\footnotesize \par}

~{\footnotesize ~~\char`\"{}package~\%s;\char`\"{}}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Armazena~o~ponteiro~do~ambiente~em~Perl~{*}/}{\footnotesize \par}

~{\footnotesize ~~\char`\"{}\$LibScript::env~=~\%p;\char`\"{}}{\footnotesize \par}

~{\footnotesize ~~\char`\"{}sub~AUTOLOAD~\{\char`\"{}}{\footnotesize \par}

~{\footnotesize ~~~~~\char`\"{}our~\$AUTOLOAD;\char`\"{}}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Extrai~o~nome~do~método}{\footnotesize \par}

~\emph{\footnotesize ~~~~~~~~do~nome~qualificado~{}``pacote::método''~{*}/}{\footnotesize \par}

~{\footnotesize ~~~~~\char`\"{}\$AUTOLOAD~=\textasciitilde{}~s/{[}\textasciicircum{}:{]}{*}:://;\char`\"{}}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~Invoca~caller~passando~o~endereço~do~ambiente,~{*}/}{\footnotesize \par}

~\emph{\footnotesize ~~~~~/{*}~o~nome~do~método,~e~o~array~de~argumentos~{*}/}{\footnotesize \par}

~\emph{\footnotesize ~~~~}~{\footnotesize \char`\"{}LibScript::caller(\%p,~\$AUTOLOAD,~@\_);\char`\"{}~~}{\footnotesize \par}

~{\footnotesize ~~\char`\"{}\}\char`\"{},}{\footnotesize \par}

~{\footnotesize ~~state->package,~env,~env);}{\footnotesize \par}

\emph{\footnotesize /{*}~Avalia~a~string~de~código;}{\footnotesize \par}

~\emph{\footnotesize ~~TRUE~indica~que~erros~devem~ser~sinalizados.~{*}/}{\footnotesize \par}

{\footnotesize Perl\_eval\_pv(my\_perl,~code,~TRUE);}{\footnotesize \par}
\end{lyxcode}

\subsection{Captura de erros\label{sub:Captura-de-erros}}

Os plugins devem capturar a ocorrência de erros na execução de strings
de código e em chamadas de função. Em Lua, ambas as operações são
realizadas usando a função \texttt{lua\_pcall}, cujo valor de retorno
indica a ocorrência de erros. No caso de erros, a mensagem de erro
é obtida no topo da pilha virtual de Lua e propagada para a biblioteca
principal usando \texttt{script\_set\_error\_message}. No caso da
execução de strings de código, erros de compilação são detectados
através do valor de retorno da função \texttt{luaL\_loadstring}, que
carrega o código a ser executado por \texttt{lua\_pcall}.

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno
das funções de execução de strings, \texttt{PyRun\_SimpleString},
e de chamada de funções, \texttt{PyEval\_CallObject}. No caso de erros,
chamamos a função \texttt{PyErr\_Occurred}, que retorna um objeto
Python representando a exceção. A mensagem de erro é obtida convertendo
este objeto para uma string Python usando \texttt{PyObject\_Str},
e finalmente para uma string C com \texttt{PyString\_AS\_STRING}.

Em Perl, erros são sinalizados na variável especial \texttt{\$@},
cujo conteúdo pode ser verificado através da API de C com a macro
\texttt{ERRSV}. O teste para ocorrência de erros é \texttt{SvTRUE(ERRSV)},
e a mensagem de erro pode ser obtida convertendo esta variável para
uma string C com a macro \texttt{SvPV}.

Ruby disponibiliza uma função para execução de strings de código,
\texttt{rb\_eval\_string}, e uma versão desta que captura erros e
sinaliza a sua ocorrência através do valor de retorno, \texttt{rb\_eval\_string\_protect}.
Entretanto, para chamadas de método, não há uma versão protegida da
função \texttt{rb\_funcall}. A função disponibilizada pela API para
proteger chamadas, \texttt{rb\_protect}, não recebe como parâmetro
um método Ruby, mas sim uma função~C. Para chamar métodos Ruby de
forma protegida, precisamos escrever uma função C que encapsula a
chamada:

\begin{lyxcode}
{\footnotesize static~VALUE~script\_ruby\_pcall(VALUE~args)~\{}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Extrai~nome~do~método~do~array~de~argumentos~{*}/}{\footnotesize \par}

~{\footnotesize ~~ID~fn\_id~=~SYM2ID(rb\_ary\_pop(args));~}{\footnotesize \par}

~\emph{\footnotesize ~~/{*}~Extrai~a~classe~do~array~de~argumentos~{*}/}{\footnotesize \par}

~{\footnotesize ~~VALUE~klass~=~rb\_ary\_pop(args);}{\footnotesize \par}

~{\footnotesize ~~return~rb\_apply(klass,~fn\_id,~args);}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}
e então invocá-la usando \texttt{rb\_protect}:

\begin{lyxcode}
\emph{\footnotesize /{*}~Insere~a~classe~no~array~de~argumentos~{*}/}{\footnotesize \par}

{\footnotesize rb\_ary\_push(args,~klass);}{\footnotesize \par}

\emph{\footnotesize /{*}~Insere~o~nome~do~método~no~array~de~argumentos~{*}/}{\footnotesize \par}

{\footnotesize rb\_ary\_push(args,~ID2SYM(rb\_intern(fn)));}{\footnotesize \par}

\emph{\footnotesize /{*}~Chama~a~função~wrapper~{*}/}{\footnotesize \par}

{\footnotesize ret~=~rb\_protect(script\_ruby\_pcall,~args,~\&error);~}{\footnotesize \par}

{\footnotesize if~(error)~\{}{\footnotesize \par}

~{\footnotesize ~~script\_reset\_buffer(env);}{\footnotesize \par}

~{\footnotesize ~~script\_set\_error\_message(env,~StringValuePtr(ruby\_errinfo));}{\footnotesize \par}

~{\footnotesize ~~ruby\_errinfo~=~Qnil;}{\footnotesize \par}

~{\footnotesize ~~return~SCRIPT\_ERRLANGRUN;}{\footnotesize \par}

{\footnotesize \}}{\footnotesize \par}
\end{lyxcode}


Como a função \texttt{rb\_protect} passa apenas um \texttt{VALUE}
para a função C, precisamos armazenar a classe, o identificador do
método e os parâmetros de entrada do método Ruby a ser invocado em
um array Ruby. A ocorrência de erros é sinalizada em uma variável
passada no terceiro parâmetro de \texttt{rb\_protect}, e a mensagem
de erro é obtida no \texttt{VALUE} global \texttt{ruby\_errinfo}.


\section{Conclusões}

O estudo de caso apresentado aqui ilustrou, através da implementação
dos plugins, o processo de embutir quatro linguagens de script realizando
interface com uma mesma API C. Diversos aspectos da interação entre
C e as linguagens de script foram abordados, contemplando inicialização
e encerramento do ambiente de execução, passagem de dados e chamadas
de função nos dois sentidos e a sinalização de erros. A partir disto,
podemos fazer algumas observações sobre a adequabilidade destas linguagens
como ambientes embutidos em aplicações.

Em muitas aplicações é importante que haja isolamento entre os scripts
executados, como por exemplo, em scripts de diferentes clientes rodando
em um servidor web. Como vimos, Lua e Perl permitem disparar múltiplos
ambientes de execução, o que garante isolamento. Já Python e Ruby
permitem apenas um estado, reduzindo sua aplicabilidade para cenários
onde os scripts devem executar isolados uns dos outros%
\footnote{Em Python é possível alternar a tabela de globais durante a execução
de diferentes threads, o que oferece uma alternativa, um tanto mais
trabalhosa, para obter isolamento. Ainda assim, o estado global compartilhado
por módulos de extensão é o mesmo. %
}. Estas duas linguagens trazem ainda outro problema: em alguns casos
não é possível trazer o seu espaço de dados de volta ao estado original
durante a execução de uma aplicação. Em Python, módulos importados
não podem ser descarregados. Em Ruby, uma classe não pode ser redefinida
(somente estendida) e \texttt{ID}s não são coletados.

Na implementação do plugin de Perl fica evidente que a sua API não
foi projetada visando embutir o interpretador em aplicações. Além
de exigir o desenvolvimento de um módulo de extensão para que o código
Perl possa ter acesso a funções C, observamos aqui que a sua API é
incompleta no que diz respeito ao seu uso como linguagem embutida.
Muitas macros foram desenvolvidas assumindo que seriam sempre invocadas
a partir de código escrito em arquivos XS, ou mesmo por código gerado
pelo pré-processador XS. Isto é confirmado pela necessidade de passar
parâmetros adicionais não-documentados para que as macros funcionem,
como pôde ser observado na Seção~\ref{sub:Passagem-de-par=E2metros}.

Lua, por sua vez, mostrou-se apropriada como linguagem embutida, não
compartilhando das limitações aqui descritas sobre as outras linguagens.
Além disso, ela possui uma API simples, que trata as construções da
linguagem de forma completa e ortogonal, o que se deve tanto ao foco
da implementação de Lua como linguagem embutida, quanto ao projeto
minimalista da linguagem em si. Mesmo em exemplos pequenos como os
apresentados aqui, que exercitam apenas uma parte pequena das APIs,
podemos observar que aspectos onde as linguagens definem tratamentos
especiais ou possuem menor uniformidade transparecem nas APIs para
C. Tanto em Python como em Ruby, funções que retornam múltiplos valores
geram conversões implícitas para tipos agregados (listas e arrays).
De forma similar, múltiplos retornos são representados em Perl através
de contextos do tipo array. Nos seus respectivos plugins LibScript,
estas características tiveram que ser tratadas de forma especial.
No plugin Lua, em contraste, o tratamento para um valor único de retorno
é igual ao de valores múltiplos, assim como ocorre na linguagem. 


\chapter{\label{cha:Considera=E7=F5es-Finais}Conclusões}

A escolha de uma linguagem de script depende de uma série de fatores,
varios deles relativos à linguagem em si, outros relativos à sua implementação.
Quando lidamos com cenários de desenvolvimento multi-linguagem, um
aspecto que não deve ser negligenciado é o projeto das interfaces
entre as linguagens. Seja estendendo a linguagem de script através
de código C, ou tornando uma aplicação C extensível através de uma
linguagem de script, a API oferecida pela linguagem tem um papel fundamental,
muitas vezes influenciando o projeto da aplicação.

Este trabalho traçou um panorama dos problemas gerais enfrentados
na interação entre código C e o ambiente de execução de uma linguagem
de script. Apresentamos as formas como as APIs de cinco linguagens
tratam estes problemas, indicando pontos positivos e negativos das
diferentes abordagens utilizadas. Realizamos uma comparação prática
do uso destas APIs através de um estudo de caso onde as linguagens
de script foram embutidas em bibliotecas C exportando uma mesma interface.
A implementação consiste de uma biblioteca genérica para scripting,
chamada LibScript, e uma série de plugins que realizam a interface
com as diferentes linguagens. Pudemos assim observar como elas tratam
aspectos importantes relativos a linguagens embutidas, como a passagem
de dados, chamadas de funções entre as duas linguagens, tratamento
de erros e o isolamento dos ambientes de execução em aplicações.

Embora os mesmos problemas gerais, como transferência de dados, registro
e chamada de funções, sejam comuns aos diferentes cenários de uso
de uma API de linguagem de script, aplicações embutindo uma máquina
virtual tendem a demandar mais da API do que bibliotecas implementando
módulos de extensão. Este ponto é ilustrado pelas dificuldades impostas
pela API de Python tanto no acesso a variáveis como no registro de
funções globais; e principalmente pela complexidade da API de chamada
de funções de Perl.

O fato de que a API de Python dificulta o uso de variáveis e funções
globais, favorecendo o uso de módulos, pode ser justificado como uma
forma de promover um modelo de programação mais estruturada. Isto
é interessante para o uso da API no desenvolvimento de módulos de
extensão, uma vez que o uso de variáveis e funções globais é extremamente
prejudicial nestes casos, já que poluiria o espaço de nomes das aplicações
Python. Já para o caso onde a linguagem é embutida para prover suporte
à execução de scripts em uma aplicação C, a ausência de uma forma
conveniente para definir funções globais no espaço de nomes dos scripts
é questionável.

A abordagem empregada por Perl, usando um pré-processador com o objetivo
de gerar automaticamente o código para a conversão de dados na passagem
de parâmetros e valores de retorno, se mostrou inadequada para o cenário
envolvendo interpretadores embutidos. Embora o uso do pré-processador
simplifique os casos simples de declaração de funções C, a falta de
uma API bem definida para tratar a transferência de dados entre o
interpretador Perl e o código C se faz perceber nos casos mais elaborados.
Duas destas situações se fizeram presentes no estudo de caso: o recebimento
de parâmetros \emph{varargs} e a passagem de valores de retorno tratando
múltiplos contextos de execução. Ambas exigiram manipulações de estruturas
e construções de mais baixo nível, que o pré-processador tem por objetivo
ocultar.

Observações interessantes resultaram da comparação da API de Java
com a das demais quatro linguagens de script, uma vez que, embora
possua diversas características em comum com estas linguagens, Java
não seja considerada uma linguagem de script. Enquanto a tipagem estática
reduz bastante a necessidade de conversões de dados explícitas no
código C para tipos primitivos da linguagem, na prática a verificação
de tipos para objetos e a ligação de campos e métodos acontece de
forma dinâmica, já que estes têm que ser realizados em tempo de execução
pela JNI. Assim, no contexto da interação de uma máquina virtual com
código C, as vantagens trazidas pela tipagem estática são reduzidas.
Além disso, a resolução dinâmica de campos e métodos faz com que a
manipulação de objetos via C tenha diferenças sutis de comportamento
em relação ao que ocorre em código Java, o que pode ser uma fonte
de erros do programador.

Ao comparar as APIs, consideramos apenas as suas interfaces, fazendo
uma análise qualitativa da usabilidade de cada uma da perspectiva
do programador C, e não uma análise quantitativa das suas implementações.
O custo de desempenho adicionado pelo código que realiza a ligação
entre duas linguagens, por exemplo, não pode ser desprezado. Muitas
decisões de projeto de uma API são influenciadas por requisitos da
implementação como restrições de portabilidade ou desempenho. Por
exemplo, o tratamento automático de controle de escopo de \texttt{VALUE}s
em Ruby, varrendo a pilha de C, traz grande conveniência para o programador,
mas reduz a portabilidade da implementação.

Merece comentário também a disparidade entre as linguagens no que
concerne à disponibilidade de documentação. Java, Python e Lua possuem
extensa documentação, tanto para a linguagem como para as suas APIs
para C. Para estas linguagens, pudemos basear largamente nosso estudo
e a implementação dos exemplos para o estudo de caso na documentação
fornecida. A documentação de Ruby relativa à sua API de C é mais escassa;
em~\cite{thomas04ruby} é coberta apenas parte da API pública. Precisamos
fazer uso de funções não documentadas para tarefas fundamentais como
liberar referências globais registradas via C. Durante o desenvolvimento
do plugin Ruby no estudo de caso, consultamos freqüentemente o código-fonte
de Ruby para compreender os aspectos que não são cobertos pela documentação
do comportamento das suas funções públicas. A documentação da API
de C de Perl também é incompleta, espalhada através de diversas \emph{man
pages} incluídas na sua distribuição e em certos casos desatualizada.
Para compreender os diversos protocolos envolvidos no uso prático
da API de Perl, precisamos recorrer ao código-fonte de aplicações
que fazem uso dela.

O equilíbrio entre simplicidade e conveniência é outro tema recorrente
ao compararmos as APIs. A extensa API de Python, contendo 656 funções
públicas, contrasta com as 113 funções expostas pela API de Lua (79
na API \emph{core}, 34 na API auxiliar). Em diversas situações, funções
na API de Python abreviam duas, três ou até mais chamadas, como no
caso de funções poderosas como \texttt{Py\_BuildValue} e \texttt{PyObject\_CallFunction},
tornando o código C sucinto e legível. A abordagem defendida por Lua
é a de uma API minimalista, oferecendo mecanismos sobre os quais funcionalidades
mais elaboradas possam ser construídas. De fato, em~\cite{ierusalimschy06pil2}
é apresentada uma função C equivalente a \texttt{PyObject\_CallFunction}
usando a API de Lua.

Ruby exporta 530 funções em seu cabeçalho e Perl 1209, mas como apenas
uma pequena fração destas é documentada, torna-se difícil avaliar
o tamanho da {}``API pública'' destas linguagens e quantas destas
são apenas funções para uso interno expostas nos seus cabeçalhos%
\footnote{Algumas funções são marcadas como sendo de uso interno, mas a maioria
não possui qualquer indicação.%
}. Isto mostra também que a documentação não é relevante apenas enquanto
material de apoio para o desenvolvimento, mas também indica o quão
bem definida é uma API.

A API de Java é bem documentada como a de Python e Lua, mas o número
de funções exportadas não é um bom parâmetro para comparações com
as demais APIs porque, em função dos tipos estaticamente definidos,
muitas funções possuem uma variante para cada tipo primitivo. Java
exporta sua API como uma estrutura contendo ponteiros para função;
228 funções ao todo são exportadas nesta estrutura.

Outro aspecto que pôde ser observado neste trabalho é que a consistência
da API depende largamente da consistência da linguagem que ela expõe.
Construções onde a linguagem tem pouca ortogonalidade, como o tratamento
de blocos em Ruby ou as diferenças nos tratamentos de valores escalares
e arrays em Perl, acabam por aumentar a complexidade da API da linguagem
e demandam tratamento específico por parte do programador no código
C.

Como possibilidades de trabalhos futuros, este trabalho pode ser estendido
através do estudo de outros aspectos de APIs de linguagens de script.
Um foco possível é o impacto de desempenho de diferentes projetos
de API em aplicações multi-linguagem. Outro é a relação entre o projeto
de uma máquina virtual e o de sua respectiva API. Além disso, outra
perspectiva de trabalho é a continuação do desenvolvimento da biblioteca
LibScript. Possibilidades incluem adicionar novos plugins, revisar
a sua API e exercitá-la embutindo a biblioteca em aplicações reais.
LibScript e os quatro plugins implementados são software livre e estão
disponíveis para download em~\url{http://libscript.sourceforge.net}.

\bibliographystyle{plain}
\bibliography{dissert}


\appendix

\chapter{\label{cha:API-de-LibScript}API de LibScript}


\section{Inicialização e Término}

\begin{itemize}
\item \texttt{script\_env{*} script\_init(const char{*} namespace)}\\
Inicializa LibScript e retorna um ponteiro para o ambiente virtual.
O parâmetro \texttt{namespace} indica o nome a ser usado nas estruturas
a serem criadas no espaço de nomes das máquinas virtuais para representar
o ambiente virtual.
\item \texttt{void script\_done(script\_env{*} env)}\\
Encerra o ambiente virtual.
\end{itemize}

\section{Registro de Funções}

\begin{itemize}
\item \texttt{typedef script\_err ({*}script\_fn)(script\_env{*})}\\
Tipo das funções C a serem registradas no ambiente virtual. Ao expor
uma API existente para LibScript, a função tipicamente será uma função
\emph{wrapper} que carrega os parâmetros de entrada do ambiente, chama
uma função do programa e envia os parâmetros de saída de volta ao
ambiente.
\item \texttt{script\_err script\_new\_function(script\_env{*} env, script\_fn
fn, const char{*} name)}\\
Registra uma função no ambiente virtual.
\end{itemize}

\section{Buffer de parâmetros}

\begin{itemize}
\item \texttt{double script\_get\_double(script\_env{*} env, int index)}~\\
\texttt{int script\_get\_int(script\_env{*} env, int index)}~\\
\texttt{int script\_get\_bool(script\_env{*} env, int index)}~\\
\texttt{const char{*} script\_get\_string(script\_env{*} env, int
index)}\\
Obtêm dados do buffer. Estas funções devem ser chamadas ao início
das funções \emph{wrapper}. Para cada parâmetro de entrada, uma chamada
deve ser realizada. Ao fim, pode-se invocar a macro \texttt{SCRIPT\_CHECK\_INPUTS(env)},
que encerra a função retornando um código de erro caso alguma leitura
com alguma destas funções não tenha encontrado um dado do tipo esperado
(A API não realiza conversões automáticas entre strings e números).
Em \texttt{script\_get\_string}, a string retornada pertence ao chamador,
que passa a ser responsável por desalocá-la.
\item \texttt{script\_type script\_get\_type(script\_env{*} env, int index)}~\\
\texttt{int script\_buffer\_len(script\_env{*} env)}~\\
Estas funções permitem escrever funções em C que realizam verificação
de tipo e número de parâmetros em tempo de execução. A função \texttt{script\_get\_type}
obtém o tipo do elemento do buffer solicitado e \texttt{script\_buffer\_len}
retorna o número de parâmetros no buffer.
\item \texttt{void script\_put\_double(script\_env{*} env, int index, double
value)}~\\
\texttt{void script\_put\_int(script\_env{*} env, int index, int value)}~\\
\texttt{void script\_put\_bool(script\_env{*} env, int index, int
value)}~\\
\texttt{void script\_put\_string(script\_env{*} env, int index, const
char{*} value)}~\\
Inserem dados no buffer. Ao final de uma função, os valores de retorno
devem ser passados com chamadas a estas funções e um código de erro
\texttt{SCRIPT\_OK} como retorno da função C.
\item \texttt{void script\_reset\_buffer(script\_env{*} env)}\\
Esvazia o buffer.
\end{itemize}

\section{Executando Código}

\begin{itemize}
\item \texttt{script\_err script\_run(script\_env{*} env, const char{*}
language, const char{*} code)}\\
Executa uma string de código em uma dada linguagem. Se necessário,
o plugin apropriado é carregado e inicializado.
\item \texttt{script\_err script\_run\_file(script\_env{*} env, const char{*}
filename)}\\
Função de conveniência; carrega o texto de um arquivo e o executa
com \texttt{script\_run}. A linguagem é detectada a partir da extensão
do arquivo.
\item \texttt{script\_err script\_call(script\_env{*} env, const char{*}
fn)}\\
Requisita a execução de uma função em algum dos plugins cadastrados.
Os parâmetros de entrada devem ser passados anteriormente com chamadas
às funções \texttt{script\_put\_{*}}; valores de retorno podem ser
obtidos com \texttt{script\_get\_{*}}. Inicialmente, a tabela de funções
C do ambiente virtual é consultada. Não havendo uma função definida
em C, os plugins são consultados na seqüência em que foram inicializados
implicitamente via \texttt{script\_run} ou \texttt{script\_run\_file}:
funções registradas na representação do ambiente virtual definido
para a LibScript na máquina virtual da linguagem (isto é, no nome
criado com \texttt{script\_init}) são acessíveis via \texttt{script\_call}.
\item \texttt{script\_err script\_error(script\_env{*} env)}~\\
\texttt{const char{*} script\_error\_message(script\_env{*} env)}~\\
\texttt{void script\_set\_error\_message(script\_env{*} env, const
char{*} message)}~\\
Obtém o código e a mensagem de erro mais recentes do ambiente. Após
uma chamada a script\_error, o código de erro é zerado de volta para
\texttt{SCRIPT\_OK}. A mensagem de erro, por sua vez, não é zerada.
A função \texttt{script\_set\_error\_message} define um novo valor
para a mensagem de erro do ambiente. Permite ao plugin propagar à
aplicação as mensagens de erro da máquina virtual.
\item \texttt{const char{*} script\_get\_namespace(script\_env{*} env)}\\
Retorna o nome do namespace registrado com \texttt{script\_init}.
\end{itemize}

\section{API Exportada por Plugins}

As chamadas aos plugins que implementam interfaces com as várias máquinas
virtuais são realizadas internamente pela biblioteca principal, que
espera encontrar as seguintes funções:

\begin{itemize}
\item \texttt{script\_plugin\_state script\_plugin\_init\_}\emph{linguagem}\texttt{(script\_env{*}
env)}\\
Responsável por inicializar o plugin. Durante a inicialização, o espaço
de nomes do ambiente virtual deve ser exposto à máquina virtual de
alguma forma apropriada para a linguagem (como uma tabela em Lua,
ou um módulo em Python, ou ainda uma classe em Ruby). A rotina de
inicialização pode retornar um handle que será passado de volta a
ele nas chamadas subseqüentes. O estado da máquina virtual e o ponteiro
para o ambiente LibScript devem ser armazenados de modo a ser posteriormente
acessíveis a partir deste handle.
\item \texttt{script\_err script\_plugin\_run\_}\emph{linguagem}\texttt{(script\_plugin\_state
st, char{*} text)}\\
Envia código para execução na máquina virtual. Esta função é utilizada
internamente por \texttt{script\_run} e \texttt{script\_run\_file}.
Deve retornar \texttt{SCRIPT\_OK} em caso de sucesso, \texttt{SCRIPT\_ERRLANGCOMP}
para erros de compilação ou \texttt{SCRIPT\_ERRLANGRUN} para erros
de execução, preferencialmente definindo uma mensagem de erro com
\texttt{script\_set\_error\_message}.
\item \texttt{script\_err script\_plugin\_call\_}\emph{linguagem}\texttt{(script\_plugin\_state
st, char{*} fn)}\\
Realiza a chamada de uma função que tenha sido definida nativamente
no espaço de nomes do ambiente na máquina virtual do plugin. Ao chamar
uma função no espaço de nomes, seja em C através de \texttt{script\_call}
ou executando código em algum dos plugins, LibScript irá utilizar
esta função para tentar executar a função no contexto do plugin. Se
a função não foi definida no plugin, o valor \texttt{SCRIPT\_ERRFNUNDEF}
deve ser retornado. Caso contrário, ela deve ser executada, com parâmetros
de entrada obtidos através de \texttt{script\_get\_{*}} e valores
de retorno enviados com \texttt{script\_put\_{*}}, e os valores \texttt{SCRIPT\_OK}
ou \texttt{SCRIPT\_ERRLANGRUN} devem ser retornados, conforme apropriado. 
\item \texttt{void script\_plugin\_done\_}\emph{linguagem}\texttt{(script\_plugin\_state
st)}\\
Responsável pelo encerramento do ambiente.
\end{itemize}
