#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{a4wide}
\usepackage{indentfirst}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Standard


\backslash 
autor{Hisham H.
 Muhammad}
\layout Standard


\backslash 
autorR{Muhammad, Hisham H.}
\layout Standard


\backslash 
orientador{Roberto Ierusalimschy}
\layout Standard


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Standard


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Standard


\backslash 
cidade{Rio de Janeiro}
\layout Standard


\backslash 
departamento{Informática}
\layout Standard


\backslash 
programa{Informática}
\layout Standard


\backslash 
centro{Centro Técnico Científico} 
\end_inset 


\layout Title

A study on scripting language APIs
\layout Author
\added_space_bottom bigskip 
Hisham H.
 Muhammad
\newline 

\newline 

\newline 

\size normal 
Advisor: Roberto Ierusalimschy
\newline 

\newline 

\newline 

\newline 
Pontifícia Universidade Católica do Rio de Janeiro
\newline 
Centro Técnico Científico
\newline 
Departamento de Informática
\layout Standard
\pagebreak_top 
\SpecialChar ~

\begin_inset ERT
status Open

\layout Standard

\backslash 
thispagestyle{empty}
\end_inset 


\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
setcounter{page}{1}
\end_inset 

Abstract
\layout Standard

Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard

This work discusses the main issues involving the design of APIs for the
 integration of language environments within C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C\SpecialChar ~
code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C\SpecialChar ~
application and that from the scripting language.
\layout Standard

We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C\SpecialChar ~
application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C\SpecialChar ~
functions and conversion of data between the environments.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\end_inset 


\layout Standard

There are many situations in which it is necessary or interesting to have
 interaction between programs written in different languages.
 A typical case is the use of external libraries, such as graphic toolkits,
 APIs for database access, or even operating system calls.
 Another scenario involves applications developed using more than one programmin
g language, in order to optimize parts where performance is critical or
 to allow extensibility through scripts written by the end-user.
\layout Standard

Regardless of purpose, communication between programs written in different
 languages brings up a number of design issues, not only in the development
 of the applications, but in the languages themselves.
 There are many ways to obtain this kind of interoperability, from translation
 of code of a language to another to the use of a common virtual machine.
 Ideally, however, a language should provide a foreign language interface
 (FLI) that allows the programmer to send and receive both calls and data
 to the other language\SpecialChar ~

\begin_inset LatexCommand \cite{finne98haskellfli}

\end_inset 

.
 Among the factors that should be taken into account when developing such
 an interface are the differences between type systems, memory management
 issues (such as garbage collection and direct access to pointers) and concurren
cy models.
 Beyond dealing with semantic differences, the design of an interface between
 languages involves pragmatic issues such as the balance between the safe
 isolation of the runtime environments, performance and the simplicity of
 the resulting API.
\layout Standard

We can observe in the existing implementations of FLIs a number of approaches
 to these problems.
 In fact, FLIs for different languages (or even different revisions of a
 single language) tend to be very different from each other.
 Still, it is possible to trace parallels among the various techniques employed,
 since the fundamental problems that they address are the same.
\layout Standard

Because of the popularity of the C\SpecialChar ~
language and the support it enjoys in
 the most popular operating systems, a considerable part of the implementations
 of foreign language interfaces are, in practice, C APIs.
 Besides, an interaction model for programming languages that has become
 especially relevant nowadays is that between statically typed compiled
 languages, such as C, and dynamically typed interpreted languages, as proposed
 by Ousterhout\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

.
 These two classes of languages have fundamentally different goals.
 Statically typed languages are usually implemented with high performance
 in mind and focus on lower-level programming.
 In contrast, scripting languages tend to be implemented as interpreters
 or virtual machines, and make extensive use of high-level constructs, such
 as lists and hashes, as basic types.
 These complementary features have made the two-language programming model
 popular, in which a lower-level language is used for the development of
 components, which are then connected through a higher-level language.
\layout Section

Objectives
\layout Standard

This work discusses the main issues involving the design of APIs for integration
 of runtime environments of scripting languages in C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as that
 from a scripting language with C\SpecialChar ~
code.
 Besides being currently the most popular class of languges for multi-language
 development, typical features of scripting languages such as garbage collection
 and dynamic typing illustrate well the problems that arise in the communication
 between different programming environment, since these features are absent
 in\SpecialChar ~
C.
 Languages with static typic may present similar needs for type conversion,
 but the problem tends to be simplified by the definition of equivalent
 types in the API and compile-time inference (as can be observed in the
 C APIs for Ada and Fortran).
 Functional languages have additional concerns related to side effects in
 C code, but this is equivalent to the paradigm break problem caused by
 the handling of I/O commonly faced by those languages.
\layout Standard

This study consists of two parts.
 In the first part, we performed an in-depth analysis of a set of C\SpecialChar ~
APIs
 provided by four scripting languages -- namely, Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06ref}

\end_inset 

, Perl\SpecialChar ~

\begin_inset LatexCommand \cite{wall00perl}

\end_inset 

, Ruby\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

, Lua\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 -- as well as the API provided by the Java language\SpecialChar ~

\begin_inset LatexCommand \cite{gosling00java}

\end_inset 

.
 Unlike the others, Java uses static typing, but like them it is based on
 a virtual machine model, features automatic memory management and allows
 dynamic loading of code.
 This allows us to observe how typing affects the design of the API.
\layout Standard

In the second part, we illustrate the differences of the APIs of those langages
 and the impact of those in the resulting code of a C application through
 a case study.
 We performed a comparison between the scripting language APIs through a
 concrete example, in order to present implementations in each of the studied
 languages side by side.
 The example consists of a generic scripting library, called LibScript,
 and a series of plugins that interface to the different languages.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures used in each language for function calls, registration
 of C\SpecialChar ~
functions and data conversion between environments.
 
\layout Section

Text structure
\layout Standard

This work is structured as follows.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, we discuss the various approaches for interaction between code written
 in different programming languages.
 Starting from an overview, the focus will then concentrate on the most
 commonly used foreign language interface: interfaces with the C\SpecialChar ~
language.
 We will discuss the problems commonly presented in the communication with
 C code and the programming models that appeared with its popularization
 in the integration with scripting languages.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

, we present in detail C\SpecialChar ~
APIs for a set of scripting languages.
 When discussing these interfaces, the different solutions employed for
 the main problems involving interaction between C and dynamic environments
 are brought up.
 Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercises these APIs through a case study: a plugin-based library that
 offers a simplified, uniform interface for scripting languages.
 By examining the implementation of each plugin, we can compare the APIs
 for each language performing equivalent operations.
 Finally, in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

, conclusions reached through this work are presented, as well as possible
 directions for future work.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interaction between programming languages
\layout Standard

The approaches applied to the interaction of different programming languages
 vary considerably, but it is possible to identify some of the more typical
 techniques: language translation, from one language to the other or of
 both to a third; communication through an intermediate protocol or language;
 sharing a common execution environment, be it a virtual machine or through
 call conventions; and foreign language interfaces.
\layout Section

Code translation
\layout Standard

Allowing the use of two languages in a program through the translation of
 the code of one of them to the other minimizes the problem of communication
 between the parts of program written in different languages, since the
 final program will use a single data space.
 On the other hand, by having to describe a language in terms of the other,
 the semantic differences of their constructs may become a problem.
 If the target language lacks constructs offered by the source language,
 simulating them may be costly.
\layout Standard

A typical example of this problem is the complexity added by the simulation
 of higher-order functions and tail recursion when translating code from
 functional languages to one that does not have those features.
 Tarditi et al.\SpecialChar ~

\begin_inset LatexCommand \cite{tarditi92mlc}

\end_inset 

 describe the development of a translator of Standard ML to ANSI C.
 Their measurements have exposed the cost of adapting the features of ML
 to C, resulting in code that is in average 2 times slower than the that
 generated by the native ML compiler.
 In 
\begin_inset LatexCommand \cite{tolmach98mlada}

\end_inset 

, similar challenges are discussed in the translation of ML to Ada: in the
 adopted approach, the process has an intermediate step where higher-order
 constructs are 
\begin_inset Quotes eld
\end_inset 

flattened
\begin_inset Quotes erd
\end_inset 

 to first-order constructs using records, so that they could be represented
 in Ada.
\layout Standard

Besides problems such as this, differences in the representation of data
 is also something to be handled when translating one language to another.
 In the particular case of\SpecialChar ~
C, its lower-level facilities for memory manipulation
 allow the description of data structures for higher-level languages without
 too much trouble.
 This makes\SpecialChar ~
C a frequent candidate for use as a portable low-level representation
 of code.
 The Glasgow Haskell Compiler offers, as an alternative to the generation
 of native code, generation of C code for use with GCC\SpecialChar ~

\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 One of the advantages of this feature is to allow the bootstrapping of
 the compiler in new architecture, given that GHC itself is written in Haskell.
 In fact, the ubiquity of C compilers has prompted the use of this language
 as a 
\emph on 
lingua franca
\emph default 
 between different languages, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Sharing virtual machines
\layout Standard

Another approach for the interaction between languages involves the use
 of a common execution environment, such as a virtual machine.
 The code of different languages is compiled to produce compatible representatio
ns, according to the data types provided by the execution environment.
 Many implementations use the Java Virtual Machine\SpecialChar ~

\begin_inset LatexCommand \cite{lindholm99jvm}

\end_inset 

 for this end.
 Jython\SpecialChar ~

\begin_inset LatexCommand \cite{hugunin97python}

\end_inset 

 is an implementation of the Python language that produces Java bytecodes.
 SMLj\SpecialChar ~

\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 is a Standard ML compiler that generates Java bytecodes and provides access
 to Java classes and methods to ML structures and vice versa.
 The fact that the Java Virtual Machine was not designed to support different
 programming languages, however, shows in the limitations presented by these
 projects.
 SMLj defines extensions to the ML language to allow access to constructs
 that are specific to Java; Jython poses limitations to the interface between
 Python and the Java APIs for reflection and dynamic class loading.
 Besides, the instruction set of the virtual machine focuses on operations
 that match Java's semantics, which makes, for example, the implementation
 of arrays with different semantics less efficient.
\layout Standard

The .NET Framework\SpecialChar ~

\begin_inset LatexCommand \cite{box02net}

\end_inset 

 is a runtime environment based on virtual machine that is being presented
 by Microsoft as their programming platform of choice in Windows system.
 Although the C#\SpecialChar ~
language 
\begin_inset LatexCommand \cite{csharp06spec}

\end_inset 

 has been introduced specifically for it, this environment has as one of
 its goals multi-language support -- evidenced by the very name of its Common
 Language Runtime (CLR) -- contrasting with the limitations imposed by the
 Java enviroment to those who try to use it with other languages.
 However, adaptations to languages remain necessary in the .NET environment:
 the .NET version of Visual Basic includes changes to the language to make
 its semantics match those from C#; a new dialect of C++, C++/CLI, was introduce
d adapting its memory management model to that of the CLR\SpecialChar ~

\begin_inset LatexCommand \cite{cppcli05spec}

\end_inset 

; similarly, a new dialect of ML called F# was developed to, among other
 reasons, provide better integration with .NET components written in other
 languages\SpecialChar ~

\begin_inset LatexCommand \cite{syme06fsharp}

\end_inset 

.
\layout Standard

Another implementation of a virtual machine for multiple languagens is being
 pursued by the Parrot project\SpecialChar ~

\begin_inset LatexCommand \cite{randal04perl6}

\end_inset 

.
 The scope of this project is narrower, aiming to serve as a common back-end
 for dynamic languages such as Perl and Python.
 The focus of the project, however, is currently on the implementation of
 Perl 6.
\layout Standard

A kind of communication that can also be considered the use of a common
 runtime environment is the communication between executables and native
 libraries through call conventions: rules for passing parameters in the
 runtime stack, use of registers and name mangling.
 This can be considered the lowest-level method method for interaction between
 code in different languages.
 Calling conventions, however, are a limited form of communication, as they
 assume data types with identical memory representation in both languages.
 Such compatibility is hardly the case, unless one of the languages explicitly
 considers this kind of interaction in its definition: the Ada standard,
 for example, requires its implementations to be compatible with the calling
 conventions of C, COBOL and Fortran\SpecialChar ~

\begin_inset LatexCommand \cite{ada95manual}

\end_inset 

.
 Likewise, C++ allows to specify functions with C-compatible linkage, through
 the 
\family typewriter 
extern "C"
\family default 
 directive.
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Language-independent object models
\layout Standard

Adopting a language-independent type model is another way to handle the
 issues of data interoperability between languages.
 This way, in the definition of the data for an application, their interfaces
 are described in a neutral way, typically using some language designed
 specifically for this end (an Interface Description Language, IDL), while
 the implementations are made using the specific languages.
 The CORBA (Common Object Request Broker Architecture) architecture\SpecialChar ~

\begin_inset LatexCommand \cite{omg02corba}

\end_inset 

 is one of the main examples of this model.
 The central motivation for the development of CORBA was to allow the developmen
t of distributed applications in heterogeneous environments; language heterogene
ity was one of the aspects taken into consideration.
\layout Standard

The challanges existing when designing a 
\begin_inset Quotes eld
\end_inset 

language independent
\begin_inset Quotes erd
\end_inset 

 model for data or objects, however, are not unlike those in the design
 of an interface between any two languages, since this model too describes
 a type system.
 When implementing bindings for any of those object models, it is necessary
 to define a correspondence between the types defined by the model and those
 offered by the target language, and provide an API for interaction with
 the runtime environment -- in the case of CORBA, with the ORB (Object Request
 Broker).
\layout Standard

If on one hand the task may be easier since the model has been designed
 with language interaction in mind (unlike, for example, the C\SpecialChar ~
type system),
 on the other one would usually expect a higher level of transparency in
 the representation of data.
 For example, while in an application intergrating\SpecialChar ~
C++ and Python the distinction
 between C++\SpecialChar ~
objects and Python objects is clear and the Python API defines
 the limits between these two universes, in an application developed using
 CORBA one would expect, in both languages, the manipulation of objects
 to be the same whether they were implemented in C++ or in Python.
 For that, the common solution is to use 
\emph on 
stubs
\emph default 
, objects that give a uniform native appearance to data, regardless of the
 language in which they were implemented, and in the case of distributed
 models such as CORBA, of the location of the objects in the network.
 The correspondence between the lifecycles of the stubs and that of the
 objects they represent is another factor that should be taken into account.
 In the Java bindings, for instance, this is done with the help of the language'
s own garbage collector.
 In languages such as C++ the control of references is explicit.
\layout Standard

Other higher-level approaches have been proposed for the integration of
 applications developed in multiple languages.
 Coordination languages such as Linda\SpecialChar ~

\begin_inset LatexCommand \cite{gelernter85linda}

\end_inset 

 and Opus\SpecialChar ~

\begin_inset LatexCommand \cite{chapman97opus}

\end_inset 

 define mechanisms for message passing and a restricted set of constructs
 to indicate the flow of those between agents implemented in other languages.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C as an intermediate language
\layout Standard

The wish for a universal intermediate language is an old one in the world
 of computing.
 Several proposals have surfaced through the years, from the UNCOL project\SpecialChar ~

\begin_inset LatexCommand \cite{conway58uncol}

\end_inset 

 to the languages with extensible syntax of the 70s\SpecialChar ~

\begin_inset LatexCommand \cite{metzner79extensible}

\end_inset 

 to the most recent virtual machine environments such as .NET.
 In practice, the needs that these projects aimed to fulfill are being handled
 through the years in a more pragmatic, if less than ideal, way by using
 C.
 Two reasons make C a common choice as an intermediate language.
 First, its 
\begin_inset Quotes eld
\end_inset 

medium-level
\begin_inset Quotes erd
\end_inset 

 nature, by providing at the same time hardware independence and direct
 manipulation of memory.
 Second, the large availability of C\SpecialChar ~
compilers, leveraged by the proliferation
 of Unix systems in the most varied architectures.
 So, as time went by, to offer an interface for interoperability with other
 languages gradually became synonymous with offering an interface for communicat
ion with C\SpecialChar ~
code.
 This is especially true for dynamic languages that offer features for applicati
on extensibility.
 Not surprisingly, these languages are typically implemented in C.
 
\layout Standard

The availability of C APIs provided by different languages also causes C
 to be widely used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

.
 The integration between Python and Fortran takes place through a Python
 module written in C that accesses a Fortran library, which on its turn
 exposes functions using a call convention compatible with C\SpecialChar ~

\begin_inset LatexCommand \cite{peterson01fortranpy}

\end_inset 

.
 LunaticPython\SpecialChar ~

\begin_inset LatexCommand \cite{niemeyer06lunaticpython}

\end_inset 

 offers bridges from Lua to Python and from Python to Lua, implemented through
 a pair of extension modules for each source language written in\SpecialChar ~
C.
\layout Standard

However, generic intermediate languages continue to be proposed as alternatives
 to C.
 C-
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1pt}
\end_inset 

-\SpecialChar ~

\begin_inset LatexCommand \cite{jones99cminusminus}

\end_inset 

 is a project that attempts to overcome the limitations of C as an intermediate
 language making the memory representation of data types more explicit and
 adding support to constructs that are not easily represented in C, such
 as tail recursion.
 Recent versions of the GCC compiler suite have standardized an intermediate
 language for communication between its various back-ends and front-ends\SpecialChar ~

\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces to C
\layout Standard

The C language has, nowadays, a special role in the world of programming
 languages.
 Besides being widely used in the implementation of compilers, interpreters
 and virtual machines (the main implementations of Perl, Python, Ruby and
 Lua are just some examples), it is also used in compilers as an output
 format in the generation of portable code (two notable examples are the
 GHC and SmartEiffel\SpecialChar ~

\begin_inset LatexCommand \cite{collin97smalleiffel}

\end_inset 

 compilers, which generate C from Haskell and Eiffel, respectively).
 This pravelence of C makes the C API a convenient format for a foreign
 language interface.
\layout Standard

In the vast majority of cases, the internal representation of code produced
 by compilers for other languages is not compatible with C, be it because
 of differences in call or name conventions, or because they produce code
 for execution in virtual machines.
 This way, to allow a C program to access this code, the language has to
 expose a library of C functions that will perform the necessary translations.
 In virtual machine environments, this library is normally generic, offering
 facilities for communication with the virtual machine itself.
 For static languages, it is usually necessary to create a specific library
 to perform the conversion of calls, as it happens in interfaces that expose
 C++ libraries to C.
 An example of this is QtC\SpecialChar ~

\begin_inset LatexCommand \cite{kdebindings}

\end_inset 

, a library of C bindings to the Qt graphic toolkit, which is implemented
 in C++.
\layout Standard

For non-imperative languages, there is still the problem of C code potentially
 generating side effects.
 Some feature for isolating calls has to be offered.
 In GHC, the construction for C calls, 
\family typewriter 
_ccall_
\family default 
, is defined in the IO monad; in the addendum for the Haskell 98 standard,
 the 
\family typewriter 
ccall
\family default 
 directive was integrated, but the use of the monad is optional, requiring
 the programmer to ensure that the functions that use it are not pure
\begin_inset Foot
collapsed true

\layout Standard

A number of additional convention calls are defined (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
), but 
\family typewriter 
ccall
\family default 
 is the only one declared mandatory by the document.
\end_inset 

.
\layout Standard

Another possible source of incompatibility between languages that has to
 be handled when they interact is the difference between concurrency models.
 C, in particular, does not define any concurrency constructs; they are
 implemented through libraries.
 At the same time that it brings great flexibility to the language, this
 also imposes portability problems for languages that depend on the availability
 of concurrency mechanisms in C that are compatible with the models they
 use.
\layout Standard

For example, APIs between C and Java must take into account the preemptive
 multithreading model adopted by Java.
 The JNI (Java Native Interface)\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

 defines functions to control mutual exclusion between data shared between
 the two languages.
 The programmer must take care to strike a balance between time spent blocking
 the virtual machine accessing shared data and time spent copying data between
 the environments to reduce sharing.
 Another situation in which the concurrency model of the language demands
 special care when integrating with C happens in the use of co-routines
 in Lua.
 The combination of two features of Lua, cooperative multitasking with multiple
 execution stacks and the ability to alternate between calls to C and Lua
 functions in a single stack, brings a limitation: a co-routine cannot execute
 a 
\emph on 
yield
\emph default 
 operation in case there is a C function in its stack, as there is no portable
 way to alternate between multiple stacks in C\SpecialChar ~

\begin_inset LatexCommand \cite{moura04colua}

\end_inset 

.
\layout Standard

One of the most frequent motivations in the integration with C code is the
 use of external libraries.
 Exposing a C library through the FLI for access by another language may
 incur in the registration of hundreds of functions.
 It is also usual to define data types that give to structures defined by
 the library a more native appearance, such as, for example, converting
 C functions that register callbacks into Ruby methods that accept code
 blocks as a parameter.
 These initializations and adaptations are usually defined as a bindings
 library, that serves as a bridge between the language and the C library
 encapsulating the interaction with the FLI.
\layout Standard

The patterns that arise when producing bindings are so common that they
 motivated the development of programs that attempt to automate the process.
 These bindings generators tend to work using some representation prepared
 for their use, since analyzing raw C headers may show itself to be insufficient
: for example, often the program wouldn't be able to interpret the intention
 of a construct such as 
\family typewriter 
int**
\family default 
.
 SWIG\SpecialChar ~

\begin_inset LatexCommand \cite{beazley96swig}

\end_inset 

 is a popular multi-language tool for generation of bindings for C and C++
 libraries which defines its own format for description of interfaces.
 FLIs may as well use stubs generators to save the programmer from having
 to write repetitive or non-portable C\SpecialChar ~
code.
 Java features a generator for C headers containing prototypes for native
 methods to be implemented.
 Pyrex\SpecialChar ~

\begin_inset LatexCommand \cite{ewing06pyrex}

\end_inset 

 is a generator for C modules for Python from a syntax based on the Python
 language itself.
 Another example is toLua++\SpecialChar ~

\begin_inset LatexCommand \cite{manzur06tolua}

\end_inset 

, a tool for integrating C and C++ code to Lua, which generates stubs from
 C headers prepared for use by the program, which may contain special annotation
 to help in the conversion process.
\layout Section

Scripting languages
\layout Standard

A model for interaction between languages that has shown to be especially
 relevant nowadays is that between statically typed compiled languages,
 such as C and C++, and dynamically typed interpreted languages, such as
 Perl and Python.
 In\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

, Ousterhout categorizes these two groups as 
\emph on 
systems programming languages
\emph default 
 and 
\emph on 
scripting languages
\emph default 
.
\layout Standard

These two categories of languages have fundamentally different goals.
 Systems programming languages emerged as an alternative to assembly in
 the development of applications, having as main features static typing,
 which eases the understanding of data structures in large systems, and
 the implemantation as compilers, due to concerns with performance.
 In contrast, scripting languages are dynamically typed and are implemented
 as interpreters or virtual machines.
 Dynamic typing and the extensive use of higher-level constructs as basic
 types, such as lists and hashes, brings greater flexibility in the interaction
 between components; in static languages, the type system imposes restrictions
 to those interactions, often requiring the programmer to write adaptation
 interfaces, which makes the reuse of components harder.
\layout Standard

Ousterhout points out that, in a model integrating these two kinds of languages,
 the tendency is that systems programming languages will no longer be used
 to write whole applications, but will instead be used in the implementation
 of components, which are then connected through code written with scripting
 languages.
 The convenience offered by high-level interpreted languages allows rapid
 prototyping and encourages the reuse of components.
\layout Standard

The integration of programs developed in systems programming languages coordinat
ed through scripting languages has been common practice for a long time
 now.
 Shell scripting in Unix systems is probably the most notable example, where
 constructs such as pipes (which connect the output of a process to the
 input of another one) allow one to perform tasks combining a series of
 programs implemented in different languages, or even other scripts.
 With the introduction of Tcl\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout94tcl}

\end_inset 

, this kind of coordination of components through scripting languages started
 to take place 
\emph on 
within
\emph default 
 applications.
 In this model, the scripting language is implemented as a library and is
 embedded in an application written in a lower-level language, such as C.
 Data structures of the application are exposed to the scripting environment
 as objects; conversely, the application can launch functions in the scripting
 language and access its data.
 Programmable applications have existed long before that, typically using
 little languages created specifically for each application, but the concept
 introduced by Tcl of implementing scripting languages as C libraries has
 propelled strongly the development of extensible applications.
\layout Standard

The development model based in two languages does not limit itself to applicatio
ns that provide customization through scripts written by the end-user.
 In many scenarios, there is a clear distinction between a lower-level layer
 where performance is a critical factor and a higher-level layer comprised
 by coordination operations between elements of the lower layer.
 Typical examples are graphic applications where the interface is described
 by scripting languages controlling components implemented in C and games
 where the logic is described in scripts and the rendering engine is implemented
 in lower-level languages.
 This greater prominence of scripting languages, where they stop being just
 an application extension mechanism and start having a more central role
 in the coordination of the execution of the program, has also promoted
 an inverted model of interaction between languages, where the application
 itself is written using the scripting language and libraries written in
 lower-level languages are loaded as extension modules.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

Scripting language APIs
\layout Standard

Interfaces provided by scripting languages are usually understood as 
\begin_inset Quotes eld
\end_inset 

extension APIs
\begin_inset Quotes erd
\end_inset 

: they extend the virtual machine with features not originally offered by
 it, or alternatively, they extend an external application with the features
 offered by the runtime environment of the language, embedding it to the
 application.
 The first scenario is the one used in the programming model where the high-leve
l coordination is made by an interpreted language and modules written in
 languages such as C and C++ are used to access external libraries or to
 implement performance-critical parts.
 The second scenario, in general, will also encompass the first one, when
 exposing to the embedded virtual machine extensions that will allow it
 to talk to the host application.
\layout Standard

Both scenarios involve the same general problems: data transfer between
 the two languages, including how to allow the scripting language to manipulate
 structures declared in C and vice versa; handling the difference between
 the memory management models, more specifically the interaction between
 garbage collection in the virtual machine and explicit deallocation in
 C; calling functions declared by the scripting language from C; and the
 registration of C functions so that they can be invoked by scripts.
 The following sections discuss the main issues involved in the communication
 between C code and scripting languages, and present the approaches employed
 by the Python, Ruby, Java, Lua and Perl APIs when handling these issues.
 Each section concludes with a comparison where the different designs presented
 in the exposition of each language are reviewed side by side and thus put
 into perspective.
\layout Section

Data transfer
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

The main complexity in the interaction between programming languages is
 not the differences in syntax or semantics from their control flow structures,
 but in their data representations.
 In the communication between code written in two different languages, data
 flow in various forms: as parameters, object attributes, elements in data
 structures, etc.
\layout Standard

Often, the format how these data are represented differ.
 In those cases, there are three alternatives to perform data transfer between
 the languages.
 The simplest is to expose the data to the target language as an opaque
 entity.
 The target language receives only some kind of handle that allows it to
 identify the datum uniquely in operations requested later.
 This approach is useful, for example, if a language is just storing data
 for the other one, in order to make use of higher-level data structures
 offered by the language.
\layout Standard

Another approach involves perform some conversion to the data from the type
 system of one language to that of the other.
 The duplication that takes place in this conversion limits the applicability
 of this method, restricting its use typically to numeric types and, in
 minor scale, strings.
 Finally, the source language may explicitly offer facilities in the target
 language to manipulate these data, that is, one language would offer an
 API for the other.
 The difference between this approach and the first one is that, while in
 the former the contents of the data remain opaque, here the API defines
 some means to manipulate their contents.
\layout Standard

Because of its focus on the manipulation of pointers and structures, C provides
 a small set of basic types.
 Besides, C is very liberal with regard to the internal representation of
 its structured types, with each different platform having to define its
 own application binary interface (ABI).
 So, even in cases where it is possible to link C code directly using compatible
 basic types and appropriate calling conventions (such as in Free Pascal
 or several Fortran compilers), bindings libraries are still usually needed
 to make the manipulation of complex types more convenient.
\layout Standard

Even in the fundamental numeric types, there are several precautions that
 must be taken.
 Some languages, like Smalltalk and Ruby, perform automatic conversion of
 integers to 
\begin_inset Quotes eld
\end_inset 

big integers
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 In Ruby, in particular, primitive integers have 1 bit less of precision
 than the machine's word size.
 There may also be the need to handle conversion of endianness and format
 of floating point numbers.
\layout Standard

For types such as strings, the size of values brings also concerns with
 performance.
 In many cases the internal representation used for strings is the same
 as used in C, so an option is to simply pass to the C code a pointer to
 the address where the string is stored, which avoids copying of data, under
 risk of allowing the C code to modify the contents of the string.
 Exposing to C code pointers to memory areas within the runtime environment
 of the other language may also bring concurrency problems, in case the
 environment uses multiple threads.
\layout Standard

When exposing to C data of structured types, the conversion to a native
 C type, in many cases, is not an option.
 Besides the issue of quantity of data to be converted, structured types
 in C are defined statically, therefore not serving to represent conveniently
 data of dynamic structures, such as objects that may gain or lose attributes
 or even change class during runtime.
 Even in languages with static types, like Java, the copy of objects is
 not usually an interesting option due to the volume of data.
 Copying of structured objects tends to be restricted to specific operations
 such as manipulation of arrays of primitive types.
\layout Standard

The alternative to allowing C code to operate over structured data, thus,
 is to provide to it an API that exposes as functions the operations defined
 over those types.
 This also avoids the need to control the consistency between two copies
 of a given structure.
 Consistency problems, however, may occur if the API allows the C code to
 store pointers to objects from the language -- this makes it necessary
 for the programmer to manage explicitly the synchronicity between pointers
 and the lifecycles of objects that may be subject to garbage collection.
 Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discusses this issue in greater detail.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

All values in the Python virtual machine are represented as objects, mapped
 to the C API as the 
\family typewriter 
PyObject
\family default 
\SpecialChar ~
structure 
\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 More specific types such as 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 and 
\family typewriter 
PyListObject
\family default 
 are 
\family typewriter 
PyObject
\family default 
s by structural equivalence, that is, they can be converted through a C
 cast.
 Reflecting the dynamic typing model of Python, the API functions use 
\family typewriter 
PyObject*
\family default 
 as a type every time they refer to Python objects, even when they are designed
 to act on Python values of more specific types, such as for example the
 
\family typewriter 
PyString_Size
\family default 
, that returns the length of a string.
 Each specific type has a check function in the API, such as 
\family typewriter 
PyNumber_Check
\family default 
 and 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python is a strongly typed language: each object is tied to a type.
 Types are represented by 
\family typewriter 
PyTypeObject
\family default 
 structures, which are also structurally equivalent to 
\family typewriter 
PyObject
\family default 
.
 Each Python type has a predefined 
\family typewriter 
PyTypeObject
\family default 
 in the API, such as 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 and 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compares the type of a 
\family typewriter 
PyObject
\family default 
 to a 
\family typewriter 
PyTypeObject
\family default 
 passed as an argument.
\layout Standard

For the conversion of data from C to Python, the language offers a series
 of functions that receive values of primitive C types as an argument, such
 as 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 and 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Each of those functions returns to the C code a pointer to a new 
\family typewriter 
PyObject
\family default 
.
 Strings passed are copied by Python.
 The following example illustrates the creation of a Python object through
 the conversion of a C value:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The two examples below are equivalent, and illustrate type checking through
 the API, first through a convenience function, and then explicitly, comparing
 the type of a string Python with 
\family typewriter 
PyString_Type
\family default 
:
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Yes.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Yes.
\backslash 
n");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For returning data from Python to C, a complementary set of functions is
 offered, mapping the basic types of Python back to C types.
 Some examples of those functions that take a 
\family typewriter 
PyObject
\family default 
 pointer as an argument and return the correspondent C datum are 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 and 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Differently from the input functions, in these output functions no string
 copying takes place: the strings returned are pointers to memory stored
 internally by Python.
 The documentation recommends not to modify the content of the string except
 if the memory area was returned by a call to 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
size
\family typewriter 
\emph default 
)
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
 This way, it is possible to allocate a string for storage in Python and
 fill its contents later through C code, as in the following example:
\layout LyX-Code


\size footnotesize 
\emph on 
/* allocating an uninitialized string in Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtaining the pointer to the string memory area */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Now, we can fill the string in C.
 An example: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For some of its basic types that do not have direct correspondence in ANSI
 C 89, Python defines equivalent C types: 
\family typewriter 
Py_UNICODE
\family default 
 and 
\family typewriter 
Py_complex
\family default 
.
 These types were added in order to expose the internal representation of
 data used by Python in numeric manipulation and Unicode text modules implemente
d in C, avoiding frequent conversions to and from 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python also offers some versions of its C conversion functions as macros
 without type checking, assuming that the given 
\family typewriter 
PyObject
\family default 
 will be compatible, offering better performance in expense of safety.
 These functions can be identified by their uppercase names.
 Among the conversion macros provided are 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 and 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Besides functions for type conversions between Python and C, the Python
 API also offers some conversion functions between Python types.
 These functions receive a 
\family typewriter 
PyObject
\family default 
 as an argument and return a new 
\family typewriter 
PyObject
\family default 
 with the result of the conversion, and are equivalent to Python functions
 that perform these conversions (actually calls to 
\family typewriter 
PyTypeObject
\family default 
 types that answer to the 
\family typewriter 
__call__
\family default 
 method).
 For example, the 
\family typewriter 
PyObject_Str
\family default 
 function is equivalent to the Python function 
\family typewriter 
str
\family default 
.
\layout Standard

In Python, objects are stored in modules, which are namespaces declared
 globally, or as attributes of objects.
 Variables are stored in an 
\emph on 
environment
\emph default 
, represented as a dictionary.
 Functions such as 
\family typewriter 
PyRun_File
\family default 
 receive, among their parameters, a dictionary of global variables and another
 of local variables.
 The set of global variables and functions is represented as the dictionary
 of the 
\family typewriter 
__main__
\family default 
 module.
 Built-in objects are accessible through the 
\family typewriter 
__builtin__
\family default 
 module.
 For example, to obtain the 
\family typewriter 
str
\family default 
 object, we will initially obtain a reference to the 
\family typewriter 
__builtin__
\family default 
 module using the 
\family typewriter 
PyImport_AddModule
\family default 
 function and then the module's dictionary with the 
\family typewriter 
PyModule_GetDict
\family default 
 function.
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In Python, 
\family typewriter 
str
\family default 
 is a callable object, which acts as the string conversion function.
 So, once we obtained a reference to the PyObject equivalent to 
\family typewriter 
str
\family default 
, the following call is the same as calling 
\family typewriter 
PyObject_Str
\family default 
 on a given Python object 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* This is a vararg function that receives as additional arguments a
\layout LyX-Code


\size footnotesize 
\emph on 
   NULL-terminated list with PyObjects to be passed to the Python function
\layout LyX-Code


\size footnotesize 
\emph on 
   given in the first argument.
 */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The storage of C data in the Python object space can be done in two ways.
 One way is to create an object of the 
\family typewriter 
CObject
\family default 
 type encapsulating a C pointer, building this way a value that will be
 opaque to Python.
 The allocation functions for objects of this type allow to associate to
 the datum a C function to be called when the 
\family typewriter 
CObject
\family default 
 is deallocated.
 According to the Python documentation, 
\family typewriter 
CObjects
\family default 
 have as their main purpose passing C data between extension modules\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
\layout Standard

The other way is to declare new Python types through C structures.
 In C, a Python type is described in two parts: a struct type, from which
 instances of the type will be produced, and an instance of the 
\family typewriter 
PyTypeObject
\family default 
 struct, which will describe the type to Python.
 The following example illustrates the creating of a new Python type in
 C.
 Initially, we have 
\family typewriter 
point
\family default 
, which will be the C type of object instances:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
PyObject_HEAD
\family default 
 macro ensures structural equivalence with 
\family typewriter 
PyObject
\family default 
.
 When functions return the object to C code as a 
\family typewriter 
PyObject*
\family default 
, this will be able to be converted back to 
\family typewriter 
point
\family default 
 through a cast, giving then access to the 
\family typewriter 
x
\family default 
 and 
\family typewriter 
y
\family default 
 attributes.
 We will also define a function that operates on objects of this type:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(p->x*p->x + p->y*p->y) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function was defined with a 
\family typewriter 
PyObject
\family default 
* return type so that it can be registered in the Python virtual machine.
 To associate the function to the Python type, we will initially store it
 in an array of 
\family typewriter 
PyMethodDef
\family default 
 structures, which will list the type's methods:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To make the attributes of the type are visible from Python, we will have
 to implement an access routine, that receives the object and the name of
 the accessed attribute.
 Its implementation is given below:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once it is registered in the type description, this function will be responsible
 for returning the type's attributes and methods.
 This way, we can expose to the Python environment attributes stored in
 the C struct.
 The 
\family typewriter 
Py_FindMethod
\family default 
 function locates a function in the array given as its parameter and returns
 it as a method
\begin_inset Foot
collapsed false

\layout Standard

Registration of Python functions will be discussed in detail in Section
 \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

Finally, we will define 
\family typewriter 
point_type
\family default 
, which will be the 
\family typewriter 
PyTypeObject
\family default 
 that will describe the Python type relative to 
\family typewriter 
point
\family default 

\begin_inset Foot
collapsed false

\layout Standard

For brevity, we will present the example using the C99 syntax for structs,
 saving us from listing the elements that will be initialized with 
\family typewriter 
NULL
\family default 
, as the 
\family typewriter 
PyTypeObject
\family default 
 struct has 54 fields in total.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",             
\emph on 
/* The name of the class */
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  
\emph on 
/* The size of the memory area to be allocated */
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    
\emph on 
/* The attribute access function */
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT  
\emph on 
/* This class does not require special treatment */
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Again, a macro was used at the top of the definition to ensure structural
 equivalence.
 
\family typewriter 
PyTypeObject
\family default 
 has many other fields, but we will keep them 
\family typewriter 
NULL
\family default 
 so that they will be filled with default values during the construction
 of the type at runtime.
 The 
\family typewriter 
PyTypeObject
\family default 
 type contains a number of fields that allow to describe the behavior of
 the declared type.
 In the 
\family typewriter 
tp_getattr
\family default 
 field of 
\family typewriter 
point_type
\family default 
, we specified that the C function to be used to handle access to attributes
 will be 
\family typewriter 
point_getattr
\family default 
.
 We specified 
\family typewriter 
Py_TPFLAGS_DEFAULT
\family default 
 in the flags field to indicate that this is a class with a default behavior,
 without the need for special treatements such as cycle checking during
 garbage collection.
\layout Standard

While the in-memory representation of 
\family typewriter 
Python
\family default 
 objects of the user-defined type are instances of 
\family typewriter 
point
\family default 
, to create a new object it is not enough to allocate an instance of 
\family typewriter 
point
\family default 
 and use it as a 
\family typewriter 
PyObject
\family default 
 through casting.
 It is necessary to initialize the object so that it is registered in the
 garbage collection mechanism and it has the fields of its 
\family typewriter 
PyObject
\family default 
 header properly initialized.
 The allocation in C of new objects of a user-defined type must be done
 through the 
\family typewriter 
PyObject_New
\family default 
 macro, which receives as arguments the type of the struct to be allocated
 and the 
\family typewriter 
PyTypeObject
\family default 
 that corresponds to the type.
 The documentation recommends assigning the default construction function,
 
\family typewriter 
PyType_GenericNew
\family default 
, during runtime for portability reasons\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Finally, any undefined fields of the struct are filled by the 
\family typewriter 
PyType_Ready
\family default 
 function.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

From there on, instances can be created with 
\family typewriter 
PyObject_New
\family default 
, as in the example below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates an instance */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Stores the instance in the Python global 'P',
\layout LyX-Code


\size footnotesize 
\emph on 
   assuming the globals dictionary was stored in 'globals'.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Once declared in C, this value can be used by Python code:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The Python API has a large number of functions for manipulation of predefined
 types in the language.
 
\emph on 
Tuples
\emph default 
 deserve a special mention with regard to data transfer between Python and
 C, as they are used in several contexts: when passing arguments to Python
 functions from C, when receiving input arguments in C functions and also
 when passing and receiving multiple return values, as we will see in Sections\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 and\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

As tuples are frequently used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

 between Python and C, the API offers a convenience function, 
\family typewriter 
PyArg_ParseTuple
\family default 
, that saves the programmer from having to perform access and type checking
 of the tuple elements one by one.
 This is a vararg C function that receives as arguments the tuple, a string
 indicating the types of expected arguments and the addresses where the
 values, converted to C types, should be stored.
 The function defines a syntax for expected type identifiers in the given
 string and the correspondent C types.
 For example: 
\family typewriter 
"s#"
\family default 
 indicates that the tuple should contain a Python object of the 
\family typewriter 
string
\family default 
 or 
\family typewriter 
Unicode
\family default 
 type and that two parameters should be passed to the C function, with types
 
\family typewriter 
const char**
\family default 
 and 
\family typewriter 
int*
\family default 
, that will return the string pointer and its size, respectively.
 In a more elaborate example, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indicates that the function expects two integer addresses (
\family typewriter 
"ii"
\family default 
), followed by the address of a 
\family typewriter 
PyObject
\family default 
 pointer
\family typewriter 
\SpecialChar ~

\family default 
(
\family typewriter 
"O"
\family default 
) and a PyTypeObject to be used when type checking the received object\SpecialChar ~
(
\family typewriter 
"!"
\family default 
) and optionally\SpecialChar ~
(
\family typewriter 
"|"
\family default 
), two addresses of 
\family typewriter 
double
\family default 
 values given to Python through another tuple\SpecialChar ~
(
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

In a similar fashion, the Python API has the 
\family typewriter 
Py_BuildValue
\family default 
, which allows the construction of structured objects, such as tuples, lists
 and dictionaries, in a single call.
 This function is frequently used both in the construction of the argument
 tuple when calling functions and in the construction of return values.
 The syntax of the parameter string resembles that of 
\family typewriter 
PyArg_ParseTuple
\family default 
, but it features a different set of type indicators, and allows to describe
 lists and dictionaries.
 For example, the following call creates a list containing an integer, a
 floating point number and a dictionary containing an element with a string
 key and an integer value:
\layout LyX-Code


\size footnotesize 
PyObject* list = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

This is equivalent to the following Python construct:
\layout LyX-Code


\size footnotesize 
list = [123, 12.30, {"foo": 1234}]
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-dados}

\end_inset 


\layout Standard

For the communication of data between Ruby and C, the Ruby API defines a
 C data type called 
\family typewriter 
VALUE
\family default 
, which represents a Ruby object.
 
\family typewriter 
VALUE
\family default 
 may represent both a reference to an object (that is, a pointer to the
 Ruby heap) as well as an immediate value.
 In particular, the constants 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 and 
\family typewriter 
Qnil
\family default 
 are defined as immediate values, allowing them to be compared in C using
 the 
\family typewriter 
==
\family default 
 operator.
\layout Standard

For type checking, Ruby provides the 
\family typewriter 
Check_Type
\family default 
 and 
\family typewriter 
TYPE
\family default 
 macros.
 
\family typewriter 
Check_Type
\family default 
 allows one to compare the type of values to constants that describe basic
 types of Ruby such as
\family typewriter 
 T_OBJECT
\family default 
 and 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 returns the constant relative to the type of a given value.
 To check the class of an object, one should use 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

When transferring numeric values, the conversion between C and Ruby is made
 through macros such as 
\family typewriter 
INT2NUM
\family default 
 and functions such as 
\family typewriter 
rb_float_new
\family default 
, which receive or return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

For passing strings to Ruby from C, the API provides the 
\family typewriter 
rb_str_new
\family default 
 function, which receives a pointer and a numeric size argument, allowing
 the use of strings containing null characters, and the 
\family typewriter 
rb_str_new2
\family default 
 function, which assumes a standard C string, with the null character as
 a terminator.
 These functions make a copy of the C string to the data space of Ruby.
 
\family typewriter 
VALUE
\family default 
s that point to Ruby strings allow C code to access and modify their contents
 through the 
\family typewriter 
RSTRING(a_string)->ptr
\family default 
 cast.
 However, the API recommends the use of the 
\family typewriter 
StringValue
\family default 
 macro, which returns the 
\family typewriter 
VALUE
\family default 
 itself in case it is a string, or a new 
\family typewriter 
VALUE
\family default 
 of the 
\family typewriter 
String
\family default 
 class produced through the 
\family typewriter 
to_s
\family default 
 conversion method applied to the given object (or raises a 
\family typewriter 
TypeError
\family default 
 exception in case the conversion was not possible).
\layout LyX-Code


\size footnotesize 
void show_value(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* This would make an illegal access if TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Works for any type that accepts obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         otherwise, raises an exception */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Value: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Under the justification of increasing performance on access, some other
 Ruby types such as 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 and 
\family typewriter 
File
\family default 
 allow low-level access to the members of structures used in the implementation
 of their objects.
 For example, with 
\family typewriter 
RARRAY(an_array)->len
\family default 
 one can read the size of an array directly.
 The recommendation of the API is to use this kind of access for reads only,
 since the modification of these values can easily make the internal state
 of objects inconsistent.
\layout Standard

For storing C data in the Ruby object space, the API provides a macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, which receives a C pointer and creates a Ruby object which encapsulates
 this pointer.
 The pointer can be accessed from C code using 
\family typewriter 
Data_Get_Struct
\family default 
, bet not from Ruby.
 A C function to be executed when the object is collected is also passed
 to 
\family typewriter 
Data_Wrap_Struct
\family default 
.
 For example, we will create a 
\family typewriter 
Point
\family default 
 class, similar to the Python type defined in the previous section.
 We will initially define a C type:
\layout LyX-Code


\begin_inset LatexCommand \label{struct-point}

\end_inset 


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Allocation and deallocation functions for the 
\family typewriter 
Point
\family default 
 class (
\family typewriter 
point_alloc
\family default 
 and 
\family typewriter 
point_free
\family default 
) follow:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

 
\newline 

\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* The 2nd argument is the mark function for garbage collection
\layout LyX-Code


\size footnotesize 
\emph on 
      (NULL here as the type doesn't store VALUES), see Sec.
 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

 */
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, NULL, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that 
\family typewriter 
Data_Wrap_Struct
\family default 
 makes use of a 
\family typewriter 
VALUE
\family default 
 that represents the 
\family typewriter 
Point
\family default 
 class in Ruby.
 Classes are created in C with the 
\family typewriter 
rb_define_class
\family default 
 function.
 This function gets a C string with the name of the new class and a VALUE
 to be used as a superclass (such as for example the 
\family typewriter 
rb_cObject
\family default 
 constant, which represents the 
\family typewriter 
Object
\family default 
 Ruby class) and returns a 
\family typewriter 
VALUE
\family default 
 representing the new class.
 For classes such as 
\family typewriter 
Point
\family default 
, whose instances will contain C data, it is possible to register a C function
 that will be responsible for allocating memory of instances using the 
\family typewriter 
rb_define_alloc_func
\family default 
 function.
 So, the creation of the class and the registration of the allocation function
 are done as follows:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Like in Ruby code, the declaration of object attributes is done in the 
\family typewriter 
initialize
\family default 
 method, which can be implemented in C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The method is registered in the class at runtime with the 
\family typewriter 
rb_define_method
\family default 
 function (the registration of C functions in Ruby will be discussed in
 detail in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To ensure that the copy of objects through Ruby's 
\family typewriter 
dup
\family default 
 and 
\family typewriter 
clone
\family default 
 methods will handle correctly the data stored through C, it is necessary
 to register the 
\family typewriter 
initialize_copy
\family default 
 method.
 A possible implementation in C is given below:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby may call this function with the same object in both args;
\layout LyX-Code


\size footnotesize 
\emph on 
      in this case, ignore the call and return the object */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the pointers stored in the objects */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Copy of the 
\begin_inset Quotes eld
\end_inset 

C part
\begin_inset Quotes erd
\end_inset 

 of the object */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Returns the copy */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

We will complete the example with a C function implementing the 
\family typewriter 
distance
\family default 
 method, like it was done in the previous section for Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(p->x*p->x + p->y*p->y)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

These functions are also registered as methods of 
\family typewriter 
Point
\family default 
:
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
rb_class_new_instance
\family default 
 function produces new Ruby objects that are instances of the class, receiving
 a C array of 
\family typewriter 
VALUE
\family default 
s to be passed during object initialization and the class 
\family typewriter 
VALUE
\family default 
.
\layout Standard

Access of Ruby values is done through the 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
 family of functions, which return 
\family typewriter 
VALUE
\family default 
s relative to attributes of objects or classes, global variables and constants.
 For each of those there is an analogous 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 function
\begin_inset Foot
collapsed true

\layout Standard

Constants can be created with the 
\family typewriter 
Qundef
\family default 
 value and have their value defined later 
\emph on 
once
\emph default 
 with 
\family typewriter 
rb_const_set
\family default 
.
\end_inset 

.
 The 
\family typewriter 
rb_iv_get
\family default 
 and 
\family typewriter 
rb_ivar_get
\family default 
 functions, for example, obtain object attributes (
\emph on 
instance variables
\emph default 
).
 The first form uses C strings as names, the latter uses 
\family typewriter 
ID
\family default 
s, identifiers that replace interned strings in Ruby's symbol table, that
 can be obtained using the 
\family typewriter 
rb_intern
\family default 
 function.
 In fact, 
\family typewriter 
ID
\family default 
s correspond to the 
\emph on 
symbol
\emph default 
 Ruby type, which in practice are immutable strings.
 The following example obtains the value of a global variable 
\family typewriter 
g
\family default 
 and sets it to the field 
\family typewriter 
f
\family default 
 of an object, and then sets the value of the global variable to zero:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtains the global variable */
\layout LyX-Code


\size footnotesize 
VALUE g = rb_gv_get("g");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Sets the field f of object obj */
\layout LyX-Code


\size footnotesize 
VALUE obj = rb_gv_get("obj");
\layout LyX-Code


\size footnotesize 
rb_iv_set(obj, "f", g);
\emph on 
 /* Same as: rb_ivar_set(obj, rb_intern("f"), g); */
\layout LyX-Code


\size footnotesize 
\emph on 
/* Zeroes the global variable */
\layout LyX-Code


\size footnotesize 
rb_gv_set("g", INT2NUM(0));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard


\family typewriter 
ID
\family default 
s are never collected: we observed that the symbol table is not cleaned
 up even after 
\family typewriter 
ruby_finalize
\family default 
.
 So, a C application that offers a scripting interface creating supposedly
 isolated environments, surrounding each script execution with 
\family typewriter 
ruby_init
\family default 
 and 
\family typewriter 
ruby_finalize
\family default 
, may have its memory consumption increased indefinitely as scripts create
 symbols.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

The JNI defines in the 
\family typewriter 
jni.h
\family default 
 header C types equivalent to each of Java's primitive types (
\family typewriter 
jint
\family default 
 for 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 for 
\family typewriter 
float
\family default 
, and so on).
 The 
\begin_inset Quotes eld
\end_inset 

reference types
\begin_inset Quotes erd
\end_inset 

, such as classes and objects, are exposed to C as opaque references, instances
 of 
\family typewriter 
jobject
\family default 
.
 Strings and arrays are also objects in Java and are thus exposed as instances
 of 
\family typewriter 
jobject
\family default 
.
 However, the JNI defines as a convenience some C types that act as 
\begin_inset Quotes eld
\end_inset 

subtypes
\begin_inset Quotes erd
\end_inset 

 of jobject: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, and an array type for each primitive type (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 The 
\family typewriter 
jvalue
\family default 
 type is a union of primitive and reference types.
 The 
\family typewriter 
NULL
\family default 
 C value corresponds to Java's 
\family typewriter 
null
\family default 
.
\layout Standard

Different methods are employed for reading primitive types, strings, arrays
 and other objects.
 Reading the contents of a 
\family typewriter 
jstring
\family default 
 in C requires the conversion from the internal format used by Java, UTF-16.
 The API offers a utility function that allocates a string containing the
 representation of the text in UTF-8 (which is an ASCII-compatible format),
 
\family typewriter 
GetStringUTFChars
\family default 
.
 This string must be later deallocated with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
 The 
\family typewriter 
GetStringChars
\family default 
 function provides direct access to the string in UTF-16 format; it has
 an output argument that indicates if the returned string is the JVM's own
 internal buffer or if it is a copy.
 At the same time that this saves the C code from duplicating the string
 in cases when one wants to modify it and the JVM has returned a copy, this
 parameter exposes to the API low-level issues of the JVM string management.
 Alternatively, the 
\family typewriter 
GetStringRegion
\family default 
 and 
\family typewriter 
GetStringUTFRegion
\family default 
 functions perform a copy of the string to a pre-allocated buffer provided
 by the programmer.
 
\family typewriter 
GetStringCritical
\family default 
 returns a pointer to the JVM internal buffer, but this involves special
 care with regard to garbage collection, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays of primitive elements are handled in a similar way to strings, differentl
y from object arrays
\begin_inset Foot
collapsed true

\layout Standard

Multi-dimensional arrays are considered as 
\begin_inset Quotes eld
\end_inset 

arrays of arrays
\begin_inset Quotes erd
\end_inset 

 and, as such, are also object arrays.
\end_inset 

.
 There are functions for performing array copies (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), functions akin to 
\family typewriter 
GetStringChars
\family default 
 that return pointers to the array that may or may not perform copies (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) and functions that can access the JVM internal buffer, like in 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 For object arrays, it is not possible to obtain a pointer to an array's
 internal buffer.
 Access to elements is performed one at a time, through 
\family typewriter 
jobject
\family default 
 references, with 
\family typewriter 
Get
\family default 
/
\family typewriter 
SetObject\SpecialChar \-
ArrayElement
\family default 
.
\layout Standard

The retrieval of values and attributes is done through functions such as
 
\family typewriter 
GetObjectField
\family default 
 and 
\family typewriter 
GetStaticField
\family default 
, which return reference of the 
\family typewriter 
jobject
\family default 
 type.
 For each primitive type there is an equivalent type, such as 
\family typewriter 
GetIntField
\family default 
 and 
\family typewriter 
GetStaticIntField
\family default 
.
 Like in Ruby, the Java API defines a specific C type to avoid the frequent
 use of C strings in the description of fields.
 However, while ruby uses 
\family typewriter 
ID
\family default 
s which are merely interned strings, in Java field identifiers, of the 
\family typewriter 
jfieldID
\family default 
 type, contain type information and are specific for a field of a given
 class.
 These values are obtained with the 
\family typewriter 
GetFieldID
\family default 
 call, which receives among its arguments a string called the 
\begin_inset Quotes eld
\end_inset 

JNI field descriptor
\begin_inset Quotes erd
\end_inset 

 with a special syntax.
 For example, the Java type 
\family typewriter 
int[][]
\family default 
 is described with 
\family typewriter 
"[[I"
\family default 
 and the 
\family typewriter 
java.lang.String
\family default 
 type as 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This is another place where implementation details leak through the API.
 Not coincidently, this syntax is the same used in the internal representation
 of types in JVM bytecodes.
\end_inset 

.
 It is also possible to obtain a 
\family typewriter 
jfieldID
\family default 
 from a 
\family typewriter 
java.lang.reflect.Field
\family default 
 object using the 
\family typewriter 
FromReflectedField
\family default 
 function.
\layout Standard

JNI calls are done in C with 
\family typewriter 
(*J)->
\family default 
\emph on 
function
\family typewriter 
\emph default 
(J,
\family default 
 ...
\family typewriter 
)
\family default 
: JNI functions are accessed through function pointers stored in a table
 pointed by a 
\family typewriter 
JNIEnv
\family default 
 structure, which is then propagated in calls.
 The goal of these two levels of indirection is to decouple the linkage
 of calls in C code from the library that implements the JNI, allowing to
 link the code at runtime to different implementations of the JVM\SpecialChar ~

\begin_inset LatexCommand \cite{stepanian05inliningjava}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExampleJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elements = { "Earth", "Air", "Fire", "Water" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaration of the externally implemented method */
\layout LyX-Code


\size footnotesize 
   private native void secondElement();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Creates an instance and invokes the native method */
\layout LyX-Code


\size footnotesize 
      new ExampleJNI().secondElement();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Loads in the JVM the external code that will implement
\layout LyX-Code


\size footnotesize 
\emph on 
         the secondElement method */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExampleJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Java class containing an externally implemented method
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExampleJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExampleJNI_secondElement(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the class of 'this': ExampleJNI */
\layout LyX-Code


\size footnotesize 
   jclass klass = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get ExemploJNI.elements, a String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, klass,
\layout LyX-Code


\size footnotesize 
      "elements", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the contents of ExemploJNI.elements */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elements[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the representation of elems_1 as a C string */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Show the string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Free the memory of the string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

C code implementing a Java method
\end_inset 


\layout Standard

The access to Java attributes in C code is illustrated through the following
 example.
 Initially, in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, we implement a Java class that has a private attribute, the elements 
\family typewriter 
array
\family default 
, and defines a function, 
\family typewriter 
secondElement
\family default 
, to be implemented in C
\begin_inset Foot
collapsed true

\layout Standard

Details about the declaration and registration of functions implemented
 in C will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

The implementation of 
\family typewriter 
secondElement
\family default 
 is presented in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, showing the sequence of calls needed to obtain in C the element of the
 Java array.
 To access the 
\family typewriter 
elements
\family default 
 attribute, the function has to obtain the field identifier.
 For that, we need first to obtain a reference of the current class with
 
\family typewriter 
GetObjectClass
\family default 
 from the object reference (
\family typewriter 
this
\family default 
) passed a parameter to the function.
 Once we have the class reference (
\family typewriter 
klass
\family default 
), we obtain the field identifier with 
\family typewriter 
GetFieldID
\family default 
.
 The content of the field is then obtained with 
\family typewriter 
GetObjectField
\family default 
: a reference to the array.
 Using it, the element of the array is obtained with 
\family typewriter 
GetObjectArrayElement
\family default 
.
 A copy of the element, converted to a UTF-8-encoded C string, is returned
 with 
\family typewriter 
GetStringUTFChars
\family default 
.
 As previously discussed, after its use, the string must be freed with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

The manipulation of objects of the 
\family typewriter 
Class
\family default 
 type is also done through specific functions.
 It is not possible to create Java classes through the C API, but it is
 possible to load classes at runtime using the 
\family typewriter 
DefineClass
\family default 
 function, which receives a buffer containing the representation of a pre-compil
ed Java class.
 References of the 
\family typewriter 
jclass
\family default 
 type can be obtained from the class name using 
\family typewriter 
FindClass
\family default 
, which uses a syntax for descriptors similar to that used by 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

In both field and class descriptors, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 represents 
\family typewriter 
String[]
\family default 
.
 For the 
\family typewriter 
String
\family default 
 type, however, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 is the field descriptor and 
\family typewriter 
"java/lang/String"
\family default 
 the class descriptor.
\end_inset 

.
\layout Standard

For assigning C values that can be converted to Java primitive types, the
 JNI provides functions such as 
\family typewriter 
SetIntField
\family default 
 and 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 For other types, there are no specific provisions for storing C data in
 the Java object space.
 In those cases, the documentation suggests the storage of pointers in numeric
 types\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

, in spite of the portability limitations brought by this approach.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

The Lua API defines a different approach for manipulating data in C: no
 pointers or handles to Lua objects are ever exposed to C code.
 Operations are defined in terms of indices of a virtual stack.
 So, data transfer from C to Lua takes place through functions that receive
 C types, convert them to Lua values and stack them, such as 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 and 
\family typewriter 
lua_pushlstring
\family default 
.
 Several operations of the API operate on the value at the top of the stack,
 such as, for example, 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

API functions that operate on a Lua execution state receive an initial argument
 (in our examples, called 
\family typewriter 
L
\family default 
), indicating the state they refer to.
 This will be discussed later, in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Inserts the number 123 in the stack */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Sets the number 123 to global 
\emph default 
foo
\emph on 
 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Most lookup functions, however, allow one to specific any stack index (with
 positive values for indexing from the bottom and negative values for indexing
 from the top).
\layout Standard

Conversion of data from Lua to C is made through functions such as 
\family typewriter 
lua_tonumber
\family default 
 and 
\family typewriter 
lua_tolstring
\family default 
, which receive a stack index, convert the value at the given index to the
 specified Lua type if necessary, and return the value converted to the
 equivalent C type.
 Numbers have the 
\family typewriter 
lua_Number
\family default 
 C type, which corresponds to 
\family typewriter 
double
\family default 
 by default but is a compile-time parameter for the Lua virtual machine.
 Strings, in particular, are immutable objects and are interned: any two
 identical strings share the same internal representation.
\layout Standard

So, unlike languages such as Python and Ruby, it is not possible to modify
 the contents of a Lua string from C through its memory representation as
 a 
\family typewriter 
char*
\family default 
.
 To make the incremental construction of Lua strings from C more efficient,
 the Lua auxiliary library defines a C type called 
\family typewriter 
luaL_Buffer
\family default 
 and functions such as 
\family typewriter 
luaL_addstring
\family default 
 and 
\family typewriter 
luaL_addvalue
\family default 
, which allow the construction of a string in stages until it can be finally
 converted to a Lua string with 
\family typewriter 
luaL_pushresult
\family default 
.
 This way, one avoids consecutive string concatenation operations through
 the Lua API.
\layout Standard

Lua defines two specific data types for storing C data, 
\emph on 
full userdata
\emph default 
 and 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 describe memory blocks managed by Lua and used by C code.
 They exist in Lua as opaque objects, and are created by 
\family typewriter 
lua_newuserdata
\family default 
, which inserts the new object in the Lua stack and returns to C a pointer
 to the memory area of the requested size.
 Objects of the 
\emph on 
light userdata
\emph default 
 type, created through 
\family typewriter 
lua_pushlightuserdata
\family default 
, allow storing C pointers in Lua; allocation and management of the memory
 block are to be handled by C code.
 The following example illustrates the use of userdata, assuming the same
 
\family typewriter 
point
\family default 
 struct defined on page\SpecialChar ~

\begin_inset LatexCommand \pageref{struct-point}

\end_inset 

.
 The userdata object is created this way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a full userdata, inserts it in the stack and returns
\layout LyX-Code


\size footnotesize 
\emph on 
   the pointer to C.
 The memory is allocated by Lua.
 */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* We then use the pointer in C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the object to the global variable 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard

Now, accessing it:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Pushes the global 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the C pointer from the userdata at the top of the stack (-1) */
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d)
\backslash 
n", p->x, p->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restores the stack to its original position, removing the item.
\layout LyX-Code


\size footnotesize 
\emph on 
   It won't be collected, as it is tied to the global variable.
 */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assuming that the global 
\family typewriter 
Point
\family default 
 is the only reference to this block, to free it all we have to do is overwrite
 
\family typewriter 
Point
\family default 
 with, for example, 
\family typewriter 
nil
\family default 
; the memory of the full userdata will then be eligible for retrieval by
 the garbage collector, like that of any Lua value with no references.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The stack storage area does not adjust itself dynamically and the API functions
 do not perform overflow checks.
 So, the programmer is responsible for controlling the stack size, through
 the 
\family typewriter 
lua_checkstack
\family default 
 function.
 In practice, the stack size will only grow in loops pushing elements, since
 typical sequences of operations tend to push values and pop them later.
\layout Standard

Tables are the only type available for construction of data structures in
 Lua.
 Lua offers a complete API for manipulation of tables from C.
 Tables can be created with 
\family typewriter 
lua_newtable
\family default 
 or 
\family typewriter 
lua_createtable
\family default 
; the second form allows one to pre-allocate memory for table elements.
 The 
\family typewriter 
lua_gettable
\family default 
 and 
\family typewriter 
lua_settable
\family default 
 implement the semantics of reading and writing fields to a Lua table, including
 eventual calls to metamethods; for calls without metamethod invocation
 there are 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, which are equivalent to 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 in Lua (besides two convenience variants, 
\family typewriter 
lua_rawgeti
\family default 
 and 
\family typewriter 
lua_rawseti
\family default 
).
 There is also the 
\family typewriter 
lua_next
\family default 
 function, equivalent to the Lua function 
\family typewriter 
next
\family default 
, which is designed for traversing elements of a table.
 An example of table manipulation is given below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tbl["key"] = 12345, in C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tbl");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "key");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable inserts the item at the top of the stack
\layout LyX-Code


\size footnotesize 
\emph on 
   to the table given as a parameter,
\layout LyX-Code


\size footnotesize 
\emph on 
   using as a key the item right below the top: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Many Lua concepts are represented through tables -- the global environment,
 metatables, registry -- are are thus handled in C using the API functions
 for table manipulation.
 The global environment table of the currently executing thread can be accessed
 through a special index of the virtual stack, 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 One can also define a function environment table, indexed with 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, to isolate data to be shared internally by functions in modules written
 in C.
 For example, the global environment can be manipulated as a table this
 way:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "Point");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Standard

This is equivalent to:
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

The procedures for extending and embedding Perl are very different from
 each other.
 For extensions, Perl provides an interface description language called
 XS.
 Instead of isolating the access to Perl's internal structures through a
 public API, the proposed approach is to encapsulate the process of generating
 wrapper code for the communication of functions written in C to the internal
 structures of Perl using interfaces written in XS.
 Files of the 
\family typewriter 
.xs
\family default 
 type contain C code along with annotation that simplifies the handling
 of input and output parameters.
 These are fed to the 
\family typewriter 
xsubpp
\family default 
 pre-processor, which generate then code using the API provided by the Perl
 library.
 This library offers low-level access to the inner workings of the interpreter,
 allowing one, for example, to manipulate its internal stack pointer.
 The goal of XS is to hide these details from the extension developer.
\layout Standard

To embed the Perl interpreter to an application, the library that implements
 it offers some functions that allow one to launch an interpreter.
 In the higher-level API, one can build an array of arguments to be passed
 to the interpreter in the same way as options are given to the Perl command-lin
e interpreter, even using the 
\family typewriter 
"-e"
\family default 
 flag to execute pieces of code.
\layout Standard

The types of Perl variables are mapped to C structs: 
\family typewriter 
SV
\family default 
 for scalars, 
\family typewriter 
AV
\family default 
 for arrays, 
\family typewriter 
HV
\family default 
 for hashes.
 These C values are better understood as 
\emph on 
containers
\emph default 
 to Perl values: a scalar variable in Perl has an 
\family typewriter 
SV
\family default 
 associated to itself; however, one can create in C an 
\family typewriter 
SV
\family default 
 that is not associated to any Perl variable name.
\layout Standard

Primitive types of Perl are represented as C values through typedefs: 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 and 
\family typewriter 
PV
\family default 
 correspond, respectively, to signed and unsigned integers, floating-point
 values and strings.
 These values can be copied to 
\family typewriter 
SV
\family default 
s.
 Perl references are represented as 
\family typewriter 
RV
\family default 
, and are also a kind of 
\family typewriter 
SV
\family default 
.
 There is also the 
\family typewriter 
GV
\family default 
 type, which represents any type representable through a Perl variable.
\layout Standard

Variables from the Perl data space are accessed with 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 and 
\family typewriter 
get_hv
\family default 
.
 These functions receive a C string with the variable name (possibly qualified
 through the 
\family typewriter 
"package::variable"
\family default 
 syntax).
 The content of scalar values are converted back to C ytpes with the 
\family typewriter 
Sv
\family default 
* macros: 
\family typewriter 
SvIV
\family default 
 returns an integer, 
\family typewriter 
SvPV
\family default 
 returns a 
\family typewriter 
char*
\family default 
 and the string length in the second argument, etc.
 The following C code prints the contents of the Perl variable 
\family typewriter 
$a
\family default 
, assuming it contains an integer value:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The flag given as a second argument for 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 indicates whether the variable should be created if the given name does
 not correspond to an existing varible.
 Passing an unexisting name and using 
\family typewriter 
TRUE
\family default 
 as the second argument is a convenient way to create a new variable accessible
 from the C space and at the same making its binding in the Perl space.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a variable of the array type,
\layout LyX-Code


\size footnotesize 
\emph on 
   accessible in Perl as the global @arr and in C as the AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

An 
\family typewriter 
SV
\family default 
 can be created in C with the 
\family typewriter 
newSV
\family default 
* family of functions: 
\family typewriter 
newSViv
\family default 
 generates a new SV storing a signed integer; 
\family typewriter 
newSVpv
\family default 
 stores a string, and so on.
 The 
\family typewriter 
newSV
\family default 
 function creates a 
\family typewriter 
SV
\family default 
 with an uninitialized memory area, accessible through the 
\family typewriter 
SvPVX
\family default 
 function, providing a way to create scalars with arbitrary values generated
 by C code.
 Using the same example of the 
\family typewriter 
point
\family default 
 struct from previous sections, we can store a C object in a Perl value
 in the following way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Allocates an unitialized SV, the size of a 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the pointer to the SV's memory area */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipulates the 
\emph default 
point
\emph on 
 in C.
 When v is returned to Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
it will be an opaque variable (its contents won't be accessible).
 */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Values are assigned to 
\family typewriter 
SV
\family default 
s using the 
\family typewriter 
sv_set
\family default 
* family of functions: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 Functions for string handling have variants such as 
\family typewriter 
newSVpvn
\family default 
 and 
\family typewriter 
sv_setpvf
\family default 
, which receive the string length or perform 
\family typewriter 
sprintf
\family default 
-style formatting.
 For strings, there are also the 
\family typewriter 
sv_cat
\family default 
* functions, which act like 
\family typewriter 
sv_set
\family default 
* but concatenate the value given to the current content of the string instead
 of replacing it.
 The 
\family typewriter 
sv_setsv
\family default 
 function copies the value of an 
\family typewriter 
SV
\family default 
 to another.
 The 
\family typewriter 
SV
\family default 
 created in the previous example can be assigned to a global variable like
 this:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the SV from the global 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* pnt = get_sv("point", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the value of 
\emph default 
v
\emph on 
 to 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
sv_setsv(pnt, v);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The type of data stored in 
\family typewriter 
SV
\family default 
s is checked with the 
\family typewriter 
SvIOK
\family default 
 macro for integers, 
\family typewriter 
SvNOK
\family default 
 for floating-point values, and 
\family typewriter 
SvPOK
\family default 
 for strings.
 These functions return success if the scalar is convertible to the specified
 type -- the variants 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verify if the value stored in the 
\family typewriter 
SV
\family default 
 is actually of that type.
\layout Standard

Arrays and hashes are created with 
\family typewriter 
newAV
\family default 
 and 
\family typewriter 
newHV
\family default 
.
 Arrays can be populated with a C array of 
\family typewriter 
SV
\family default 
 pointers through 
\family typewriter 
av_make
\family default 
.
 Operations such as 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 and 
\family typewriter 
hv_exists
\family default 
 operate on elements of these structures.
 In 
\family typewriter 
av_fetch
\family default 
 and 
\family typewriter 
hv_fetch
\family default 
, the return type is 
\family typewriter 
SV**
\family default 
, to differentiate between returning an existing element which points to
 
\family typewriter 
NULL
\family default 
 from returning 
\begin_inset Quotes eld
\end_inset 

element not found
\begin_inset Quotes erd
\end_inset 

.
 In the following example, we create a Perl array containing the 10 first
 elements of the Fibonacci series:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Create a new array.
 */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Store two values, 0 and 1, at its first positions.
 */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviously, it would be more efficient to store these values in
\layout LyX-Code


\size footnotesize 
\emph on 
      temporary values in C, but we'll obtain the last two values
\layout LyX-Code


\size footnotesize 
\emph on 
      back from the Perl array for illustration purposes: */
\layout LyX-Code


\size footnotesize 
   SV** next_to_last_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** last_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the integers stored in those SVs */
\layout LyX-Code


\size footnotesize 
   int next_to_last = SvIV(*next_to_last_sv);
\layout LyX-Code


\size footnotesize 
   int last = SvIV(*last_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Create a new SV and insert it in the end of the array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( next_to_last + last ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once this 
\family typewriter 
AV
\family default 
 is created, however, there is no way to associate it to a Perl variable.
 Its contents must be copied item by item.
 To make it accessible from Perl, we should have created it with 
\family typewriter 
get_av
\family default 
, and not 
\family typewriter 
newAV
\family default 
.
 
\family typewriter 
AV
\family default 
s that are not associated to variables are useful, however, when passing
 arguments in function calls and as return values.
\layout Standard

Some functions for hash manipulation expose the key/value pairs as 
\family typewriter 
HE
\family default 
 pointers.
 The 
\family typewriter 
HeSVKEY
\family default 
 and 
\family typewriter 
HeVAL
\family default 
 macros extract the key and value from an 
\family typewriter 
HE
\family default 
.
 The following C function prints the elements of a Perl hash:
\layout LyX-Code


\size footnotesize 
void print_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Each HV keeps its own internal iteration control */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the next key/value pair in the iteration */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Get the string representation of scalars
\layout LyX-Code


\size footnotesize 
\emph on 
         representing key and value of the item */
\layout LyX-Code


\size footnotesize 
      char* key = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* value = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", key, value);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Special care should be taken when using the values 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 and 
\family typewriter 
false
\family default 
 in arrays and hashes, even though Perl exposes these constants in its C
 API (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 The constant 
\family typewriter 
PL_sv_undef
\family default 
 is used internally in the implementation of 
\family typewriter 
AV
\family default 
s and 
\family typewriter 
HV
\family default 
s, and the update of values in 
\family typewriter 
HV
\family default 
s happens in-place, which generates problems when updating elements containing
 these constants.
 The documentation recommends generating copies of these values when using
 them in 
\family typewriter 
AV
\family default 
 and 
\family typewriter 
HV
\family default 
 structures\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlguts}

\end_inset 

.
\layout Standard

Perl references are created with 
\family typewriter 
newRV_inc
\family default 
 and 
\family typewriter 
newRV_noinc
\family default 
, which receive an 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 pointer as a parameter (these two functions differ in how they handle reference
 counted, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 The value pointed by a reference is obtained with 
\family typewriter 
SvRV
\family default 
.
 The return value of this macro must be converted through a cast to the
 appropriate type (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), which can be checked with 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Many functions of the API have argument or return types declared as 
\family typewriter 
SV
\family default 
 when in fact they accept 
\family typewriter 
AV
\family default 
s or 
\family typewriter 
HV
\family default 
s; this is analogous to the concept of Perl 
\emph on 
contexts
\emph default 
, in which the same value can be treated as a list (array or hash) or scalar
 depending on the expression where it is inserted\SpecialChar ~

\begin_inset LatexCommand \cite{marquess06perlcall}

\end_inset 

.
 In Perl code, the context where a function is executed can be inspected
 with 
\family typewriter 
wantarray
\family default 
.
 In C, the context can be checked with the 
\family typewriter 
GIMME_V
\family default 
 macro, which returns 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 or 
\family typewriter 
G_ARRAY
\family default 
.
\layout Subsection

Comparison
\layout Standard

The basic set of functions for manipulating data in the five languages presented
 here is similar: all of them provide functions for converting values from
 the language to basic C types and vice versa.
 All of them also offer functions for manipulating their fundamental structured
 types (tables in Lua, arrays in Java, arrays and hashes in Ruby and Perl,
 lists and dictionaries in Python).
 Python, in particular, defines an extensive function API for operations
 on its built-in classes; most of these functions could be performed using
 the generic API for method invocation, but they are offered directly in
 C as a convenience.
\layout Standard

Lua stands out for having, with its stack model, the simplest and most orthogona
l data manipulation API among the ones studied.
 However, the resulting code often loses in readability when the stack indices
 are not obvious.
 It is commonplace to see C code using the Lua API commented line by line,
 to save the programmer from having to simulate mentally the stack operations
 while reading the program.
\layout Standard

In Java, static typing reduces greatly the need of explicit data conversion
 in C code.
 On the other hand, treatment of multi-threading complicates the access
 of types such as strings and arrays.
\layout Standard

A negative point in the Ruby API is the exposure of implementation details
 of the struct fields that describe its fundamental 
\family typewriter 
VALUE
\family default 
 type.
 This restricts the flexibility of the language implementation and fosters
 unsafe programming practices.
 Perl also exposes a good deal of its internal structures; not as directly
 as Ruby, but through macros.
 These macros, however, assume the adherence to usage protocols so strict
 that in practice they also largely limit the possibilities of changes in
 the implementation (an example of this is the sequence for function calls,
 which will be presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

).
\layout Standard

The creation of data containing C structures stored by the scripting language
 is an easy task in Perl, Ruby and Lua: Perl allows one to create 
\family typewriter 
SV
\family default 
s containing arbitrary memory blocks for use in C; Ruby offers the 
\family typewriter 
Data_Wrap_Struct
\family default 
 macro which generates a Ruby object which encapsulates a C structure; Lua
 defines a basic type in the language especially for this end.
 In Python, on its turn, the process is not as straightforward.
 Creating a Python class from C involves declaring parts of it statically
 and other parts dynamically, being usually necessary to define three different
 C structures.
 In Java, it is not possible to create new types from C, one can only load
 classes.
\layout Standard

Another common task when interacting with C is the need to store pointers
 in the data space of the scripting language.
 Python, Lua and Perl offer features to do this directly: creating a 
\family typewriter 
PyCObject
\family default 
 in Python; a light userdata in Lua; or storing a pointer in the data area
 of an 
\family typewriter 
SV
\family default 
 in Perl.
 In Java and Ruby, the alternative is to convert pointers and store them
 as numbers.
 In fact, this happens internally in the implementation of Ruby, and the
 portability limitations of this approach are made evident by the fact that
 the compilation of Ruby fails if 
\family typewriter 
sizeof(void*) != sizeof(long)
\family default 
.
\layout Standard

Finally, an aspect that deserves being mentioned is the concern on not polluting
 the C namespace.
 Python, Java and Lua define all its functions and C types with prefixes
 that aim to avoid conflicts with names defined by the application.
 Perl and Ruby define names in a disorganized fashin, which occasionally
 causes problems
\begin_inset Foot
collapsed true

\layout Standard

For example, conflicts of this kind happened in the Ruby bindings of the
 Subversion revision control system in Win32 platforms (
\begin_inset LatexCommand \url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}

\end_inset 

).
\end_inset 

.
 Perl has options to disable a series of macros and force a common prefix
 in its functions, but this feature is incomplete and using it hampers the
 functionality of its headers
\begin_inset Foot
collapsed true

\layout Standard

In the case study presented in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

, when using the Perl API we tried to restrict ourselves to the 
\family typewriter 
Perl_
\family default 
-prefixed versions of the API functions, but many necessary macros are only
 available in versions with no prefix.
\end_inset 

.
\layout Section

Garbage collection
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

From the moment when C code gains access to references to data stored in
 the storage space of another language, be them pointers or identifiers,
 the programmer must take into consideration the differences between the
 memory management models involved, since code executed in the other language
 may free the data.
 For example, the C program may deallocate an object referenced by data
 in the scripting language, or the scripting language may remove an element
 from a structure causing it to be collected.
 In principle, this task of maintaining consistency between these two environmen
ts is no different from manual memory management normally taken care by
 C programmers.
 However, the interaction with some languages adds an important factor of
 complexity: the garbage collection mechanisms perform deallocation of data
 from memory in an implicity manner.
 The fundamental principle of garbage collection dictates that an object
 is not collected in case there is some element (variable, data structure)
 pointing to it.
 However, the same is not valid for the C environment: the presence of a
 pointer pointing to an object does not guarantee that it will not be collected,
 given that the garbage collector does not manage pointers from C code.
\layout Standard

It is necessary, then, to indicate from C code that the data remain accessible
 from it and must not be collected.
 In a complementary way, when transferring the control of C objects to the
 domain of the other language -- for example, when storing them in a data
 structure of the other language -- it is necessary to indicate to the language
 how to deallocate the memory of the structure when the garbage collector
 detects that it is no longer in use.
 The way how the API will provide these functionalities depends not only
 of the design of the C API, but also of the garbage collection mode employed
 by the implementation of the language.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

The Python virtual machine features a garbage collector based on reference
 counting.
 As the Python API returns to C code pointers to 
\family typewriter 
PyObject
\family default 
s, the programmer must have the care of ensuring that they will remain valid.
 For such, it is necessary to increment and decrement the pointed object's
 reference count according to how one wants to control the validity of the
 pointers in C code.
\layout Standard

In general, once the C code needs to retain a 
\family typewriter 
PyObject*
\family default 
, it should use the 
\family typewriter 
Py_INCREF
\family default 
 macro to increment its reference count and so prevent it from being collected.
 Once the value is no longer needed, the reference count should be accordingly
 decremented with 
\family typewriter 
Py_DECREF
\family default 
.
 Python works with the concept of 
\emph on 

\begin_inset Quotes eld
\end_inset 

reference ownership
\begin_inset Quotes erd
\end_inset 


\emph default 
 to define when the programmer needs to increment or decrement the counter
 of references returned by API functions.
 Most API functions that return pointers to 
\family typewriter 
PyObject
\family default 
s transfer references to the caller; the reference becomes the caller's
 responsibility -- it can either pass it on or it will have to decrement
 it with 
\family typewriter 
Py_DECREF
\family default 
 when it is not needed anymore (C code can store owned references in its
 data structures; they will remain valid even after the return of the function,
 until they are explicitly decremented).
 Other functions 
\emph on 
lend
\emph default 
 references; the code that borrows the reference does not need to decrement
 it after using it, but the validity of the object is attached to the validity
 of the reference in the object that returned it to C.
 For example, 
\family typewriter 
PyList_GetItem
\family default 
 lends a reference to an element of the list.
 The pointer returned will remain valid while the the item remains stored
 in the list.
 It is possible to obtain 
\begin_inset Quotes eld
\end_inset 

ownership
\begin_inset Quotes erd
\end_inset 

 of a borrowed reference by incrementing the object count with 
\family typewriter 
Py_INCREF
\family default 
: the validity of the pointer becomes independent from the container object
 that returned it, but the C code becomes responsible for decrementing the
 reference later with 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

For object references passed from C back to Python, there are two cases
 in the API where functions 
\emph on 

\begin_inset Quotes eld
\end_inset 

steal
\begin_inset Quotes erd
\end_inset 


\emph default 
 references, that is, in which the reference no longer belongs to the calling
 C function: 
\family typewriter 
PyList_SetItem
\family default 
 and 
\family typewriter 
PyTuple_SetItem
\family default 
.
 The given reference, which belonged to the caller, becomes owned by the
 list or tuple.
 In the context of the caller, it is now a borrowed reference, which does
 not have to be decremented anymore.
 The point of this is to allow nested function calls where, for example,
 the argument for 
\family typewriter 
PyList_SetItem
\family default 
 is a call that generates a new object to be stored in the list.
 So, this avoids having to store a pointer to the object only to decrement
 its reference later.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Possibly invalid access in 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 is definitely valid in 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Possibly invalid access in a reference to a 
\family typewriter 
PyObject
\family default 
 in C code
\end_inset 


\layout Standard

The interaction with the reference counter can be very subtle.
 The example in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extracted from the Python documentation, demonstrates that a reference
 can be invalidated by apparently unrelated code
\begin_inset Foot
collapsed true

\layout Standard

In fact, the documentation informs that older versions of Python contained
 variants of this bug in some of its modules.
\end_inset 

.
 At first sight, the insertion of an element in 
\family typewriter 
list[1]
\family default 
 seems not to affect the 
\family typewriter 
item
\family default 
 reference, which corresponds to 
\family typewriter 
list[0]
\family default 
.
 However, the insertion of 
\family typewriter 
list[1]
\family default 
 may have removed from the list an element that was in this position.
 In case the list was the last valid reference to the element, it might
 be collected.
 The collection of the object can invoke its finalizer method 
\family typewriter 
__del__
\family default 
, that can run arbitrary Python code.
 If this code removes the element from position 0 of 
\family typewriter 
list
\family default 
 and this triggers its collection, 
\family typewriter 
item
\family default 
 becomes invalid, because 
\family typewriter 
PyList_GetItem
\family default 
 returns a borrowed reference.
\layout Standard

When implementing C functions that return references to 
\family typewriter 
PyObject
\family default 
s, the same care of defining the lifetime policy of the reference should
 be taken.
 To return a new reference to be owned by the caller, it may be necessary
 to increment the object's count.
 This manifests itself, for example, in the correct way for a C function
 to return the value None, which involves calling 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This pattern is so common that the sequence 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 was encapsulated in the 
\family typewriter 
Py_RETURN_NONE
\family default 
 macro.
\end_inset 

.
 Even Python objects representing numbers need to have their reference count
 controlled by the C programmer.
\layout Standard

It is possible to define a deallocation function in the 
\family typewriter 
tp_dealloc
\family default 
 field of the 
\family typewriter 
PyTypeObject
\family default 
 structure so that C code can perform finalization operations over data
 stored in a Python type defined in C.
 This function is normally responsible for freeing resources allocated through
 C code (open files, pointers to memory areas unaccessible from Python,
 etc.) and decrementing references to other Python objects maintained by
 the object.
\layout Standard

When deallocating data structures such as lists it is possible to trigger
 an arbitrarily large chain of deallocations, as each element causes the
 deallocation of the next element of the structure.
 This launches the deallocation function recursively and could easily cause
 a stack overflow in C.
 To work around this problem, Python includes a pair of macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 and 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, that control the accepted number of recursion levels.
 At each execution of 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 an internal counter is incremented.
 While this counter does not reach the limit value defined in the 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 constant (50 by default), the function runs normally.
 When the limit is reached, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 stores the object in an internal list and jumps straight to 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, avoiding the deallocation the object and another recursion.
 At the end of each level of the recursion, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 decrements the counter.
 When the counter reaches zero, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 launches again 
\family typewriter 
tp_dealloc
\family default 
 on the elements stored in the internal list, restarting then the recursion
 on the structure.
 So, a chain of 
\begin_inset Formula $n$
\end_inset 

 deallocations is broken into 
\begin_inset Formula $n/$
\end_inset 


\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 chains, none of them exceeding 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 levels of recursion in the C stack.
 The implementation of the main structured types of Python, such as lists,
 tuples and dictionaries, make use of this mechanism.
\layout Standard

Garbage collection using reference counts brings with it concerns about
 circular references: a chain of objects maintaining references to each
 other keeps the count of each of its elements greater than zero, even if
 they are not reachable from any other object.
 Python includes a cycle detector, but special measures must be taken to
 ensure that types implemented in C behave correctly if they can generate
 cycles.
 One must implement a function to traverse references contained in the object
 and a function to decrement their reference counts.
 These functions must be registered in the 
\family typewriter 
tp_traverse
\family default 
 and 
\family typewriter 
tp_clear
\family default 
 fields of the 
\family typewriter 
PyTypeObject
\family default 
 structure.
 The 
\family typewriter 
tp_clear
\family default 
 function has to take the precaution of clearing the value of its 
\family typewriter 
PyObject*
\family default 
 fields to 
\family typewriter 
NULL
\family default 
 before decrementing each reference, since the decrement operation may start
 the deallocation of the object and launch a call to 
\family typewriter 
tp_traverse
\family default 
 which, due to the cycle, may return to the previous object.
 The type must be, then, identified with the 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 flage in the 
\family typewriter 
tp_flags
\family default 
 field of 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard

Besides, the implementation of Python objects that support cyclic collection
 in C implies in yet more care.
 Objects must be allocated with 
\family typewriter 
PyObject_GC_New
\family default 
 or 
\family typewriter 
PyObject_\SpecialChar \-
GC_NewVar
\family default 
 instead of the usual functions 
\family typewriter 
PyObject_New
\family default 
 and 
\family typewriter 
PyObject_NewVar
\family default 
.
 During the construction of the object, after the fields to be visited by
 
\family typewriter 
tp_traverse
\family default 
 are filled, it is still necessary to call a notification function, 
\family typewriter 
PyObject_GC_Track
\family default 
, and during deallocation, before invalidating the object's fields, to call
\family typewriter 
 PyObject_GC_UnTrack
\family default 
.
 For objects that need the 
\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 

 mechanism to avoid stack overflow, it is also necessary to take the precaution
 of unmarking the object with 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 before entering the 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
 block.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\end_inset 


\layout Standard

In spite of offering a cycle detection mechanism, Python is unable to collect
 cycles whose objects contain finalizers implemented in Python itself (
\family typewriter 
__del__
\family default 
 methods); the only way to access those objects is then through the 
\family typewriter 
garbage
\family default 
 list in the 
\family typewriter 
gc
\family default 
 module.
 This module (accessible to C through Python function calls using the C
 API) offers an interface to the garbage collector, including 
\family typewriter 
enable
\family default 
 and 
\family typewriter 
disable
\family default 
 functions, to activate and deactivate the garbage collector; 
\family typewriter 
collect
\family default 
, to run a collection; 
\family typewriter 
get_objects
\family default 
, which returns a list containing all objects controlled by the collector
 (except the list itself); 
\family typewriter 
get_referrers
\family default 
 and 
\family typewriter 
get_referents
\family default 
, which return the list of object that refer or are referred by a given
 object -- these lists are obtained using the 
\family typewriter 
tp_traverse
\family default 
 function, which may not point to all objects actually reachable, or may
 still return objects in an invalid state (such as objects in cycles that
 were not yet collected or objects still not fully constructed) and therefore
 should be used only for debugging purposes.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby uses a mark-and-sweep garbage collector\SpecialChar ~

\begin_inset LatexCommand \cite{wilson92gc}

\end_inset 

.
 This technique avoids the problem of cyclic references faced by Python;
 having valid objects correctly indicated as reachable is sufficient.
\layout Standard

Objects that are reachable from the Ruby data space -- assigned to a Ruby
 global variable or inserted in some data structure reachable in Ruby --
 will not be subjected to garbage collection.
 In addition, we have objects returned by Ruby to the C space, since many
 API functions return 
\family typewriter 
VALUE
\family default 
s.
 The documentation warns that, to store Ruby objects in C, either in global
 variables or in data structures, it is necessary to notify the virtual
 machine that the 
\family typewriter 
VALUE
\family default 
 must not be collected using the 
\family typewriter 
rb_global_variable
\family default 
 function\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 (although not mentioned in the documentation, it is possible to unmark
 a global value with 
\family typewriter 
rb_gc_unregister_address
\family default 
).
\layout Standard

Objects in the local scope of a C function, however, do not need to be notified.
 The way how Ruby ensures the validity of local 
\family typewriter 
VALUE
\family default 
s is remarkably peculiar: when performing the mark phase, the garbage collector
 scans the C stack looking for values that look like 
\family typewriter 
VALUE
\family default 
 addresses, that is, numeric sequences that correspond to valid 
\family typewriter 
VALUE
\family default 
 addresses.
 These addresses can be identified because objects are always allocated
 within heaps maintained by the Ruby interpreter.
 Each 
\family typewriter 
VALUE
\family default 
 found in the stack is then marked.
 This ensures that any 
\family typewriter 
VALUE
\family default 
 locally accessible by C code becomes invalidated, but may generate 
\begin_inset Quotes eld
\end_inset 

false positives
\begin_inset Quotes erd
\end_inset 

 stopping data that could be collected from being so.
\layout Standard

In spite of programmer convenience, such approach is extremely non-portable.
 The implementation of the garbage collector in Ruby 1.8.2 has 
\family typewriter 
#ifdef
\family default 
s for IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC and Motorola 68000.
 Besides, the collector forces the discharge of registers to the stack using
 
\family typewriter 
setjmp
\family default 
, to prevent variables of the 
\family typewriter 
VALUE
\family default 
 type that may have been optimized into registers by the compiler from being
 missed.
\layout Standard

As we have seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-dados}

\end_inset 

, Ruby objects created with 
\family typewriter 
Data_Wrap_Struct
\family default 
 contain C structs, and those may contain references to Ruby 
\family typewriter 
VALUE
\family default 
s.
 The encapsulated struct, however, is opaque to the Ruby universe.
 So, to ensure that these 
\family typewriter 
VALUE
\family default 
s are marked as reachable during garbage collection this has to be done
 through C code.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 accepts, beside the struct to be wrapped, pointers to a mark function and
 to a deallocation function.
 When the garbage collector visits the object in the mark phase, it invokes
 the registered function, which must call 
\family typewriter 
rb_gc_mark
\family default 
 on each 
\family typewriter 
VALUE
\family default 
 stored in the object's struct, informing thus that these objects are reachable.
 When an object wrapped with 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 is considered unreachable, its deallocation function is called.
 On structures that do not store other 
\family typewriter 
VALUE
\family default 
s, the mark function can be set to 
\family typewriter 
NULL
\family default 
 and the deallocation function to 
\family typewriter 
free
\family default 
.
\layout Standard

Ruby has a 
\family typewriter 
GC
\family default 
 module featuring functions to turn the collector on and off (
\family typewriter 
GC.enable
\family default 
 and 
\family typewriter 
GC.disable
\family default 
), as well as to launch a collection immediately (
\family typewriter 
GC.start
\family default 
).
 There are equivalent functions in the C API: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 The C API includes also a function that inserts an object immediately in
 the list of objects to be recycled by Ruby's memory allocator, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 This function should be used with caution, since if there are still any
 references pointing to the recycled object, they will point to the new
 object when the memory area is reclaimed by the Ruby allocator.
\layout Standard

Ruby also offers as a convenience to the C programmer some wrappers to the
 malloc and realloc functions that interact with the garbage collector,
 forcing its execution during large allocations
\begin_inset Foot
collapsed false

\layout Standard

The definition of 
\begin_inset Quotes eld
\end_inset 

large
\begin_inset Quotes erd
\end_inset 

 is adjusted dynamically, based on the execution of the collector and previously
 performed allocations.
\end_inset 

 or in low-memory situations.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Like in Python and Ruby, the Java API returns references to objects from
 the virtual machine that can be stored in C variables.
 The JNI defines three types of references, 
\emph on 
local
\emph default 
, 
\emph on 
global
\emph default 
 and 
\emph on 
weak global
\emph default 
 references, to aid in controlling their lifetime and their interaction
 with the garbage collector.
\layout Standard

Most functions of the JNI return local references, which are valid until
 the return of the C function that has obtained them.
 It is not necessary to deallocate a local reference explicitly: during
 the execution of a C function, the JVM maintains a list of local references
 passed to the function and frees them all when control returns to the virtual
 machine.
 This way, in general, the programmer does not need to worry about garbage
 collection when manipulating values returned during a function.
 On the other hand, in code that may use a large number of local references
 it is more efficient to free local references explicitly, using 
\family typewriter 
DeleteLocalRef
\family default 
.
 In Java version 1.2, functions were added to manage local references in
 blocks.
 
\family typewriter 
PushLocalFrame
\family default 
 and 
\family typewriter 
PopLocalFrame
\family default 
 allow one to create nested scopes of local references, which are freed
 all at once.
 
\family typewriter 
PushLocalFrame
\family default 
 receives also an argument indicating a number of slots to be pre-allocated,
 as an optimization.
 This value can also be configured with 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Global references are generated from local references using 
\family typewriter 
NewGlobalRef
\family default 
.
 References of this kind remain valid until they are explicitly deallocated
 with 
\family typewriter 
DeleteGlobalRef
\family default 
.
 A global reference stops the object from being collected; it can therefore
 be used to store Java objects in C space beyond the duration of a function,
 for example, in global or static variables.
\layout Standard

Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 shows an example of the kind of reference management that is needed when
 a loop creates temporary references for an arbitrary number of objects.
\layout Standard

In the example, the 
\family typewriter 
Java_Example_concatArray
\family default 
 function (equivalent, therefore, to the 
\family typewriter 
concatArray
\family default 
 method from class 
\family typewriter 
Example
\family default 
) converts the elements of an array to strings using 
\family typewriter 
Object.toString
\family default 
 and concatenates them using 
\family typewriter 
String.concat
\family default 
.
 Notice that, as the number of iterations of the loop depends on the size
 of the given array, one should prevent the number of references from increasing
 on each iteration.
 For that, the options would be either to use 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, or to destroy references one by one with 
\family typewriter 
DeleteLocalRef
\family default 
.
 If we used 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 in the example, we would have to keep the temporary string holding the
 concatenation in a global reference.
 Further, this reference would have to be destroyed and recreated on each
 iteration, since strings are immutable in Java.
 As the number of locals is small, it is more convenient in this case to
 control them explicitly with 
\family typewriter 
DeleteLocalRef
\family default 
 than resorting to global references.
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 allows, through an additional argument, transferring a local reference
 from the set that is being popped to the external scope of local reference,
 creating this way a new reference.
 For the example of Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, this would still not avoid the need of freeing references explicitly on
 each iteration of the loop, since each 
\family typewriter 
PopLocalFrame
\family default 
 would create a new local reference.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
\emph on 
/* Caching jmethodIDs in C code is a common technique.
\layout LyX-Code


\size footnotesize 
\emph on 
   It's worth mentioning that jmethodIDs are not Java objects,
\layout LyX-Code


\size footnotesize 
\emph on 
   and are therefore not subjected to garbage collection.
 */
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Example_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);     
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);     
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\emph on 
   /* os = o.toString() */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\emph on 
 /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Routine for concatenating elements of an array represented as strings.
\end_inset 


\layout Standard

Since Java 1.2, the JNI includes weak global references, with the goal of
 offering a simplified version of Java's weak references (
\family typewriter 
java.lang.ref
\family default 
) -- an object pointed only by weak global references can be collected.
 Originally, the API defined the 
\family typewriter 
IsSameObject
\family default 
 function as a way to check the validity of a weak reference, but evidently
 this method is insufficient: since Java is multi-threaded, the garbage
 collector may invalidate the reference between the test and the following
 instruction in C code.
 The revised documentation warns about this limitation and recommends the
 use of global references, as well as alerting on undefined behaviors in
 the relationship between weak global references in C and Java's own weak
 reference types\SpecialChar ~

\begin_inset LatexCommand \cite{jni1503spec}

\end_inset 

.
\layout Standard

More issues arise from the combination of Java's multi-threaded model with
 the exposure of references of virtual machine objects to C code.
 To reduce the volume of data copying between Java and C, the JNI offers
 some functions that return and release pointers to the internal representation
 of strings and arrays of primitive types: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 and 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 The use of these functions, however, has important restrictions.
 The API specifies that, once a pointer is obtained through these functions,
 the C code must not call other JNI functions or perform calls that may
 block the current thread and make it wait for another Java thread, under
 risk of a deadlock.
 It is recommended that memory blocks held using these functions are not
 retained for a long time, since one of the possible techniques fro implementing
 this 
\begin_inset Quotes eld
\end_inset 

critical section
\begin_inset Quotes erd
\end_inset 

 consists in disabling the garbage collector.
 It is also important to note that local references and the pointer to the
 JNI environment passed to native functions are valid only in the thread
 where they were created; global references can be shared among threads.
\layout Standard

Besides the weak reference mechanism provided by the 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
 package, the only way provided by Java to interact in a more direct way
 with the garbage collector is through the 
\family typewriter 
System.gc()
\family default 
 call, which asks the virtual machine to launch the collection thread as
 soon as possible so that it deallocate unreachable objects.
 There is no equivalent C function in the JNI, but this method can be invoked
 from C with 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

The interaction of native C code with the Lua garbage collector is greatly
 simplified by the fact that the Lua API does not return explicit references
 to Lua objects to the C space.
 Operations on Lua objects are always specified through indices of the virtual
 stack.
 This way, the virtual machine retains all control over which objects are
 accessible from C at any given moment.
\layout Standard

Although pointers to objects are not manipulated in the API, some functions
 return pointers to structures managed by Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
 and 
\family typewriter 
lua_touserdata
\family default 
.
 The validity of pointers returned by these functions is dependent on the
 lifetime of the object they correspond to; for strings in particular, a
 returned pointer is only decidedly valid as long as the string is in the
 stack.
 Lua offers still the 
\family typewriter 
lua_topointer
\family default 
 function, which returns pointers to some kinds of objects (userdata, tables,
 threads and functions), but only with the intention of providing debugging
 information, as it is not possible to convert such pointers back into Lua
 values.
\layout Standard

The virtual stack is emptied when the C function returns control to the
 Lua virtual machine.
 This way, it is not possible to retain pointers returned by Lua for later
 use in global variables or C structures.
 Alternatively, the API offers a mechanism for storing Lua values in a location
 that is known to C code and that cannot be altered by Lua code: the registry.
 The registry is a table made available through the Lua API for the storage
 of Lua values from C; this table is not normally accessible from Lua.
 Since the table that implements the registry is part of the root set of
 the garbage collector, the inclusion of an object in this table prevents
 it from being collected, keeping it in the registry until it is explicitly
 removed through C code.
\layout Standard

Using the registry, a possible way to describe data from the Lua space in
 C data structures is to store data in the registry and store the used indices
 in the C structure.
 Lua's auxiliary library encapsulates such idiom through two functions,
 
\family typewriter 
luaL_ref
\family default 
 and 
\family typewriter 
luaL_unref
\family default 
.
 The 
\family typewriter 
luaL_ref
\family default 
 function associates the given Lua value to an integer numeric key in the
 registry, and returns this number.
 This value can then be seen as a high-level handle to the object: C code
 can store it in variables and structures and use it to refer to the object
 through its registry field.
 The 
\family typewriter 
luaL_unref
\family default 
 function removes the Lua value from the registry and frees the index for
 reuse.
 To ensure that this mechanism works properly, integer keys should not be
 used directly be the programmer to store data in the registry.
\layout Standard

The API allows associating a deallocation function, 
\family typewriter 
__gc
\family default 
, to the metatable of full userdata objects.
 When present, this function will be typically implemented in C, performing
 resource finalization.
 For example, the 
\family typewriter 
__gc
\family default 
 metamethod of objects returned by the 
\family typewriter 
io.open
\family default 
 Lua function is a C function that closes the corresponding file descriptor
 using the 
\family typewriter 
fclose
\family default 
 function.
\layout Standard

In principle, the fact that its possible to obtain and modify the metatable
 of userdata through Lua code may seem problematic, as one could replace
 its finalizer in 
\family typewriter 
__gc
\family default 
.
 However, collection functions implemented in C typically validate received
 userdata checking its 
\begin_inset Quotes eld
\end_inset 

type
\begin_inset Quotes erd
\end_inset 

, identified through its metatable.
 So, even if Lua code manipulates the table, a collection function implemented
 in C which uses 
\family typewriter 
luaL_checkudata
\family default 
 will not be made to operate on userdata of incorrect type.
 To stop Lua code from modifying the collection function of a userdata object,
 one can assign some value, such as false, to the 
\family typewriter 
__metatable
\family default 
 field of the metatable; this will be returned in place of the metatable,
 making the metatable itself unaccessible.
\layout Standard

Another resource related to memory management provided by Lua is the possiblity
 of configuring, at runtime, the allocation function to be used by the virtual
 machine.
 In the creation of a new Lua state, an allocation function is passed as
 a its first argument.
 This function must offer functionality like that from the C functions 
\family typewriter 
free
\family default 
 and 
\family typewriter 
realloc
\family default 
, depending if the given block size is equal or greater than zero.
\layout Standard

Lua offers an interface to its garbage collector through two functions:
 
\family typewriter 
lua_gc
\family default 
 in C and 
\family typewriter 
collectgarbage
\family default 
 in Lua.
 The collector implements incremental mark-and-sweep and allows the programmer
 to configure parameters related to collection intervals, as well as enable,
 disable, launch full cycles and executing collection steps.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Like Python, Perl performs garbage collection based on reference counting.
 The API provides functions for explicit control of reference counts: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 and a getter, 
\family typewriter 
SvREFCNT
\family default 
.
 Another way to modify the reference count of a value is to assign it to
 a Perl reference with 
\family typewriter 
newRV_inc
\family default 
.
 The count of the referenced value will be incremented, keeping it valid
 -- unless it has its count altered explicitly -- as long as it is referenced
 by the 
\family typewriter 
RV
\family default 
.
 It is important to note, however, that API functions that create values,
 such as 
\family typewriter 
newSViv
\family default 
, initialize their reference counts with 1.
 This has the effect that if a value is created in a C function, stored
 in an 
\family typewriter 
RV
\family default 
 with 
\family typewriter 
newRV_inc
\family default 
 and this reference is returned to Perl, the value will never be collected,
 because its counter will not reach 0 when the reference is destroyed.
 The correct form, then, is to use 
\family typewriter 
newRV_noinc
\family default 
 for 
\family typewriter 
RV
\family default 
s containing newly-created values and 
\family typewriter 
newRV_inc
\family default 
 when an 
\family typewriter 
RV
\family default 
 needs to retain an already existing value.
\layout Standard

Initializing reference counts with 1 ensures that values created will remain
 valid during the execution of a C function without storing the value in
 Perl space.
 These values can also be stored in C global variables and data structures
 and will remain valid until their reference count is decremented.
 For values with a lifetime restricted to a single function, the Perl API
 defines the concept of 
\begin_inset Quotes eld
\end_inset 

mortal
\begin_inset Quotes erd
\end_inset 

 variables as a way of deallocating all temporary values of a function at
 once.
 An 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 can be created with 
\family typewriter 
sv_newmortal
\family default 
 or, more commonly, converted to a mortal with 
\family typewriter 
sv_2mortal
\family default 
.
 In practice, marking a value as mortal corresponds to indicating that it
 should have its reference count decremented by the 
\family typewriter 
FREETMPS
\family default 
 macro by the end of a function, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Some functions of the API return mortal values: for example, 
\family typewriter 
hv_delete
\family default 
 removes an element of a hash and, unless the 
\family typewriter 
G_DISCARD
\family default 
 is passed, returns the removed element as a mortal 
\family typewriter 
SV
\family default 
.
\layout Standard

The Perl API does not provide facilites for interfacing with the garbage
 collector, but features some debugging support functions that report informatio
n about the state of garbage collection.
 The 
\family typewriter 
sv_report_used
\family default 
 function displays the contents of every 
\family typewriter 
SV
\family default 
 stored in the interpreter.
 The 
\family typewriter 
Devel::Peek
\family default 
 module allows examining from Perl the content of values (reference counts,
 flags, etc.) -- from C, these informations are directly available, since
 their structures are not opaque.
\layout Subsection

Comparison
\layout Standard

Garbage collection aims to isolate, as much as possible, the programmer
 from memory management.
 This way, ideally an API should also be as independent as possible from
 the garbage collection algorithm used in the implementation of the virtual
 machine.
 Perl and Python perform garbage collection based on reference counting,
 and this shows through in the reference increment and decrement operations
 frequently needed during the use of their APIs.
\layout Standard

Ruby uses a mark-and-sweep garbage collector.
 Its API manages to abstract this fact well for manipulation of native Ruby
 objects, but the implementation of the collector is evident in the creation
 of Ruby types in C, where we need to declare a mark function when there
 are C structures that store reference to Ruby objects.
 The Lua API goes further when isolating itself from the implementation
 of the garbage collector: the only point of the API where the use of an
 incremental garbage collection is apparent is in the routine for direct
 interaction with the collector, 
\family typewriter 
lua_gc
\family default 
, where its parameters can be configured.
\layout Standard

Of the five languages studied, the only whose API abstracts entirely the
 implementation of the garbage collector is Java.
 The only intarfacing operation provided by the language, 
\family typewriter 
System.gc()
\family default 
, does not receive any arguments and does not specify how or when the collection
 should be done
\begin_inset Foot
collapsed true

\layout Standard

The documentation is purposely vague, stating only that this method 
\begin_inset Quotes eld
\end_inset 

suggests that the Java Virtual Machine expend effort toward recycling unused
 objects
\begin_inset Quotes erd
\end_inset 


\emph on 
 
\emph default 
.
\end_inset 

.
 In fact, the various implementations of the JVM use different algorithms
 for garbage collection.
\layout Standard

For manipulating data through the API, Lua and Ruby are the languages that
 demand the least concerns from the programmer about managing references.
 Ruby keeps control of references returned to C functions scanning the C
 stack during garbage collection, detecting the presence of references stored
 in local variables.
 Lua avoids the problem altogether, by keeping its objects in the virtual
 stack and not returning references to C code.
\layout Standard

The issue of references stored in local variables is handled by Perl and
 Java in a similar way, by defining two types of references, global and
 local (local references are called 
\begin_inset Quotes eld
\end_inset 

mortal variables
\begin_inset Quotes erd
\end_inset 

 in Perl).
 Local references have implicit management (save a few cases, as discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

).
 API functions in Java return local references by default, which can be
 converted to global ones with 
\family typewriter 
NewGlobalRef
\family default 
.
 In Perl, the opposite happens, and global references can be converted to
 local ones with 
\family typewriter 
sv_2mortal
\family default 
.
 Java's approach is more interesting, as normally more locally-scoped than
 globally-scoped variables are used.
 Values stored globally always need to have some for of explicit management
 to them, even in Ruby and Lua, through 
\family typewriter 
rb_global_variable
\family default 
 and 
\family typewriter 
luaL_ref
\family default 
/
\family typewriter 
luaL_unref
\family default 
.
\layout Section

Calling functions from C
\layout Standard

The API must provide a form of invoking from C functions to be executed
 by the scripting language.
 This involves passing data between these two 
\begin_inset Quotes eld
\end_inset 

spaces
\begin_inset Quotes erd
\end_inset 

, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 and the implications that this brings about the objects' lifetime, discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Because of the static typing of C, it is not possible to use a transparent
 syntax for calling functions registered at runtime.
 It is therefore necessary for the API to define functions for performing
 calls to the scripting language.
\layout Standard

In this section, we will discuss the facilities provided by each API for
 invoking functions to be executed by its virtual machine.
 The main issues involved are how to reference the function to be called,
 how to pass arguments to it and how to obtain the return value, including
 forms of notification in case of errors.
 For illustration purposes, for each language we will present an example
 of a simple function call.
 Assume that in the space of each scripting language a 
\family typewriter 
test
\family default 
 function was defined, which receives an integer and a string as arguments
 and returns an integer as a result.
 For brevity, error handling will be omitted in the examples.
 
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

When calling a Python function from C, one should initially obtain a pointer
 to the 
\family typewriter 
PyObject
\family default 
 corresponding to the function, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Besides functions implemented in Python and C functions registered through
 the Python API, any data type that implements the 
\family typewriter 
__call__
\family default 
 method (or declares a function in the 
\family typewriter 
tp_call
\family default 
 field of its 
\family typewriter 
PyTypeObject
\family default 
 structure) can be called as a function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções para chamar funções
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

The Python API offers several functions for performing calls from C.
 The most general function, 
\family typewriter 
PyObject_Call
\family default 
, receives as arguments the object to be called, a Python tuple containing
 the arguments to be passed and optionally a dictionary of keyword arguments.
 As a convenience, other functions allow passing arguments in other ways.
 For example, 
\family typewriter 
PyObject_CallFunction
\family default 
 ncapsulates the call to 
\family typewriter 
Py_BuildValue
\family default 
 (seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), accepting directly the format string and the value to be converted.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 is a vararg function that accepts a sequence of pointers to 
\family typewriter 
PyObject
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

There are also many convenience functions for method invocation.
 The 
\family typewriter 
PyObject_CallMethod
\family default 
 is a variant of 
\family typewriter 
PyObject_CallFunction
\family default 
 that receives as arguments a 
\family typewriter 
PyObject
\family default 
 and a C string containing the method name.
 So, for example, both forms below are equivalent to the Python statement
 
\family typewriter 
ret = some_string.split(" ")
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* "s" indicates that the next parameter is a string.
 */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(some_string, "split", "s", " ");
\newline 
 
\newline 
PyObject* split = PyObject_GetAttrString(some_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

It is interesting to note that when a method is called as a function, the
 
\family typewriter 
self
\family default 
 argument is not passed explicitly.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

The return value in all invocation functions is a 
\family typewriter 
PyObject
\family default 
 pointer.
 As it happens in Python code, when Python functions return multiple values,
 they are encapsulated in a tuple.
 For functions that do not return a value, C functions must return 
\family typewriter 
Py_None
\family default 
.
 In case of errors in the call, these functions return 
\family typewriter 
NULL
\family default 
.
 The occurrence of exceptions can then be verified with the 
\family typewriter 
PyErr_Occurred
\family default 
 function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A typical way of calling a Python function called 
\family typewriter 
test
\family default 
, including retrieval of the function and conversion of input and output
 values between Python and C, is shown below:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* test = PyDict_GetItemString(globals, "test");
\layout LyX-Code


\size footnotesize 
\emph on 
/* "si" indicates string and integer arguments */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(test, "si", "foo", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converts the value to C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Frees the temporary PyObject that was returned.
 */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

A global function is obtain through the dictionary in the 
\family typewriter 
__main__
\family default 
 module.
 The conversion of input data from C to Python is made through a format
 string received by 
\family typewriter 
PyObject_CallFunction
\family default 
.
 This call is equivalent to 
\family typewriter 
obj_result = test("foo", 2)
\family default 
 in Python.
 The output value is returned as a new reference to a Python object and,
 as such, needs to have its reference count decremented after its use.
 The 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 and 
\family typewriter 
PyDict_GetItemString
\family default 
 return borrowed references, therefore the reference count of 
\family typewriter 
PyObject
\family default 
s returned by them do not need to be decremented after their use.
 However, after calling the Python function, there is no guarantee that
 the 
\family typewriter 
globals
\family default 
 and 
\family typewriter 
test
\family default 
 pointers still point to valid objects -- we would have to have incremented
 their reference counts if we wanted to use them again.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções para chamar funções
\end_inset 


\layout Standard

Since methods are not first-class values in Ruby, they are not represented
 as 
\family typewriter 
VALUE
\family default 
s in their C API.
 For calling Ruby methods in C, the API offers the 
\family typewriter 
rb_funcall
\family default 
 function and some variations.
 In common, all of them receive as an argument the 
\family typewriter 
VALUE
\family default 
 indicating to the object the method refers to, an 
\family typewriter 
ID
\family default 
 referring to the interned string containing the method name and an integer
 informing the number of arguments.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

Like in Python, the API functions for method invocation differ in how arguments
 are passed.
 For example, rb_funcall receives arguments as 
\family typewriter 
VALUE
\family default 
s passed as C varargs; 
\family typewriter 
rb_funcall2
\family default 
 receives a C array of 
\family typewriter 
VALUE
\family default 
s; rb_apply receives a 
\family typewriter 
VALUE
\family default 
 that must be a Ruby array containing arguments.
 All of them return a 
\family typewriter 
VALUE
\family default 
 as an argument.
 Like in Ruby code, multiple return values are represented as a Ruby array.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

All function call routines from the API refer to methods, expecting thus
 an object on which the method should be applied.
 Global functions are defined in Ruby as methods of the 
\family typewriter 
Kernel
\family default 
 module, which is included by the class 
\family typewriter 
Object
\family default 
 and are, therefore, accessible from every object, including 
\family typewriter 
nil
\family default 
.
 This way, one can invoke global functions passing the C constant 
\family typewriter 
Qnil
\family default 
 as the method's target object.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Below, we present the typical way a Ruby global function 
\family typewriter 
test
\family default 
 is called from C, again including conversion of input and output values
 between C and the interpreter.
\layout LyX-Code


\size footnotesize 
ID test = rb_intern("test");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, test, 2, rb_str_new2("foo"), INT2NUM(2));
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Unlike it happens in Python, it is not necessary to obtain a reference to
 the function, sufficing to pass its name as an 
\family typewriter 
ID
\family default 
 and the object it refers to (in this case, 
\family typewriter 
Qnil
\family default 
, indicating a global function).
 Conversion of input data from C to Ruby is done through the 
\family typewriter 
rb_str_new2
\family default 
 function and the 
\family typewriter 
INT2NUM
\family default 
 macro, which return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs.
 no exemplo
\end_inset 


\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, the control of validity of 
\family typewriter 
VALUE
\family default 
s is done implicitly.
 So, we can call functions that create 
\family typewriter 
VALUE
\family default 
s directly when passing parameters to 
\family typewriter 
rb_funcall
\family default 
.
 In fact, all three lines above could have been condensed, passing 
\family typewriter 
rb_funcall
\family default 
 as a parameter to 
\family typewriter 
NUM2LONG
\family default 
 and 
\family typewriter 
rb_intern
\family default 
 as the second argument of 
\family typewriter 
rb_funcall
\family default 
; they were separated here for greater readability.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: blocos Ruby
\end_inset 


\layout Standard

A data type that is treated in a quite irregular way in Ruby is that from
 code blocks.
 Ruby features special syntax for declaring blocks: they can only be defined
 as the last argument of a method call.
 This way, they are not first-class values and cannot be, for example, declared
 in a variable assignment.
 They can, however, be promoted to first-class values, as objects of the
 
\family typewriter 
Proc
\family default 
 class.
 This can be done in two ways: explicitly, passing a block to the 
\family typewriter 
Proc.new
\family default 
 method, or implicitly, when a block is passed to a method that declares
 a final formal argument preceded by 
\family typewriter 
&
\family default 
.
 This variable will contain the block converted to a 
\family typewriter 
Proc
\family default 
.
 When calling functions that expect blocks, 
\family typewriter 
&
\family default 
 converts a 
\family typewriter 
Proc
\family default 
 to a block.
 
\family typewriter 
Proc
\family default 
 objects can be manipulated through the C API as any other Ruby object,
 but there is no match in the C API to the functionality of the 
\family typewriter 
&
\family default 
 operator in function calls.
\layout Standard

The special status of code blocks complicates their use from C code, and
 in particular the invocation of methods that expect them as a parameter.
 Say we want to invoke the following Ruby method from C:
\layout LyX-Code


\size footnotesize 
def a_ruby_function()
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function will invoke the block.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function is done.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function expects a code block to be passed to it, so it can be invoked
 by the 
\family typewriter 
yield
\family default 
 command.
 Since we will invoke the function from C, we also want to pass C code as
 a block, represented by the following function:
\layout LyX-Code


\size footnotesize 
VALUE a_C_block() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "a_C_block is running.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The conversion of 
\family typewriter 
Proc
\family default 
 objects to blocks performed by the 
\family typewriter 
&
\family default 
 operator in Ruby has no equivalent in the C API.
 Therefore, 
\family typewriter 
rb_funcall
\family default 
 is unable to pass 
\family typewriter 
Proc
\family default 
s to functions expecting blocks.
 The intuitive way of doing Ruby function calls from C, in this case then,
 does not work:
\layout LyX-Code


\size footnotesize 
ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
\emph on 
/* The second argument is an additional argument to be
\layout LyX-Code


\size footnotesize 
\emph on 
   optionally passed when invoking a Proc */
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Doesn't work! A Proc is not a code block.
 */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_funcall(Qnil, a_ruby_function, 1, a_proc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The only ways for invoking a Ruby method passing a code block are through
 
\family typewriter 
rb_eval_string
\family default 
 and 
\family typewriter 
rb_iterate
\family default 
.
 The first approach, besides the performance penalty caused by parsing a
 string of code, has the inconvenience of requiring temporary variables
 so that one can obtain return values back to the C data space.
 In the model using 
\family typewriter 
rb_eval_string
\family default 
, the C function that will act as a block must be declared in the Ruby space.
 There are two alternatives on how to do this: registering the method in
 Ruby and invoking it in a wrapper block declared in the string of Ruby
 code:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Declares a global function with 0 input parameters */
\layout LyX-Code


\size footnotesize 
rb_define_global_function("a_C_block", a_C_block, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function { a_C_block() }");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard

Or encapsulating the function in a 
\family typewriter 
Proc
\family default 
 object from C with 
\family typewriter 
rb_proc_new
\family default 
 and then using the 
\family typewriter 
&
\family default 
 notation in the string of Ruby code:
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$a_proc", a_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function(&$a_proc)");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The second approach makes use of the fact that the only API function that
 is capable of producing code blocks directly is 
\family typewriter 
rb_iterate
\family default 
.
 This function receives two function pointers, one to the function to be
 invoked and another to the function that will act as a block; calls to
 
\family typewriter 
yield
\family default 
 withing the first function will invoke the second one.
 The block may break the flow of execution with 
\family typewriter 
rb_iter_break
\family default 
.
 By passing as a 
\begin_inset Quotes eld
\end_inset 

iteration function
\begin_inset Quotes erd
\end_inset 

 to rb_iterate a wrapper function that simply calls the desired Ruby method
 with 
\family typewriter 
rb_funcall
\family default 
, it is possible to simulate a call to 
\family typewriter 
rb_funcall
\family default 
 that receives a C function as a code block.
\layout LyX-Code


\size footnotesize 
VALUE call_a_ruby_function() {
\layout LyX-Code


\size footnotesize 
   ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, a_ruby_function, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
\emph on 
/* The Qnil arguments indicate that there are no parameters
\layout LyX-Code


\size footnotesize 
\emph on 
   to be passed to either function.
 */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_iterate(call_a_ruby_function, Qnil, a_C_block, Qnil);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that no arguments are passed to 
\family typewriter 
rb_funcall
\family default 
 -- 
\family typewriter 
rb_iterate
\family default 
 defines 
\family typewriter 
a_C_block
\family default 
 as the 
\begin_inset Quotes eld
\end_inset 

current code block
\begin_inset Quotes erd
\end_inset 

 and this definition is inherited implicitly by 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

For the common case of performing iteration on the 
\family typewriter 
each
\family default 
 method of collections, Ruby offers a wrapper function, 
\family typewriter 
rb_each
\family default 
.
 This function was designed to be passed as a first argument to 
\family typewriter 
rb_iterate
\family default 
.
 C functions executing as a code block can break the control flow with 
\family typewriter 
rb_iter_break
\family default 
.
 The yielding mechanism, for both C code and native Ruby calls, is implemented
 using the 
\family typewriter 
setjmp
\family default 
 and 
\family typewriter 
longjmp
\family default 
 C functions.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

For correct error handling, C functions that perform calls to Ruby functions
 must be encapsulated by a 
\family typewriter 
rb_protect
\family default 
 call or one of its variants, 
\family typewriter 
rb_ensure
\family default 
 and 
\family typewriter 
rb_rescue
\family default 
.
 If a program does not use 
\family typewriter 
rb_protect
\family default 
, Ruby exceptions will result in fatal errors.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

Like in attribute access, when calling Java methods from C one must initially
 obtain a method identifier, of the 
\family typewriter 
jmethodID
\family default 
 type.
 These identifiers are typically obtained with the 
\family typewriter 
GetMethodID
\family default 
 function, which receives as arguments the class (an instance of jclass)
 and two strings, one with the method name and the other with the method
 signature.
 The syntax for describing method signatures is similar to that of field
 descriptors discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Arguments are listed in parentheses, followed by the return type.
 For example, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 describes a function with 
\family typewriter 
String[], int, int
\family default 
 arguments and 
\family typewriter 
void
\family default 
 return.
 Alternatively to 
\family typewriter 
GetMethodID
\family default 
, since Java 1.2 it is possible to obtain a 
\family typewriter 
jmethodID
\family default 
 corresponding to a method by applying the 
\family typewriter 
FromReflectedMethod
\family default 
 function on a Java object of the 
\family typewriter 
Method
\family default 
 class -- that is, a method reified through Java's reflection API.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API para invocar funções
\end_inset 


\layout Standard

Once a jmethodID was obtained, a method can be invoked through some of the
 90 functions of the 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
* family.
 Function names follow this format:
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<type><return>
\family default 
\emph default 
Method
\family roman 
\emph on 
<arguments>
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

Here, 
\emph on 
<type>
\emph default 
 may be 
\family typewriter 
Static
\family default 
 for static functions, passing a 
\family typewriter 
jclass
\family default 
 as an argument in calls; 
\family typewriter 
Nonvirtual
\family default 
 when invoking implementations of a method from a specific class on a given
 object, passing a 
\family typewriter 
jclass
\family default 
 and a 
\family typewriter 
jobject
\family default 
 as parameters; or omitted for instance methods, passing the 
\family typewriter 
jobject
\family default 
 on which the method will be applied.
 Return type is indicated in 
\emph on 
<return>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Method arguments can be passed in three ways: as varargs, as a C array of
 
\family typewriter 
jvalue
\family default 
s, or propagating a received 
\family typewriter 
va_list
\family default 
.
 For example, in its simplest form, an instance method without input or
 output values is invoked with 
\family typewriter 
CallVoidMethod
\family default 
.
 
\family typewriter 
CallStaticIntMethodA
\family default 
, in contrast, invokes a static method which returns a 
\family typewriter 
jint
\family default 
 and has its argument list passed in an array of 
\family typewriter 
jvalue
\family default 
s.
 Since Java is a statically typed language, it is not necessary to specify
 the number of type of arguments passed in functions for method invocation.
 This information is already specified in 
\family typewriter 
jmethodID
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\end_inset 


\layout Standard

It is important to point out that, when obtaining method and field identifiers
 resolving them based on the 
\family typewriter 
jobject
\family default 
 obtained in the this variable and the method or field name, with 
\family typewriter 
GetObjectClass
\family default 
 and 
\family typewriter 
GetFieldID
\family default 
, we are effectively resolving names through dynamic scoping.
 This implies that, for example, if a method called 
\family typewriter 
Parent.method
\family default 
 implemented in C accesses a private attribute 
\family typewriter 
anAttribute
\family default 
 and a 
\family typewriter 
Child
\family default 
 subclass also defines a private attribute with the same name, a call to
 this method in an instance 
\family typewriter 
c
\family default 
 of 
\family typewriter 
Child
\family default 
 would end up accessing 
\family typewriter 
Child.anAttribute
\family default 
 and not 
\family typewriter 
Parent.anAttribute
\family default 
.
 This behavior differs from what would happen if 
\family typewriter 
Parent.method
\family default 
 was implemented in Java, where binding of private members is defined lexically.
 To ensure to the C implementation of 
\family typewriter 
Parent.method
\family default 
 that the 
\family typewriter 
anAttribute
\family default 
 it is accessing is really 
\family typewriter 
Parent.anAttribute
\family default 
, one must store in C space the field identifier from 
\family typewriter 
Parent
\family default 
's 
\family typewriter 
jclass
\family default 
 -- obtained, for example, in a 
\family typewriter 
static native
\family default 
 function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

C code may verify the ocurrence of exceptions through 
\family typewriter 
ExceptionCheck
\family default 
 and choose to handle it, obtaining a local reference of the exception with
 ExceptionOccurred and later clearing it with 
\family typewriter 
ExceptionClear
\family default 
; or keep it active so that it propagates to Java code.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

For the example of the 
\family typewriter 
test
\family default 
 function, since Java does not have global functions, we will assume that
 
\family typewriter 
test
\family default 
 is a static method of a class called 
\family typewriter 
Example
\family default 
 and that we are running the following C code in a context where we have
 a reference to a Java runtime environment called 
\family typewriter 
J
\family default 
 (this pointer, of 
\family typewriter 
JNIEnv
\family default 
 type, will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass example = (*J)->FindClass(J, "Example");
\layout LyX-Code


\size footnotesize 
jmethodID test = (*J)->GetStaticMethodID(J, example,
\layout LyX-Code


\size footnotesize 
                       "test", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring foo = (*J)->NewStringUTF(J, "foo");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, example, test, foo, (jint)2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Initially, we get a reference to the 
\family typewriter 
Example
\family default 
 class, from which we obtain the identifier of the desired method, based
 on its name and signature.
 Like in Ruby, the string passed as a parameter must be converted to a virtual
 machine type, but for the second argument and for the return value we explore
 the fact that 
\family typewriter 
jint
\family default 
, corresponding to the Java type 
\family typewriter 
int
\family default 
 (32-bit integer) is compatible with the C type 
\family typewriter 
long
\family default 
 (defined as an integer of at least 32 bits).
 All these API functions return local references, which will be freed automatica
lly by the end of the C function where the API calls were made.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Both in C functions launched by Lua and in Lua function calls performed
 from C code, input arguments and return values are passed through the virtual
 stack presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Verificação da ocorrência de erros
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

To call a Lua function from C, we must initially push to the stack the Lua
 object referring to it: for global functions, obtaining it with 
\family typewriter 
lua_getglobal
\family default 
, for functions stored in tables, with 
\family typewriter 
lua_gettable
\family default 
.
 Afterwards, we push its arguments and then invoke 
\family typewriter 
lua_call
\family default 
 or 
\family typewriter 
lua_pcall
\family default 
, indicating how many stack values are to be passed as a parameter.
 The difference between these two functions is in error handling: 
\family typewriter 
lua_call
\family default 
 propagates any signalled errors, using 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 captures errors, returning a status code and the error message in the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

When no errors occur, the stack will contain any values returned by the
 called function.
 The number of return values can be explicitly requested with lua_call or
 lua_pcall, or be defined at runtime, requesting the special value 
\family typewriter 
LUA_MULTRET
\family default 
.
 If a specific number of return values is requested and these are not passed
 by the called function, the number of values will be adjusted by adding
 
\family typewriter 
nil
\family default 
 elements or discarding excessive values.
 For calls with 
\family typewriter 
LUA_MULTRET
\family default 
, all values are pushed.
 In this case, the only way to find out how many values were returned is
 comparing the size of the stack before and after the call.
\layout Standard

The 
\family typewriter 
lua_cpcall
\family default 
 function allows calling C functions performing error capture like that
 which takes place on 
\family typewriter 
lua_pcall
\family default 
 without having to register them as Lua values.
 This functionality is similar to that offered by 
\family typewriter 
rb_protect
\family default 
 in Ruby.
 Ruby, however, does not offer any function analogous to 
\family typewriter 
lua_pcall
\family default 
, being sometimes necessary to wrap Ruby function calls in C functions that
 follow the signature expected by 
\family typewriter 
rb_protect
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Lua does not have a distinction between functions and methods, but features
 syntactic sugar that allows one to invoke functions stored in tables with
 a method-call-style syntax: 
\family typewriter 
t:m(x)
\family default 
 means 
\family typewriter 
t.m(t,x)
\family default 
.
 Still, there is no specific call in the C API to replicate this abbreviation.
 For functions stored in tables, the function must be obtained with 
\family typewriter 
lua_gettable
\family default 
 and the table has to be pushed explicitly alongside the other parameters.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

The example of the 
\family typewriter 
test
\family default 
 function call demonstrates the stack discipline adopted by the Lua API.
 Similarly to the Java example of Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, we will assume the existence of a 
\family typewriter 
lua_State
\family default 
 pointer called 
\family typewriter 
L
\family default 
, which will be explained later on in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "test");            
\emph on 
/* Pushes the function test */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "foo");            
\emph on 
/* Pushes the string "foo" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Pushes the number 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Calls the function with 2 arguments,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        expect 1 as the result */
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1); 
\emph on 
 /* Get the result at the top (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove it off the stack */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs no exemplo
\end_inset 


\layout Standard

With 
\family typewriter 
lua_getglobal
\family default 
, we push the global function 
\family typewriter 
test
\family default 
.
 Then, two input arguments are pushed.
 The function is invoked with 
\family typewriter 
lua_call
\family default 
, indicating two input arguments and requesting one output value.
 The return value, at the top of the stack (index\SpecialChar ~

\begin_inset Formula $-1$
\end_inset 

) is converted to C with 
\family typewriter 
lua_tointeger
\family default 
.
 This last function does not pop the value off the stack: to return it to
 its initial state, we need to remove it explicitly with 
\family typewriter 
lua_pop
\family default 
.
 As the API never returns pointers to Lua objects, there are no concerns
 related to garbage collection.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Funções vs.
 métodos
\end_inset 


\layout Standard

Calling Perl functions from C is done through a stack discipline, like in
 Lua.
 Input parameters are specified through push operations and return values
 are obtained from the stack after the function call.
 The call functions 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 and 
\family typewriter 
call_method
\family default 
 vary only in the way how the function to be called is specified: through
 an 
\family typewriter 
SV
\family default 
, a C string, or a C string describing the name of a method in some object
 or class previously inserted in the stack.
 The 
\family typewriter 
call_argv
\family default 
 function, as a convenience, receives as an additional argument a C array
 containing C strings representing arguments to be pushed.
 All of them return the number of return values available in the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: contextos Perl
\end_inset 


\layout Standard

All 
\family typewriter 
call_
\family default 
* functions receive an argument with flags to be passed that indicate how
 the function should be called and how to handle input arguments and return
 values.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 and 
\family typewriter 
G_ARRAY
\family default 
 indicate the context how the function should be called.
 In scalar contexts, for example, only one scalar is returned in the stack;
 if the called function returns a list, only its last element will be available
 on the stack.
 
\family typewriter 
G_DISCARD
\family default 
 specifies that return values should be automatically discarded; 
\family typewriter 
G_NOARGS
\family default 
 indicates that the default array of parameters, 
\family typewriter 
@_
\family default 
, should not be constructed
\begin_inset Foot
collapsed true

\layout Standard

This has the side effect that the called function inherits the value of
 
\family typewriter 
@_
\family default 
 from its caller.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

The procedure for error checking depends on the context and given flags,
 which affect how error situations are reported to the return value of 
\family typewriter 
call_
\family default 
* functions and to values returned on the stack.
 The 
\family typewriter 
G_EVAL
\family default 
 flag encapsulates the call in an 
\family typewriter 
eval
\family default 
 block, capturing errors.
 So, the occurrence of errors can be checked through the 
\family typewriter 
ERRSV
\family default 
 macro, which returns an 
\family typewriter 
SV
\family default 
 containing the error message.
 By adding the 
\family typewriter 
G_KEEPERR
\family default 
 flag, error messages do not overwrite the special variable 
\family typewriter 
$@
\family default 
, but concatenate to it, accumulating sequences of errors in diferent call
 levels.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A series of macros describe a protocol for calling functions and manipulating
 input and output parameters.
 The main ones will be explained below, as we present the Perl version of
 the 
\family typewriter 
test
\family default 
 function call:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("foo", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("test", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Controle de referências no exemplo
\end_inset 


\layout Standard

First, 
\family typewriter 
dSP
\family default 
 declares a local copy of Perl's stack pointer.
 Then, 
\family typewriter 
ENTER
\family default 
 and 
\family typewriter 
SAVETMPS
\family default 
 create a scope for mortal values.
 
\family typewriter 
PUSHMARK
\family default 
 starts the count of parameters to be passed to the function.
 These parameters are then pushed with 
\family typewriter 
XPUSHs
\family default 
.
 Values created with 
\family typewriter 
newSVpv
\family default 
 and 
\family typewriter 
newSViv
\family default 
 are converted to mortal values with 
\family typewriter 
sv_2mortal
\family default 
, so that they do not need to have their reference counts decremented explicitly
 after the function call.
 
\family typewriter 
PUTBACK
\family default 
 finishes counting parameters.
 Then, we call the global Perl function 
\family typewriter 
test
\family default 
, in scalar context, with 
\family typewriter 
call_pv
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

After this function returns, memory in Perl's stack may have been reallocated,
 changing the address of the stack pointer obtained with 
\family typewriter 
dSP
\family default 
.
 To make sure its value is correct, one must call 
\family typewriter 
SPAGAIN
\family default 
 after 
\family typewriter 
call_
\family default 
* functions.
 The 
\family typewriter 
POPl
\family default 
 function pops a value and converts it to 
\family typewriter 
long
\family default 
 (there are similar functions for other types, such as 
\family typewriter 
POPs
\family default 
 for 
\family typewriter 
SV
\family default 
s and 
\family typewriter 
POPpx
\family default 
 for strings).
 These operations pop values updating the local copy of the stack pointer.
 Thus, 
\family typewriter 
PUTBACK
\family default 
 must be called again to update the global pointer.
 Finally, 
\family typewriter 
FREETMPS
\family default 
 and 
\family typewriter 
LEAVE
\family default 
 decrement the reference count of mortal values.
\layout Subsection

Comparison
\layout Standard

In Python, Lua and Perl, functions can be accessed as language objects and
 invoked.
 In Ruby and Java, the API defines special types used to reference methods.
 Like in data manipulation, Python offers an extensive API, with several
 convenience functions allowing parameters to be passed as Python tuples,
 Python objects given as varargs, C values to be converted by the invocation
 function, etc.
 Java also offers a large number of method invocation functions and, due
 to static typing, input parameters can be passed as varargs in a direct
 way, without having to specify how their conversion should be made.
 Ruby also offers some variants for call functions.
\layout Standard

Lua, in contrast, separates the function call routine from argument passing,
 which is done previously through the stack.
 This is a very simple solution, but the resulting code is less clear than
 the equivalent calls in languages such as Ruby and Python.
 Perl also features function calls using a stack model, but unlike Lua its
 use is exceedingly complex, demanding a macro protocol to be followed which
 exposes the internal workings of the interpreter.
 Another complicating factor is the handling of return values, for these
 vary according to the Perl context in which the function is called.
\layout Standard

In Lua and Python, the occurrence of errors can be checked through the function'
s return value.
 In a similar way, Perl allows detecting errors in the most recent call
 checking a special variable; in Java, this is done calling an API function.
 In Ruby, error handling is more convoluted: strangely, the API offers a
 function for invoking C functions in protected mode, but lacks an equivalent
 for calling Ruby functions.
 It is necessary to write a wrapper function in those cases, which will
 be illustrated in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Section

Registering C functions
\layout Standard

To allow the invocation of C functions from code written in a scripting
 language, its API must provide a way to register these functions in the
 execution environment.
 In statically typed languages, such as Java, to make it possible to call
 external functions using the same syntax as native calls, the set of external
 functions must be declared 
\emph on 
a priori
\emph default 
 in some way.
 On the other hand, in dynamically typed languages, as it is the case with
 Python, Lua, Ruby and Perl, functions can be used directly; defining them
 at some point in time before their call is sufficient.
 This way, one can declare external functions at runtime through C code
 using the scripting language API.
\layout Standard

Again in this section, the presentation of each language will conclude with
 an example.
 A C function, which like in the previous section's examples, receives an
 integer and a string and returns an integer, will be registered.
 We will present as well, for each language, how to register this function
 as a global value
\begin_inset Foot
collapsed true

\layout Standard

Or in the case of Java, a static method.
\end_inset 

 
\family typewriter 
test
\family default 
 so that it can be directly invoked from the language or through the API.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

Python does not have a proper 
\begin_inset Quotes eld
\end_inset 

function
\begin_inset Quotes erd
\end_inset 

 type declarable from C.
 Class methods, however, are objects and have a specific type, which can
 be verified with the 
\family typewriter 
PyMethod_Check
\family default 
 function.
 Typically, methods are created passing an array of 
\family typewriter 
PyMethodDef
\family default 
 structures.
 These structures are composed by the name of the function, the pointer
 to the C function, a flags vector and a documentation string.
 These flags are used to indicate the convention adopted for input parameters
 in the C function.
 The most common flags are: 
\family typewriter 
METH_NOARGS
\family default 
, used for Python functions which receive no arguments, indicating that
 the C function will receive a sole 
\family typewriter 
PyObject
\family default 
 pointer which will contain the method's 
\family typewriter 
self
\family default 
; 
\family typewriter 
METH_VARARGS
\family default 
, for functions that receive as a second parameters a Python tuple containing
 a variable number of parameters passed from Python to C; and 
\family typewriter 
METH_KEYWORDS
\family default 
, to indicate that the C function receives as a third parameter a dictionary
 containing keyword arguments passed to the function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\end_inset 


\layout Standard

With this information in hand, API functions which operate on 
\family typewriter 
PyMethodDef
\family default 
 arrays can create and associate method objects to Python's space.
 
\family typewriter 
Py_InitModule
\family default 
, for example, initializes a module with functions from a 
\family typewriter 
PyMethodDef
\family default 
 array.
 Likewise, methods of a class implemented in C can be given in the tp_methods
 field of the 
\family typewriter 
PyTypeObject
\family default 
 structure relative to the class.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

C functions registered in Python must return a pointer to PyObject, or NULL
 in case of error (optionally declaring an exception with 
\family typewriter 
PyErr_SetString
\family default 
 or 
\family typewriter 
PyErr_SetObject
\family default 
).
 Functions that do not return values must return the pre-defined object
 
\family typewriter 
Py_None
\family default 
, always keeping in mind reference counting issues for returned values as
 discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

O que são funções na linguagem
\end_inset 


\layout Standard

Although methods are usually created in C using 
\family typewriter 
PyMethodDef
\family default 
 structures, it is also possible to create a method object explicitly from
 C with the 
\family typewriter 
PyMethod_New
\family default 
 function, passing as a parameter any callable Python object and the object
 or class is should refer to.
 As seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, Python object can be made callable by implementing a 
\family typewriter 
__call__
\family default 
 method in Python or associating a C function to the 
\family typewriter 
tp_call
\family default 
 field of their corresponding 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo
\end_inset 


\layout Standard

A simple implementation of a C function that can be registered in Python
 as the 
\family typewriter 
test
\family default 
 global function is given below:
\layout LyX-Code


\size footnotesize 
PyObject* test_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* foo; long n;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* In case of argument errors, PyArg_ParseTuple
\layout LyX-Code


\size footnotesize 
\emph on 
      raises the appropriate exception automatically */
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &foo, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Received: %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Since arguments were received as a tuple in the second parameter, the function
 signature corresponds to the 
\family typewriter 
METH_VARARGS
\family default 
 flag.
 Input arguments are converted to C and checked with 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 The return value is converted from the native C type to a 
\family typewriter 
PyObject
\family default 
 with 
\family typewriter 
PyInt_FromLong
\family default 
, generating a new reference.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de global
\end_inset 


\layout Standard

The Python API is designed primarily to the development of extension modules
 for the language.
 Though several functions exist for registering methods in classes and initializ
ing modules with function lists, there is no direct way for registering
 global functions in the virtual machine.
 A possible way is using the utility routing for method lookup, 
\family typewriter 
Py_FindMethod
\family default 
, and inserting the returned moethod in the dictionary of the global module
 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef test_def[] = {
\layout LyX-Code


\size footnotesize 
   { "test", (PyCFunction) test_py, METH_VARARGS, "a test" },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* test_obj = Py_FindMethod(test_def, NULL, "test");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "test", test_obj);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that 
\family typewriter 
NULL
\family default 
 was passed to 
\family typewriter 
Py_FindMethod
\family default 
, indicating that there is no object the method will be part of.
 Because of that, the 
\family typewriter 
self
\family default 
 argument received by the C function 
\family typewriter 
test_py
\family default 
 will also be 
\family typewriter 
NULL
\family default 
 and can be ignored.
 The 
\family typewriter 
test_def
\family default 
 array was declared 
\family typewriter 
static
\family default 
 to ensure that the 
\family typewriter 
PyMethodDef
\family default 
 will remain valid as long as the global function is registered, as in the
 creation of 
\family typewriter 
test_obj
\family default 
 a pointer to it is stored internally in the newly created object.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\layout Standard

Convenção para parâmetros de entrada
\end_inset 


\layout Standard

For C functions to be callable from Ruby, they must be declared as methods
 of some class or module, or as a global function.
 For that, a C function pointer and the number of arguments expected by
 the function is passed to one of the appropriate functions of the Ruby
 API: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 or 
\family typewriter 
rb_define_singleton\SpecialChar \-
_method
\family default 
.
 The number of arguments passed indicates the expected signature for the
 C function.
 Ruby supports explicitly C functions with up to 15 arguments; as an alternative
, the special values -1 and -2 indicate, respectively, that the C function
 will receive its arguments as a C array of 
\family typewriter 
VALUE
\family default 
s or as a 
\family typewriter 
VALUE
\family default 
 corresponding to a Ruby array.
\layout Standard

Resembling the 
\family typewriter 
PyArg_ParseTuple
\family default 
 function discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

, Ruby features a function designed to simplify the processing of input
 values in C functions: 
\family typewriter 
rb_scan_args
\family default 
.
 This function can be used when input arguments are received in a Ruby array.
 Like 
\family typewriter 
PyArg_ParseTuple
\family default 
, it is a vararg function which receives a format string indicating the
 number of arguments to be collected.
 Unlike its Python counterpart, though, it does not perform type checking
 in its arguments.
 The format string allows indicating the minimum and maximum number of parameter
s that will be accepted and if exceeding parameters should be collected
 into a Ruby array.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: blocos
\end_inset 


\layout Standard

Once declared in Ruby's object space, a C function can be called like any
 other method.
 The C function can check if Ruby code has passed it a code block through
 the 
\family typewriter 
rb_block_given_p
\family default 
 function.
 The block can then be invoked with 
\family typewriter 
rb_yield
\family default 
, which receives a 
\family typewriter 
VALUE
\family default 
 as an argument.
 To pass multiple arguments to 
\family typewriter 
rb_yield
\family default 
, one must pass a Ruby array.
 To obtain a 
\family typewriter 
VALUE
\family default 
 of the Proc type produced from a received code block it is necessary to
 use 
\family typewriter 
rb_scan_args
\family default 
, which provides functionality similar to that of the 
\family typewriter 
&
\family default 
 operator in Ruby function declarations.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

C functions implementing Ruby methods must always return a 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 when there is no result).
 Functions that return multiple values must do so through Ruby arrays.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Proceeding with the series of examples, the Ruby global function 
\family typewriter 
test
\family default 
 can be implemented in C as follows:
\layout LyX-Code


\size footnotesize 
VALUE test_rb(VALUE self, VALUE val_foo, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* foo = StringValuePtr(val_foo);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Received: %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Conversion of input 
\family typewriter 
VALUE
\family default 
s is done with the 
\family typewriter 
StringValuePtr
\family default 
 and 
\family typewriter 
NUM2INT
\family default 
 macros.
 There is no explicit code for error handling during these conversions because
 these macros trigger exceptions that escape the function using 
\family typewriter 
longjmp
\family default 
 in case the conversion was not possible.
 For output, a 
\family typewriter 
VALUE
\family default 
 is produced with the 
\family typewriter 
INT2NUM
\family default 
 macro.
 The first input argument is necessary because of the convention of function
 signatures adopted by the API, but for global functions it should be ignored.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de fn global
\end_inset 


\layout Standard

As Ruby offers an API function for defining global functions, the registration
 of 
\family typewriter 
test
\family default 
 is very simple:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("test", test_rb, 2); 
\layout Standard

We indicate the Ruby name of the function, the corresponding C function
 and the number of arguments it expect (not including 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: métodos native
\end_inset 


\layout Standard

Methods declared in Java that are not implemented in the language itself
 must be declared through a prototype including the 
\family typewriter 
native
\family default 
 modifier.
 Thus, 
\family typewriter 
native
\family default 
 does not refer to a native implementation in Java, but to the fact that
 the method's code will be compiler with native code of its runtime environment,
 as opposed to virtual machine bytecodes.
 The implementation of the method, usually wrapped in a C dynamic library,
 must be loaded before its execution using the 
\family typewriter 
System.loadLibrary
\family default 
 call in Java, usually in a static block of the corresponding class.
 For each 
\family typewriter 
native
\family default 
 method, a matching C function must be declared in the loaded library.
\layout Standard

The 
\family typewriter 
javah
\family default 
 utility generates C header files from Java classes, with prototypes for
 C functions following the format specified by the JNI.
 This format specifies not only the signature of input parameters and return
 types, but also the name of the function, so that the loader can link the
 C function to the proper Java method in the virtual machine.
 Functions must be called Java_
\emph on 
<class name>
\emph default 
_
\emph on 
<method name>
\emph default 
.
 In case of function overloading, a suffix is added indicating the type
 of input parameters (for example, 
\family typewriter 
Java_SomeClass_method__DI
\family default 
 for the version of 
\family typewriter 
SomeClass.method
\family default 
 which accepts a 
\family typewriter 
double
\family default 
 and an 
\family typewriter 
int
\family default 
 as arguments).
\layout Standard

The function input arguments are a pointer to 
\family typewriter 
JNIEnv
\family default 
, which represents a thread in the JVM, a 
\family typewriter 
jobject
\family default 
 representing the object on which the method was applied (or a 
\family typewriter 
jclass
\family default 
 for static methods) and the remaining arguments of the Java method in their
 C representations, discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 As the types of given arguments are defined statically both in Java and
 C, it is not necessary to perform type checking of received arguments in
 C code.
 The signatures of functions which implement methods, specified in header
 files generated by the 
\family typewriter 
javah
\family default 
 tool, already declare correct types.
\layout Standard

The return value corresponds the equivalent C type to the return type declared
 in the Java method.
 Values represented as reference types can be returned either as local or
 global references.
 Besides handling or propagating errors as discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, C functions can also generate exceptions with 
\family typewriter 
Throw
\family default 
 and 
\family typewriter 
ThrowNew
\family default 
 and return immediately.
 The return value will be ignored when the exception is captured in Java
 code.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de função global
\layout Standard

Funções da API para registrar funções (não há)
\end_inset 


\layout Standard

Since the way for exposing to the virtual machine Java functions implemented
 in C is different than that used in languages presented earlier, we will
 start by declaring the function to the Java space, and present the C implementa
tion of 
\family typewriter 
test
\family default 
 afterwards.
 In the Java class, we declare a 
\family typewriter 
native
\family default 
 method:
\layout LyX-Code


\size footnotesize 
public class Example {
\layout LyX-Code


\size footnotesize 
   static native int test(String foo, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...other class members
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Example");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

After compiling this class we can pass it to the 
\family typewriter 
javah
\family default 
 command, which will generate a C header.
 This file will contain the name and signature of the C function that the
 JVM will lookup in the library that will be loaded by 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed false

\layout Standard

The argument given to it in Java code is used as a basis when constructing
 a platform-dependent name.
 In Unix systems, for example, 
\family typewriter 
System.loadLibrary("Example")
\family default 
 loads the file 
\family typewriter 
libExample.so
\family default 
.
\end_inset 

.
 This library will implement functions relative to methods declared as 
\family typewriter 
native
\family default 
.
\layout Standard

Below, we present a C implementation, using the header generated by 
\family typewriter 
javah
\family default 
, for the 
\family typewriter 
test
\family default 
 method:
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
\emph on 
/* Header generated by javah */
\layout LyX-Code


\size footnotesize 
#include "Example.h" 
\layout LyX-Code


\size footnotesize 
 
\newline 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Example_test(JNIEnv* J, jclass c, jstring obj_foo, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* foo = (*J)->GetStringUTFChars(J, obj_foo, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_foo, foo);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 and 
\family typewriter 
JNICALL
\family default 
 are macros defined in jni.h to provide greater portability to the resulting
 C code.
 Since the method was declared 
\family typewriter 
static
\family default 
 in Java, a class reference is received as an argument to the function.
 The remaining arguments correspond to the arguments of the Java method,
 and are given in the equivalent types defined by the JNI.
 As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, the JNI handles reference types and immediate types differently.
 Because of that, only 
\family typewriter 
obj_foo
\family default 
 needs to be converted to C; both 
\family typewriter 
n
\family default 
 and the return value are used directly as basic C data types.
\layout Standard

The string obtained with 
\family typewriter 
GetStringUTFChars
\family default 
 is converted to UTF-8 from its internal Unicode representation in Java.
 The same pointer can be returned by the JVM to different threads that request
 the same string.
 This way, C code must explicitly notify its release with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

C functions exposed to Lua must match the 
\family typewriter 
lua_CFunction
\family default 
 type, receiving as a single argument a pointer to a variable of the 
\family typewriter 
lua_State
\family default 
 type and returning an 
\family typewriter 
int
\family default 
.
 A 
\family typewriter 
lua_State
\family default 
 encapsulates the entire state of a Lua virtual machine; multiple Lua states
 can be mantained in parallel.
 Every function of the core API receives a 
\family typewriter 
lua_State
\family default 
 as a first argument, except for 
\family typewriter 
lua_newstate
\family default 
, which creates a new 
\family typewriter 
lua_State
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Convenções p/ parâmetros de entrada
\end_inset 


\layout Standard

At the beginning of the C function, arguments given to it are available
 in the virtual stack.
 Like in Lua functions, there is no checking on the number of arguments
 given to a C function invoked from Lua or through the API.
 C code can check the number of received arguments inspecting the size of
 the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

The auxiliary library also provides functions for checking in a more convenient
 way types of passed arguments.
 Functions of the 
\family typewriter 
luaL_check
\family default 
* family (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) check the type of a stack elements and return them, signalling error
 if the element type is not as requested.
 The 
\family typewriter 
luaL_opt
\family default 
* functions behave in a similar way, allowing also to indicate a default
 value if the requested element is absent or 
\family typewriter 
nil
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Return values are also passed by the C function back to Lua through the
 virtual stack.
 The integer value returned by the C function indicates how many elements
 of the stack should be returned to the caller function.
 Any remaining values are discarded.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API p/ registrar funções
\end_inset 


\layout Standard

A C function of the 
\family typewriter 
lua_CFunction
\family default 
 type can be passed to Lua through the 
\family typewriter 
lua_pushcfunction
\family default 
 call.
 Lua has also some convenience functions for registering a set of C functions
 at once.
 Like when using 
\family typewriter 
PyMethodDef
\family default 
 arrays in Python, the 
\family typewriter 
luaL_register
\family default 
 function registers a list of functions, receiving an array of luaL_Reg
 structures containing names and function pointers.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

A C function implemented the example function 
\family typewriter 
test
\family default 
 is given below:
\layout LyX-Code


\size footnotesize 
int test_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* foo = luaL_checkstring(L, 1); 
\emph on 
 /* Get the first argument */
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);         
\emph on 
/* Get the second argument */
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);                     
\emph on 
/* Push the return value */
\layout LyX-Code


\size footnotesize 
   return 1;               
\emph on 
/* Return one value, off the top of the stack*/
\layout LyX-Code


\size footnotesize 
}
\layout Standard

The function's signature matches the definition of 
\family typewriter 
lua_CFunction
\family default 
.
 Input parameters are obtained from stack positions 1 and 2 and their types
 are checked using the auxiliary library functions 
\family typewriter 
luaL_checkstring
\family default 
 and 
\family typewriter 
luaL_checkinteger
\family default 
.
 These functions signal error in case of conversion failure, causing a 
\family typewriter 
longjmp
\family default 
 like in Ruby.
\layout Standard

The type of the obtained string is 
\family typewriter 
const char*
\family default 
, as it points to a memory block managed by the virtual machine.
 In Lua, however, it is not necessary to notify explicitly the release of
 the string, because it remains valid as long as the value is on the stack.
 As the functions 
\family typewriter 
luaL_check
\family default 
* do not pop the parameters and the stack is emptied implicitly by the end
 of the C function, the obtained C string will remain valid during the whole
 function.
\layout Standard

At the end of 
\family typewriter 
test_lua
\family default 
, the return value passed to Lua is pushed using 
\family typewriter 
lua_push\SpecialChar \-
integer
\family default 
.
 The return value of the function in C, 
\family typewriter 
1
\family default 
, indicates to the virtual machine that there is a single output value to
 be fetched from the stack and used as a function result in Lua.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro
\end_inset 


\layout Standard

The function is registered in Lua creating a Lua object of the 
\family typewriter 
function
\family default 
 type from the C function and storing this object in a global variable.
 This could be done with 
\family typewriter 
lua_pushcclosure
\family default 
 and 
\family typewriter 
lua_setglobal
\family default 
, but Lua's header file has a macro that wraps these two calls.
 Therefor, hte function can be registered simply with:
\layout LyX-Code


\size footnotesize 
lua_register(L, "test", test_lua);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Using 
\family typewriter 
lua_pushcclosure
\family default 
, it is possible to associate to a C function Lua values that will be accessible
 to the function every time it is called, akin to local 
\family typewriter 
static
\family default 
 variables in C.
 This feature provides functionality that is similar to Lua closures, but
 in a more limited form: these values are private to C functions, while
 in Lua two closures defined in a single scope will access the same variables,
 that is, changes to values in one function will affect the other.
 This restricted form, however, is often enough for implementing in C 
\begin_inset Quotes eld
\end_inset 

stateful functions
\begin_inset Quotes erd
\end_inset 

 such as iterators and generators.
 Once registered in Lua, C functions are seen as values of the 
\family typewriter 
function
\family default 
 type, no differently than Lua functions.
 In fact, 
\family typewriter 
lua_pushcfunction
\family default 
 is a particular case of 
\family typewriter 
lua_pushcclosure
\family default 
 in which no Lua values are associated to the function.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas
\end_inset 


\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

, the interface between Perl and C was designed having in mind that the
 connection between C functions and the Perl interpreter is made through
 generated code from a description given in a higher-level language, XS.
 XS code consists of function signature declarations using a special syntax,
 indicating conversion rules for input and output parameters, and C code
 describing the implementation of these functions.
 XS was designed for the development of Perl extensions including functions
 implemented in C: the end result of the compilation of code generated by
 the XS tools (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) are C and Perl code that combined describe a Perl package (a set of variables
 and functions stored under a common namespace).
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções (não tem)
\end_inset 


\layout Standard

There is a public API for manipulating Perl data in C code, but this consists
 basically of the interpreter's internal structures exposed for use by the
 XS pre-processor, extended with some macros for programmer convenience.
 In fact, Perl does not expose a documented API for registering functions\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

.
 Because of that, it is not practical for an application to embed a Perl
 interpreter and expose to it a set of C functions using C code only.
 The alternative is to create a Perl extension using XS which exposes functions
 from the application and import the resulting package into the embedded
 interpreter.
 We observed the use of this approach in Perl scripting plugins of several
 applications
\begin_inset Foot
collapsed false

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) and Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) are some applications that implement Perl plugins through XS extensions.
 In the Perl plugin for Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), there are no 
\family typewriter 
.xs
\family default 
 files, but 
\family typewriter 
.c
\family default 
 sources include functions declared with undocumented APIs and Perl code
 equivalent to the 
\family typewriter 
.pm
\family default 
 file generated by xsubpp is declared as a C string evaluated with 
\family typewriter 
eval_pv
\family default 
, leading us to assume that the plugin was implemented as an XS extension
 and later converted to a single C source file.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

The 
\family typewriter 
h2xs
\family default 
 utility generates a directory containing the skeleton of a Perl module:
 a Makefile generator script, 
\family typewriter 
.xs
\family default 
 and 
\family typewriter 
.pm
\family default 
 files to be filled by the programmer with XS and Perl code, as well as
 auxiliary files.
 Resuming the example of the 
\family typewriter 
test
\family default 
 function, this is how it would be declared in XS:
\layout LyX-Code


\size footnotesize 
long test(foo, n)
\layout LyX-Code


\size footnotesize 
        char* foo
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

The .xs file is converted to 
\family typewriter 
.c
\family default 
 with 
\family typewriter 
xsubpp
\family default 
.
 C code for converting input and output parameters is generated automatically.
 In some cases, however, we need to manipulate values from the Perl stack
 explicitly, as described in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 In vararg functions, for example, additional arguments must be accessed
 directly from the stack.
 Code for registering module functions is also generated automatically.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

XS creates variable called 
\family typewriter 
RETVAL
\family default 
 automatically for storing the return value in C code.
 The contents of this variable are then converted to a Perl value by generated
 C code.
 To make sure that functions returning arrays will operate correctly in
 scalar contexts, their code should verify the context the function was
 called with 
\family typewriter 
GIMME_V
\family default 
 and then return an 
\family typewriter 
SV
\family default 
 or 
\family typewriter 
AV
\family default 
 accordingly.
 In those cases, a function must be declared with 
\family typewriter 
SV*
\family default 
 as the return type, and as such, C values have to be converted to Perl
 
\family typewriter 
SV
\family default 
s explicitly.
 The documentation alerts that, for the case of 
\family typewriter 
AV
\family default 
s, one must declare the return value as a mortal variable
\begin_inset Foot
collapsed false

\layout Standard

This behavior is described in the documentation as 
\begin_inset Quotes eld
\end_inset 

an unfixable bug (fixing it would break lots of existing CPAN modules)
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{roehrich06perlxs}

\end_inset 

.
 
\end_inset 

.
\layout Standard

Once a extension is compiled using Makefiles generated by 
\family typewriter 
h2xs
\family default 
, it can be loaded an used from Perl:
\layout LyX-Code


\size footnotesize 
use Example;
\layout LyX-Code


\size footnotesize 
$ret = Example::test("foo", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To expose functions from a C application to an embedded Perl interpreter,
 we have to create an extension that wraps these functions using XS, link
 the extension to the application and load it.
 The loading is performed passing to the interpeter during its initialization
 a C function containing 
\family typewriter 
newXS
\family default 
 calls.
 The 
\family typewriter 
ExtUtils::Embed
\family default 
 Perl module has a utility routine called 
\family typewriter 
xsinit
\family default 
 which generates C code for this function.
 In practice, generating code with 
\family typewriter 
xsinit
\family default 
 is the best approach, since the initialization protocol depends on undocumented
 routines (the example initialization function included in Perl's documentation\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

 is out-of-date).
\layout Subsection

Comparison
\layout Standard

Python and Ruby offer to the programmer various options for C function signature
s that are recognized by the API, which is practical, given that this way
 one can choose different C representations for the input parameters (collected
 in an array, obtained one by one, etc.) according to their use in the function.
 Lua offers only one possible signature for C functions to be registered
 in its virtual machine, but this is appropriate for the stack model adopted
 by its API.
\layout Standard

In Java, function signatures are created through the 
\family typewriter 
javah
\family default 
 tool -- due to its static type system, types of input parameters passed
 by Java are converted automatically by the JNI, which is very convenient
 as it avoids explicit operations for conversion and type checking in the
 function.
 Because of their dynamic type systems, the other languages offer specific
 API functions for performing these checks.
 Perl function signatures are created only through the XS tool, but differently
 from Java they are not exposed to the programmer.
 This brings the inconvenience that the programmer needs to pre-process
 C code as an XS extension even when they are embedding Perl in an application.
\layout Standard

Registration of functions in Ruby and Lua is simple.
 In Lua, in particular, it is an assignment, not different from any other
 object.
 In Python, there are features for batch registering, using 
\family typewriter 
PyMethodDef
\family default 
 arrays (Lua offers a similar feature with 
\family typewriter 
luaL_register
\family default 
), but there is no simple way to register a single function.
 Both in Java and Perl, function registration is done implicitly, and there
 are no API functions for registering new C functions at runtime in either
 of them.
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Case study: LibScript
\layout Standard

In previous chapters, we discussed the main issues involving language interfaces
 for C and the way these issues are handled by the languages covered by
 this study.
 In this chapter, we will make a comparison between their APIs through a
 concrete example, in order to put implementations on each of those languages
 side by side.
 The example consists of a generic scripting library called LibScript, and
 a series of plugins that interface different scripting languages.
\layout Section

LibScript
\layout Standard

LibScript is a library designed to provide extensibility to applications
 through scripting in a language-independent way.
 It is based on a plugin architecture, in order to decouple the application
 from runtime environments provided by the various languages.
 The main library provides a language-independent scripting API, allowing
 an application to register its functions and launch scripts that use these
 functions.
 This library then invokes a plugin for the appropriate language to run
 the script (for example, LibScript-Python for Python code).
 This way, application developers allow their users to employ different
 scripting languages without adding all of them as program dependencies.
\layout Standard

The main library provides features for registering C functions from the
 application and for calling these functions from the plugins (allowing
 scripts to access these functions), besides functions for transferring
 data between the application and plugins.
 It is also possible to invoke functions implemented in virtual machines
 embedded in plugins, enabling scripts written in different languages to
 interact with each other.
\layout Subsection

Architecture of LibScript
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura1.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Visão-geral}

\end_inset 

Overview of the LibScript architecture
\end_inset 


\layout Standard

LibScript is composed of a main dynamic library, 
\family typewriter 
libscript
\family default 
, and plugins for different languages (Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Visão-geral}

\end_inset 

).
 The main library is linked to an application, and exposes to it a language-inde
pendent scripting API which allows running files, strings of code and invoking
 functions.
 This library is a thin layers which forwards these operations to plugins,
 which are auxiliary dynamic libraries, loaded at runtime by the main library.
 These plugins embed the scripting languages' runtime environments.
 
\layout Standard

The application can register C functions in the main library (illustrated
 by the 
\family typewriter 
c_fun
\family default 
 function in the figure) and ask it to run scripts which register functions
 in different languages.
 However, the application does not interact directly with plugins.
 When the main library receives code to be executed in a given language,
 it loads the appropriate plugin (in case it was not already loaded) and
 forwards the code.
 The plugin will run the script in its virtual machine, which may register
 in it new functions (illustrated by functions 
\family typewriter 
py_fun
\family default 
, 
\family typewriter 
r_fun
\family default 
, 
\family typewriter 
l_fun
\family default 
 and 
\family typewriter 
pl_fun
\family default 
 in the figure).
\layout Standard

The main library decides which plugin to load through an identifier which
 specifies which is the language of the code to be executed.
 This identifier can be obtained from the filename extension of a script,
 through the 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

#!
\begin_inset Quotes erd
\end_inset 


\family default 
 identification line at the beginning of the script
\begin_inset Foot
collapsed false

\layout Standard

The 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

#!
\begin_inset Quotes erd
\end_inset 


\family default 
 line is used only to detect which language the script is written in.
 For example, a line with 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 will indicate that libscript-perl should be loaded, but the Perl interpreter
 in 
\family typewriter 
/usr/bin
\family default 
 is not used and the 
\family typewriter 
-w
\family default 
 flag is not considered.
\end_inset 

 or even passed explicitly by the application.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura2.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ambientes-virtuais}

\end_inset 

Ambientes virtuais em LibScript
\end_inset 


\layout Standard

Functions are registered in LibScript in a virtual environment.
 An application can create one or more environments in the main library,
 identifying them through a name.
 A virtual environment has, in each plugin, a language-specific data structure
 (class, module, etc.) which will represent it.
 In the example in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Ambientes-virtuais}

\end_inset 

 we have two virtual environments created by the application in the main
 library, 
\family typewriter 
X
\family default 
 and 
\family typewriter 
Y
\family default 
.
 In each of these environments, the application registered a C function
 with the name 
\family typewriter 
c_fun
\family default 
 (which may or may not correspond to the same C function).
 Scripts were executed in these environments, which prompted the loading
 of plugins.
 In the example, these scripts registered some functions (
\family typewriter 
X.py_fn
\family default 
, 
\family typewriter 
Y.py_fn
\family default 
, 
\family typewriter 
X#r_fun
\family default 
, etc.).
\layout Standard

Apart from the function for creating a virtual environment, all functions
 in the LibScript API receive as an argument a virtual environment they
 should operate on.
 This indicates in which C structure should be stored error messages and
 return values.
 For languages that allow multiple independent runtime states, like Lua
 and Perl, this also indicates in which state the script should run.
\layout Standard

When a script declares a function in a virtual environment, this function
 becomes accessible through the LibScript API.
 For example, in the Lua plugin, virtual environments are represented as
 tables named after the environment; once a Ruby method\SpecialChar ~

\family typewriter 
r
\family default 
 is declared in class 
\family typewriter 
X
\family default 
, this function becomes callable by C (using the LibScript API) or by other
 plugins.
 So, for example, even though the Lua table that implements virtual environment
 
\family typewriter 
X
\family default 
 contains only function 
\family typewriter 
l_fun
\family default 
, Lua scripts can invoke other functions through the virtual environment,
 like 
\family typewriter 
X.c_fun
\family default 
 and 
\family typewriter 
X.r_fun
\family default 
.
 These calls will be handled by the main library and resolved by itself,
 in the case of C functions such as 
\family typewriter 
X.c_fun
\family default 
, or forwarded to the appropriate plugin, as in the case of 
\family typewriter 
X.r_fun
\family default 
, performing the call in the Ruby plugin and forwarding return values back
 to the Lua plugin.
 The main library finds the function do be executed consulting each plugin,
 as it will be explained in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:A-API-de-plugins}

\end_inset 

.
\layout Standard

When implementing plugins, we used features offered by these languages to
 handle accesses to missing elements in their structures, capturing these
 accesses and forwarding them to the main library.
 These features will be discussed in Section \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

.
\layout Subsection


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

The main library API
\layout Standard

The API provided by LibScript isolates the application from the different
 APIs provided by scripting languages.
 It is not only a matter of adding a layer of indirection between calls,
 which would be appropriate only for features that are common to all of
 them, such as initialization and function calls.
 The main issue here are the various features that are particular to each
 language.
 An unpractical approach would be to define the API as the union of the
 feature sets of every supported language (such as offering features for
 sequence handling to map this Python feature, table handling features for
 Lua, and so on).
 This path would bring several problems: the API would be complex and would
 probably have to be extended as each new language is introduced; even for
 mappings that could apparently be reused (for example, mapping Python hashes
 and Lua tables to a single API of associative arrays) there is the problem
 of subtle semantic variations between the implementations of those features
 in the various languages.
 Besides, application bindings could offer functionality that is available
 for a single language, going against the model of language independence
 proposed by LibScript.
\layout Standard

Another approach is to, instead of exposing the language API to the application,
 expose only a function API of the application to the language and keep
 its data structures and features restricted to the domain where it is invoked.
 The application interacts with the virtual machine sending strings of code
 to be executed and obtains results back when the script passes parameters
 when calling application functions.
 This approach is proposed in\SpecialChar ~

\begin_inset LatexCommand \cite{thomas02ltn004}

\end_inset 

 and uses what, for example, Python calls a 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy,vanrossum06ref}

\end_inset 

.
 Primitives for running strings of code are a basic feature in scripting
 languages -- 
\family typewriter 
luaL_loadstring
\family default 
 in Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 in Python, 
\family typewriter 
rb_eval_string
\family default 
 in Ruby , 
\family typewriter 
perl_eval_sv
\family default 
 in Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename figura3.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:API-para-execução}

\end_inset 

API para execução de código em LibScript
\end_inset 


\layout Standard

LibScript adopts this minimalist approach for its API: no specific operations
 for data structure manipulation are offered, only for 
\emph on 
executing strings
\emph default 
 -- 
\family typewriter 
script_run
\family default 
 (and the convenience function 
\family typewriter 
script_run_file
\family default 
, which reads a file and sends it to script_run) -- and 
\emph on 
function calls
\emph default 
 with basic types (numbers and strings) -- 
\family typewriter 
script_call
\family default 
.
 Operations on more complex data of language-specific types, when needed,
 can be encapsulated in functions implemented in the scripting language.
 One can also reference language objects from C storing it in structures
 of the scripting language and returning to C numerical indices of these
 structures, acting as high-level handles for these objects.
\layout Standard

Figure\SpecialChar ~

\begin_inset LatexCommand \ref{fig:API-para-execução}

\end_inset 

 depicts the interaction between the application, the main library and plugins
 with regard to these two fundamental operations, represented by functions
 
\family typewriter 
script_run
\family default 
 and 
\family typewriter 
script_call
\family default 
.
 For executing strings, the main library receives input from the application
 and forwards code to be executed to the appropriate plugin.
 When using 
\family typewriter 
script_run
\family default 
, two strings are passed, one identifying the language and another containing
 code; for 
\family typewriter 
script_run_file
\family default 
, a filename
\begin_inset Foot
collapsed false

\layout Standard

For code executed with 
\family typewriter 
script_run_file
\family default 
, the language is automatically detected as discussed in the previous section.
\end_inset 

.
 The following example declares a virtual environment, registers a C function
 called 
\family typewriter 
hello
\family default 
 and invokes it from Lua code:
\layout LyX-Code


\size footnotesize 
script_env* env = script_init("example");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "example.hello()");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The virtual environment is declared with the 
\family typewriter 
script_init
\family default 
 function.
 It receives the name that will identify the environment and returns an
 identifier of the 
\family typewriter 
script_env
\family default 
 type, which is an opaque pointer that represents a virtual environment.
 The C function is registered using 
\family typewriter 
script_new_\SpecialChar \-
function
\family default 
, which receives as arguments the environment, a function to be registered
 and the name that the function will have in the virtual environment.
 In Lua code, the function is accessed as element 
\family typewriter 
hello
\family default 
 (the registered name of the function) of global table 
\family typewriter 
example
\family default 
 (name of the virtual environment).
\layout Standard

For function calls, the application should pass input parameters (how this
 is done will be discussed later on), and call 
\family typewriter 
script_call
\family default 
, indicating the name of a function registered in the virtual environment.
 This same function 
\family typewriter 
script_call
\family default 
 is used by plugins when they wish to invoke functions from the virtual
 environment registered in C or implemented by other plugins.
\layout Standard

For this reason, we adopted a generic API for data transfer, to be used
 both in input and output of data, both in the communication between the
 application and the main library and between the main library and plugins.
 We chose an approach similar to those employed by Lua (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) and Perl (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) for sending data when passing parameters and obtaining return values,
 using an internal buffer as a transfer area.
 Differently from those languages, however, we pass indices to parameters
 explicitly instead of implementing a stack discipline.
 Functions 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} are used for input and output of values.
 Functions 
\family typewriter 
script_put_
\family default 
* store values in the internal buffer and 
\family typewriter 
script_get_
\family default 
* remove them.
 A call to a function called 
\family typewriter 
test
\family default 
 passing a string and an integer as parameters and obtaining an integer
 as a result is performed like this:
\layout LyX-Code


\size footnotesize 
script_put_string(env, 0, "foo");   
\emph on 
/* index 0: "foo" */
\layout LyX-Code


\size footnotesize 
script_put_int(env, 1, 2);          
\emph on 
/* index 1: 2 */
\layout LyX-Code


\size footnotesize 
script_call(env, "test");
\layout LyX-Code


\size footnotesize 
result = script_get_int(env, 0);    
\emph on 
/* return index 0 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Function calls are offered as a primitive operation because they allow a
 minimum degree of language-independent interoperability.
 Two goals are met this way.
 The first one is that this way C programs embedding LibScript can access
 the functionality of loaded scripts without having to include in their
 source code strings of code written in some specific scripting language,
 for example, inserting in their code an invocation to a callback function
 to be defined through a script.
 Notice that in the above example, the language in which the 
\family typewriter 
test
\family default 
 function is implemented is not specified.
 If the call was made by running a string of code, this would tie the applicatio
n to at least one scripting language.
 Using script_run_file and script_call, one can implement an extensible
 application without specifying explicitly the scripting language to be
 used with it.
 The second goal is allowing the plugins themselves to invoke functions
 defined in other plugins.
 We would have to provide to plugins an invocation function anyway, to allow
 them to invoke C functions registered into LibScript.
 Making this invocation function generic enough so that it can also invoke
 functions implemented in the plugins themselves does not make, thus, the
 main library API any more complex.
\layout Standard

The LibScript buffer was designed to be used only as a temporary transfer
 area between the main library and plugins, and not as a general facility
 for data storage and manipulation.
 Therefore, its API is focused on sequential insertion and removal of elements.
 For example, the insertion of an element at position 0 automatically empties
 the buffer, avoiding in most cases the need to use the 
\family typewriter 
script_reset_buffer
\family default 
 function, which performs this operation explicitly.
\layout Standard

C functions registered with 
\family typewriter 
script_new_function
\family default 
 must receive the virtual environment as a parameter and return an error
 code.
 Functions 
\family typewriter 
script_get_
\family default 
* and 
\family typewriter 
script_put_
\family default 
* are used to receive arguments and return values when implementing functions
 that can be called through LibScript, the same way they are used to pass
 arguments and obtain return values and perform calls with 
\family typewriter 
script_call
\family default 
.
\layout LyX-Code


\size footnotesize 
script_err test_lua(script_env* env) {
\layout LyX-Code


\size footnotesize 
   char* foo = script_get_string(env, 0);  
\emph on 
/* Input, index 0: string */
\layout LyX-Code


\size footnotesize 
   int n = script_get_int(env, 1);         
\emph on 
/* Input, index 1: integer */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Escape the function with an error if any script_get* failed.
 */
\layout LyX-Code


\size footnotesize 
   SCRIPT_CHECK_INPUTS(env);
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   free(foo);
\layout LyX-Code


\size footnotesize 
   script_put_int(env, 0, 42);             
\emph on 
/* Output, index 0: integer */
\layout LyX-Code


\size footnotesize 
   return SCRIPT_OK;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In LibScript, strings returned by script_get_string belong to the caller,
 being their responsibility to deallocate its memory, unlike what happens
 in similar function of the APIs of languages discussed in this work.
 Such decision was made due to the temporary nature of the LibScript buffer:
 returning to the caller a pointer to a string whose validity would be ensured
 only until the next API call would be counter-intuitive, and in practice
 would force the programmer to copy strings frequently.
\layout Subsection

The plugins API
\begin_inset LatexCommand \label{sub:A-API-de-plugins}

\end_inset 


\layout Standard

A plugin embedding a scripting language must implement four operations:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 and 
\family typewriter 
done
\family default 
.
 The main library expects that the dynamic library implementing a plugin
 for a language will expose four functions, named as 
\family typewriter 
script_plugin_
\family default 
\emph on 
<operation>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<language>
\emph default 
.
\layout Standard

The 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 function is responsible for initializing a plugin, and is called by the
 
\family typewriter 
script_init
\family default 
 function of the main library.
 When initializing a plugin, the main library passes to 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 a script_env pointer and receives a 
\family typewriter 
script_plugin_state
\family default 
, which is an opaque type which is always passed back to the plugin in subsequen
t calls.
 Each plugin defines its internal representation for 
\family typewriter 
script_plugin_state
\family default 
.
 Typical the virtual machine state and the LibScript virtual environment
 should be stored so that they can be later accessible through this handle.
 In Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 we will discuss how each plugin represents the environment and its internal
 state in 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

The 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<language>
\emph default 
 function is invoked by 
\family typewriter 
script_run
\family default 
.
 It receives a string containing code in the scripting language, executes
 this code in the virtual machine and returns a status code indicating success
 or the occurrence of compile or runtime errors.
 In case of errors, plugins should capture exceptions raised by the virtual
 machine and return the constant 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
.
 If it is possible to obtain from the language an error message, it can
 be propagated using the 
\family typewriter 
script_set_error_message
\family default 
 function from the main library.
 The message can be later consulted by the application using the 
\family typewriter 
script_error_message
\family default 
 function.
\layout Standard

The function 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 is used by 
\family typewriter 
script_call
\family default 
, and is responsible for performing calls to functions implemented in the
 language embedded by the plugin.
 If the function was defined in the plugin, that is, if a function with
 the given name was registered in the data structure that describes the
 environment within the virtual machine, it will be executed, and success
 or failure will be reported like it happens with 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<language>
\emph default 
.
 If the requested function was not defined in this virtual machine, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 must return the constant 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
 Input arguments and return values are passed through the argument buffer,
 using the same functions from the main library that are used to transfer
 data between the application and the main library, 
\family typewriter 
script_get_*
\family default 
 and 
\family typewriter 
script_put_*
\family default 
.
\layout Standard

The implementation of 
\family typewriter 
script_call
\family default 
 in the main library makes use of this behavior of plugins for invoking
 functions in a language-independent way.
 Initially, it tries to find a requested function in the list of registered
 C functions.
 If there is no C function in the virtual environment with that name, 
\family typewriter 
script_call
\family default 
 tries to locate the function in loaded plugins, calling 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 on each plugin and trying the next one each time it receives 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
\layout Standard

Finally, the 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<language>
\emph default 
 function is called by 
\family typewriter 
script_done
\family default 
 when a virtual environment is terminated.
 Depending on the internal representation used in the plugin, the termination
 of a state may or may not imply in the termination of the virtual machine.
 Preferrably, this function should remove the data structure that describe
 the virtual environment, but as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

, this is not always possible.
\layout Section

Implementation of plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Standard

In this section we will discuss the main aspects involved in the implementation
 of the plugins developed in this case study.
 We implemented plugins for Python, Ruby, Lua and Perl.
 We will present here how the representation of virtual states is made in
 each plugin (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

), issues involving state termination (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

), passing parameters between the main library and plugins (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

), how function calls from scripts are handled by plugins (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

) and error capturing (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

).
\layout Subsection

Representation of states
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

The design of LibScript allows plugins to have multiple independent states
 of execution.
 Ideally these states would be totally isolated from each other, like for
 example with different virtual machine instances.
 However, languages offer different degrees of isolation between independent
 states.
 Lua and Perl allow multiple isolated instances of their runtime environments
 in a simple way, since their API calls include a state identifier
\begin_inset Foot
collapsed true

\layout Standard

The feature of multiple independent states is optional in Perl, and can
 be selected during compilation of the interpreter's library.
\end_inset 

.
 Language that keep state in a static manner, like Python and Ruby, don't
 allow working with multiple isolated states easily
\begin_inset Foot
collapsed true

\layout Standard

Python's threading model offers a way for alternating between virtual machine
 states obtaining 
\family typewriter 
PyThreadState
\family default 
 objects through the 
\family typewriter 
Py_NewInterpreter
\family default 
 call, but this can cause problems when extension modules written in C use
 global static variables or when modules manipulate their own dictionary,
 which is shared between states.
 The documentation states, since 1999, that 
\emph on 

\begin_inset Quotes eld
\end_inset 


\emph default 
This is a hard-to-fix bug that will be addressed in a future release.
\emph on 

\begin_inset Quotes erd
\end_inset 


\emph default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum99api,vanrossum06api}

\end_inset 


\end_inset 

.
 For languages that do not allow multiple virtual machine instances, we
 can only define separate namespaces for LibScript virtual environments,
 which share a single global state of execution within the plugin.
 We term the representation of a state of execution relative to a LibScript
 virtual environment within a plugin a 
\emph on 
virtual state
\emph default 
, which may or may not correspond to an isolated state of execution.
\layout Standard

As discussed in the previous section, the 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 function returns a 
\family typewriter 
script_plugin_state
\family default 
 to the main library, which is the opaque representation of its virtual
 state.
 The contents if this representation vary from language to language, but
 the basic principle is that two data should be available from this value:
 a reference to the LibScript virtual environment, received as an argument
 by 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
, so that the plugin can make calls to the main library, and an identifier
 that allows the plugin to access the data structure that represents for
 the language the namespace of LibScript-accessible functions.
 In the Lua plugin, this structure is a table; in Python, a module; in Ruby,
 a class; in Perl, a package.
\layout Standard

In LibScript-Lua, states are implemented as 
\family typewriter 
lua_State
\family default 
s (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 This way, scripts executed in an environment are fully isolated from other
 environments.
 For example, the modification of the value of a global variable in an environme
nt does not affect the other ones.
 In fact, the 
\family typewriter 
script_plugin_state
\family default 
 returned by the Lua plugin is simply the 
\family typewriter 
lua_State
\family default 
 converted with a cast.
 The pointer to the LibScript environment is stored in Lua in the registry,
 as follows:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "LibScript.env"); 
\emph on 
  /* Pushes the index */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);        
\emph on 
/* Pushes the LibScript environment */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX);   
\emph on 
/* registry["LibScript.env"] = env */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The plugin creates in this 
\family typewriter 
lua_State
\family default 
 a table representing the virtual environment for Lua scripts.
 This table is stored in the 
\family typewriter 
lua_State
\family default 
 as a global variable with the name of the virtual environment.
\layout Standard

In LibScript-Perl states are isolated like in Lua.
 Each state created initializes a new instance of 
\family typewriter 
PerlInterpreter
\family default 
.
 In this interpreter, a package is created, which will be the visible representa
tion of the environment in Perl code.
 The 
\family typewriter 
script_plugin_state
\family default 
 type is then a typedef for 
\family typewriter 
PerlInterpreter
\family default 
*.
\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-registro}

\end_inset 

, the implementation of C functions exported to a Perl interpreter is made
 writing an extension module using the XS pre-processor, and the way to
 obtain communication in the Perl
\begin_inset Formula $\rightarrow$
\end_inset 

C direction in an embedded virtual machine is linking an extension module
 to the virtual machine.
 Thus, part of LibScript-Perl is implemente as an XS module, exposed to
 the embedded virtual machine as the 
\family typewriter 
LibScript
\family default 
 Perl package.
 During the initialization of a virtual state, the pointer to the LibScript
 virtual environment is stored in this package, in the 
\family typewriter 
$LibScript::env
\family default 
 variable.
 The package that represents the virtual environment is created by the 
\family typewriter 
script_plugin_init_perl
\family default 
 function, executing the string of code 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 using the function 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

As Python does not feature facilities for launching multiple fully isolated
 virtual machines, the Python plugin implements virtual states only as separate
 modules, sharing a single global state.
 During the initialization of a state, a Python module with the name of
 the environment is created.
 The following excerpt of the 
\family typewriter 
script_plugin_init_python
\family default 
 function shows the sequence where the module is created and imported:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Get the name of the environment */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates the module.
 The first argument is the module name,
\layout LyX-Code


\size footnotesize 
\emph on 
   the second one the module's method list, which will start empty.
 */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Get the globals dictionary */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the module to the global with its name */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
script_plugin_state
\family default 
 type is a typedef for 
\family typewriter 
PyObject*
\family default 
.
 The object returned by the initialization function is the elements dictionary
 of the module, obtained with 
\family typewriter 
PyModule_GetDict\SpecialChar \-
(module)
\family default 
.
 In this dictionary, we store the pointer to the virtual environment as
 the private attribute 
\family typewriter 
__env
\family default 
.
\layout Standard

Similarly, in Ruby virtual states are implemented as classes that share
 a single global state, since Ruby does not allow multiple isolated runtime
 environments either.
 In the initialization function, 
\family typewriter 
script_plugin_init_ruby
\family default 
, a class with the name of the virtual environment is created using the
 
\family typewriter 
rb_define_class
\family default 
 function.
 The pointer to the virtual environment is stored in a class constant as
 a number.
 The 
\family typewriter 
VALUE
\family default 
 corresponding to the new class is returned as the 
\family typewriter 
script_plugin_state
\family default 
.
\layout LyX-Code


\size footnotesize 
VALUE state;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (initialization of the interpreter omitted) ...
 */
\layout LyX-Code


\size footnotesize 
\emph on 
/* class_name is the name of the virtual environment,
\layout LyX-Code


\size footnotesize 
\emph on 
   with its initial converted to uppercase,
\layout LyX-Code


\size footnotesize 
\emph on 
   respecting Ruby's class naming convention */
\layout LyX-Code


\size footnotesize 
state = rb_define_class(class_name, rb_cObject);
\layout LyX-Code


\size footnotesize 
\emph on 
/* This assumes void* fits in a long */
\layout LyX-Code


\size footnotesize 
rb_const_set(state, rb_intern("@@LibScriptEnv"), INT2NUM((long)env));  
  
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
return (script_plugin_state) state;
\layout Subsection

Encerramento de estados
\begin_inset LatexCommand \label{sub:Encerramento-de-estados}

\end_inset 


\layout Standard

Como Lua e Perl representam estados de forma independente, o encerramento
 de um estado nestes plugins é simples: a estrutura da linguagem que encapsula
 o ambiente completo de execução é encerrada.
 A implementação da função de finalização no plugin Lua é a seguinte:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Em Lua, um state é um lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Encerra o estado.
 Não afeta outros ambientes.
 */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Perl, o processo, embora um tanto mais elaborado, é essencialmente similar:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas macros assumem que o ponteiro do interpretador
\layout LyX-Code


\size footnotesize 
\emph on 
      se chama my_perl.
 */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = (PerlInterpreter*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas operações operam sobre o 
\begin_inset Quotes eld
\end_inset 

estado atual
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      então a macro PERL_SET_CONTEXT deve ser usada para
\layout LyX-Code


\size footnotesize 
\emph on 
      alternar o interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Esta flag deve ser ativada para que a limpeza do
\layout LyX-Code


\size footnotesize 
\emph on 
      ambiente seja completa, o que é necessário quando
\layout LyX-Code


\size footnotesize 
\emph on 
      pode haver mais de um interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Encerramento do interpretador */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Em Python e Ruby, o plugin precisa manter o controle do número de estados
 ativos para desalocar a máquina virtual somente quando este chegar a zero.
 Além disso, tanto em Ruby como em Python não há recursos nas APIs (ou nas
 linguagens, de fato) para remover, respectivamente, classes ou módulos.
 Em Ruby, poderíamos atribuir 
\family typewriter 
nil
\family default 
 à constante que representa a classe que descreve o ambiente virtual, mas
 depois disso não é possível definir uma nova classe em seu lugar: tanto
 
\family typewriter 
rb_define_class
\family default 
 via C como 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 via Ruby geram um erro indicando que o valor já foi definido com outro
 tipo.
 Como Ruby possui classes abertas, uma construção 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 para um 
\emph on 
<Nome>
\emph default 
 já existente é entendida como a continuação da descrição da classe, e não
 como a redefinição de 
\emph on 
<Nome>
\emph default 
.
 Python, por sua vez, não disponibiliza recursos na API para a descarga
 de módulos, mas permite atribuir 
\family typewriter 
None
\family default 
 à global referente ao módulo.
 O módulo pode ser importado novamente, mas a mesma instância dele, armazenada
 internamente por Python, será retornada.
 A seguinte sessão interativa de linha de comando permite observar este
 comportamento, que ocorre tanto diretamente em Python como via a API de
 C:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, as estruturas de dados referentes aos estados LibScript não são encerrado
s nos plugins Python e Ruby.
 Esta é a implementação da rotina de encerramento no plugin Ruby:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrementa o contador de estados, uma variável global 
\emph default 
static
\emph on 
 do plugin.
 */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Finaliza o interpretador se este for o último estado.
 */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A implementação no plugin Python é basicamente igual:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Passagem de parâmetros
\begin_inset LatexCommand \label{sub:Passagem-de-parâmetros}

\end_inset 


\layout Standard

A transferência de dados entre a biblioteca principal e os plugins é concentrada
 em duas operações: uma para passar o conteúdo do buffer de parâmetros de
 LibScript para o espaço de dados da máquina virtual e outra para realizar
 a operação inversa.
 A primeira é usada na passagem de parâmetros de entrada quando funções
 da linguagem de script são chamadas por C e para a obtenção dos valores
 de retorno quando a linguagem de script faz chamadas que são tratadas C.
 A segunda operação, de forma complementar, é usada para os valores de retorno
 quando C chama a linguagem de script e para os parâmetros de entrada quando
 uma chamada feita pela linguagem de script é tratada por código C.
\layout Standard

Na implementação do plugin LibScript-Lua, a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 converte o conteúdo da pilha de Lua para o buffer de parâmetros de LibScript.
 A função do plugin responsável por invocar funções Lua a partir de C, 
\family typewriter 
script_plugin_call_lua
\family default 
, usa a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 para armazenar no buffer LibScript os valores de retorno da função Lua
 invocada, já que estes são retornados na pilha virtual.
 Quando o código Lua chama funções implementadas em C ou em outro plugin,
 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 é usada para converter os parâmetros de entrada da função, também recebidos
 na pilha virtual.
 A seguir, vemos a implementação desta função:
\layout LyX-Code


\size footnotesize 
static void script_lua_stack_to_buffer(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int nargs; int i; 
\layout LyX-Code


\size footnotesize 
   nargs = lua_gettop(L);    
\emph on 
/* Número de elementos na pilha de Lua */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env); 
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 1; i <= nargs; i++) {
\layout LyX-Code


\size footnotesize 
      
\emph on 
/* Verifica o tipo Lua do elemento na posição i da pilha */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, converte o elemento e o armazena no buffer */
\layout LyX-Code


\size footnotesize 
      switch(lua_type(L, i)) { 
\layout LyX-Code


\size footnotesize 
      case LUA_TNUMBER:
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, lua_tonumber(L, i)); break; 
\layout LyX-Code


\size footnotesize 
      case LUA_TSTRING:
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i-1, lua_tostring(L, i)); break;
\layout LyX-Code


\size footnotesize 
      case LUA_TBOOLEAN:
\layout LyX-Code


\size footnotesize 
         script_put_bool(env, i-1, lua_toboolean(L, i)); break;
\layout LyX-Code


\size footnotesize 
      default:
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Tipos não tratados são substituídos por zero.
 */
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, 0);
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumimos em LibScript strings no formato de C: a função 
\family typewriter 
script_put_string
\family default 
 copia a string passada até o primeiro 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Assim, ao obter strings de linguagens que permitem conteúdo arbitrário,
 estas serão truncadas caso contenham 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Por isso, no plugin Lua usamos diretamente a função 
\family typewriter 
lua_tostring
\family default 
, e não a função mais geral 
\family typewriter 
lua_tolstring
\family default 
 (que retorna também o tamanho do buffer).
\layout Standard

Os valores de tipos desconhecidos são substituídos pelo valor zero, o que
 mantém a posição dos demais valores na lista de argumentos.
 Optamos por não sinalizar erro nesta situação para evitar aqui a geração
 de exceções, o que complicaria a exposição.
 A captura e propagação de erros serão vistas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Standard

A segunda função de transferência de dados de LibScript-Lua, 
\family typewriter 
script_lua_buffer_to_stack
\family default 
, obtém os valores do buffer LibScript e os insere na pilha virtual de Lua.
 Esta função é usada para passar os parâmetros de entrada para Lua em 
\family typewriter 
script_plugin_call_lua
\family default 
 e para passar para Lua os valores obtidos pelo retorno da função 
\family typewriter 
script_call
\family default 
, que é invocada internamente pelo plugin quando Lua invoca uma função C.
\layout LyX-Code


\size footnotesize 
static int script_lua_buffer_to_stack(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int i; char* s;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env); 
\emph on 
/* Número de elementos no buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Verifica o tipo do elemento na posição i do buffer */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, o obtém e o insere na pilha de Lua */
\layout LyX-Code


\size footnotesize 
      type = script_get_type(env, i);
\layout LyX-Code


\size footnotesize 
      switch (type) {
\layout LyX-Code


\size footnotesize 
      case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
         lua_pushnumber(L, script_get_double(env, i)); break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
         s = script_get_string(env, i); 
\emph on 
/* A string pertence ao chamador.
 */
\layout LyX-Code


\size footnotesize 
         lua_pushstring(L, s);
\layout LyX-Code


\size footnotesize 
         free(s); 
\emph on 
/* Libera a string, já que Lua armazena sua própria cópia.
 */
\layout LyX-Code


\size footnotesize 
         break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
         lua_pushboolean(L, script_get_bool(env, i)); break;
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return len;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript-Python, não foi possível concentrar as operações de transferência
 de dados em apenas duas funções.
 Cada operação teve que ser dividida em duas partes.
 A conversão de dados recebidos de Python para o buffer de LibScript foi
 divida nas funções 
\family typewriter 
script_python_put_object
\family default 
 e 
\family typewriter 
script_python_tuple_to_buffer
\family default 
.
 A primeira função converte um único valor Python e o insere na posição
 solicitada no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_put_object(script_env* env, int i, PyObject* o)
 {
\layout LyX-Code


\size footnotesize 
   if (PyString_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, PyString_AS_STRING(o));
\layout LyX-Code


\size footnotesize 
   else if (PyInt_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, PyInt_AS_LONG(o));
\layout LyX-Code


\size footnotesize 
   else if (PyLong_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyLong_AsDouble(o));
\layout LyX-Code


\size footnotesize 
   else if (PyFloat_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyFloat_AS_DOUBLE(o));
\layout LyX-Code


\size footnotesize 
   else if (PyBool_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, o == Py_True ? 1 : 0);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É importante notar que os tipos Python 
\family typewriter 
PyInt
\family default 
 e 
\family typewriter 
PyLong
\family default 
 não correspondem aos tipos C 
\family typewriter 
int
\family default 
 e 
\family typewriter 
long
\family default 
: 
\family typewriter 
PyInt
\family default 
 é o tipo inteiro correspondente ao tamanho da palavra da máquina (análogo
 a 
\family typewriter 
int
\family default 
), mas 
\family typewriter 
PyLong
\family default 
 é um inteiro de precisão arbitrária.
 Em LibScript, representamos 
\family typewriter 
PyLong
\family default 
s como 
\family typewriter 
double
\family default 
s.
 A API de LibScript oferece a função 
\family typewriter 
script_put_int
\family default 
 como conveniência, mas internamente, como ocorre por exemplo em Lua, todos
 os números são armazenados como 
\family typewriter 
double
\family default 
s.
\layout Standard

A segunda função, 
\family typewriter 
script_python_tuple_to_buffer
\family default 
, insere os elementos de uma tupla no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_tuple_to_buffer(script_env* env, PyObject* tuple)
 {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = PyTuple_GET_SIZE(tuple); 
\emph on 
/* Número de elementos da tupla */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);          
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = PyTuple_GET_ITEM(tuple, i); 
\emph on 
/* Obtém elemento da tupla */
\layout LyX-Code


\size footnotesize 
      script_python_put_object(env, i, o);      
\emph on 
/* Insere-o no buffer.
 */
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A operação inversa, de transferência de dados do buffer LibScript para Python,
 também é implementada em duas funções, uma tratando objetos individualmente
 e outra tratando tuplas.
 A função 
\family typewriter 
script_get_object
\family default 
 converte um elemento do buffer para um 
\family typewriter 
PyObject
\family default 
 equivalente:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_get_object(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   PyObject* ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return PyFloat_FromDouble(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      PyObject* ret = PyString_FromString(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return PyBool_FromLong(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
script_python_buffer_to_tuple
\family default 
 gera uma tupla contendo todos os elementos do buffer LibScript:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_buffer_to_tuple(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   PyObject* ret = PyTuple_New(len);
\layout LyX-Code


\size footnotesize 
   for(i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = script_python_get_object(env, i);
\layout LyX-Code


\size footnotesize 
      PyTuple_SetItem(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, estes dois pares de funções realizam funções equivalentes às que
 
\family typewriter 
script_lua_\SpecialChar \-
stack_to_buffer
\family default 
 e 
\family typewriter 
script_lua_buffer_to_stack
\family default 
 exercem no plugin Lua.
 Elas foram separadas em duas partes em função do modelo de retorno de valores
 em funções Python: no caso de múltiplos valores de retorno, eles são retornados
 como uma tupla; para valores simples, eles são passados diretamente.
 Isto é evidenciado no seguinte trecho da função 
\family typewriter 
script_plugin_call_python
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject *ret, *args;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
args = script_python_buffer_to_tuple(env);  
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
ret = PyEval_CallObject(func, args); 
\emph on 
       /* Chama uma função Python */
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
if (ret == Py_None)                         
\emph on 
/* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);                
\emph on 
/* Apenas zere o buffer LibScript */
\layout LyX-Code


\size footnotesize 
else if (PyTuple_Check(ret))                
\emph on 
/* Se retornou uma tupla */
\layout LyX-Code


\size footnotesize 
   script_python_tuple_to_buffer(env, ret); 
\emph on 
/* Insira seus elementos no buffer */
\layout LyX-Code


\size footnotesize 
else                                        
\emph on 
/* Se retornou outro tipo de objeto */
\layout LyX-Code


\size footnotesize 
   script_python_put_object(env, 0, ret);   
\emph on 
/* Insira-o como único elemento */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

No tratador de chamadas a funções externas do plugin, a comunicação no sentido
 inverso emprega uma lógica similar:
\layout LyX-Code


\size footnotesize 
script_python_tuple_to_buffer(env, args);    
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
err = script_call(env, fn_name);             
\emph on 
/* Chama um função via LibScript */
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
switch(script_buffer_len(env)) {
\layout LyX-Code


\size footnotesize 
case 0:                                      
\emph on 
 /* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   Py_RETURN_NONE;                           
\emph on 
 /* Retorne o valor Python 'None' */
\layout LyX-Code


\size footnotesize 
case 1:                                      
\emph on 
 /* Se retornou um único valor */
\layout LyX-Code


\size footnotesize 
   return script_python_get_object(env, 0);  
\emph on 
 /* Converta e retorne-o */
\layout LyX-Code


\size footnotesize 
default:                                      
\emph on 
/* Se retornou mais de um valor */
\layout LyX-Code


\size footnotesize 
   return script_python_buffer_to_tuple(env); 
\emph on 
/* Retorne-os em uma tupla */
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim como em Python, funções em Ruby retornam múltiplos valores encapsulando-os
 em um tipo agregado.
 Desta forma, as operações de transferências de dados de LibScript-Ruby
 também são divididas em pares de funções, uma convertendo um valor do buffer,
 e outra operando sobre um array Ruby.
 A função análoga a 
\family typewriter 
script_python_put_object
\family default 
 é 
\family typewriter 
script_ruby_put_value
\family default 
:
\layout LyX-Code


\size footnotesize 
static void script_ruby_put_value(script_env* env, int i, VALUE arg) {
\layout LyX-Code


\size footnotesize 
   switch (TYPE(arg)) {
\layout LyX-Code


\size footnotesize 
   case T_FLOAT:
\layout LyX-Code


\size footnotesize 
   case T_FIXNUM:
\layout LyX-Code


\size footnotesize 
   case T_BIGNUM:
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, NUM2DBL(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_STRING:
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, StringValuePtr(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_TRUE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 1); break;
\layout LyX-Code


\size footnotesize 
   case T_FALSE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 0); break;
\layout LyX-Code


\size footnotesize 
   default:
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Aqui, alguns problemas da API de Ruby são aparentes.
 Além da inconsistência na nomenclatura das funções de conversão de objetos,
 o significado do valor retornado pela macro 
\family typewriter 
TYPE
\family default 
 só pode ser compreendido através da representação interna de 
\family typewriter 
VALUE
\family default 
s na implementação de Ruby, e não através da hierarquia de tipos dos objetos
 da linguagem.
 As classes que têm tratamento especial na estrutura interna de 
\family typewriter 
VALUE
\family default 
s possuem constantes associadas a si, como 
\family typewriter 
T_FLOAT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
; as demais são identificados apenas como 
\family typewriter 
T_OBJECT
\family default 
s.
 O uso de 
\family typewriter 
T_TRUE
\family default 
 e 
\family typewriter 
T_FALSE
\family default 
 pode dar a entender que alguns valores específicos também retornam resultados
 especiais para 
\family typewriter 
TYPE
\family default 
.
 De fato, estes valores são definidos como 
\family typewriter 
VALUE
\family default 
s que não correspondem a índices da heap de objetos de Ruby e são tratados
 de forma especial na implementação.
 Do ponto de vista de código Ruby, entretanto, esta classificação dos valores
 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em tipos separados na API C é justificada definindo-os como 
\emph on 
singletons
\emph default 
 das classes 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
, abordagem provavelmente influenciada por Smalltalk.
 Porém, diferentemente de Smalltalk, onde 
\family typewriter 
True
\family default 
 e 
\family typewriter 
False
\family default 
 são subclasses de 
\family typewriter 
Boolean
\family default 
, em Ruby 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
 são subclasses diretas de 
\family typewriter 
Object
\family default 
.
 Isto traz a inconveniência de que verificar se um tipo é um valor booleano
 incorre sempre em dois testes.
\layout Standard

Assim como LibScript-Python tem uma função para armazenar no buffer os elementos
 de uma tupla, LibScript-Ruby possui uma função para armazenar os elementos
 de um array:
\layout LyX-Code


\size footnotesize 
static void script_ruby_array_to_buffer(script_env* env, VALUE array) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = RARRAY(array)->len;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = rb_ary_entry(array, i);
\layout LyX-Code


\size footnotesize 
      script_ruby_put_value(env, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Ruby não possui uma função na API C para retornar o tamanho de um array;
 ao invés disso, a estrutura interna do 
\family typewriter 
VALUE
\family default 
 é exposta através da macro 
\family typewriter 
RARRAY
\family default 
 (que apenas encapsula um cast).
 
\layout Standard

As operações para conversão de valores do buffer LibScript para Ruby também
 são similares às implementadas no plugin Python.
 Novamente, onde em Python há uma função para manipulação de tuplas, temos
 em Ruby uma função que opera sobre arrays:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_get_value(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   VALUE ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return rb_float_new(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      ret = rb_str_new2(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return script_get_bool(env, i) ? Qtrue : Qfalse;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\newline 
static VALUE script_ruby_buffer_to_array(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   VALUE ret = rb_ary_new2(len);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = script_ruby_get_value(env, i);
\layout LyX-Code


\size footnotesize 
      rb_ary_store(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

De forma similar ao plugin Python, a implementação da chamada de funções
 Ruby a partir de LibScript usa a função 
\family typewriter 
script_ruby_buffer_to_array
\family default 
 para converter os parâmetros de entrada e as funções 
\family typewriter 
script_ruby_put_value
\family default 
 ou 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 para converter o valor de retorno, dependendo se a função retornou um ou
 mais valores (ou mais precisamente, se a função retornou ou não um array).
 Em chamadas de funções LibScript a partir de Ruby, os parâmetros de entrada
 são convertidos com 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 e os valores de retorno com 
\family typewriter 
script_ruby_get_value
\family default 
 ou 
\family typewriter 
script_ruby_buffer_to_array
\family default 
.
\layout Standard

No plugin Perl, temos três funções: a transferência de dados da pilha para
 o buffer LibScript pôde ser implementada em uma única função como em Lua,
 mas a transferência no sentido oposto teve que ser dividida em duas funções,
 como em Python e Ruby.
 Esta assimetria vem do fato de que o tratamento de valores de retorno é
 encapsulado pelo pré-processador XS através da variável especial 
\family typewriter 
RETVAL
\family default 
; assim, nesta situação não podemos manipular a pilha diretamente, mas apenas
 passar 
\family typewriter 
SV
\family default 
s como valores de saída.
 
\layout Standard

A transferência de dados da pilha de Perl para o buffer LibScript é razoavelment
e simples:
\layout LyX-Code


\size footnotesize 
void script_perl_stack_to_buffer(pTHX_ int ax, script_env* env,
\layout LyX-Code


\size footnotesize 
                                 int count, int offset) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < count; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém um ponteiro para o SV */
\layout LyX-Code


\size footnotesize 
      SV* o = ST(offset+i);
\layout LyX-Code


\size footnotesize 
      if (SvIOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, SvIV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvNOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i, SvNV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvPOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i, SvPV_nolen(o));
\layout LyX-Code


\size footnotesize 
      else
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os parâmetros de entrada desta função merecem comentário.
 Inicialmente, temos a macro 
\family typewriter 
pTHX_
\family default 
.
 Esta macro foi adicionada à API quando Perl passou a permitir múltiplos
 interpretadores simultâneos por processo: as funções da API foram transformadas
 em macros que encapsulam a passagem deste primeiro parâmetro.
 Por exemplo, a função 
\family typewriter 
eval_sv
\family default 
 pode ser chamada como 
\family typewriter 
Perl_eval_sv
\family default 
, passando a macro 
\family typewriter 
aTHX_
\family default 
 como parâmetro inicial.
 De maneira geral o uso destas macros fica implícito, mas ao escrever funções
 que usam a API de Perl torna-se necessário usar a macro 
\family typewriter 
pTHX_
\family default 
 na declaração
\begin_inset Foot
collapsed true

\layout Standard

A macro 
\family typewriter 
pTHX_
\family default 
 é usada sem a vírgula separando-a do argumento seguinte.
 Quando ela é o único argumento, deve-se usar 
\family typewriter 
pTHX
\family default 
.
\end_inset 

, para propagar a informação de estado do interpretador através de chamadas
 de função, e 
\family typewriter 
aTHX_
\family default 
 nas chamadas.
\layout Standard

Outro sintoma de que a API de Perl foi projetada mais para uso interno do
 pré-processador XS do que para manipulação direta transparece no segundo
 argumento, 
\family typewriter 
ax
\family default 
.
 Algumas macros assumem a existência deste valor, que não é propagado via
 
\family typewriter 
pTHX_
\family default 
, mas é declarado implicitamente quando funções são encapsuladas via XS.
 A API parece assumir que uma função XS não irá invocar outra função C que
 também use a API.
 Tivemos então que propagar esta variável (que é citada na documentação,
 mas apenas como 
\emph on 
"the 'ax' variable"\SpecialChar ~

\emph default 

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

, sem explicações do seu propósito).
\layout Standard

Os outros dois parâmetros, 
\family typewriter 
count
\family default 
 e 
\family typewriter 
offset
\family default 
, são necessários devido às diferentes formas que as informações que eles
 representam são obtidas nos dois contextos onde esta função é usada.
 Nos outros plugins, podemos obter a quantidade de elementos de entrada
 de forma uniforme (consultando o número de elementos da tupla em Python,
 por exemplo).
 Em Perl, nas duas situações onde a função é chamada, o número de elementos
 a serem lidos da pilha deve ser obtido de formas diferentes, e por isso
 o passamos como parâmetro 
\family typewriter 
count
\family default 
.
 Na rotina chamadora de funções LibScript, implementada no arquivo XS, o
 tamanho da pilha é obtido através de uma variável especial, 
\family typewriter 
items
\family default 
.
 Já na chamada de funções Perl, o valor de 
\family typewriter 
count
\family default 
 é obtido como retorno da função que realiza a invocação, 
\family typewriter 
Perl_call_pv
\family default 
.
 
\layout Standard

A posição inicial da pilha a partir da qual devemos obter os elementos (
\family typewriter 
offset
\family default 
) também varia.
 Dentro da função XS, os parâmetros de entrada começam a partir da posição
 2, pois LibScript passa o ponteiro do ambiente e o nome da função nos dois
 primeiros argumentos.
 Na chamada de funções Perl, o valor de 
\family typewriter 
offset
\family default 
 é zero pois, como visto no protocolo de chamada de funções Perl discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

, a base da pilha é ajustada após a chamada da função pela macro 
\family typewriter 
SPAGAIN
\family default 
.
 
\layout Standard

A conversão de valores do buffer LibScript para a pilha de Perl é dada em
 duas funções, uma que gera um único SV e outra que empilha todos os elementos:
\layout LyX-Code


\size footnotesize 
SV* script_perl_get_sv(pTHX_ script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE: return newSVnv(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* 0 indica que o tamanho da string deve ser calculado por Perl.
 */
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING: return newSVpv(script_get_string(env, i), 0);
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL: return newSViv(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
  
\newline 
SV** script_perl_buffer_to_stack(pTHX_ SV** sp, script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      XPUSHs(sv_2mortal(script_perl_get_sv(aTHX_ env, i)));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return sp;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Novamente, uma variável criada internamente por Perl teve que ser propagada
 explicitamente: 
\family typewriter 
sp
\family default 
, o 
\emph on 
stack pointer
\emph default 
.
 Esta variável é referenciada internamente pela macro 
\family typewriter 
xPUSHs
\family default 
.
 Além disso, como 
\family typewriter 
XPUSHs
\family default 
 pode redimensionar a pilha, precisamos retornar o valor atualizado de 
\family typewriter 
sp
\family default 
 de volta para o chamador.
 No mais, a geração de 
\family typewriter 
SV
\family default 
s, o registro destes como variáveis mortais e o seu empilhamento ocorre
 da forma usual, já apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
\layout Standard

Assim como nos demais plugins, a passagem de parâmetros de entrada em LibScript-
Perl, tanto para a chamada de funções Perl como de funções via LibScript,
 é feita chamando a função de conversão que opera sobre o buffer como um
 todo: na chamada de funções Perl usamos 
\family typewriter 
script_perl_buffer_to_stack
\family default 
 e na de funções via LibScript, 
\family typewriter 
script_perl_stack_to_buffer
\family default 
.
 Para tratar os valores de retorno de funções Perl, pudemos utilizar diretamente
 a função 
\family typewriter 
script_perl_stack_to_buffer
\family default 
, de forma similar à realizada em LibScript-Lua.
 Para o retorno de funções chamadas via LibScript, porém, precisamos lidar
 com a variável especial 
\family typewriter 
RETVAL
\family default 
 de XS e com os diferentes contextos de chamada de Perl.
 O trecho abaixo ilustra o tratamento de valores de retorno neste caso:
\layout LyX-Code


\size footnotesize 
err = script_call(env, function_name);
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (tratamento de erro omitido) ...
 */
\layout LyX-Code


\size footnotesize 
switch (GIMME_V) {
\layout LyX-Code


\size footnotesize 
case G_SCALAR:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna o primeiro item do buffer */
\layout LyX-Code


\size footnotesize 
   RETVAL = script_perl_get_sv(aTHX_ env, 0);
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_ARRAY:
\layout LyX-Code


\size footnotesize 
   len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um array */
\layout LyX-Code


\size footnotesize 
   RETVAL = (SV*)newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Arrays retornados devem ser marcados como mortais */
\layout LyX-Code


\size footnotesize 
   sv_2mortal((SV*)RETVAL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Insere o conteúdo do buffer no array */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++)
\layout LyX-Code


\size footnotesize 
      av_push((AV*)RETVAL, script_perl_get_sv(aTHX_ env, i));
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_VOID:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O valor de retorno é descartado em contextos void.
 */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retornamos então a constante Perl undef.
 */
\layout LyX-Code


\size footnotesize 
   RETVAL = &PL_sv_undef;
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
}
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Chamada de funções
\layout Standard

Nos plugins de LibScript, funções implementadas externamente (em C ou outros
 plugins) são localizadas somente no momento em que elas são chamadas.
 O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória no ambiente de execução da linguagem de script (ao evitar a declaração
 de funções que não serão utilizadas), é permitir a localização de funções
 declaradas após a inicialização do ambiente.
 Para permitir esta resolução de funções de forma dinâmica, é preciso capturar
 o acesso a elementos inexistentes na estrutura que descreve o ambiente
 virtual no plugin e encaminhar a chamada à biblioteca principal via 
\family typewriter 
script_call
\family default 
.
 Ao comparar as abordagens empregadas em cada plugin para obter tal comportament
o, podemos avaliar alguns recursos de meta-programação oferecidos por cada
 linguagem e a sua disponibilidade através das suas APIs.
\layout Standard

Como vimos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, em Lua, durante a inicialização do plugin, é criada uma tabela armazenada
 em uma variável global com o nome do ambiente.
 Funções são inseridas dinamicamente nesta tabela através da metatabela
 associada a ela logo após a sua criação em 
\family typewriter 
script_plugin_init_lua
\family default 
.
 O campo 
\family typewriter 
__index
\family default 
 da metatabela aponta para uma função\SpecialChar ~
C interna ao plugin, 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, que é então invocada sempre que um elemento inexistente for solicitado
 na tabela.
 A função 
\family typewriter 
script_lua_make_caller
\family default 
 cria uma 
\emph on 
closure
\emph default 
\SpecialChar ~
C, que consiste de outra função\SpecialChar ~
C interna ao plugin (
\family typewriter 
script_lua_caller
\family default 
) e o nome da função solicitada.
 Esta closure é associada à entrada da tabela do ambiente.
 Assim, chamadas a funções implementadas externamente serão resolvidas por
 
\family typewriter 
script_lua_caller
\family default 
, que as passará adiante para 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Python, ao chamar uma função no módulo do ambiente virtual, o
 
\emph on 
callback
\emph default 
 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_python_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 cria um objeto do tipo 
\family typewriter 
script_python_object
\family default 
, e o retorna como resultado de 
\family typewriter 
__getattro
\family default 
.
 Este tipo de dado é declarado no plugin como uma classe Python, cujas instância
s contêm um ponteiro para o ambiente virtual e uma string C com o nome da
 função que eles representam.
 Estes objetos possuem o seu 
\emph on 
callback
\emph default 
 
\family typewriter 
__call
\family default 
 definido como 
\family typewriter 
script_python_caller
\family default 
, uma função que, assim como 
\family typewriter 
script_lua_caller
\family default 
, converte os parâmetros recebidos para o buffer de LibScript, invoca 
\family typewriter 
script_call
\family default 
 e converte os valores de retorno de volta a Python.
 Assim, objetos deste tipo são 
\emph on 
functors
\emph default 
, e se comportam de forma similar à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
\layout Standard

A resolução de funções sob demanda em Ruby é implementada utilizando o método
 
\family typewriter 
method_missing
\family default 
, que é um fallback definido pela linguagem, chamado sempre que um método
 inexistente é invocado em uma classe.
 Diferentemente de 
\family typewriter 
__getattro
\family default 
 em Python e 
\family typewriter 
__index
\family default 
 em Lua, que são tratadores de acesso a atributos e portanto precisam retornar
 um objeto que é chamado em um passo seguinte, o método 
\family typewriter 
method_missing
\family default 
 trata chamadas diretamente.
 Assim, ao ser invocado, 
\family typewriter 
method_missing
\family default 
 recebe o nome do método solicitado e os parâmetros passados e os encaminha
 para a função 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Perl, como em Lua e Python, também há uma função C responsável
 por realizar a conversão de parâmetros e valores de retorno a invocação
 de 
\family typewriter 
script_call
\family default 
.
 Esta função, 
\family typewriter 
script_perl_caller
\family default 
, para que possa ser exposta ao interpretador Perl, é implementada em um
 módulo XS.
 Uma vez carregado o módulo, a função é visível em Perl como a função 
\family typewriter 
LibScript::caller
\family default 
.
 A resolução dinâmica de funções do pacote Perl que representa o ambiente
 virtual é feita usando a função 
\family typewriter 
AUTOLOAD
\family default 
 de Perl, que se comporta como 
\family typewriter 
method_missing
\family default 
 em Ruby, capturando chamadas a funções inexistentes.
 Na função de inicialização do plugin, código Perl é executado para carregar
 o módulo de extensão, inicializar o pacote do ambiente e inserir nele uma
 função 
\family typewriter 
AUTOLOAD
\family default 
 que chamará 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
   "bootstrap LibScript;"   
\emph on 
/* Inicializa o módulo de extensão */
\layout LyX-Code


\size footnotesize 
   "package %s;" 
\emph on 
           /* Declara o pacote do ambiente */
\layout LyX-Code


\size footnotesize 
   "$LibScript::env = %p;"  
\emph on 
/* Armazena o ponteiro do ambiente em Perl */
\layout LyX-Code


\size footnotesize 
   "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
      "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Extrai o nome do método do nome qualificado 
\begin_inset Quotes eld
\end_inset 

pacote::método
\begin_inset Quotes erd
\end_inset 

 */
\layout LyX-Code


\size footnotesize 
      "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Invoca caller passando o endereço do ambiente, */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o nome do método, e o array de argumentos */
\layout LyX-Code


\size footnotesize 
\emph on 
      
\emph default 
"LibScript::caller(%p, $AUTOLOAD, @_);"  
\layout LyX-Code


\size footnotesize 
   "}",
\layout LyX-Code


\size footnotesize 
   state->package, env, env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Avalia a string de código;
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indica que erros devem ser sinalizados.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Subsection

Captura de erros
\begin_inset LatexCommand \label{sub:Captura-de-erros}

\end_inset 


\layout Standard

Os plugins devem capturar a ocorrência de erros na execução de strings de
 código e em chamadas de função.
 Em Lua, ambas as operações são realizadas usando a função 
\family typewriter 
lua_pcall
\family default 
, cujo valor de retorno indica a ocorrência de erros.
 No caso de erros, a mensagem de erro é obtida no topo da pilha virtual
 de Lua e propagada para a biblioteca principal usando 
\family typewriter 
script_set_error_message
\family default 
.
 No caso da execução de strings de código, erros de compilação são detectados
 através do valor de retorno da função 
\family typewriter 
luaL_loadstring
\family default 
, que carrega o código a ser executado por 
\family typewriter 
lua_pcall
\family default 
.
\layout Standard

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno das
 funções de execução de strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, e de chamada de funções, 
\family typewriter 
PyEval_CallObject
\family default 
.
 No caso de erros, chamamos a função 
\family typewriter 
PyErr_Occurred
\family default 
, que retorna um objeto Python representando a exceção.
 A mensagem de erro é obtida convertendo este objeto para uma string Python
 usando 
\family typewriter 
PyObject_Str
\family default 
, e finalmente para uma string C com 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

Em Perl, erros são sinalizados na variável especial 
\family typewriter 
$@
\family default 
, cujo conteúdo pode ser verificado através da API de C com a macro 
\family typewriter 
ERRSV
\family default 
.
 O teste para ocorrência de erros é 
\family typewriter 
SvTRUE(ERRSV)
\family default 
, e a mensagem de erro pode ser obtida convertendo esta variável para uma
 string C com a macro 
\family typewriter 
SvPV
\family default 
.
\layout Standard

Ruby disponibiliza uma função para execução de strings de código, 
\family typewriter 
rb_eval_string
\family default 
, e uma versão desta que captura erros e sinaliza a sua ocorrência através
 do valor de retorno, 
\family typewriter 
rb_eval_string_protect
\family default 
.
 Entretanto, para chamadas de método, não há uma versão protegida da função
 
\family typewriter 
rb_funcall
\family default 
.
 A função disponibilizada pela API para proteger chamadas, 
\family typewriter 
rb_protect
\family default 
, não recebe como parâmetro um método Ruby, mas sim uma função\SpecialChar ~
C.
 Para chamar métodos Ruby de forma protegida, precisamos escrever uma função
 C que encapsula a chamada:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_pcall(VALUE args) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai nome do método do array de argumentos */
\layout LyX-Code


\size footnotesize 
   ID fn_id = SYM2ID(rb_ary_pop(args)); 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai a classe do array de argumentos */
\layout LyX-Code


\size footnotesize 
   VALUE klass = rb_ary_pop(args);
\layout LyX-Code


\size footnotesize 
   return rb_apply(klass, fn_id, args);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

e então invocá-la usando 
\family typewriter 
rb_protect
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere a classe no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, klass);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere o nome do método no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, ID2SYM(rb_intern(fn)));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Chama a função wrapper */
\layout LyX-Code


\size footnotesize 
ret = rb_protect(script_ruby_pcall, args, &error); 
\layout LyX-Code


\size footnotesize 
if (error) {
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   script_set_error_message(env, StringValuePtr(ruby_errinfo));
\layout LyX-Code


\size footnotesize 
   ruby_errinfo = Qnil;
\layout LyX-Code


\size footnotesize 
   return SCRIPT_ERRLANGRUN;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como a função 
\family typewriter 
rb_protect
\family default 
 passa apenas um 
\family typewriter 
VALUE
\family default 
 para a função C, precisamos armazenar a classe, o identificador do método
 e os parâmetros de entrada do método Ruby a ser invocado em um array Ruby.
 A ocorrência de erros é sinalizada em uma variável passada no terceiro
 parâmetro de 
\family typewriter 
rb_protect
\family default 
, e a mensagem de erro é obtida no 
\family typewriter 
VALUE
\family default 
 global 
\family typewriter 
ruby_errinfo
\family default 
.
\layout Section

Conclusões
\layout Standard

O estudo de caso apresentado aqui ilustrou, através da implementação dos
 plugins, o processo de embutir quatro linguagens de script realizando interface
 com uma mesma API C.
 Diversos aspectos da interação entre C e as linguagens de script foram
 abordados, contemplando inicialização e encerramento do ambiente de execução,
 passagem de dados e chamadas de função nos dois sentidos e a sinalização
 de erros.
 A partir disto, podemos fazer algumas observações sobre a adequabilidade
 destas linguagens como ambientes embutidos em aplicações.
\layout Standard

Em muitas aplicações é importante que haja isolamento entre os scripts executado
s, como por exemplo, em scripts de diferentes clientes rodando em um servidor
 web.
 Como vimos, Lua e Perl permitem disparar múltiplos ambientes de execução,
 o que garante isolamento.
 Já Python e Ruby permitem apenas um estado, reduzindo sua aplicabilidade
 para cenários onde os scripts devem executar isolados uns dos outros
\begin_inset Foot
collapsed true

\layout Standard

Em Python é possível alternar a tabela de globais durante a execução de
 diferentes threads, o que oferece uma alternativa, um tanto mais trabalhosa,
 para obter isolamento.
 Ainda assim, o estado global compartilhado por módulos de extensão é o
 mesmo.
 
\end_inset 

.
 Estas duas linguagens trazem ainda outro problema: em alguns casos não
 é possível trazer o seu espaço de dados de volta ao estado original durante
 a execução de uma aplicação.
 Em Python, módulos importados não podem ser descarregados.
 Em Ruby, uma classe não pode ser redefinida (somente estendida) e 
\family typewriter 
ID
\family default 
s não são coletados.
\layout Standard

Na implementação do plugin de Perl fica evidente que a sua API não foi projetada
 visando embutir o interpretador em aplicações.
 Além de exigir o desenvolvimento de um módulo de extensão para que o código
 Perl possa ter acesso a funções C, observamos aqui que a sua API é incompleta
 no que diz respeito ao seu uso como linguagem embutida.
 Muitas macros foram desenvolvidas assumindo que seriam sempre invocadas
 a partir de código escrito em arquivos XS, ou mesmo por código gerado pelo
 pré-processador XS.
 Isto é confirmado pela necessidade de passar parâmetros adicionais não-document
ados para que as macros funcionem, como pôde ser observado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

.
\layout Standard

Lua, por sua vez, mostrou-se apropriada como linguagem embutida, não compartilha
ndo das limitações aqui descritas sobre as outras linguagens.
 Além disso, ela possui uma API simples, que trata as construções da linguagem
 de forma completa e ortogonal, o que se deve tanto ao foco da implementação
 de Lua como linguagem embutida, quanto ao projeto minimalista da linguagem
 em si.
 Mesmo em exemplos pequenos como os apresentados aqui, que exercitam apenas
 uma parte pequena das APIs, podemos observar que aspectos onde as linguagens
 definem tratamentos especiais ou possuem menor uniformidade transparecem
 nas APIs para C.
 Tanto em Python como em Ruby, funções que retornam múltiplos valores geram
 conversões implícitas para tipos agregados (listas e arrays).
 De forma similar, múltiplos retornos são representados em Perl através
 de contextos do tipo array.
 Nos seus respectivos plugins LibScript, estas características tiveram que
 ser tratadas de forma especial.
 No plugin Lua, em contraste, o tratamento para um valor único de retorno
 é igual ao de valores múltiplos, assim como ocorre na linguagem.
 
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Conclusões
\layout Standard

A escolha de uma linguagem de script depende de uma série de fatores, varios
 deles relativos à linguagem em si, outros relativos à sua implementação.
 Quando lidamos com cenários de desenvolvimento multi-linguagem, um aspecto
 que não deve ser negligenciado é o projeto das interfaces entre as linguagens.
 Seja estendendo a linguagem de script através de código C, ou tornando
 uma aplicação C extensível através de uma linguagem de script, a API oferecida
 pela linguagem tem um papel fundamental, muitas vezes influenciando o projeto
 da aplicação.
\layout Standard

Este trabalho traçou um panorama dos problemas gerais enfrentados na interação
 entre código C e o ambiente de execução de uma linguagem de script.
 Apresentamos as formas como as APIs de cinco linguagens tratam estes problemas,
 apontando pontos positivos e negativos das diferentes abordagens utilizadas.
 Realizamos uma comparação prática do uso destas APIs através de um estudo
 de caso onde as linguagens de script foram embutidas em bibliotecas C exportand
o uma mesma interface.
 A implementação consiste de uma biblioteca genérica para scripting, chamada
 LibScript, e uma série de plugins que realizam a interface com as diferentes
 linguagens.
 Pudemos assim observar como elas tratam aspectos importantes relativos
 a linguagens embutidas, como a passagem de dados, chamadas de funções entre
 as duas linguagens, tratamento de erros e o isolamento dos ambientes de
 execução em aplicações.
\layout Standard

Embora os mesmos problemas gerais, como transferência de dados, registro
 e chamada de funções, sejam comuns aos diferentes cenários de uso de uma
 API de linguagem de script, aplicações embutindo uma máquina virtual tendem
 a demandar mais da API do que bibliotecas implementando módulos de extensão.
 Este ponto é ilustrado pelas dificuldades impostas pela API de Python tanto
 no acesso a variáveis como no registro de funções globais; e principalmente
 pela complexidade da API de chamada de funções de Perl.
\layout Standard

O fato de que a API de Python dificulta o uso de variáveis e funções globais,
 favorecendo o uso de módulos, pode ser justificado como uma forma de promover
 um modelo de programação mais estruturada.
 Isto é interessante para o uso da API no desenvolvimento de módulos de
 extensão, uma vez que o uso de variáveis e funções globais é extremamente
 prejudicial nestes casos, já que poluiria o espaço de nomes das aplicações
 Python.
 Já para o caso onde a linguagem é embutida para prover suporte à execução
 de scripts em uma aplicação C, a ausência de uma forma conveniente para
 definir funções globais no espaço de nomes dos scripts é questionável.
\layout Standard

A abordagem empregada por Perl, usando um pré-processador com o objetivo
 de gerar automaticamente o código para a conversão de dados na passagem
 de parâmetros e valores de retorno, se mostrou inadequada para o cenário
 envolvendo interpretadores embutidos.
 Embora o uso do pré-processador simplifique os casos simples de declaração
 de funções C, a falta de uma API bem definida para tratar a transferência
 de dados entre o interpretador Perl e o código C se faz perceber nos casos
 mais elaborados.
 Duas destas situações se fizeram presentes no estudo de caso: o recebimento
 de parâmetros 
\emph on 
varargs
\emph default 
 e a passagem de valores de retorno tratando múltiplos contextos de execução.
 Ambas exigiram manipulações de estruturas e construções de mais baixo nível,
 que o pré-processador tem por objetivo ocultar.
\layout Standard

Observações interessantes resultaram da comparação da API de Java com a
 das demais quatro linguagens de script, uma vez que, embora possua diversas
 características em comum com estas linguagens, Java não seja considerada
 uma linguagem de script.
 Enquanto a tipagem estática reduz bastante a necessidade de conversões
 de dados explícitas no código C para tipos primitivos da linguagem, na
 prática a verificação de tipos para objetos e a ligação de campos e métodos
 acontece de forma dinâmica, já que estes têm que ser realizados em tempo
 de execução pela JNI.
 Assim, no contexto da interação de uma máquina virtual com código C, as
 vantagens trazidas pela tipagem estática são reduzidas.
 Além disso, a resolução dinâmica de campos e métodos faz com que a manipulação
 de objetos via C tenha diferenças sutis de comportamento em relação ao
 que ocorre em código Java, o que pode ser uma fonte de erros do programador.
\layout Standard

Ao comparar as APIs, consideramos apenas as suas interfaces, fazendo uma
 análise qualitativa da usabilidade de cada uma da perspectiva do programador
 C, e não uma análise quantitativa das suas implementações.
 O custo de desempenho adicionado pelo código que realiza a ligação entre
 duas linguagens, por exemplo, não pode ser desprezado.
 Muitas decisões de projeto de uma API são influenciadas por requisitos
 da implementação como restrições de portabilidade ou desempenho.
 Por exemplo, o tratamento automático de controle de escopo de 
\family typewriter 
VALUE
\family default 
s em Ruby, varrendo a pilha de C, traz grande conveniência para o programador,
 mas reduz a portabilidade da implementação.
\layout Standard

Merece comentário também a disparidade entre as linguagens no que concerne
 à disponibilidade de documentação.
 Java, Python e Lua possuem extensa documentação, tanto para a linguagem
 como para as suas APIs para C.
 Para estas linguagens, pudemos basear largamente nosso estudo e a implementação
 dos exemplos para o estudo de caso na documentação fornecida.
 A documentação de Ruby relativa à sua API de C é mais escassa; em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 é coberta apenas parte da API pública.
 Precisamos fazer uso de funções não documentadas para tarefas fundamentais
 como liberar referências globais registradas via C.
 Durante o desenvolvimento do plugin Ruby no estudo de caso, consultamos
 freqüentemente o código-fonte de Ruby para compreender os aspectos que
 não são cobertos pela documentação do comportamento das suas funções públicas.
 A documentação da API de C de Perl também é incompleta, espalhada através
 de diversas 
\emph on 
man pages
\emph default 
 incluídas na sua distribuição e em certos casos desatualizada.
 Para compreender os diversos protocolos envolvidos no uso prático da API
 de Perl, precisamos recorrer ao código-fonte de aplicações que fazem uso
 dela.
\layout Standard

O equilíbrio entre simplicidade e conveniência é outro tema recorrente ao
 compararmos as APIs.
 A extensa API de Python, contendo 656 funções públicas, contrasta com as
 113 funções expostas pela API de Lua (79 na API 
\emph on 
core
\emph default 
, 34 na API auxiliar).
 Em diversas situações, funções na API de Python abreviam duas, três ou
 até mais chamadas, como no caso de funções poderosas como 
\family typewriter 
Py_BuildValue
\family default 
 e 
\family typewriter 
PyObject_CallFunction
\family default 
, tornando o código C sucinto e legível.
 A abordagem defendida por Lua é a de uma API minimalista, oferecendo mecanismos
 sobre os quais funcionalidades mais elaboradas possam ser construídas.
 De fato, em\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 é apresentada uma função C equivalente a 
\family typewriter 
PyObject_CallFunction
\family default 
 usando a API de Lua.
\layout Standard

Ruby exporta 530 funções em seu cabeçalho e Perl 1209, mas como apenas uma
 pequena fração destas é documentada, torna-se difícil avaliar o tamanho
 da 
\begin_inset Quotes eld
\end_inset 

API pública
\begin_inset Quotes erd
\end_inset 

 destas linguagens e quantas destas são apenas funções para uso interno
 expostas nos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

Algumas funções são marcadas como sendo de uso interno, mas a maioria não
 possui qualquer indicação.
\end_inset 

.
 Isto mostra também que a documentação não é relevante apenas enquanto material
 de apoio para o desenvolvimento, mas também indica o quão bem definida
 é uma API.
\layout Standard

A API de Java é bem documentada como a de Python e Lua, mas o número de
 funções exportadas não é um bom parâmetro para comparações com as demais
 APIs porque, em função dos tipos estaticamente definidos, muitas funções
 possuem uma variante para cada tipo primitivo.
 Java exporta sua API como uma estrutura contendo ponteiros para função;
 228 funções ao todo são exportadas nesta estrutura.
\layout Standard

Outro aspecto que pôde ser observado neste trabalho é que a consistência
 da API depende largamente da consistência da linguagem que ela expõe.
 Construções onde a linguagem tem pouca ortogonalidade, como o tratamento
 de blocos em Ruby ou as diferenças nos tratamentos de valores escalares
 e arrays em Perl, acabam por aumentar a complexidade da API da linguagem
 e demandam tratamento específico por parte do programador no código C.
\layout Standard

Como possibilidades de trabalhos futuros, este trabalho pode ser estendido
 através do estudo de outros aspectos de APIs de linguagens de script.
 Um foco possível é o impacto de desempenho de diferentes projetos de API
 em aplicações multi-linguagem.
 Outro é a relação entre o projeto de uma máquina virtual e o de sua respectiva
 API.
 Além disso, outra perspectiva de trabalho é a continuação do desenvolvimento
 da biblioteca LibScript.
 Possibilidades incluem adicionar novos plugins, revisar a sua API e exercitá-la
 embutindo a biblioteca em aplicações reais.
 LibScript e os quatro plugins implementados são software livre e estão
 disponíveis para download em\SpecialChar ~

\begin_inset LatexCommand \url{http://libscript.sourceforge.net}

\end_inset 

.
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{dissert}

\end_inset 


\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

API de LibScript
\layout Section

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ponteiro para o ambiente virtual.
 O parâmetro 
\family typewriter 
namespace
\family default 
 indica o nome a ser usado nas estruturas a serem criadas no espaço de nomes
 das máquinas virtuais para representar o ambiente virtual.
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente virtual.
\layout Section

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo das funções C a serem registradas no ambiente virtual.
 Ao expor uma API existente para LibScript, a função tipicamente será uma
 função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente virtual.
\layout Section

Buffer de parâmetros
\layout Itemize


\family typewriter 
double script_get_double(script_env* env, int index)
\newline 
int script_get_int(script_env* env, int index)
\newline 
int script_get_bool(script_env* env, int index)
\newline 
const char* script_get_string(script_env* env, int index)
\family default 

\newline 
Obtêm dados do buffer.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_get_string
\family default 
, a string retornada pertence ao chamador, que passa a ser responsável por
 desalocá-la.
\layout Itemize


\family typewriter 
script_type script_get_type(script_env* env, int index)
\newline 
int script_buffer_len(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_get_type
\family default 
 obtém o tipo do elemento do buffer solicitado e 
\family typewriter 
script_buffer_len
\family default 
 retorna o número de parâmetros no buffer.
\layout Itemize


\family typewriter 
void script_put_double(script_env* env, int index, double value)
\newline 
void script_put_int(script_env* env, int index, int value)
\newline 
void script_put_bool(script_env* env, int index, int value)
\newline 
void script_put_string(script_env* env, int index, const char* value)
\newline 

\family default 
Inserem dados no buffer.
 Ao final de uma função, os valores de retorno devem ser passados com chamadas
 a estas funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Itemize


\family typewriter 
void script_reset_buffer(script_env* env)
\family default 

\newline 
Esvazia o buffer.
\layout Section

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_put_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_get_*
\family default 
.
 Inicialmente, a tabela de funções C do ambiente virtual é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas na representação do ambiente virtual definido para
 a LibScript na máquina virtual da linguagem (isto é, no nome criado com
 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\newline 
void script_set_error_message(script_env* env, const char* message)
\newline 

\family default 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
 A função 
\family typewriter 
script_set_error_message
\family default 
 define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente virtual deve ser
 exposto à máquina virtual de alguma forma apropriada para a linguagem (como
 uma tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 O estado da máquina virtual e o ponteiro para o ambiente LibScript devem
 ser armazenados de modo a ser posteriormente acessíveis a partir deste
 handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_get_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_put_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\the_end
