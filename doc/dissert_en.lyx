#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{a4wide}
\usepackage{indentfirst}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Standard


\backslash 
autor{Hisham H.
 Muhammad}
\layout Standard


\backslash 
autorR{Muhammad, Hisham H.}
\layout Standard


\backslash 
orientador{Roberto Ierusalimschy}
\layout Standard


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Standard


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Standard


\backslash 
cidade{Rio de Janeiro}
\layout Standard


\backslash 
departamento{Informática}
\layout Standard


\backslash 
programa{Informática}
\layout Standard


\backslash 
centro{Centro Técnico Científico} 
\end_inset 


\layout Title

A study on scripting language APIs
\layout Author
\added_space_bottom bigskip 
Hisham H.
 Muhammad
\newline 

\newline 

\newline 

\size normal 
Advisor: Roberto Ierusalimschy
\newline 

\newline 

\newline 

\newline 
Pontifícia Universidade Católica do Rio de Janeiro
\newline 
Centro Técnico Científico
\newline 
Departamento de Informática
\layout Standard
\pagebreak_top 
\SpecialChar ~

\begin_inset ERT
status Open

\layout Standard

\backslash 
thispagestyle{empty}
\end_inset 


\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
setcounter{page}{1}
\end_inset 

Abstract
\layout Standard

Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard

This work discusses the main issues involving the design of APIs for the
 integration of language environments within C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C\SpecialChar ~
code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C\SpecialChar ~
application and that from the scripting language.
\layout Standard

We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C\SpecialChar ~
application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C\SpecialChar ~
functions and conversion of data between the environments.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\end_inset 


\layout Standard

There are many situations in which it is necessary or interesting to have
 interaction between programs written in different languages.
 A typical case is the use of external libraries, such as graphic toolkits,
 APIs for database access, or even operating system calls.
 Another scenario involves applications developed using more than one programmin
g language, in order to optimize parts where performance is critical or
 to allow extensibility through scripts written by the end-user.
\layout Standard

Regardless of purpose, communication between programs written in different
 languages brings up a number of design issues, not only in the development
 of the applications, but in the languages themselves.
 There are many ways to obtain this kind of interoperability, from translation
 of code of a language to another to the use of a common virtual machine.
 Ideally, however, a language should provide a foreign language interface
 (FLI) that allows the programmer to send and receive both calls and data
 to the other language\SpecialChar ~

\begin_inset LatexCommand \cite{finne98haskellfli}

\end_inset 

.
 Among the factors that should be taken into account when developing such
 an interface are the differences between type systems, memory management
 issues (such as garbage collection and direct access to pointers) and concurren
cy models.
 Beyond dealing with semantic differences, the design of an interface between
 languages involves pragmatic issues such as the balance between the safe
 isolation of the runtime environments, performance and the simplicity of
 the resulting API.
\layout Standard

We can observe in the existing implementations of FLIs a number of approaches
 to these problems.
 Indeed, FLIs for different languages (or even different revisions of a
 single language) tend to be very different from each other.
 Still, it is possible to trace parallels among the various techniques employed,
 since the fundamental problems that they address are the same.
\layout Standard

Because of the popularity of the C\SpecialChar ~
language and the support it enjoys in
 the most popular operating systems, a considerable part of the implementations
 of foreign language interfaces are, in practice, C APIs.
 Besides, an interaction model for programming languages that has become
 especially relevant nowadays is that between statically typed compiled
 languages, such as C, and dynamically typed interpreted languages, as proposed
 by Ousterhout\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

.
 These two classes of languages have fundamentally different goals.
 Statically typed languages are usually implemented with high performance
 in mind and focus on lower-level programming.
 In contrast, scripting languages tend to be implemented as interpreters
 or virtual machines, and make extensive use of high-level constructs, such
 as lists and hashes, as basic types.
 These complementary features have made the two-language programming model
 popular, in which a lower-level language is used for the development of
 components, which are then connected through a higher-level language.
\layout Section

Objectives
\layout Standard

This work discusses the main issues involving the design of APIs for integration
 of runtime environments of scripting languages in C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as that
 from a scripting language with C\SpecialChar ~
code.
 Besides being currently the most popular class of languges for multi-language
 development, typical features of scripting languages such as garbage collection
 and dynamic typing illustrate well the problems that arise in the communication
 between different programming environment, since these features are absent
 in\SpecialChar ~
C.
 Languages with static typic may present similar needs for type conversion,
 but the problem tends to be simplified by the definition of equivalent
 types in the API and compile-time inference (as can be observed in the
 C APIs for Ada and Fortran).
 Functional languages have additional concerns related to side effects in
 C code, but this is equivalent to the paradigm break problem caused by
 the handling of I/O commonly faced by those languages.
\layout Standard

This study consists of two parts.
 In the first part, we performed an in-depth analysis of a set of C\SpecialChar ~
APIs
 provided by four scripting languages -- namely, Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06ref}

\end_inset 

, Perl\SpecialChar ~

\begin_inset LatexCommand \cite{wall00perl}

\end_inset 

, Ruby\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

, Lua\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 -- as well as the API provided by the Java language\SpecialChar ~

\begin_inset LatexCommand \cite{gosling00java}

\end_inset 

.
 Unlike the others, Java uses static typing, but like them it is based on
 a virtual machine model, features automatic memory management and allows
 dynamic loading of code.
 This allows us to observe how typing affects the design of the API.
\layout Standard

In the second part, we illustrate the differences of the APIs of those langages
 and the impact of those in the resulting code of a C application through
 a case study.
 We performed a comparison between the scripting language APIs through a
 concrete example, in order to present implementations in each of the studied
 languages side by side.
 The example consists of a generic scripting library, called LibScript,
 and a series of plugins that interface to the different languages.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures used in each language for function calls, registration
 of C\SpecialChar ~
functions and data conversion between environments.
 
\layout Section

Text structure
\layout Standard

This work is structured as follows.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, we discuss the various approaches for interaction between code written
 in different programming languages.
 Starting from an overview, the focus will then concentrate on the most
 commonly used foreign language interface: interfaces with the C\SpecialChar ~
language.
 We will discuss the problems commonly presented in the communication with
 C code and the programming models that appeared with its popularization
 in the integration with scripting languages.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

, we present in detail C\SpecialChar ~
APIs for a set of scripting languages.
 When discussing these interfaces, the different solutions employed for
 the main problems involving interaction between C and dynamic environments
 are brought up.
 Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercises these APIs through a case study: a plugin-based library that
 offers a simplified, uniform interface for scripting languages.
 By examining the implementation of each plugin, we can compare the APIs
 for each language performing equivalent operations.
 Finally, in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

, conclusions reached through this work are presented, as well as possible
 directions for future work.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interaction between programming languages
\layout Standard

The approaches applied to the interaction of different programming languages
 vary considerably, but it is possible to identify some of the more typical
 techniques: language translation, from one language to the other or of
 both to a third; communication through an intermediate protocol or language;
 sharing a common execution environment, be it a virtual machine or through
 call conventions; and foreign language interfaces.
\layout Section

Code translation
\layout Standard

Allowing the use of two languages in a program through the translation of
 the code of one of them to the other minimizes the problem of communication
 between the parts of program written in different languages, since the
 final program will use a single data space.
 On the other hand, by having to describe a language in terms of the other,
 the semantic differences of their constructs may become a problem.
 If the target language lacks constructs offered by the source language,
 simulating them may be costly.
\layout Standard

A typical example of this problem is the complexity added by the simulation
 of higher-order functions and tail recursion when translating code from
 functional languages to one that does not have those features.
 Tarditi et al.\SpecialChar ~

\begin_inset LatexCommand \cite{tarditi92mlc}

\end_inset 

 describe the development of a translator of Standard ML to ANSI C.
 Their measurements have exposed the cost of adapting the features of ML
 to C, resulting in code that is in average 2 times slower than the that
 generated by the native ML compiler.
 In 
\begin_inset LatexCommand \cite{tolmach98mlada}

\end_inset 

, similar challenges are discussed in the translation of ML to Ada: in the
 adopted approach, the process has an intermediate step where higher-order
 constructs are 
\begin_inset Quotes eld
\end_inset 

flattened
\begin_inset Quotes erd
\end_inset 

 to first-order constructs using records, so that they could be represented
 in Ada.
\layout Standard

Besides problems such as this, differences in the representation of data
 is also something to be handled when translating one language to another.
 In the particular case of\SpecialChar ~
C, its lower-level facilities for memory manipulation
 allow the description of data structures for higher-level languages without
 too much trouble.
 This makes\SpecialChar ~
C a frequent candidate for use as a portable low-level representation
 of code.
 The Glasgow Haskell Compiler offers, as an alternative to the generation
 of native code, generation of C code for use with GCC\SpecialChar ~

\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 One of the advantages of this feature is to allow the bootstrapping of
 the compiler in new architecture, given that GHC itself is written in Haskell.
 In fact, the ubiquity of C compilers has prompted the use of this language
 as a 
\emph on 
lingua franca
\emph default 
 between different languages, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Sharing virtual machines
\layout Standard

Another approach for the interaction between languages involves the use
 of a common execution environment, such as a virtual machine.
 The code of different languages is compiled to produce compatible representatio
ns, according to the data types provided by the execution environment.
 Many implementations use the Java Virtual Machine\SpecialChar ~

\begin_inset LatexCommand \cite{lindholm99jvm}

\end_inset 

 for this end.
 Jython\SpecialChar ~

\begin_inset LatexCommand \cite{hugunin97python}

\end_inset 

 is an implementation of the Python language that produces Java bytecodes.
 SMLj\SpecialChar ~

\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 is a Standard ML compiler that generates Java bytecodes and provides access
 to Java classes and methods to ML structures and vice versa.
 The fact that the Java Virtual Machine was not designed to support different
 programming languages, however, shows in the limitations presented by these
 projects.
 SMLj defines extensions to the ML language to allow access to constructs
 that are specific to Java; Jython poses limitations to the interface between
 Python and the Java APIs for reflection and dynamic class loading.
 Besides, the instruction set of the virtual machine focuses on operations
 that match Java's semantics, which makes, for example, the implementation
 of arrays with different semantics less efficient.
\layout Standard

The .NET Framework\SpecialChar ~

\begin_inset LatexCommand \cite{box02net}

\end_inset 

 is a runtime environment based on virtual machine that is being presented
 by Microsoft as their programming platform of choice in Windows system.
 Although the C#\SpecialChar ~
language 
\begin_inset LatexCommand \cite{csharp06spec}

\end_inset 

 has been introduced specifically for it, this environment has as one of
 its goals multi-language support -- evidenced by the very name of its Common
 Language Runtime (CLR) -- contrasting with the limitations imposed by the
 Java enviroment to those who try to use it with other languages.
 However, adaptations to languages remain necessary in the .NET environment:
 the .NET version of Visual Basic includes changes to the language to make
 its semantics match those from C#; a new dialect of C++, C++/CLI, was introduce
d adapting its memory management model to that of the CLR\SpecialChar ~

\begin_inset LatexCommand \cite{cppcli05spec}

\end_inset 

; similarly, a new dialect of ML called F# was developed to, among other
 reasons, provide better integration with .NET components written in other
 languages\SpecialChar ~

\begin_inset LatexCommand \cite{syme06fsharp}

\end_inset 

.
\layout Standard

Another implementation of a virtual machine for multiple languagens is being
 pursued by the Parrot project\SpecialChar ~

\begin_inset LatexCommand \cite{randal04perl6}

\end_inset 

.
 The scope of this project is narrower, aiming to serve as a common back-end
 for dynamic languages such as Perl and Python.
 The focus of the project, however, is currently on the implementation of
 Perl 6.
\layout Standard

A kind of communication that can also be considered the use of a common
 runtime environment is the communication between executables and native
 libraries through call conventions: rules for passing parameters in the
 runtime stack, use of registers and name mangling.
 This can be considered the lowest-level method method for interaction between
 code in different languages.
 Calling conventions, however, are a limited form of communication, as they
 assume data types with identical memory representation in both languages.
 Such compatibility is hardly the case, unless one of the languages explicitly
 considers this kind of interaction in its definition: the Ada standard,
 for example, requires its implementations to be compatible with the calling
 conventions of C, COBOL and Fortran\SpecialChar ~

\begin_inset LatexCommand \cite{ada95manual}

\end_inset 

.
 Likewise, C++ allows to specify functions with C-compatible linkage, through
 the 
\family typewriter 
extern "C"
\family default 
 directive.
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Language-independent object models
\layout Standard

Adopting a language-independent type model is another way to handle the
 issues of data interoperability between languages.
 This way, in the definition of the data for an application, their interfaces
 are described in a neutral way, typically using some language designed
 specifically for this end (an Interface Description Language, IDL), while
 the implementations are made using the specific languages.
 The CORBA (Common Object Request Broker Architecture) architecture\SpecialChar ~

\begin_inset LatexCommand \cite{omg02corba}

\end_inset 

 is one of the main examples of this model.
 The central motivation for the development of CORBA was to allow the developmen
t of distributed applications in heterogeneous environments; language heterogene
ity was one of the aspects taken into consideration.
\layout Standard

The challanges existing when designing a 
\begin_inset Quotes eld
\end_inset 

language independent
\begin_inset Quotes erd
\end_inset 

 model for data or objects, however, are not unlike those in the design
 of an interface between any two languages, since this model too describes
 a type system.
 When implementing bindings for any of those object models, it is necessary
 to define a correspondence between the types defined by the model and those
 offered by the target language, and provide an API for interaction with
 the runtime environment -- in the case of CORBA, with the ORB (Object Request
 Broker).
\layout Standard

If on one hand the task may be easier since the model has been designed
 with language interaction in mind (unlike, for example, the C\SpecialChar ~
type system),
 on the other one would usually expect a higher level of transparency in
 the representation of data.
 For example, while in an application intergrating\SpecialChar ~
C++ and Python the distinction
 between C++\SpecialChar ~
objects and Python objects is clear and the Python API defines
 the limits between these two universes, in an application developed using
 CORBA one would expect, in both languages, the manipulation of objects
 to be the same whether they were implemented in C++ or in Python.
 For that, the common solution is to use 
\emph on 
stubs
\emph default 
, objects that give a uniform native appearance to data, regardless of the
 language in which they were implemented, and in the case of distributed
 models such as CORBA, of the location of the objects in the network.
 The correspondence between the lifecycles of the stubs and that of the
 objects they represent is another factor that should be taken into account.
 In the Java bindings, for instance, this is done with the help of the language'
s own garbage collector.
 In languages such as C++ the control of references is explicit.
\layout Standard

Other higher-level approaches have been proposed for the integration of
 applications developed in multiple languages.
 Coordination languages such as Linda\SpecialChar ~

\begin_inset LatexCommand \cite{gelernter85linda}

\end_inset 

 and Opus\SpecialChar ~

\begin_inset LatexCommand \cite{chapman97opus}

\end_inset 

 define mechanisms for message passing and a restricted set of constructs
 to indicate the flow of those between agents implemented in other languages.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C as an intermediate language
\layout Standard

The wish for a universal intermediate language is an old one in the world
 of computing.
 Several proposals have surfaced through the years, from the UNCOL project\SpecialChar ~

\begin_inset LatexCommand \cite{conway58uncol}

\end_inset 

 to the languages with extensible syntax of the 70s\SpecialChar ~

\begin_inset LatexCommand \cite{metzner79extensible}

\end_inset 

 to the most recent virtual machine environments such as .NET.
 In practice, the needs that these projects aimed to fulfill are being handled
 through the years in a more pragmatic, if less than ideal, way by using
 C.
 Two reasons make C a common choice as an intermediate language.
 First, its 
\begin_inset Quotes eld
\end_inset 

medium-level
\begin_inset Quotes erd
\end_inset 

 nature, by providing at the same time hardware independence and direct
 manipulation of memory.
 Second, the large availability of C\SpecialChar ~
compilers, leveraged by the proliferation
 of Unix systems in the most varied architectures.
 So, as time went by, to offer an interface for interoperability with other
 languages gradually became synonymous with offering an interface for communicat
ion with C\SpecialChar ~
code.
 This is especially true for dynamic languages that offer features for applicati
on extensibility.
 Not surprisingly, these languages are typically implemented in C.
 
\layout Standard

The availability of C APIs provided by different languages also causes C
 to be widely used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

.
 The integration between Python and Fortran takes place through a Python
 module written in C that accesses a Fortran library, which on its turn
 exposes functions using a call convention compatible with C\SpecialChar ~

\begin_inset LatexCommand \cite{peterson01fortranpy}

\end_inset 

.
 LunaticPython\SpecialChar ~

\begin_inset LatexCommand \cite{niemeyer06lunaticpython}

\end_inset 

 offers bridges from Lua to Python and from Python to Lua, implemented through
 a pair of extension modules for each source language written in\SpecialChar ~
C.
\layout Standard

However, generic intermediate languages continue to be proposed as alternatives
 to C.
 C-
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1pt}
\end_inset 

-\SpecialChar ~

\begin_inset LatexCommand \cite{jones99cminusminus}

\end_inset 

 is a project that attempts to overcome the limitations of C as an intermediate
 language making the memory representation of data types more explicit and
 adding support to constructs that are not easily represented in C, such
 as tail recursion.
 Recent versions of the GCC compiler suite have standardized an intermediate
 language for communication between its various back-ends and front-ends\SpecialChar ~

\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces to C
\layout Standard

The C language has, nowadays, a special role in the world of programming
 languages.
 Besides being widely used in the implementation of compilers, interpreters
 and virtual machines (the main implementations of Perl, Python, Ruby and
 Lua are just some examples), it is also used in compilers as an output
 format in the generation of portable code (two notable examples are the
 GHC and SmartEiffel\SpecialChar ~

\begin_inset LatexCommand \cite{collin97smalleiffel}

\end_inset 

 compilers, which generate C from Haskell and Eiffel, respectively).
 This pravelence of C makes the C API a convenient format for a foreign
 language interface.
\layout Standard

In the vast majority of cases, the internal representation of code produced
 by compilers for other languages is not compatible with C, be it because
 of differences in call or name conventions, or because they produce code
 for execution in virtual machines.
 This way, to allow a C program to access this code, the language has to
 expose a library of C functions that will perform the necessary translations.
 In virtual machine environments, this library is normally generic, offering
 facilities for communication with the virtual machine itself.
 For static languages, it is usually necessary to create a specific library
 to perform the conversion of calls, as it happens in interfaces that expose
 C++ libraries to C.
 An example of this is QtC\SpecialChar ~

\begin_inset LatexCommand \cite{kdebindings}

\end_inset 

, a library of C bindings to the Qt graphic toolkit, which is implemented
 in C++.
\layout Standard

For non-imperative languages, there is still the problem of C code potentially
 generating side effects.
 Some feature for isolating calls has to be offered.
 In GHC, the construction for C calls, 
\family typewriter 
_ccall_
\family default 
, is defined in the IO monad; in the addendum for the Haskell 98 standard,
 the 
\family typewriter 
ccall
\family default 
 directive was integrated, but the use of the monad is optional, requiring
 the programmer to ensure that the functions that use it are not pure
\begin_inset Foot
collapsed true

\layout Standard

A number of additional convention calls are defined (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
), but 
\family typewriter 
ccall
\family default 
 is the only one declared mandatory by the document.
\end_inset 

.
\layout Standard

Another possible source of incompatibility between languages that has to
 be handled when they interact is the difference between concurrency models.
 C, in particular, does not define any concurrency constructs; they are
 implemented through libraries.
 At the same time that it brings great flexibility to the language, this
 also imposes portability problems for languages that depend on the availability
 of concurrency mechanisms in C that are compatible with the models they
 use.
\layout Standard

For example, APIs between C and Java must take into account the preemptive
 multithreading model adopted by Java.
 The JNI (Java Native Interface)\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

 defines functions to control mutual exclusion between data shared between
 the two languages.
 The programmer must take care to strike a balance between time spent blocking
 the virtual machine accessing shared data and time spent copying data between
 the environments to reduce sharing.
 Another situation in which the concurrency model of the language demands
 special care when integrating with C happens in the use of co-routines
 in Lua.
 The combination of two features of Lua, cooperative multitasking with multiple
 execution stacks and the ability to alternate between calls to C and Lua
 functions in a single stack, brings a limitation: a co-routine cannot execute
 a 
\emph on 
yield
\emph default 
 operation in case there is a C function in its stack, as there is no portable
 way to alternate between multiple stacks in C\SpecialChar ~

\begin_inset LatexCommand \cite{moura04colua}

\end_inset 

.
\layout Standard

One of the most frequent motivations in the integration with C code is the
 use of external libraries.
 Exposing a C library through the FLI for access by another language may
 incur in the registration of hundreds of functions.
 It is also usual to define data types that give to structures defined by
 the library a more native appearance, such as, for example, converting
 C functions that register callbacks into Ruby methods that accept code
 blocks as a parameter.
 These initializations and adaptations are usually defined as a bindings
 library, that serves as a bridge between the language and the C library
 encapsulating the interaction with the FLI.
\layout Standard

The patterns that arise when producing bindings are so common that they
 motivated the development of programs that attempt to automate the process.
 These bindings generators tend to work using some representation prepared
 for their use, since analyzing raw C headers may show itself to be insufficient
: for example, often the program wouldn't be able to interpret the intention
 of a construct such as 
\family typewriter 
int**
\family default 
.
 SWIG\SpecialChar ~

\begin_inset LatexCommand \cite{beazley96swig}

\end_inset 

 is a popular multi-language tool for generation of bindings for C and C++
 libraries which defines its own format for description of interfaces.
 FLIs may as well use stubs generators to save the programmer from having
 to write repetitive or non-portable C\SpecialChar ~
code.
 Java features a generator for C headers containing prototypes for native
 methods to be implemented.
 Pyrex\SpecialChar ~

\begin_inset LatexCommand \cite{ewing06pyrex}

\end_inset 

 is a generator for C modules for Python from a syntax based on the Python
 language itself.
 Another example is toLua++\SpecialChar ~

\begin_inset LatexCommand \cite{manzur06tolua}

\end_inset 

, a tool for integrating C and C++ code to Lua, which generates stubs from
 C headers prepared for use by the program, which may contain special annotation
 to help in the conversion process.
\layout Section

Scripting languages
\layout Standard

A model for interaction between languages that has shown to be especially
 relevant nowadays is that between statically typed compiled languages,
 such as C and C++, and dynamically typed interpreted languages, such as
 Perl and Python.
 In\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

, Ousterhout categorizes these two groups as 
\emph on 
systems programming languages
\emph default 
 and 
\emph on 
scripting languages
\emph default 
.
\layout Standard

These two categories of languages have fundamentally different goals.
 Systems programming languages emerged as an alternative to assembly in
 the development of applications, having as main features static typing,
 which eases the understanding of data structures in large systems, and
 the implemantation as compilers, due to concerns with performance.
 In contrast, scripting languages are dynamically typed and are implemented
 as interpreters or virtual machines.
 Dynamic typing and the extensive use of higher-level constructs as basic
 types, such as lists and hashes, brings greater flexibility in the interaction
 between components; in static languages, the type system imposes restrictions
 to those interactions, often requiring the programmer to write adaptation
 interfaces, which makes the reuse of components harder.
\layout Standard

Ousterhout points out that, in a model integrating these two kinds of languages,
 the tendency is that systems programming languages will no longer be used
 to write whole applications, but will instead be used in the implementation
 of components, which are then connected through code written with scripting
 languages.
 The convenience offered by high-level interpreted languages allows rapid
 prototyping and encourages the reuse of components.
\layout Standard

The integration of programs developed in systems programming languages coordinat
ed through scripting languages has been common practice for a long time
 now.
 Shell scripting in Unix systems is probably the most notable example, where
 constructs such as pipes (which connect the output of a process to the
 input of another one) allow one to perform tasks combining a series of
 programs implemented in different languages, or even other scripts.
 With the introduction of Tcl\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout94tcl}

\end_inset 

, this kind of coordination of components through scripting languages started
 to take place 
\emph on 
within
\emph default 
 applications.
 In this model, the scripting language is implemented as a library and is
 embedded in an application written in a lower-level language, such as C.
 Data structures of the application are exposed to the scripting environment
 as objects; conversely, the application can launch functions in the scripting
 language and access its data.
 Programmable applications have existed long before that, typically using
 little languages created specifically for each application, but the concept
 introduced by Tcl of implementing scripting languages as C libraries has
 propelled strongly the development of extensible applications.
\layout Standard

The development model based in two languages does not limit itself to applicatio
ns that provide customization through scripts written by the end-user.
 In many scenarios, there is a clear distinction between a lower-level layer
 where performance is a critical factor and a higher-level layer comprised
 by coordination operations between elements of the lower layer.
 Typical examples are graphic applications where the interface is described
 by scripting languages controlling components implemented in C and games
 where the logic is described in scripts and the rendering engine is implemented
 in lower-level languages.
 This greater prominence of scripting languages, where they stop being just
 an application extension mechanism and start having a more central role
 in the coordination of the execution of the program, has also promoted
 an inverted model of interaction between languages, where the application
 itself is written using the scripting language and libraries written in
 lower-level languages are loaded as extension modules.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

Scripting language APIs
\layout Standard

Interfaces provided by scripting languages are usually understood as 
\begin_inset Quotes eld
\end_inset 

extension APIs
\begin_inset Quotes erd
\end_inset 

: they extend the virtual machine with features not originally offered by
 it, or alternatively, they extend an external application with the features
 offered by the runtime environment of the language, embedding it to the
 application.
 The first scenario is the one used in the programming model where the high-leve
l coordination is made by an interpreted language and modules written in
 languages such as C and C++ are used to access external libraries or to
 implement performance-critical parts.
 The second scenario, in general, will also encompass the first one, when
 exposing to the embedded virtual machine extensions that will allow it
 to talk to the host application.
\layout Standard

Both scenarios involve the same general problems: data transfer between
 the two languages, including how to allow the scripting language to manipulate
 structures declared in C and vice versa; handling the difference between
 the memory management models, more specifically the interaction between
 garbage collection in the virtual machine and explicit deallocation in
 C; calling functions declared by the scripting language from C; and the
 registration of C functions so that they can be invoked by scripts.
 The following sections discuss the main issues involved in the communication
 between C code and scripting languages, and present the approaches employed
 by the Python, Ruby, Java, Lua and Perl APIs when handling these issues.
 Each section concludes with a comparison where the different designs presented
 in the exposition of each language are reviewed side by side and thus put
 into perspective.
\layout Section

Data transfer
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

The main complexity in the interaction between programming languages is
 not the differences in syntax or semantics from their control flow structures,
 but in their data representations.
 In the communication between code written in two different languages, data
 flow in various forms: as parameters, object attributes, elements in data
 structures, etc.
\layout Standard

Often, the format how these data are represented differ.
 In those cases, there are three alternatives to perform data transfer between
 the languages.
 The simplest is to expose the data to the target language as an opaque
 entity.
 The target language receives only some kind of handle that allows it to
 identify the datum uniquely in operations requested later.
 This approach is useful, for example, if a language is just storing data
 for the other one, in order to make use of higher-level data structures
 offered by the language.
\layout Standard

Another approach involves perform some conversion to the data from the type
 system of one language to that of the other.
 The duplication that takes place in this conversion limits the applicability
 of this method, restricting its use typically to numeric types and, in
 minor scale, strings.
 Finally, the source language may explicitly offer facilities in the target
 language to manipulate these data, that is, one language would offer an
 API for the other.
 The difference between this approach and the first one is that, while in
 the former the contents of the data remain opaque, here the API defines
 some means to manipulate their contents.
\layout Standard

Because of its focus on the manipulation of pointers and structures, C provides
 a small set of basic types.
 Besides, C is very liberal with regard to the internal representation of
 its structured types, with each different platform having to define its
 own application binary interface (ABI).
 So, even in cases where it is possible to link C code directly using compatible
 basic types and appropriate calling conventions (such as in Free Pascal
 or several Fortran compilers), bindings libraries are still usually needed
 to make the manipulation of complex types more convenient.
\layout Standard

Even in the fundamental numeric types, there are several precautions that
 must be taken.
 Some languages, like Smalltalk and Ruby, perform automatic conversion of
 integers to 
\begin_inset Quotes eld
\end_inset 

big integers
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 In Ruby, in particular, primitive integers have 1 bit less of precision
 than the machine's word size.
 There may also be the need to handle conversion of endianness and format
 of floating point numbers.
\layout Standard

For types such as strings, the size of values brings also concerns with
 performance.
 In many cases the internal representation used for strings is the same
 as used in C, so an option is to simply pass to the C code a pointer to
 the address where the string is stored, which avoids copying of data, under
 risk of allowing the C code to modify the contents of the string.
 Exposing to C code pointers to memory areas within the runtime environment
 of the other language may also bring concurrency problems, in case the
 environment uses multiple threads.
\layout Standard

When exposing to C data of structured types, the conversion to a native
 C type, in many cases, is not an option.
 Besides the issue of quantity of data to be converted, structured types
 in C are defined statically, therefore not serving to represent conveniently
 data of dynamic structures, such as objects that may gain or lose attributes
 or even change class during runtime.
 Even in languages with static types, like Java, the copy of objects is
 not usually an interesting option due to the volume of data.
 Copying of structured objects tends to be restricted to specific operations
 such as manipulation of arrays of primitive types.
\layout Standard

The alternative to allowing C code to operate over structured data, thus,
 is to provide to it an API that exposes as functions the operations defined
 over those types.
 This also avoids the need to control the consistency between two copies
 of a given structure.
 Consistency problems, however, may occur if the API allows the C code to
 store pointers to objects from the language -- this makes it necessary
 for the programmer to manage explicitly the synchronicity between pointers
 and the lifecycles of objects that may be subject to garbage collection.
 Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discusses this issue in greater detail.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

All values in the Python virtual machine are represented as objects, mapped
 to the C API as the 
\family typewriter 
PyObject
\family default 
\SpecialChar ~
structure 
\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 More specific types such as 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 and 
\family typewriter 
PyListObject
\family default 
 are 
\family typewriter 
PyObject
\family default 
s by structural equivalence, that is, they can be converted through a C
 cast.
 Reflecting the dynamic typing model of Python, the API functions use 
\family typewriter 
PyObject*
\family default 
 as a type every time they refer to Python objects, even when they are designed
 to act on Python values of more specific types, such as for example the
 
\family typewriter 
PyString_Size
\family default 
, that returns the length of a string.
 Each specific type has a check function in the API, such as 
\family typewriter 
PyNumber_Check
\family default 
 and 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python is a strongly typed language: each object is tied to a type.
 Types are represented by 
\family typewriter 
PyTypeObject
\family default 
 structures, which are also structurally equivalent to 
\family typewriter 
PyObject
\family default 
.
 Each Python type has a predefined 
\family typewriter 
PyTypeObject
\family default 
 in the API, such as 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 and 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compares the type of a 
\family typewriter 
PyObject
\family default 
 to a 
\family typewriter 
PyTypeObject
\family default 
 passed as an argument.
\layout Standard

For the conversion of data from C to Python, the language offers a series
 of functions that receive values of primitive C types as an argument, such
 as 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 and 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Each of those functions returns to the C code a pointer to a new 
\family typewriter 
PyObject
\family default 
.
 Strings passed are copied by Python.
 The following example illustrates the creation of a Python object through
 the conversion of a C value:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The two examples below are equivalent, and illustrate type checking through
 the API, first through a convenience function, and then explicitly, comparing
 the type of a string Python with 
\family typewriter 
PyString_Type
\family default 
:
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Yes.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Yes.
\backslash 
n");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For returning data from Python to C, a complementary set of functions is
 offered, mapping the basic types of Python back to C types.
 Some examples of those functions that take a 
\family typewriter 
PyObject
\family default 
 pointer as an argument and return the correspondent C datum are 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 and 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Differently from the input functions, in these output functions no string
 copying takes place: the strings returned are pointers to memory stored
 internally by Python.
 The documentation recommends not to modify the content of the string except
 if the memory area was returned by a call to 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
size
\family typewriter 
\emph default 
)
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
 This way, it is possible to allocate a string for storage in Python and
 fill its contents later through C code, as in the following example:
\layout LyX-Code


\size footnotesize 
\emph on 
/* allocating an uninitialized string in Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtaining the pointer to the string memory area */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Now, we can fill the string in C.
 An example: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For some of its basic types that do not have direct correspondence in ANSI
 C 89, Python defines equivalent C types: 
\family typewriter 
Py_UNICODE
\family default 
 and 
\family typewriter 
Py_complex
\family default 
.
 These types were added in order to expose the internal representation of
 data used by Python in numeric manipulation and Unicode text modules implemente
d in C, avoiding frequent conversions to and from 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python also offers some versions of its C conversion functions as macros
 without type checking, assuming that the given 
\family typewriter 
PyObject
\family default 
 will be compatible, offering better performance in expense of safety.
 These functions can be identified by their uppercase names.
 Among the conversion macros provided are 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 and 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Besides functions for type conversions between Python and C, the Python
 API also offers some conversion functions between Python types.
 These functions receive a 
\family typewriter 
PyObject
\family default 
 as an argument and return a new 
\family typewriter 
PyObject
\family default 
 with the result of the conversion, and are equivalent to Python functions
 that perform these conversions (actually calls to 
\family typewriter 
PyTypeObject
\family default 
 types that answer to the 
\family typewriter 
__call__
\family default 
 method).
 For example, the 
\family typewriter 
PyObject_Str
\family default 
 function is equivalent to the Python function 
\family typewriter 
str
\family default 
.
\layout Standard

In Python, objects are stored in modules, which are namespaces declared
 globally, or as attributes of objects.
 Variables are stored in an 
\emph on 
environment
\emph default 
, represented as a dictionary.
 Functions such as 
\family typewriter 
PyRun_File
\family default 
 receive, among their parameters, a dictionary of global variables and another
 of local variables.
 The set of global variables and functions is represented as the dictionary
 of the 
\family typewriter 
__main__
\family default 
 module.
 Built-in objects are accessible through the 
\family typewriter 
__builtin__
\family default 
 module.
 For example, to obtain the 
\family typewriter 
str
\family default 
 object, we will initially obtain a reference to the 
\family typewriter 
__builtin__
\family default 
 module using the 
\family typewriter 
PyImport_AddModule
\family default 
 function and then the module's dictionary with the 
\family typewriter 
PyModule_GetDict
\family default 
 function.
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In Python, 
\family typewriter 
str
\family default 
 is a callable object, which acts as the string conversion function.
 So, once we obtained a reference to the PyObject equivalent to 
\family typewriter 
str
\family default 
, the following call is the same as calling 
\family typewriter 
PyObject_Str
\family default 
 on a given Python object 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* This is a vararg function that receives as additional arguments a
\layout LyX-Code


\size footnotesize 
\emph on 
   NULL-terminated list with PyObjects to be passed to the Python function
\layout LyX-Code


\size footnotesize 
\emph on 
   given in the first argument */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The storage of C data in the Python object space can be done in two ways.
 One way is to create an object of the 
\family typewriter 
CObject
\family default 
 type encapsulating a C pointer, building this way a value that will be
 opaque to Python.
 The allocation functions for objects of this type allow to associate to
 the datum a C function to be called when the 
\family typewriter 
CObject
\family default 
 is deallocated.
 According to the Python documentation, 
\family typewriter 
CObjects
\family default 
 have as their main purpose passing C data between extension modules\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
\layout Standard

The other way is to declare new Python types through C structures.
 In C, a Python type is described in two parts: a struct type, from which
 instances of the type will be produced, and an instance of the 
\family typewriter 
PyTypeObject
\family default 
 struct, which will describe the type to Python.
 The following example illustrates the creating of a new Python type in
 C.
 Initially, we have 
\family typewriter 
point
\family default 
, which will be the C type of object instances:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
PyObject_HEAD
\family default 
 macro ensures structural equivalence with 
\family typewriter 
PyObject
\family default 
.
 When functions return the object to C code as a 
\family typewriter 
PyObject*
\family default 
, this will be able to be converted back to 
\family typewriter 
point
\family default 
 through a cast, giving then access to the 
\family typewriter 
x
\family default 
 and 
\family typewriter 
y
\family default 
 attributes.
 We will also define a function that operates on objects of this type:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(p->x*p->x + p->y*p->y) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function was defined with a 
\family typewriter 
PyObject
\family default 
* return type so that it can be registered in the Python virtual machine.
 To associate the function to the Python type, we will initially store it
 in an array of 
\family typewriter 
PyMethodDef
\family default 
 structures, which will list the type's methods:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To make the attributes of the type are visible from Python, we will have
 to implement an access routine, that receives the object and the name of
 the accessed attribute.
 Its implementation is given below:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once it is registered in the type description, this function will be responsible
 for returning the type's attributes and methods.
 This way, we can expose to the Python environment attributes stored in
 the C struct.
 The 
\family typewriter 
Py_FindMethod
\family default 
 function locates a function in the array given as its parameter and returns
 it as a method
\begin_inset Foot
collapsed false

\layout Standard

Registration of Python functions will be discussed in detail in Section
 \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

Finally, we will define 
\family typewriter 
point_type
\family default 
, which will be the 
\family typewriter 
PyTypeObject
\family default 
 that will describe the Python type relative to 
\family typewriter 
point
\family default 

\begin_inset Foot
collapsed false

\layout Standard

For brevity, we will present the example using the C99 syntax for structs,
 saving us from listing the elements that will be initialized with 
\family typewriter 
NULL
\family default 
, as the 
\family typewriter 
PyTypeObject
\family default 
 struct has 54 fields in total.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",             
\emph on 
/* The name of the class */
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  
\emph on 
/* The size of the memory area to be allocated */
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    
\emph on 
/* The attribute access function */
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT  
\emph on 
/* This class does not require special treatment */
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Again, a macro was used at the top of the definition to ensure structural
 equivalence.
 
\family typewriter 
PyTypeObject
\family default 
 has many other fields, but we will keep them 
\family typewriter 
NULL
\family default 
 so that they will be filled with default values during the construction
 of the type at runtime.
 The 
\family typewriter 
PyTypeObject
\family default 
 type contains a number of fields that allow to describe the behavior of
 the declared type.
 In the 
\family typewriter 
tp_getattr
\family default 
 field of 
\family typewriter 
point_type
\family default 
, we specified that the C function to be used to handle access to attributes
 will be 
\family typewriter 
point_getattr
\family default 
.
 We specified 
\family typewriter 
Py_TPFLAGS_DEFAULT
\family default 
 in the flags field to indicate that this is a class with a default behavior,
 without the need for special treatements such as cycle checking during
 garbage collection.
\layout Standard

While the in-memory representation of 
\family typewriter 
Python
\family default 
 objects of the user-defined type are instances of 
\family typewriter 
point
\family default 
, to create a new object it is not enough to allocate an instance of 
\family typewriter 
point
\family default 
 and use it as a 
\family typewriter 
PyObject
\family default 
 through casting.
 It is necessary to initialize the object so that it is registered in the
 garbage collection mechanism and it has the fields of its 
\family typewriter 
PyObject
\family default 
 header properly initialized.
 The allocation in C of new objects of a user-defined type must be done
 through the 
\family typewriter 
PyObject_New
\family default 
 macro, which receives as arguments the type of the struct to be allocated
 and the 
\family typewriter 
PyTypeObject
\family default 
 that corresponds to the type.
 The documentation recommends assigning the default construction function,
 
\family typewriter 
PyType_GenericNew
\family default 
, during runtime for portability reasons\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Finally, any undefined fields of the struct are filled by the 
\family typewriter 
PyType_Ready
\family default 
 function.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

From there on, instances can be created with 
\family typewriter 
PyObject_New
\family default 
, as in the example below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates an instance */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Stores the instance in the Python global 'P',
\layout LyX-Code


\size footnotesize 
\emph on 
   assuming the globals dictionary was stored in 'globals' */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Once declared in C, this value can be used by Python code:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The Python API has a large number of functions for manipulation of predefined
 types in the language.
 
\emph on 
Tuples
\emph default 
 deserve a special mention with regard to data transfer between Python and
 C, as they are used in several contexts: when passing arguments to Python
 functions from C, when receiving input arguments in C functions and also
 when passing and receiving multiple return values, as we will see in Sections\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 and\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

As tuples are frequently used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

 between Python and C, the API offers a convenience function, 
\family typewriter 
PyArg_ParseTuple
\family default 
, that saves the programmer from having to perform access and type checking
 of the tuple elements one by one.
 This is a vararg C function that receives as arguments the tuple, a string
 indicating the types of expected arguments and the addresses where the
 values, converted to C types, should be stored.
 The function defines a syntax for expected type identifiers in the given
 string and the correspondent C types.
 For example: 
\family typewriter 
"s#"
\family default 
 indicates that the tuple should contain a Python object of the 
\family typewriter 
string
\family default 
 or 
\family typewriter 
Unicode
\family default 
 type and that two parameters should be passed to the C function, with types
 
\family typewriter 
const char**
\family default 
 and 
\family typewriter 
int*
\family default 
, that will return the string pointer and its size, respectively.
 In a more elaborate example, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indicates that the function expects two integer addresses (
\family typewriter 
"ii"
\family default 
), followed by the address of a 
\family typewriter 
PyObject
\family default 
 pointer
\family typewriter 
\SpecialChar ~

\family default 
(
\family typewriter 
"O"
\family default 
) and a PyTypeObject to be used when type checking the received object\SpecialChar ~
(
\family typewriter 
"!"
\family default 
) and optionally\SpecialChar ~
(
\family typewriter 
"|"
\family default 
), two addresses of 
\family typewriter 
double
\family default 
 values given to Python through another tuple\SpecialChar ~
(
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

In a similar fashion, the Python API has the 
\family typewriter 
Py_BuildValue
\family default 
, which allows the construction of structured objects, such as tuples, lists
 and dictionaries, in a single call.
 This function is frequently used both in the construction of the argument
 tuple when calling functions and in the construction of return values.
 The syntax of the parameter string resembles that of 
\family typewriter 
PyArg_ParseTuple
\family default 
, but it features a different set of type indicators, and allows to describe
 lists and dictionaries.
 For example, the following call creates a list containing an integer, a
 floating point number and a dictionary containing an element with a string
 key and an integer value:
\layout LyX-Code


\size footnotesize 
PyObject* list = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

This is equivalent to the following Python construct:
\layout LyX-Code


\size footnotesize 
list = [123, 12.30, {"foo": 1234}]
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-dados}

\end_inset 


\layout Standard

For the communication of data between Ruby and C, the Ruby API defines a
 C data type called 
\family typewriter 
VALUE
\family default 
, which represents a Ruby object.
 
\family typewriter 
VALUE
\family default 
 may represent both a reference to an object (that is, a pointer to the
 Ruby heap) as well as an immediate value.
 In particular, the constants 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 and 
\family typewriter 
Qnil
\family default 
 are defined as immediate values, allowing them to be compared in C using
 the 
\family typewriter 
==
\family default 
 operator.
\layout Standard

For type checking, Ruby provides the 
\family typewriter 
Check_Type
\family default 
 and 
\family typewriter 
TYPE
\family default 
 macros.
 
\family typewriter 
Check_Type
\family default 
 allows one to compare the type of values to constants that describe basic
 types of Ruby such as
\family typewriter 
 T_OBJECT
\family default 
 and 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 returns the constant relative to the type of a given value.
 To check the class of an object, one should use 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

When transferring numeric values, the conversion between C and Ruby is made
 through macros such as 
\family typewriter 
INT2NUM
\family default 
 and functions such as 
\family typewriter 
rb_float_new
\family default 
, which receive or return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

For passing strings to Ruby from C, the API provides the 
\family typewriter 
rb_str_new
\family default 
 function, which receives a pointer and a numeric size argument, allowing
 the use of strings containing null characters, and the 
\family typewriter 
rb_str_new2
\family default 
 function, which assumes a standard C string, with the null character as
 a terminator.
 These functions make a copy of the C string to the data space of Ruby.
 
\family typewriter 
VALUE
\family default 
s that point to Ruby strings allow C code to access and modify their contents
 through the 
\family typewriter 
RSTRING(a_string)->ptr
\family default 
 cast.
 However, the API recommends the use of the 
\family typewriter 
StringValue
\family default 
 macro, which returns the 
\family typewriter 
VALUE
\family default 
 itself in case it is a string, or a new 
\family typewriter 
VALUE
\family default 
 of the 
\family typewriter 
String
\family default 
 class produced through the 
\family typewriter 
to_s
\family default 
 conversion method applied to the given object (or raises a 
\family typewriter 
TypeError
\family default 
 exception in case the conversion was not possible).
\layout LyX-Code


\size footnotesize 
void show_value(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* This would make an illegal access if TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Works for any type that accepts obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         otherwise, raises an exception */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Value: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Under the justification of increasing performance on access, some other
 Ruby types such as 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 and 
\family typewriter 
File
\family default 
 allow low-level access to the members of structures used in the implementation
 of their objects.
 For example, with 
\family typewriter 
RARRAY(an_array)->len
\family default 
 one can read the size of an array directly.
 The recommendation of the API is to use this kind of access for reads only,
 since the modification of these values can easily make the internal state
 of objects inconsistent.
\layout Standard

For storing C data in the Ruby object space, the API provides a macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, which receives a C pointer and creates a Ruby object which encapsulates
 this pointer.
 The pointer can be accessed from C code using 
\family typewriter 
Data_Get_Struct
\family default 
, bet not from Ruby.
 A C function to be executed when the object is collected is also passed
 to 
\family typewriter 
Data_Wrap_Struct
\family default 
.
 For example, we will create a 
\family typewriter 
Point
\family default 
 class, similar to the Python type defined in the previous section.
 We will initially define a C type:
\layout LyX-Code


\begin_inset LatexCommand \label{struct-point}

\end_inset 


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Allocation and deallocation functions for the 
\family typewriter 
Point
\family default 
 class (
\family typewriter 
point_alloc
\family default 
 and 
\family typewriter 
point_free
\family default 
) follow:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

 
\newline 

\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* The 2nd argument is the mark function for garbage collection
\layout LyX-Code


\size footnotesize 
\emph on 
      (NULL here as the type doesn't store VALUES), see Sec.
 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

 */
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, NULL, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that 
\family typewriter 
Data_Wrap_Struct
\family default 
 makes use of a 
\family typewriter 
VALUE
\family default 
 that represents the 
\family typewriter 
Point
\family default 
 class in Ruby.
 Classes are created in C with the 
\family typewriter 
rb_define_class
\family default 
 function.
 This function gets a C string with the name of the new class and a VALUE
 to be used as a superclass (such as for example the 
\family typewriter 
rb_cObject
\family default 
 constant, which represents the 
\family typewriter 
Object
\family default 
 Ruby class) and returns a 
\family typewriter 
VALUE
\family default 
 representing the new class.
 For classes such as 
\family typewriter 
Point
\family default 
, whose instances will contain C data, it is possible to register a C function
 that will be responsible for allocating memory of instances using the 
\family typewriter 
rb_define_alloc_func
\family default 
 function.
 So, the creation of the class and the registration of the allocation function
 are done as follows:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Like in Ruby code, the declaration of object attributes is done in the 
\family typewriter 
initialize
\family default 
 method, which can be implemented in C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The method is registered in the class at runtime with the 
\family typewriter 
rb_define_method
\family default 
 function (the registration of C functions in Ruby will be discussed in
 detail in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To ensure that the copy of objects through Ruby's 
\family typewriter 
dup
\family default 
 and 
\family typewriter 
clone
\family default 
 methods will handle correctly the data stored through C, it is necessary
 to register the 
\family typewriter 
initialize_copy
\family default 
 method.
 A possible implementation in C is given below:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby may call this function with the same object in both args;
\layout LyX-Code


\size footnotesize 
\emph on 
      in this case, ignore the call and return the object */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the pointers stored in the objects */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Copy of the 
\begin_inset Quotes eld
\end_inset 

C part
\begin_inset Quotes erd
\end_inset 

 of the object */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Returns the copy */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

We will complete the example with a C function implementing the 
\family typewriter 
distance
\family default 
 method, like it was done in the previous section for Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(p->x*p->x + p->y*p->y)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

These functions are also registered as methods of 
\family typewriter 
Point
\family default 
:
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
rb_class_new_instance
\family default 
 function produces new Ruby objects that are instances of the class, receiving
 a C array of 
\family typewriter 
VALUE
\family default 
s to be passed during object initialization and the class 
\family typewriter 
VALUE
\family default 
.
\layout Standard

Access of Ruby values is done through the 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
 family of functions, which return 
\family typewriter 
VALUE
\family default 
s relative to attributes of objects or classes, global variables and constants.
 For each of those there is an analogous 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 function
\begin_inset Foot
collapsed true

\layout Standard

Constants can be created with the 
\family typewriter 
Qundef
\family default 
 value and have their value defined later 
\emph on 
once
\emph default 
 with 
\family typewriter 
rb_const_set
\family default 
.
\end_inset 

.
 The 
\family typewriter 
rb_iv_get
\family default 
 and 
\family typewriter 
rb_ivar_get
\family default 
 functions, for example, obtain object attributes (
\emph on 
instance variables
\emph default 
).
 The first form uses C strings as names, the latter uses 
\family typewriter 
ID
\family default 
s, identifiers that replace interned strings in Ruby's symbol table, that
 can be obtained using the 
\family typewriter 
rb_intern
\family default 
 function.
 In fact, 
\family typewriter 
ID
\family default 
s correspond to the 
\emph on 
symbol
\emph default 
 Ruby type, which in practice are immutable strings.
 The following example obtains the value of a global variable 
\family typewriter 
g
\family default 
 and sets it to the field 
\family typewriter 
f
\family default 
 of an object, and then sets the value of the global variable to zero:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtains the global variable */
\layout LyX-Code


\size footnotesize 
VALUE g = rb_gv_get("g");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Sets the field f of object obj */
\layout LyX-Code


\size footnotesize 
VALUE obj = rb_gv_get("obj");
\layout LyX-Code


\size footnotesize 
rb_iv_set(obj, "f", g);
\emph on 
 /* Same as: rb_ivar_set(obj, rb_intern("f"), g); */
\layout LyX-Code


\size footnotesize 
\emph on 
/* Zeroes the global variable */
\layout LyX-Code


\size footnotesize 
rb_gv_set("g", INT2NUM(0));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard


\family typewriter 
ID
\family default 
s are never collected: we observed that the symbol table is not cleaned
 up even after 
\family typewriter 
ruby_finalize
\family default 
.
 So, a C application that offers a scripting interface creating supposedly
 isolated environments, surrounding each script execution with 
\family typewriter 
ruby_init
\family default 
 and 
\family typewriter 
ruby_finalize
\family default 
, may have its memory consumption increased indefinitely as scripts create
 symbols.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

The JNI defines in the 
\family typewriter 
jni.h
\family default 
 header C types equivalent to each of Java's primitive types (
\family typewriter 
jint
\family default 
 for 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 for 
\family typewriter 
float
\family default 
, and so on).
 The 
\begin_inset Quotes eld
\end_inset 

reference types
\begin_inset Quotes erd
\end_inset 

, such as classes and objects, are exposed to C as opaque references, instances
 of 
\family typewriter 
jobject
\family default 
.
 Strings and arrays are also objects in Java and are thus exposed as instances
 of 
\family typewriter 
jobject
\family default 
.
 However, the JNI defines as a convenience some C types that act as 
\begin_inset Quotes eld
\end_inset 

subtypes
\begin_inset Quotes erd
\end_inset 

 of jobject: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, and an array type for each primitive type (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 The 
\family typewriter 
jvalue
\family default 
 type is a union of primitive and reference types.
 The 
\family typewriter 
NULL
\family default 
 C value corresponds to Java's 
\family typewriter 
null
\family default 
.
\layout Standard

Different methods are employed for reading primitive types, strings, arrays
 and other objects.
 Reading the contents of a 
\family typewriter 
jstring
\family default 
 in C requires the conversion from the internal format used by Java, UTF-16.
 The API offers a utility function that allocates a string containing the
 representation of the text in UTF-8 (which is an ASCII-compatible format),
 
\family typewriter 
GetStringUTFChars
\family default 
.
 This string must be later deallocated with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
 The 
\family typewriter 
GetStringChars
\family default 
 function provides direct access to the string in UTF-16 format; it has
 an output argument that indicates if the returned string is the JVM's own
 internal buffer or if it is a copy.
 At the same time that this saves the C code from duplicating the string
 in cases when one wants to modify it and the JVM has returned a copy, this
 parameter exposes to the API low-level issues of the JVM string management.
 Alternatively, the 
\family typewriter 
GetStringRegion
\family default 
 and 
\family typewriter 
GetStringUTFRegion
\family default 
 functions perform a copy of the string to a pre-allocated buffer provided
 by the programmer.
 
\family typewriter 
GetStringCritical
\family default 
 returns a pointer to the JVM internal buffer, but this involves special
 care with regard to garbage collection, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays of primitive elements are handled in a similar way to strings, differentl
y from object arrays
\begin_inset Foot
collapsed true

\layout Standard

Multi-dimensional arrays are considered as 
\begin_inset Quotes eld
\end_inset 

arrays of arrays
\begin_inset Quotes erd
\end_inset 

 and, as such, are also object arrays.
\end_inset 

.
 There are functions for performing array copies (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), functions akin to 
\family typewriter 
GetStringChars
\family default 
 that return pointers to the array that may or may not perform copies (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) and functions that can access the JVM internal buffer, like in 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 For object arrays, it is not possible to obtain a pointer to an array's
 internal buffer.
 Access to elements is performed one at a time, through 
\family typewriter 
jobject
\family default 
 references, with 
\family typewriter 
Get
\family default 
/
\family typewriter 
SetObject\SpecialChar \-
ArrayElement
\family default 
.
\layout Standard

The retrieval of values and attributes is done through functions such as
 
\family typewriter 
GetObjectField
\family default 
 and 
\family typewriter 
GetStaticField
\family default 
, which return reference of the 
\family typewriter 
jobject
\family default 
 type.
 For each primitive type there is an equivalent type, such as 
\family typewriter 
GetIntField
\family default 
 and 
\family typewriter 
GetStaticIntField
\family default 
.
 Like in Ruby, the Java API defines a specific C type to avoid the frequent
 use of C strings in the description of fields.
 However, while ruby uses 
\family typewriter 
ID
\family default 
s which are merely interned strings, in Java field identifiers, of the 
\family typewriter 
jfieldID
\family default 
 type, contain type information and are specific for a field of a given
 class.
 These values are obtained with the 
\family typewriter 
GetFieldID
\family default 
 call, which receives among its arguments a string called the 
\begin_inset Quotes eld
\end_inset 

JNI field descriptor
\begin_inset Quotes erd
\end_inset 

 with a special syntax.
 For example, the Java type 
\family typewriter 
int[][]
\family default 
 is described with 
\family typewriter 
"[[I"
\family default 
 and the 
\family typewriter 
java.lang.String
\family default 
 type as 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This is another place where implementation details leak through the API.
 Not coincidently, this syntax is the same used in the internal representation
 of types in JVM bytecodes.
\end_inset 

.
 It is also possible to obtain a 
\family typewriter 
jfieldID
\family default 
 from a 
\family typewriter 
java.lang.reflect.Field
\family default 
 object using the 
\family typewriter 
FromReflectedField
\family default 
 function.
\layout Standard

JNI calls are done in C with 
\family typewriter 
(*J)->
\family default 
\emph on 
function
\family typewriter 
\emph default 
(J,
\family default 
 ...
\family typewriter 
)
\family default 
: JNI functions are accessed through function pointers stored in a table
 pointed by a 
\family typewriter 
JNIEnv
\family default 
 structure, which is then propagated in calls.
 The goal of these two levels of indirection is to decouple the linkage
 of calls in C code from the library that implements the JNI, allowing to
 link the code at runtime to different implementations of the JVM\SpecialChar ~

\begin_inset LatexCommand \cite{stepanian05inliningjava}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExampleJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elements = { "Earth", "Air", "Fire", "Water" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaration of the externally implemented method */
\layout LyX-Code


\size footnotesize 
   private native void secondElement();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Creates an instance and invokes the native method */
\layout LyX-Code


\size footnotesize 
      new ExampleJNI().secondElement();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Loads in the JVM the external code that will implement
\layout LyX-Code


\size footnotesize 
\emph on 
         the secondElement method */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExampleJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Java class containing an externally implemented method
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExampleJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExampleJNI_secondElement(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the class of 'this': ExampleJNI */
\layout LyX-Code


\size footnotesize 
   jclass klass = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get ExemploJNI.elements, a String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, klass,
\layout LyX-Code


\size footnotesize 
      "elements", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the contents of ExemploJNI.elements */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elements[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the representation of elems_1 as a C string */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Show the string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Free the memory of the string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

C code implementing a Java method
\end_inset 


\layout Standard

The access to Java attributes in C code is illustrated through the following
 example.
 Initially, in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, we implement a Java class that has a private attribute, the elements 
\family typewriter 
array
\family default 
, and defines a function, 
\family typewriter 
secondElement
\family default 
, to be implemented in C
\begin_inset Foot
collapsed true

\layout Standard

Details about the declaration and registration of functions implemented
 in C will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

The implementation of 
\family typewriter 
secondElement
\family default 
 is presented in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, showing the sequence of calls needed to obtain in C the element of the
 Java array.
 To access the 
\family typewriter 
elements
\family default 
 attribute, the function has to obtain the field identifier.
 For that, we need first to obtain a reference of the current class with
 
\family typewriter 
GetObjectClass
\family default 
 from the object reference (
\family typewriter 
this
\family default 
) passed a parameter to the function.
 Once we have the class reference (
\family typewriter 
klass
\family default 
), we obtain the field identifier with 
\family typewriter 
GetFieldID
\family default 
.
 The content of the field is then obtained with 
\family typewriter 
GetObjectField
\family default 
: a reference to the array.
 Using it, the element of the array is obtained with 
\family typewriter 
GetObjectArrayElement
\family default 
.
 A copy of the element, converted to a UTF-8-encoded C string, is returned
 with 
\family typewriter 
GetStringUTFChars
\family default 
.
 As previously discussed, after its use, the string must be freed with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

The manipulation of objects of the 
\family typewriter 
Class
\family default 
 type is also done through specific functions.
 It is not possible to create Java classes through the C API, but it is
 possible to load classes at runtime using the 
\family typewriter 
DefineClass
\family default 
 function, which receives a buffer containing the representation of a pre-compil
ed Java class.
 References of the 
\family typewriter 
jclass
\family default 
 type can be obtained from the class name using 
\family typewriter 
FindClass
\family default 
, which uses a syntax for descriptors similar to that used by 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

In both field and class descriptors, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 represents 
\family typewriter 
String[]
\family default 
.
 For the 
\family typewriter 
String
\family default 
 type, however, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 is the field descriptor and 
\family typewriter 
"java/lang/String"
\family default 
 the class descriptor.
\end_inset 

.
\layout Standard

For assigning C values that can be converted to Java primitive types, the
 JNI provides functions such as 
\family typewriter 
SetIntField
\family default 
 and 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 For other types, there are no specific provisions for storing C data in
 the Java object space.
 In those cases, the documentation suggests the storage of pointers in numeric
 types\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

, in spite of the portability limitations brought by this approach.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

The Lua API defines a different approach for manipulating data in C: no
 pointers or handles to Lua objects are ever exposed to C code.
 Operations are defined in terms of indices of a virtual stack.
 So, data transfer from C to Lua takes place through functions that receive
 C types, convert them to Lua values and stack them, such as 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 and 
\family typewriter 
lua_pushlstring
\family default 
.
 Several operations of the API operate on the value at the top of the stack,
 such as, for example, 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

API functions that operate on a Lua execution state receive an initial argument
 (in our examples, called 
\family typewriter 
L
\family default 
), indicating the state they refer to.
 This will be discussed later, in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Inserts the number 123 in the stack */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Sets the number 123 to global 
\emph default 
foo
\emph on 
 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Most lookup functions, however, allow one to specific any stack index (with
 positive values for indexing from the bottom and negative values for indexing
 from the top).
\layout Standard

Conversion of data from Lua to C is made through functions such as 
\family typewriter 
lua_tonumber
\family default 
 and 
\family typewriter 
lua_tolstring
\family default 
, which receive a stack index, convert the value at the given index to the
 specified Lua type if necessary, and return the value converted to the
 equivalent C type.
 Numbers have the 
\family typewriter 
lua_Number
\family default 
 C type, which corresponds to 
\family typewriter 
double
\family default 
 by default but is a compile-time parameter for the Lua virtual machine.
 Strings, in particular, are immutable objects and are interned: any two
 identical strings share the same internal representation.
\layout Standard

So, unlike languages such as Python and Ruby, it is not possible to modify
 the contents of a Lua string from C through its memory representation as
 a 
\family typewriter 
char*
\family default 
.
 To make the incremental construction of Lua strings from C more efficient,
 the Lua auxiliary library defines a C type called 
\family typewriter 
luaL_Buffer
\family default 
 and functions such as 
\family typewriter 
luaL_addstring
\family default 
 and 
\family typewriter 
luaL_addvalue
\family default 
, which allow the construction of a string in stages until it can be finally
 converted to a Lua string with 
\family typewriter 
luaL_pushresult
\family default 
.
 This way, one avoids consecutive string concatenation operations through
 the Lua API.
\layout Standard

Lua defines two specific data types for storing C data, 
\emph on 
full userdata
\emph default 
 and 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 describe memory blocks managed by Lua and used by C code.
 They exist in Lua as opaque objects, and are created by 
\family typewriter 
lua_newuserdata
\family default 
, which inserts the new object in the Lua stack and returns to C a pointer
 to the memory area of the requested size.
 Objects of the 
\emph on 
light userdata
\emph default 
 type, created through 
\family typewriter 
lua_pushlightuserdata
\family default 
, allow storing C pointers in Lua; allocation and management of the memory
 block are to be handled by C code.
 The following example illustrates the use of userdata, assuming the same
 
\family typewriter 
point
\family default 
 struct defined on page\SpecialChar ~

\begin_inset LatexCommand \pageref{struct-point}

\end_inset 

.
 The userdata object is created this way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a full userdata, inserts it in the stack and returns
\layout LyX-Code


\size footnotesize 
\emph on 
   the pointer to C.
 The memory is allocated by Lua */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* We then use the pointer in C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the object to the global variable 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard

Now, accessing it:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Pushes the global 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the C pointer from the userdata at the top of the stack (-1) */
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d)
\backslash 
n", p->x, p->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restores the stack to its original position, removing the item.
\layout LyX-Code


\size footnotesize 
\emph on 
   It won't be collected, as it is tied to the global variable */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assuming that the global 
\family typewriter 
Point
\family default 
 is the only reference to this block, to free it all we have to do is overwrite
 
\family typewriter 
Point
\family default 
 with, for example, 
\family typewriter 
nil
\family default 
; the memory of the full userdata will then be eligible for retrieval by
 the garbage collector, like that of any Lua value with no references.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The stack storage area does not adjust itself dynamically and the API functions
 do not perform overflow checks.
 So, the programmer is responsible for controlling the stack size, through
 the 
\family typewriter 
lua_checkstack
\family default 
 function.
 In practice, the stack size will only grow in loops pushing elements, since
 typical sequences of operations tend to push values and pop them later.
\layout Standard

Tables are the only type available for construction of data structures in
 Lua.
 Lua offers a complete API for manipulation of tables from C.
 Tables can be created with 
\family typewriter 
lua_newtable
\family default 
 or 
\family typewriter 
lua_createtable
\family default 
; the second form allows one to pre-allocate memory for table elements.
 The 
\family typewriter 
lua_gettable
\family default 
 and 
\family typewriter 
lua_settable
\family default 
 implement the semantics of reading and writing fields to a Lua table, including
 eventual calls to metamethods; for calls without metamethod invocation
 there are 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, which are equivalent to 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 in Lua (besides two convenience variants, 
\family typewriter 
lua_rawgeti
\family default 
 and 
\family typewriter 
lua_rawseti
\family default 
).
 There is also the 
\family typewriter 
lua_next
\family default 
 function, equivalent to the Lua function 
\family typewriter 
next
\family default 
, which is designed for traversing elements of a table.
 An example of table manipulation is given below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tbl["key"] = 12345, in C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tbl");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "key");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable inserts the item at the top of the stack
\layout LyX-Code


\size footnotesize 
\emph on 
   to the table given as a parameter,
\layout LyX-Code


\size footnotesize 
\emph on 
   using as a key the item right below the top: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Many Lua concepts are represented through tables -- the global environment,
 metatables, registry -- are are thus handled in C using the API functions
 for table manipulation.
 The global environment table of the currently executing thread can be accessed
 through a special index of the virtual stack, 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 One can also define a function environment table, indexed with 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, to isolate data to be shared internally by functions in modules written
 in C.
 For example, the global environment can be manipulated as a table this
 way:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "Point");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Standard

This is equivalent to:
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

The procedures for extending and embedding Perl are very different from
 each other.
 For extensions, Perl provides an interface description language called
 XS.
 Instead of isolating the access to Perl's internal structures through a
 public API, the proposed approach is to encapsulate the process of generating
 wrapper code for the communication of functions written in C to the internal
 structures of Perl using interfaces written in XS.
 Files of the 
\family typewriter 
.xs
\family default 
 type contain C code along with annotation that simplifies the handling
 of input and output parameters.
 These are fed to the 
\family typewriter 
xsubpp
\family default 
 pre-processor, which generate then code using the API provided by the Perl
 library.
 This library offers low-level access to the inner workings of the interpreter,
 allowing one, for example, to manipulate its internal stack pointer.
 The goal of XS is to hide these details from the extension developer.
\layout Standard

To embed the Perl interpreter to an application, the library that implements
 it offers some functions that allow one to launch an interpreter.
 In the higher-level API, one can build an array of arguments to be passed
 to the interpreter in the same way as options are given to the Perl command-lin
e interpreter, even using the 
\family typewriter 
"-e"
\family default 
 flag to execute pieces of code.
\layout Standard

The types of Perl variables are mapped to C structs: 
\family typewriter 
SV
\family default 
 for scalars, 
\family typewriter 
AV
\family default 
 for arrays, 
\family typewriter 
HV
\family default 
 for hashes.
 These C values are better understood as 
\emph on 
containers
\emph default 
 to Perl values: a scalar variable in Perl has an 
\family typewriter 
SV
\family default 
 associated to itself; however, one can create in C an 
\family typewriter 
SV
\family default 
 that is not associated to any Perl variable name.
\layout Standard

Primitive types of Perl are represented as C values through typedefs: 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 and 
\family typewriter 
PV
\family default 
 correspond, respectively, to signed and unsigned integers, floating-point
 values and strings.
 These values can be copied to 
\family typewriter 
SV
\family default 
s.
 Perl references are represented as 
\family typewriter 
RV
\family default 
, and are also a kind of 
\family typewriter 
SV
\family default 
.
 There is also the 
\family typewriter 
GV
\family default 
 type, which represents any type representable through a Perl variable.
\layout Standard

Variables from the Perl data space are accessed with 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 and 
\family typewriter 
get_hv
\family default 
.
 These functions receive a C string with the variable name (possibly qualified
 through the 
\family typewriter 
"package::variable"
\family default 
 syntax).
 The content of scalar values are converted back to C ytpes with the 
\family typewriter 
Sv
\family default 
* macros: 
\family typewriter 
SvIV
\family default 
 returns an integer, 
\family typewriter 
SvPV
\family default 
 returns a 
\family typewriter 
char*
\family default 
 and the string length in the second argument, etc.
 The following C code prints the contents of the Perl variable 
\family typewriter 
$a
\family default 
, assuming it contains an integer value:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The flag given as a second argument for 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 indicates whether the variable should be created if the given name does
 not correspond to an existing varible.
 Passing an unexisting name and using 
\family typewriter 
TRUE
\family default 
 as the second argument is a convenient way to create a new variable accessible
 from the C space and at the same making its binding in the Perl space.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a variable of the array type,
\layout LyX-Code


\size footnotesize 
\emph on 
   accessible in Perl as the global @arr and in C as the AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

An 
\family typewriter 
SV
\family default 
 can be created in C with the 
\family typewriter 
newSV
\family default 
* family of functions: 
\family typewriter 
newSViv
\family default 
 generates a new SV storing a signed integer; 
\family typewriter 
newSVpv
\family default 
 stores a string, and so on.
 The 
\family typewriter 
newSV
\family default 
 function creates a 
\family typewriter 
SV
\family default 
 with an uninitialized memory area, accessible through the 
\family typewriter 
SvPVX
\family default 
 function, providing a way to create scalars with arbitrary values generated
 by C code.
 Using the same example of the 
\family typewriter 
point
\family default 
 struct from previous sections, we can store a C object in a Perl value
 in the following way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Allocates an unitialized SV, the size of a 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the pointer to the SV's memory area */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipulates the 
\emph default 
point
\emph on 
 in C.
 When v is returned to Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
it will be an opaque variable (its contents won't be accessible) */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Values are assigned to 
\family typewriter 
SV
\family default 
s using the 
\family typewriter 
sv_set
\family default 
* family of functions: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 Functions for string handling have variants such as 
\family typewriter 
newSVpvn
\family default 
 and 
\family typewriter 
sv_setpvf
\family default 
, which receive the string length or perform 
\family typewriter 
sprintf
\family default 
-style formatting.
 For strings, there are also the 
\family typewriter 
sv_cat
\family default 
* functions, which act like 
\family typewriter 
sv_set
\family default 
* but concatenate the value given to the current content of the string instead
 of replacing it.
 The 
\family typewriter 
sv_setsv
\family default 
 function copies the value of an 
\family typewriter 
SV
\family default 
 to another.
 The 
\family typewriter 
SV
\family default 
 created in the previous example can be assigned to a global variable like
 this:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the SV from the global 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* pnt = get_sv("point", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the value of 
\emph default 
v
\emph on 
 to 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
sv_setsv(pnt, v);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The type of data stored in 
\family typewriter 
SV
\family default 
s is checked with the 
\family typewriter 
SvIOK
\family default 
 macro for integers, 
\family typewriter 
SvNOK
\family default 
 for floating-point values, and 
\family typewriter 
SvPOK
\family default 
 for strings.
 These functions return success if the scalar is convertible to the specified
 type -- the variants 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verify if the value stored in the 
\family typewriter 
SV
\family default 
 is actually of that type.
\layout Standard

Arrays and hashes are created with 
\family typewriter 
newAV
\family default 
 and 
\family typewriter 
newHV
\family default 
.
 Arrays can be populated with a C array of 
\family typewriter 
SV
\family default 
 pointers through 
\family typewriter 
av_make
\family default 
.
 Operations such as 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 and 
\family typewriter 
hv_exists
\family default 
 operate on elements of these structures.
 In 
\family typewriter 
av_fetch
\family default 
 and 
\family typewriter 
hv_fetch
\family default 
, the return type is 
\family typewriter 
SV**
\family default 
, to differentiate between returning an existing element which points to
 
\family typewriter 
NULL
\family default 
 from returning 
\begin_inset Quotes eld
\end_inset 

element not found
\begin_inset Quotes erd
\end_inset 

.
 In the following example, we create a Perl array containing the 10 first
 elements of the Fibonacci series:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Create a new array */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Store two values, 0 and 1, at its first positions */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviously, it would be more efficient to store these values in
\layout LyX-Code


\size footnotesize 
\emph on 
      temporary values in C, but we'll obtain the last two values
\layout LyX-Code


\size footnotesize 
\emph on 
      back from the Perl array for illustration purposes: */
\layout LyX-Code


\size footnotesize 
   SV** next_to_last_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** last_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the integers stored in those SVs */
\layout LyX-Code


\size footnotesize 
   int next_to_last = SvIV(*next_to_last_sv);
\layout LyX-Code


\size footnotesize 
   int last = SvIV(*last_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Create a new SV and insert it in the end of the array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( next_to_last + last ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once this 
\family typewriter 
AV
\family default 
 is created, however, there is no way to associate it to a Perl variable.
 Its contents must be copied item by item.
 To make it accessible from Perl, we should have created it with 
\family typewriter 
get_av
\family default 
, and not 
\family typewriter 
newAV
\family default 
.
 
\family typewriter 
AV
\family default 
s that are not associated to variables are useful, however, when passing
 arguments in function calls and as return values.
\layout Standard

Some functions for hash manipulation expose the key/value pairs as 
\family typewriter 
HE
\family default 
 pointers.
 The 
\family typewriter 
HeSVKEY
\family default 
 and 
\family typewriter 
HeVAL
\family default 
 macros extract the key and value from an 
\family typewriter 
HE
\family default 
.
 The following C function prints the elements of a Perl hash:
\layout LyX-Code


\size footnotesize 
void print_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Each HV keeps its own internal iteration control */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the next key/value pair in the iteration */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Get the string representation of scalars
\layout LyX-Code


\size footnotesize 
\emph on 
         representing key and value of the item */
\layout LyX-Code


\size footnotesize 
      char* key = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* value = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", key, value);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Special care should be taken when using the values 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 and 
\family typewriter 
false
\family default 
 in arrays and hashes, even though Perl exposes these constants in its C
 API (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 The constant 
\family typewriter 
PL_sv_undef
\family default 
 is used internally in the implementation of 
\family typewriter 
AV
\family default 
s and 
\family typewriter 
HV
\family default 
s, and the update of values in 
\family typewriter 
HV
\family default 
s happens in-place, which generates problems when updating elements containing
 these constants.
 The documentation recommends generating copies of these values when using
 them in 
\family typewriter 
AV
\family default 
 and 
\family typewriter 
HV
\family default 
 structures\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlguts}

\end_inset 

.
\layout Standard

Perl references are created with 
\family typewriter 
newRV_inc
\family default 
 and 
\family typewriter 
newRV_noinc
\family default 
, which receive an 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 pointer as a parameter (these two functions differ in how they handle reference
 counted, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 The value pointed by a reference is obtained with 
\family typewriter 
SvRV
\family default 
.
 The return value of this macro must be converted through a cast to the
 appropriate type (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), which can be checked with 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Many functions of the API have argument or return types declared as 
\family typewriter 
SV
\family default 
 when in fact they accept 
\family typewriter 
AV
\family default 
s or 
\family typewriter 
HV
\family default 
s; this is analogous to the concept of Perl 
\emph on 
contexts
\emph default 
, in which the same value can be treated as a list (array or hash) or scalar
 depending on the expression where it is inserted\SpecialChar ~

\begin_inset LatexCommand \cite{marquess06perlcall}

\end_inset 

.
 In Perl code, the context where a function is executed can be inspected
 with 
\family typewriter 
wantarray
\family default 
.
 In C, the context can be checked with the 
\family typewriter 
GIMME_V
\family default 
 macro, which returns 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 or 
\family typewriter 
G_ARRAY
\family default 
.
\layout Subsection

Comparison
\layout Standard

The basic set of functions for manipulating data in the five languages presented
 here is similar: all of them provide functions for converting values from
 the language to basic C types and vice versa.
 All of them also offer functions for manipulating their fundamental structured
 types (tables in Lua, arrays in Java, arrays and hashes in Ruby and Perl,
 lists and dictionaries in Python).
 Python, in particular, defines an extensive function API for operations
 on its built-in classes; most of these functions could be performed using
 the generic API for method invocation, but they are offered directly in
 C as a convenience.
\layout Standard

Lua stands out for having, with its stack model, the simplest and most orthogona
l data manipulation API among the ones studied.
 However, the resulting code often loses in readability when the stack indices
 are not obvious.
 It is commonplace to see C code using the Lua API commented line by line,
 to save the programmer from having to simulate mentally the stack operations
 while reading the program.
\layout Standard

In Java, static typing reduces greatly the need of explicit data conversion
 in C code.
 On the other hand, treatment of multi-threading complicates the access
 of types such as strings and arrays.
\layout Standard

A negative point in the Ruby API is the exposure of implementation details
 of the struct fields that describe its fundamental 
\family typewriter 
VALUE
\family default 
 type.
 This restricts the flexibility of the language implementation and fosters
 unsafe programming practices.
 Perl also exposes a good deal of its internal structures; not as directly
 as Ruby, but through macros.
 These macros, however, assume the adherence to usage protocols so strict
 that in practice they also largely limit the possibilities of changes in
 the implementation (an example of this is the sequence for function calls,
 which will be presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

).
\layout Standard

The creation of data containing C structures stored by the scripting language
 is an easy task in Perl, Ruby and Lua: Perl allows one to create 
\family typewriter 
SV
\family default 
s containing arbitrary memory blocks for use in C; Ruby offers the 
\family typewriter 
Data_Wrap_Struct
\family default 
 macro which generates a Ruby object which encapsulates a C structure; Lua
 defines a basic type in the language especially for this end.
 In Python, on its turn, the process is not as straightforward.
 Creating a Python class from C involves declaring parts of it statically
 and other parts dynamically, being usually necessary to define three different
 C structures.
 In Java, it is not possible to create new types from C, one can only load
 classes.
\layout Standard

Another common task when interacting with C is the need to store pointers
 in the data space of the scripting language.
 Python, Lua and Perl offer features to do this directly: creating a 
\family typewriter 
PyCObject
\family default 
 in Python; a light userdata in Lua; or storing a pointer in the data area
 of an 
\family typewriter 
SV
\family default 
 in Perl.
 In Java and Ruby, the alternative is to convert pointers and store them
 as numbers.
 In fact, this happens internally in the implementation of Ruby, and the
 portability limitations of this approach are made evident by the fact that
 the compilation of Ruby fails if 
\family typewriter 
sizeof(void*) != sizeof(long)
\family default 
.
\layout Standard

Finally, an aspect that deserves being mentioned is the concern on not polluting
 the C namespace.
 Python, Java and Lua define all its functions and C types with prefixes
 that aim to avoid conflicts with names defined by the application.
 Perl and Ruby define names in a disorganized fashin, which occasionally
 causes problems
\begin_inset Foot
collapsed true

\layout Standard

For example, conflicts of this kind happened in the Ruby bindings of the
 Subversion revision control system in Win32 platforms (
\begin_inset LatexCommand \url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}

\end_inset 

).
\end_inset 

.
 Perl has options to disable a series of macros and force a common prefix
 in its functions, but this feature is incomplete and using it hampers the
 functionality of its headers
\begin_inset Foot
collapsed true

\layout Standard

In the case study presented in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

, when using the Perl API we tried to restrict ourselves to the 
\family typewriter 
Perl_
\family default 
-prefixed versions of the API functions, but many necessary macros are only
 available in versions with no prefix.
\end_inset 

.
\layout Section

Garbage collection
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

From the moment when C code gains access to references to data stored in
 the storage space of another language, be them pointers or identifiers,
 the programmer must take into consideration the differences between the
 memory management models involved, since code executed in the other language
 may free the data.
 For example, the C program may deallocate an object referenced by data
 in the scripting language, or the scripting language may remove an element
 from a structure causing it to be collected.
 In principle, this task of maintaining consistency between these two environmen
ts is no different from manual memory management normally taken care by
 C programmers.
 However, the interaction with some languages adds an important factor of
 complexity: the garbage collection mechanisms perform deallocation of data
 from memory in an implicity manner.
 The fundamental principle of garbage collection dictates that an object
 is not collected in case there is some element (variable, data structure)
 pointing to it.
 However, the same is not valid for the C environment: the presence of a
 pointer pointing to an object does not guarantee that it will not be collected,
 given that the garbage collector does not manage pointers from C code.
\layout Standard

It is necessary, then, to indicate from C code that the data remain accessible
 from it and must not be collected.
 In a complementary way, when transferring the control of C objects to the
 domain of the other language -- for example, when storing them in a data
 structure of the other language -- it is necessary to indicate to the language
 how to deallocate the memory of the structure when the garbage collector
 detects that it is no longer in use.
 The way how the API will provide these functionalities depends not only
 of the design of the C API, but also of the garbage collection mode employed
 by the implementation of the language.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

The Python virtual machine features a garbage collector based on reference
 counting.
 As the Python API returns to C code pointers to 
\family typewriter 
PyObject
\family default 
s, the programmer must have the care of ensuring that they will remain valid.
 For such, it is necessary to increment and decrement the pointed object's
 reference count according to how one wants to control the validity of the
 pointers in C code.
\layout Standard

In general, once the C code needs to retain a 
\family typewriter 
PyObject*
\family default 
, it should use the 
\family typewriter 
Py_INCREF
\family default 
 macro to increment its reference count and so prevent it from being collected.
 Once the value is no longer needed, the reference count should be accordingly
 decremented with 
\family typewriter 
Py_DECREF
\family default 
.
 Python works with the concept of 
\emph on 

\begin_inset Quotes eld
\end_inset 

reference ownership
\begin_inset Quotes erd
\end_inset 


\emph default 
 to define when the programmer needs to increment or decrement the counter
 of references returned by API functions.
 Most API functions that return pointers to 
\family typewriter 
PyObject
\family default 
s transfer references to the caller; the reference becomes the caller's
 responsibility -- it can either pass it on or it will have to decrement
 it with 
\family typewriter 
Py_DECREF
\family default 
 when it is not needed anymore (C code can store owned references in its
 data structures; they will remain valid even after the return of the function,
 until they are explicitly decremented).
 Other functions 
\emph on 
lend
\emph default 
 references; the code that borrows the reference does not need to decrement
 it after using it, but the validity of the object is attached to the validity
 of the reference in the object that returned it to C.
 For example, 
\family typewriter 
PyList_GetItem
\family default 
 lends a reference to an element of the list.
 The pointer returned will remain valid while the the item remains stored
 in the list.
 It is possible to obtain 
\begin_inset Quotes eld
\end_inset 

ownership
\begin_inset Quotes erd
\end_inset 

 of a borrowed reference by incrementing the object count with 
\family typewriter 
Py_INCREF
\family default 
: the validity of the pointer becomes independent from the container object
 that returned it, but the C code becomes responsible for decrementing the
 reference later with 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

For object references passed from C back to Python, there are two cases
 in the API where functions 
\emph on 

\begin_inset Quotes eld
\end_inset 

steal
\begin_inset Quotes erd
\end_inset 


\emph default 
 references, that is, in which the reference no longer belongs to the calling
 C function: 
\family typewriter 
PyList_SetItem
\family default 
 and 
\family typewriter 
PyTuple_SetItem
\family default 
.
 The given reference, which belonged to the caller, becomes owned by the
 list or tuple.
 In the context of the caller, it is now a borrowed reference, which does
 not have to be decremented anymore.
 The point of this is to allow nested function calls where, for example,
 the argument for 
\family typewriter 
PyList_SetItem
\family default 
 is a call that generates a new object to be stored in the list.
 So, this avoids having to store a pointer to the object only to decrement
 its reference later.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Possibly invalid access in 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 is definitely valid in 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Possibly invalid access in a reference to a 
\family typewriter 
PyObject
\family default 
 in C code
\end_inset 


\layout Standard

The interaction with the reference counter can be very subtle.
 The example in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extracted from the Python documentation, demonstrates that a reference
 can be invalidated by apparently unrelated code
\begin_inset Foot
collapsed true

\layout Standard

In fact, the documentation informs that older versions of Python contained
 variants of this bug in some of its modules.
\end_inset 

.
 At first sight, the insertion of an element in 
\family typewriter 
list[1]
\family default 
 seems not to affect the 
\family typewriter 
item
\family default 
 reference, which corresponds to 
\family typewriter 
list[0]
\family default 
.
 However, the insertion of 
\family typewriter 
list[1]
\family default 
 may have removed from the list an element that was in this position.
 In case the list was the last valid reference to the element, it might
 be collected.
 The collection of the object can invoke its finalizer method 
\family typewriter 
__del__
\family default 
, that can run arbitrary Python code.
 If this code removes the element from position 0 of 
\family typewriter 
list
\family default 
 and this triggers its collection, 
\family typewriter 
item
\family default 
 becomes invalid, because 
\family typewriter 
PyList_GetItem
\family default 
 returns a borrowed reference.
\layout Standard

When implementing C functions that return references to 
\family typewriter 
PyObject
\family default 
s, the same care of defining the lifetime policy of the reference should
 be taken.
 To return a new reference to be owned by the caller, it may be necessary
 to increment the object's count.
 This manifests itself, for example, in the correct way for a C function
 to return the value None, which involves calling 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This pattern is so common that the sequence 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 was encapsulated in the 
\family typewriter 
Py_RETURN_NONE
\family default 
 macro.
\end_inset 

.
 Even Python objects representing numbers need to have their reference count
 controlled by the C programmer.
\layout Standard

It is possible to define a deallocation function in the 
\family typewriter 
tp_dealloc
\family default 
 field of the 
\family typewriter 
PyTypeObject
\family default 
 structure so that C code can perform finalization operations over data
 stored in a Python type defined in C.
 This function is normally responsible for freeing resources allocated through
 C code (open files, pointers to memory areas unaccessible from Python,
 etc.) and decrementing references to other Python objects maintained by
 the object.
\layout Standard

When deallocating data structures such as lists it is possible to trigger
 an arbitrarily large chain of deallocations, as each element causes the
 deallocation of the next element of the structure.
 This launches the deallocation function recursively and could easily cause
 a stack overflow in C.
 To work around this problem, Python includes a pair of macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 and 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, that control the accepted number of recursion levels.
 At each execution of 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 an internal counter is incremented.
 While this counter does not reach the limit value defined in the 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 constant (50 by default), the function runs normally.
 When the limit is reached, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 stores the object in an internal list and jumps straight to 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, avoiding the deallocation the object and another recursion.
 At the end of each level of the recursion, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 decrements the counter.
 When the counter reaches zero, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 launches again 
\family typewriter 
tp_dealloc
\family default 
 on the elements stored in the internal list, restarting then the recursion
 on the structure.
 So, a chain of 
\begin_inset Formula $n$
\end_inset 

 deallocations is broken into 
\begin_inset Formula $n/$
\end_inset 


\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 chains, none of them exceeding 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 levels of recursion in the C stack.
 The implementation of the main structured types of Python, such as lists,
 tuples and dictionaries, make use of this mechanism.
\layout Standard

Garbage collection using reference counts brings with it concerns about
 circular references: a chain of objects maintaining references to each
 other keeps the count of each of its elements greater than zero, even if
 they are not reachable from any other object.
 Python includes a cycle detector, but special measures must be taken to
 ensure that types implemented in C behave correctly if they can generate
 cycles.
 One must implement a function to traverse references contained in the object
 and a function to decrement their reference counts.
 These functions must be registered in the 
\family typewriter 
tp_traverse
\family default 
 and 
\family typewriter 
tp_clear
\family default 
 fields of the 
\family typewriter 
PyTypeObject
\family default 
 structure.
 The 
\family typewriter 
tp_clear
\family default 
 function has to take the precaution of clearing the value of its 
\family typewriter 
PyObject*
\family default 
 fields to 
\family typewriter 
NULL
\family default 
 before decrementing each reference, since the decrement operation may start
 the deallocation of the object and launch a call to 
\family typewriter 
tp_traverse
\family default 
 which, due to the cycle, may return to the previous object.
 The type must be, then, identified with the 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 flage in the 
\family typewriter 
tp_flags
\family default 
 field of 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard

Besides, the implementation of Python objects that support cyclic collection
 in C implies in yet more care.
 Objects must be allocated with 
\family typewriter 
PyObject_GC_New
\family default 
 or 
\family typewriter 
PyObject_\SpecialChar \-
GC_NewVar
\family default 
 instead of the usual functions 
\family typewriter 
PyObject_New
\family default 
 and 
\family typewriter 
PyObject_NewVar
\family default 
.
 During the construction of the object, after the fields to be visited by
 
\family typewriter 
tp_traverse
\family default 
 are filled, it is still necessary to call a notification function, 
\family typewriter 
PyObject_GC_Track
\family default 
, and during deallocation, before invalidating the object's fields, to call
\family typewriter 
 PyObject_GC_UnTrack
\family default 
.
 For objects that need the 
\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 

 mechanism to avoid stack overflow, it is also necessary to take the precaution
 of unmarking the object with 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 before entering the 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
 block.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\end_inset 


\layout Standard

In spite of offering a cycle detection mechanism, Python is unable to collect
 cycles whose objects contain finalizers implemented in Python itself (
\family typewriter 
__del__
\family default 
 methods); the only way to access those objects is then through the 
\family typewriter 
garbage
\family default 
 list in the 
\family typewriter 
gc
\family default 
 module.
 This module (accessible to C through Python function calls using the C
 API) offers an interface to the garbage collector, including 
\family typewriter 
enable
\family default 
 and 
\family typewriter 
disable
\family default 
 functions, to activate and deactivate the garbage collector; 
\family typewriter 
collect
\family default 
, to run a collection; 
\family typewriter 
get_objects
\family default 
, which returns a list containing all objects controlled by the collector
 (except the list itself); 
\family typewriter 
get_referrers
\family default 
 and 
\family typewriter 
get_referents
\family default 
, which return the list of object that refer or are referred by a given
 object -- these lists are obtained using the 
\family typewriter 
tp_traverse
\family default 
 function, which may not point to all objects actually reachable, or may
 still return objects in an invalid state (such as objects in cycles that
 were not yet collected or objects still not fully constructed) and therefore
 should be used only for debugging purposes.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby uses a mark-and-sweep garbage collector\SpecialChar ~

\begin_inset LatexCommand \cite{wilson92gc}

\end_inset 

.
 This technique avoids the problem of cyclic references faced by Python;
 having valid objects correctly indicated as reachable is sufficient.
\layout Standard

Objects that are reachable from the Ruby data space -- assigned to a Ruby
 global variable or inserted in some data structure reachable in Ruby --
 will not be subjected to garbage collection.
 In addition, we have objects returned by Ruby to the C space, since many
 API functions return 
\family typewriter 
VALUE
\family default 
s.
 The documentation warns that, to store Ruby objects in C, either in global
 variables or in data structures, it is necessary to notify the virtual
 machine that the 
\family typewriter 
VALUE
\family default 
 must not be collected using the 
\family typewriter 
rb_global_variable
\family default 
 function\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 (although not mentioned in the documentation, it is possible to unmark
 a global value with 
\family typewriter 
rb_gc_unregister_address
\family default 
).
\layout Standard

Objects in the local scope of a C function, however, do not need to be notified.
 The way how Ruby ensures the validity of local 
\family typewriter 
VALUE
\family default 
s is remarkably peculiar: when performing the mark phase, the garbage collector
 scans the C stack looking for values that look like 
\family typewriter 
VALUE
\family default 
 addresses, that is, numeric sequences that correspond to valid 
\family typewriter 
VALUE
\family default 
 addresses.
 These addresses can be identified because objects are always allocated
 within heaps maintained by the Ruby interpreter.
 Each 
\family typewriter 
VALUE
\family default 
 found in the stack is then marked.
 This ensures that any 
\family typewriter 
VALUE
\family default 
 locally accessible by C code becomes invalidated, but may generate 
\begin_inset Quotes eld
\end_inset 

false positives
\begin_inset Quotes erd
\end_inset 

 stopping data that could be collected from being so.
\layout Standard

In spite of programmer convenience, such approach is extremely non-portable.
 The implementation of the garbage collector in Ruby 1.8.2 has 
\family typewriter 
#ifdef
\family default 
s for IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC and Motorola 68000.
 Besides, the collector forces the discharge of registers to the stack using
 
\family typewriter 
setjmp
\family default 
, to prevent variables of the 
\family typewriter 
VALUE
\family default 
 type that may have been optimized into registers by the compiler from being
 missed.
\layout Standard

As we have seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-dados}

\end_inset 

, Ruby objects created with 
\family typewriter 
Data_Wrap_Struct
\family default 
 contain C structs, and those may contain references to Ruby 
\family typewriter 
VALUE
\family default 
s.
 The encapsulated struct, however, is opaque to the Ruby universe.
 So, to ensure that these 
\family typewriter 
VALUE
\family default 
s are marked as reachable during garbage collection this has to be done
 through C code.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 accepts, beside the struct to be wrapped, pointers to a mark function and
 to a deallocation function.
 When the garbage collector visits the object in the mark phase, it invokes
 the registered function, which must call 
\family typewriter 
rb_gc_mark
\family default 
 on each 
\family typewriter 
VALUE
\family default 
 stored in the object's struct, informing thus that these objects are reachable.
 When an object wrapped with 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 is considered unreachable, its deallocation function is called.
 On structures that do not store other 
\family typewriter 
VALUE
\family default 
s, the mark function can be set to 
\family typewriter 
NULL
\family default 
 and the deallocation function to 
\family typewriter 
free
\family default 
.
\layout Standard

Ruby has a 
\family typewriter 
GC
\family default 
 module featuring functions to turn the collector on and off (
\family typewriter 
GC.enable
\family default 
 and 
\family typewriter 
GC.disable
\family default 
), as well as to launch a collection immediately (
\family typewriter 
GC.start
\family default 
).
 There are equivalent functions in the C API: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 The C API includes also a function that inserts an object immediately in
 the list of objects to be recycled by Ruby's memory allocator, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 This function should be used with caution, since if there are still any
 references pointing to the recycled object, they will point to the new
 object when the memory area is reclaimed by the Ruby allocator.
\layout Standard

Ruby also offers as a convenience to the C programmer some wrappers to the
 malloc and realloc functions that interact with the garbage collector,
 forcing its execution during large allocations
\begin_inset Foot
collapsed false

\layout Standard

The definition of 
\begin_inset Quotes eld
\end_inset 

large
\begin_inset Quotes erd
\end_inset 

 is adjusted dynamically, based on the execution of the collector and previously
 performed allocations.
\end_inset 

 or in low-memory situations.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Like in Python and Ruby, the Java API returns references to objects from
 the virtual machine that can be stored in C variables.
 The JNI defines three types of references, 
\emph on 
local
\emph default 
, 
\emph on 
global
\emph default 
 and 
\emph on 
weak global
\emph default 
 references, to aid in controlling their lifetime and their interaction
 with the garbage collector.
\layout Standard

Most functions of the JNI return local references, which are valid until
 the return of the C function that has obtained them.
 It is not necessary to deallocate a local reference explicitly: during
 the execution of a C function, the JVM maintains a list of local references
 passed to the function and frees them all when control returns to the virtual
 machine.
 This way, in general, the programmer does not need to worry about garbage
 collection when manipulating values returned during a function.
 On the other hand, in code that may use a large number of local references
 it is more efficient to free local references explicitly, using 
\family typewriter 
DeleteLocalRef
\family default 
.
 In Java version 1.2, functions were added to manage local references in
 blocks.
 
\family typewriter 
PushLocalFrame
\family default 
 and 
\family typewriter 
PopLocalFrame
\family default 
 allow one to create nested scopes of local references, which are freed
 all at once.
 
\family typewriter 
PushLocalFrame
\family default 
 receives also an argument indicating a number of slots to be pre-allocated,
 as an optimization.
 This value can also be configured with 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Global references are generated from local references using 
\family typewriter 
NewGlobalRef
\family default 
.
 References of this kind remain valid until they are explicitly deallocated
 with 
\family typewriter 
DeleteGlobalRef
\family default 
.
 A global reference stops the object from being collected; it can therefore
 be used to store Java objects in C space beyond the duration of a function,
 for example, in global or static variables.
\layout Standard

Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 shows an example of the kind of reference management that is needed when
 a loop creates temporary references for an arbitrary number of objects.
\layout Standard

In the example, the 
\family typewriter 
Java_Example_concatArray
\family default 
 function (equivalent, therefore, to the 
\family typewriter 
concatArray
\family default 
 method from class 
\family typewriter 
Example
\family default 
) converts the elements of an array to strings using 
\family typewriter 
Object.toString
\family default 
 and concatenates them using 
\family typewriter 
String.concat
\family default 
.
 Notice that, as the number of iterations of the loop depends on the size
 of the given array, one should prevent the number of references from increasing
 on each iteration.
 For that, the options would be either to use 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, or to destroy references one by one with 
\family typewriter 
DeleteLocalRef
\family default 
.
 If we used 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 in the example, we would have to keep the temporary string holding the
 concatenation in a global reference.
 Further, this reference would have to be destroyed and recreated on each
 iteration, since strings are immutable in Java.
 As the number of locals is small, it is more convenient in this case to
 control them explicitly with 
\family typewriter 
DeleteLocalRef
\family default 
 than resorting to global references.
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 allows, through an additional argument, transferring a local reference
 from the set that is being popped to the external scope of local reference,
 creating this way a new reference.
 For the example of Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, this would still not avoid the need of freeing references explicitly on
 each iteration of the loop, since each 
\family typewriter 
PopLocalFrame
\family default 
 would create a new local reference.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
\emph on 
/* Caching jmethodIDs in C code is a common technique.
\layout LyX-Code


\size footnotesize 
\emph on 
   It's worth mentioning that jmethodIDs are not Java objects,
\layout LyX-Code


\size footnotesize 
\emph on 
   and are therefore not subjected to garbage collection.
 */
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Example_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);     
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);     
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\emph on 
   /* os = o.toString() */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\emph on 
 /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Routine for concatenating elements of an array represented as strings.
\end_inset 


\layout Standard

Since Java 1.2, the JNI includes weak global references, with the goal of
 offering a simplified version of Java's weak references (
\family typewriter 
java.lang.ref
\family default 
) -- an object pointed only by weak global references can be collected.
 Originally, the API defined the 
\family typewriter 
IsSameObject
\family default 
 function as a way to check the validity of a weak reference, but evidently
 this method is insufficient: since Java is multi-threaded, the garbage
 collector may invalidate the reference between the test and the following
 instruction in C code.
 The revised documentation warns about this limitation and recommends the
 use of global references, as well as alerting on undefined behaviors in
 the relationship between weak global references in C and Java's own weak
 reference types\SpecialChar ~

\begin_inset LatexCommand \cite{jni1503spec}

\end_inset 

.
\layout Standard

More issues arise from the combination of Java's multi-threaded model with
 the exposure of references of virtual machine objects to C code.
 To reduce the volume of data copying between Java and C, the JNI offers
 some functions that return and release pointers to the internal representation
 of strings and arrays of primitive types: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 and 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 The use of these functions, however, has important restrictions.
 The API specifies that, once a pointer is obtained through these functions,
 the C code must not call other JNI functions or perform calls that may
 block the current thread and make it wait for another Java thread, under
 risk of a deadlock.
 It is recommended that memory blocks held using these functions are not
 retained for a long time, since one of the possible techniques fro implementing
 this 
\begin_inset Quotes eld
\end_inset 

critical section
\begin_inset Quotes erd
\end_inset 

 consists in disabling the garbage collector.
 It is also important to note that local references and the pointer to the
 JNI environment passed to native functions are valid only in the thread
 where they were created; global references can be shared among threads.
\layout Standard

Besides the weak reference mechanism provided by the 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
 package, the only way provided by Java to interact in a more direct way
 with the garbage collector is through the 
\family typewriter 
System.gc()
\family default 
 call, which asks the virtual machine to launch the collection thread as
 soon as possible so that it deallocate unreachable objects.
 There is no equivalent C function in the JNI, but this method can be invoked
 from C with 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

The interaction of native C code with the Lua garbage collector is greatly
 simplified by the fact that the Lua API does not return explicit references
 to Lua objects to the C space.
 Operations on Lua objects are always specified through indices of the virtual
 stack.
 This way, the virtual machine retains all control over which objects are
 accessible from C at any given moment.
\layout Standard

Although pointers to objects are not manipulated in the API, some functions
 return pointers to structures managed by Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
 and 
\family typewriter 
lua_touserdata
\family default 
.
 The validity of pointers returned by these functions is dependent on the
 lifetime of the object they correspond to; for strings in particular, a
 returned pointer is only decidedly valid as long as the string is in the
 stack.
 Lua offers still the 
\family typewriter 
lua_topointer
\family default 
 function, which returns pointers to some kinds of objects (userdata, tables,
 threads and functions), but only with the intention of providing debugging
 information, as it is not possible to convert such pointers back into Lua
 values.
\layout Standard

The virtual stack is emptied when the C function returns control to the
 Lua virtual machine.
 This way, it is not possible to retain pointers returned by Lua for later
 use in global variables or C structures.
 Alternatively, the API offers a mechanism for storing Lua values in a location
 that is known to C code and that cannot be altered by Lua code: the registry.
 The registry is a table made available through the Lua API for the storage
 of Lua values from C; this table is not normally accessible from Lua.
 Since the table that implements the registry is part of the root set of
 the garbage collector, the inclusion of an object in this table prevents
 it from being collected, keeping it in the registry until it is explicitly
 removed through C code.
\layout Standard

Using the registry, a possible way to describe data from the Lua space in
 C data structures is to store data in the registry and store the used indices
 in the C structure.
 Lua's auxiliary library encapsulates such idiom through two functions,
 
\family typewriter 
luaL_ref
\family default 
 and 
\family typewriter 
luaL_unref
\family default 
.
 The 
\family typewriter 
luaL_ref
\family default 
 function associates the given Lua value to an integer numeric key in the
 registry, and returns this number.
 This value can then be seen as a high-level handle to the object: C code
 can store it in variables and structures and use it to refer to the object
 through its registry field.
 The 
\family typewriter 
luaL_unref
\family default 
 function removes the Lua value from the registry and frees the index for
 reuse.
 To ensure that this mechanism works properly, integer keys should not be
 used directly be the programmer to store data in the registry.
\layout Standard

The API allows associating a deallocation function, 
\family typewriter 
__gc
\family default 
, to the metatable of full userdata objects.
 When present, this function will be typically implemented in C, performing
 resource finalization.
 For example, the 
\family typewriter 
__gc
\family default 
 metamethod of objects returned by the 
\family typewriter 
io.open
\family default 
 Lua function is a C function that closes the corresponding file descriptor
 using the 
\family typewriter 
fclose
\family default 
 function.
\layout Standard

In principle, the fact that its possible to obtain and modify the metatable
 of userdata through Lua code may seem problematic, as one could replace
 its finalizer in 
\family typewriter 
__gc
\family default 
.
 However, collection functions implemented in C typically validate received
 userdata checking its 
\begin_inset Quotes eld
\end_inset 

type
\begin_inset Quotes erd
\end_inset 

, identified through its metatable.
 So, even if Lua code manipulates the table, a collection function implemented
 in C which uses 
\family typewriter 
luaL_checkudata
\family default 
 will not be made to operate on userdata of incorrect type.
 To stop Lua code from modifying the collection function of a userdata object,
 one can assign some value, such as false, to the 
\family typewriter 
__metatable
\family default 
 field of the metatable; this will be returned in place of the metatable,
 making the metatable itself unaccessible.
\layout Standard

Another resource related to memory management provided by Lua is the possiblity
 of configuring, at runtime, the allocation function to be used by the virtual
 machine.
 In the creation of a new Lua state, an allocation function is passed as
 a its first argument.
 This function must offer functionality like that from the C functions 
\family typewriter 
free
\family default 
 and 
\family typewriter 
realloc
\family default 
, depending if the given block size is equal or greater than zero.
\layout Standard

Lua offers an interface to its garbage collector through two functions:
 
\family typewriter 
lua_gc
\family default 
 in C and 
\family typewriter 
collectgarbage
\family default 
 in Lua.
 The collector implements incremental mark-and-sweep and allows the programmer
 to configure parameters related to collection intervals, as well as enable,
 disable, launch full cycles and executing collection steps.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Like Python, Perl performs garbage collection based on reference counting.
 The API provides functions for explicit control of reference counts: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 and a getter, 
\family typewriter 
SvREFCNT
\family default 
.
 Another way to modify the reference count of a value is to assign it to
 a Perl reference with 
\family typewriter 
newRV_inc
\family default 
.
 The count of the referenced value will be incremented, keeping it valid
 -- unless it has its count altered explicitly -- as long as it is referenced
 by the 
\family typewriter 
RV
\family default 
.
 It is important to note, however, that API functions that create values,
 such as 
\family typewriter 
newSViv
\family default 
, initialize their reference counts with 1.
 This has the effect that if a value is created in a C function, stored
 in an 
\family typewriter 
RV
\family default 
 with 
\family typewriter 
newRV_inc
\family default 
 and this reference is returned to Perl, the value will never be collected,
 because its counter will not reach 0 when the reference is destroyed.
 The correct form, then, is to use 
\family typewriter 
newRV_noinc
\family default 
 for 
\family typewriter 
RV
\family default 
s containing newly-created values and 
\family typewriter 
newRV_inc
\family default 
 when an 
\family typewriter 
RV
\family default 
 needs to retain an already existing value.
\layout Standard

Initializing reference counts with 1 ensures that values created will remain
 valid during the execution of a C function without storing the value in
 Perl space.
 These values can also be stored in C global variables and data structures
 and will remain valid until their reference count is decremented.
 For values with a lifetime restricted to a single function, the Perl API
 defines the concept of 
\begin_inset Quotes eld
\end_inset 

mortal
\begin_inset Quotes erd
\end_inset 

 variables as a way of deallocating all temporary values of a function at
 once.
 An 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 can be created with 
\family typewriter 
sv_newmortal
\family default 
 or, more commonly, converted to a mortal with 
\family typewriter 
sv_2mortal
\family default 
.
 In practice, marking a value as mortal corresponds to indicating that it
 should have its reference count decremented by the 
\family typewriter 
FREETMPS
\family default 
 macro by the end of a function, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Some functions of the API return mortal values: for example, 
\family typewriter 
hv_delete
\family default 
 removes an element of a hash and, unless the 
\family typewriter 
G_DISCARD
\family default 
 is passed, returns the removed element as a mortal 
\family typewriter 
SV
\family default 
.
\layout Standard

The Perl API does not provide facilites for interfacing with the garbage
 collector, but features some debugging support functions that report informatio
n about the state of garbage collection.
 The 
\family typewriter 
sv_report_used
\family default 
 function displays the contents of every 
\family typewriter 
SV
\family default 
 stored in the interpreter.
 The 
\family typewriter 
Devel::Peek
\family default 
 module allows examining from Perl the content of values (reference counts,
 flags, etc.) -- from C, these informations are directly available, since
 their structures are not opaque.
\layout Subsection

Comparison
\layout Standard

Garbage collection aims to isolate, as much as possible, the programmer
 from memory management.
 This way, ideally an API should also be as independent as possible from
 the garbage collection algorithm used in the implementation of the virtual
 machine.
 Perl and Python perform garbage collection based on reference counting,
 and this shows through in the reference increment and decrement operations
 frequently needed during the use of their APIs.
\layout Standard

Ruby uses a mark-and-sweep garbage collector.
 Its API manages to abstract this fact well for manipulation of native Ruby
 objects, but the implementation of the collector is evident in the creation
 of Ruby types in C, where we need to declare a mark function when there
 are C structures that store reference to Ruby objects.
 The Lua API goes further when isolating itself from the implementation
 of the garbage collector: the only point of the API where the use of an
 incremental garbage collection is apparent is in the routine for direct
 interaction with the collector, 
\family typewriter 
lua_gc
\family default 
, where its parameters can be configured.
\layout Standard

Of the five languages studied, the only whose API abstracts entirely the
 implementation of the garbage collector is Java.
 The only intarfacing operation provided by the language, 
\family typewriter 
System.gc()
\family default 
, does not receive any arguments and does not specify how or when the collection
 should be done
\begin_inset Foot
collapsed true

\layout Standard

The documentation is purposely vague, stating only that this method 
\begin_inset Quotes eld
\end_inset 

suggests that the Java Virtual Machine expend effort toward recycling unused
 objects
\begin_inset Quotes erd
\end_inset 


\emph on 
 
\emph default 
.
\end_inset 

.
 Indeed, the various available implementations of the JVM use different
 algorithms for garbage collection.
\layout Standard

For manipulating data through the API, Lua and Ruby are the languages that
 demand the least concerns from the programmer about managing references.
 Ruby keeps control of references returned to C functions scanning the C
 stack during garbage collection, detecting the presence of references stored
 in local variables.
 Lua avoids the problem altogether, by keeping its objects in the virtual
 stack and not returning references to C code.
\layout Standard

The issue of references stored in local variables is handled by Perl and
 Java in a similar way, by defining two types of references, global and
 local (local references are called 
\begin_inset Quotes eld
\end_inset 

mortal variables
\begin_inset Quotes erd
\end_inset 

 in Perl).
 Local references have implicit management (save a few cases, as discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

).
 API functions in Java return local references by default, which can be
 converted to global ones with 
\family typewriter 
NewGlobalRef
\family default 
.
 In Perl, the opposite happens, and global references can be converted to
 local ones with 
\family typewriter 
sv_2mortal
\family default 
.
 Java's approach is more interesting, as normally more locally-scoped than
 globally-scoped variables are used.
 Values stored globally always need to have some for of explicit management
 to them, even in Ruby and Lua, through 
\family typewriter 
rb_global_variable
\family default 
 and 
\family typewriter 
luaL_ref
\family default 
/
\family typewriter 
luaL_unref
\family default 
.
\layout Section

Calling functions from C
\layout Standard

The API must provide a form of invoking from C functions to be executed
 by the scripting language.
 This involves passing data between these two 
\begin_inset Quotes eld
\end_inset 

spaces
\begin_inset Quotes erd
\end_inset 

, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 and the implications that this brings about the objects' lifetime, discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Because of the static typing of C, it is not possible to use a transparent
 syntax for calling functions registered at runtime.
 It is therefore necessary for the API to define functions for performing
 calls to the scripting language.
\layout Standard

In this section, we will discuss the facilities provided by each API for
 invoking functions to be executed by its virtual machine.
 The main issues involved are how to reference the function to be called,
 how to pass arguments to it and how to obtain the return value, including
 forms of notification in case of errors.
 For illustration purposes, for each language we will present an example
 of a simple function call.
 Assume that in the space of each scripting language a 
\family typewriter 
test
\family default 
 function was defined, which receives an integer and a string as arguments
 and returns an integer as a result.
 For brevity, error handling will be omitted in the examples.
 
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

When calling a Python function from C, one should initially obtain a pointer
 to the 
\family typewriter 
PyObject
\family default 
 corresponding to the function, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Besides functions implemented in Python and C functions registered through
 the Python API, any data type that implements the 
\family typewriter 
__call__
\family default 
 method (or declares a function in the 
\family typewriter 
tp_call
\family default 
 field of its 
\family typewriter 
PyTypeObject
\family default 
 structure) can be called as a function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções para chamar funções
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

The Python API offers several functions for performing calls from C.
 The most general function, 
\family typewriter 
PyObject_Call
\family default 
, receives as arguments the object to be called, a Python tuple containing
 the arguments to be passed and optionally a dictionary of keyword arguments.
 As a convenience, other functions allow passing arguments in other ways.
 For example, 
\family typewriter 
PyObject_CallFunction
\family default 
 ncapsulates the call to 
\family typewriter 
Py_BuildValue
\family default 
 (seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), accepting directly the format string and the value to be converted.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 is a vararg function that accepts a sequence of pointers to 
\family typewriter 
PyObject
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

There are also many convenience functions for method invocation.
 The 
\family typewriter 
PyObject_CallMethod
\family default 
 is a variant of 
\family typewriter 
PyObject_CallFunction
\family default 
 that receives as arguments a 
\family typewriter 
PyObject
\family default 
 and a C string containing the method name.
 So, for example, both forms below are equivalent to the Python statement
 
\family typewriter 
ret = some_string.split(" ")
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* "s" indicates that the next parameter is a string */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(some_string, "split", "s", " ");
\newline 
 
\newline 
PyObject* split = PyObject_GetAttrString(some_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

It is interesting to note that when a method is called as a function, the
 
\family typewriter 
self
\family default 
 argument is not passed explicitly.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

The return value in all invocation functions is a 
\family typewriter 
PyObject
\family default 
 pointer.
 As it happens in Python code, when Python functions return multiple values,
 they are encapsulated in a tuple.
 For functions that do not return a value, C functions must return 
\family typewriter 
Py_None
\family default 
.
 In case of errors in the call, these functions return 
\family typewriter 
NULL
\family default 
.
 The occurrence of exceptions can then be verified with the 
\family typewriter 
PyErr_Occurred
\family default 
 function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A typical way of calling a Python function called 
\family typewriter 
test
\family default 
, including retrieval of the function and conversion of input and output
 values between Python and C, is shown below:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* test = PyDict_GetItemString(globals, "test");
\layout LyX-Code


\size footnotesize 
\emph on 
/* "si" indicates string and integer arguments */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(test, "si", "foo", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converts the value to C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Frees the temporary PyObject that was returned */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

A global function is obtain through the dictionary in the 
\family typewriter 
__main__
\family default 
 module.
 The conversion of input data from C to Python is made through a format
 string received by 
\family typewriter 
PyObject_CallFunction
\family default 
.
 This call is equivalent to 
\family typewriter 
obj_result = test("foo", 2)
\family default 
 in Python.
 The output value is returned as a new reference to a Python object and,
 as such, needs to have its reference count decremented after its use.
 The 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 and 
\family typewriter 
PyDict_GetItemString
\family default 
 return borrowed references, therefore the reference count of 
\family typewriter 
PyObject
\family default 
s returned by them do not need to be decremented after their use.
 However, after calling the Python function, there is no guarantee that
 the 
\family typewriter 
globals
\family default 
 and 
\family typewriter 
test
\family default 
 pointers still point to valid objects -- we would have to have incremented
 their reference counts if we wanted to use them again.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções para chamar funções
\end_inset 


\layout Standard

Since methods are not first-class values in Ruby, they are not represented
 as 
\family typewriter 
VALUE
\family default 
s in their C API.
 For calling Ruby methods in C, the API offers the 
\family typewriter 
rb_funcall
\family default 
 function and some variations.
 In common, all of them receive as an argument the 
\family typewriter 
VALUE
\family default 
 indicating to the object the method refers to, an 
\family typewriter 
ID
\family default 
 referring to the interned string containing the method name and an integer
 informing the number of arguments.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

Like in Python, the API functions for method invocation differ in how arguments
 are passed.
 For example, rb_funcall receives arguments as 
\family typewriter 
VALUE
\family default 
s passed as C varargs; 
\family typewriter 
rb_funcall2
\family default 
 receives a C array of 
\family typewriter 
VALUE
\family default 
s; rb_apply receives a 
\family typewriter 
VALUE
\family default 
 that must be a Ruby array containing arguments.
 All of them return a 
\family typewriter 
VALUE
\family default 
 as an argument.
 Like in Ruby code, multiple return values are represented as a Ruby array.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

All function call routines from the API refer to methods, expecting thus
 an object on which the method should be applied.
 Global functions are defined in Ruby as methods of the 
\family typewriter 
Kernel
\family default 
 module, which is included by the class 
\family typewriter 
Object
\family default 
 and are, therefore, accessible from every object, including 
\family typewriter 
nil
\family default 
.
 This way, one can invoke global functions passing the C constant 
\family typewriter 
Qnil
\family default 
 as the method's target object.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Below, we present the typical way a Ruby global function 
\family typewriter 
test
\family default 
 is called from C, again including conversion of input and output values
 between C and the interpreter.
\layout LyX-Code


\size footnotesize 
ID test = rb_intern("test");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, test, 2, rb_str_new2("foo"), INT2NUM(2));
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Unlike it happens in Python, it is not necessary to obtain a reference to
 the function, sufficing to pass its name as an 
\family typewriter 
ID
\family default 
 and the object it refers to (in this case, 
\family typewriter 
Qnil
\family default 
, indicating a global function).
 Conversion of input data from C to Ruby is done through the 
\family typewriter 
rb_str_new2
\family default 
 function and the 
\family typewriter 
INT2NUM
\family default 
 macro, which return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs.
 no exemplo
\end_inset 


\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, the control of validity of 
\family typewriter 
VALUE
\family default 
s is done implicitly.
 So, we can call functions that create 
\family typewriter 
VALUE
\family default 
s directly when passing parameters to 
\family typewriter 
rb_funcall
\family default 
.
 Actually, all three lines above could have been condensed, passing 
\family typewriter 
rb_funcall
\family default 
 as a parameter to 
\family typewriter 
NUM2LONG
\family default 
 and 
\family typewriter 
rb_intern
\family default 
 as the second argument of 
\family typewriter 
rb_funcall
\family default 
; they were separated here for greater readability.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: blocos Ruby
\end_inset 


\layout Standard

A data type that is treated in a quite irregular way in Ruby is that from
 code blocks.
 Ruby features special syntax for declaring blocks: they can only be defined
 as the last argument of a method call.
 This way, they are not first-class values and cannot be, for example, declared
 in a variable assignment.
 They can, however, be promoted to first-class values, as objects of the
 
\family typewriter 
Proc
\family default 
 class.
 This can be done in two ways: explicitly, passing a block to the 
\family typewriter 
Proc.new
\family default 
 method, or implicitly, when a block is passed to a method that declares
 a final formal argument preceded by 
\family typewriter 
&
\family default 
.
 This variable will contain the block converted to a 
\family typewriter 
Proc
\family default 
.
 When calling functions that expect blocks, 
\family typewriter 
&
\family default 
 converts a 
\family typewriter 
Proc
\family default 
 to a block.
 
\family typewriter 
Proc
\family default 
 objects can be manipulated through the C API as any other Ruby object,
 but there is no match in the C API to the functionality of the 
\family typewriter 
&
\family default 
 operator in function calls.
\layout Standard

The special status of code blocks complicates their use from C code, and
 in particular the invocation of methods that expect them as a parameter.
 Say we want to invoke the following Ruby method from C:
\layout LyX-Code


\size footnotesize 
def a_ruby_function()
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function will invoke the block.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function is done.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function expects a code block to be passed to it, so it can be invoked
 by the 
\family typewriter 
yield
\family default 
 command.
 Since we will invoke the function from C, we also want to pass C code as
 a block, represented by the following function:
\layout LyX-Code


\size footnotesize 
VALUE a_C_block() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "a_C_block is running.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The conversion of 
\family typewriter 
Proc
\family default 
 objects to blocks performed by the 
\family typewriter 
&
\family default 
 operator in Ruby has no equivalent in the C API.
 Therefore, 
\family typewriter 
rb_funcall
\family default 
 is unable to pass 
\family typewriter 
Proc
\family default 
s to functions expecting blocks.
 The intuitive way of doing Ruby function calls from C, in this case then,
 does not work:
\layout LyX-Code


\size footnotesize 
ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
\emph on 
/* The second argument is an additional argument to be
\layout LyX-Code


\size footnotesize 
\emph on 
   optionally passed when invoking a Proc */
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Doesn't work! A Proc is not a code block */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_funcall(Qnil, a_ruby_function, 1, a_proc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The only ways for invoking a Ruby method passing a code block are through
 
\family typewriter 
rb_eval_string
\family default 
 and 
\family typewriter 
rb_iterate
\family default 
.
 The first approach, besides the performance penalty caused by parsing a
 string of code, has the inconvenience of requiring temporary variables
 so that one can obtain return values back to the C data space.
 In the model using 
\family typewriter 
rb_eval_string
\family default 
, the C function that will act as a block must be declared in the Ruby space.
 There are two alternatives on how to do this: registering the method in
 Ruby and invoking it in a wrapper block declared in the string of Ruby
 code:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Declares a global function with 0 input parameters */
\layout LyX-Code


\size footnotesize 
rb_define_global_function("a_C_block", a_C_block, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function { a_C_block() }");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard

Or encapsulating the function in a 
\family typewriter 
Proc
\family default 
 object from C with 
\family typewriter 
rb_proc_new
\family default 
 and then using the 
\family typewriter 
&
\family default 
 notation in the string of Ruby code:
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$a_proc", a_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function(&$a_proc)");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The second approach makes use of the fact that the only API function that
 is capable of producing code blocks directly is 
\family typewriter 
rb_iterate
\family default 
.
 This function receives two function pointers, one to the function to be
 invoked and another to the function that will act as a block; calls to
 
\family typewriter 
yield
\family default 
 withing the first function will invoke the second one.
 The block may break the flow of execution with 
\family typewriter 
rb_iter_break
\family default 
.
 By passing as a 
\begin_inset Quotes eld
\end_inset 

iteration function
\begin_inset Quotes erd
\end_inset 

 to rb_iterate a wrapper function that simply calls the desired Ruby method
 with 
\family typewriter 
rb_funcall
\family default 
, it is possible to simulate a call to 
\family typewriter 
rb_funcall
\family default 
 that receives a C function as a code block.
\layout LyX-Code


\size footnotesize 
VALUE call_a_ruby_function() {
\layout LyX-Code


\size footnotesize 
   ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, a_ruby_function, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
\emph on 
/* The Qnil arguments indicate that there are no parameters
\layout LyX-Code


\size footnotesize 
\emph on 
   to be passed to either function */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_iterate(call_a_ruby_function, Qnil, a_C_block, Qnil);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that no arguments are passed to 
\family typewriter 
rb_funcall
\family default 
 -- 
\family typewriter 
rb_iterate
\family default 
 defines 
\family typewriter 
a_C_block
\family default 
 as the 
\begin_inset Quotes eld
\end_inset 

current code block
\begin_inset Quotes erd
\end_inset 

 and this definition is inherited implicitly by 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

For the common case of performing iteration on the 
\family typewriter 
each
\family default 
 method of collections, Ruby offers a wrapper function, 
\family typewriter 
rb_each
\family default 
.
 This function was designed to be passed as a first argument to 
\family typewriter 
rb_iterate
\family default 
.
 C functions executing as a code block can break the control flow with 
\family typewriter 
rb_iter_break
\family default 
.
 The yielding mechanism, for both C code and native Ruby calls, is implemented
 using the 
\family typewriter 
setjmp
\family default 
 and 
\family typewriter 
longjmp
\family default 
 C functions.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

For correct error handling, C functions that perform calls to Ruby functions
 must be encapsulated by a 
\family typewriter 
rb_protect
\family default 
 call or one of its variants, 
\family typewriter 
rb_ensure
\family default 
 and 
\family typewriter 
rb_rescue
\family default 
.
 If a program does not use 
\family typewriter 
rb_protect
\family default 
, Ruby exceptions will result in fatal errors.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

Like in attribute access, when calling Java methods from C one must initially
 obtain a method identifier, of the 
\family typewriter 
jmethodID
\family default 
 type.
 These identifiers are typically obtained with the 
\family typewriter 
GetMethodID
\family default 
 function, which receives as arguments the class (an instance of jclass)
 and two strings, one with the method name and the other with the method
 signature.
 The syntax for describing method signatures is similar to that of field
 descriptors discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Arguments are listed in parentheses, followed by the return type.
 For example, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 describes a function with 
\family typewriter 
String[], int, int
\family default 
 arguments and 
\family typewriter 
void
\family default 
 return.
 Alternatively to 
\family typewriter 
GetMethodID
\family default 
, since Java 1.2 it is possible to obtain a 
\family typewriter 
jmethodID
\family default 
 corresponding to a method by applying the 
\family typewriter 
FromReflectedMethod
\family default 
 function on a Java object of the 
\family typewriter 
Method
\family default 
 class -- that is, a method reified through Java's reflection API.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API para invocar funções
\end_inset 


\layout Standard

Once a jmethodID was obtained, a method can be invoked through some of the
 90 functions of the 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
* family.
 Function names follow this format:
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<type><return>
\family default 
\emph default 
Method
\family roman 
\emph on 
<arguments>
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

Here, 
\emph on 
<type>
\emph default 
 may be 
\family typewriter 
Static
\family default 
 for static functions, passing a 
\family typewriter 
jclass
\family default 
 as an argument in calls; 
\family typewriter 
Nonvirtual
\family default 
 when invoking implementations of a method from a specific class on a given
 object, passing a 
\family typewriter 
jclass
\family default 
 and a 
\family typewriter 
jobject
\family default 
 as parameters; or omitted for instance methods, passing the 
\family typewriter 
jobject
\family default 
 on which the method will be applied.
 Return type is indicated in 
\emph on 
<return>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Method arguments can be passed in three ways: as varargs, as a C array of
 
\family typewriter 
jvalue
\family default 
s, or propagating a received 
\family typewriter 
va_list
\family default 
.
 For example, in its simplest form, an instance method without input or
 output values is invoked with 
\family typewriter 
CallVoidMethod
\family default 
.
 
\family typewriter 
CallStaticIntMethodA
\family default 
, in contrast, invokes a static method which returns a 
\family typewriter 
jint
\family default 
 and has its argument list passed in an array of 
\family typewriter 
jvalue
\family default 
s.
 Since Java is a statically typed language, it is not necessary to specify
 the number of type of arguments passed in functions for method invocation.
 This information is already specified in 
\family typewriter 
jmethodID
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\end_inset 


\layout Standard

It is important to point out that, when obtaining method and field identifiers
 resolving them based on the 
\family typewriter 
jobject
\family default 
 obtained in the this variable and the method or field name, with 
\family typewriter 
GetObjectClass
\family default 
 and 
\family typewriter 
GetFieldID
\family default 
, we are effectively resolving names through dynamic scoping.
 This implies that, for example, if a method called 
\family typewriter 
Parent.method
\family default 
 implemented in C accesses a private attribute 
\family typewriter 
anAttribute
\family default 
 and a 
\family typewriter 
Child
\family default 
 subclass also defines a private attribute with the same name, a call to
 this method in an instance 
\family typewriter 
c
\family default 
 of 
\family typewriter 
Child
\family default 
 would end up accessing 
\family typewriter 
Child.anAttribute
\family default 
 and not 
\family typewriter 
Parent.anAttribute
\family default 
.
 This behavior differs from what would happen if 
\family typewriter 
Parent.method
\family default 
 was implemented in Java, where binding of private members is defined lexically.
 To ensure to the C implementation of 
\family typewriter 
Parent.method
\family default 
 that the 
\family typewriter 
anAttribute
\family default 
 it is accessing is really 
\family typewriter 
Parent.anAttribute
\family default 
, one must store in C space the field identifier from 
\family typewriter 
Parent
\family default 
's 
\family typewriter 
jclass
\family default 
 -- obtained, for example, in a 
\family typewriter 
static native
\family default 
 function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

C code may verify the ocurrence of exceptions through 
\family typewriter 
ExceptionCheck
\family default 
 and choose to handle it, obtaining a local reference of the exception with
 ExceptionOccurred and later clearing it with 
\family typewriter 
ExceptionClear
\family default 
; or keep it active so that it propagates to Java code.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

For the example of the 
\family typewriter 
test
\family default 
 function, since Java does not have global functions, we will assume that
 
\family typewriter 
test
\family default 
 is a static method of a class called 
\family typewriter 
Example
\family default 
 and that we are running the following C code in a context where we have
 a reference to a Java runtime environment called 
\family typewriter 
J
\family default 
 (this pointer, of 
\family typewriter 
JNIEnv
\family default 
 type, will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass example = (*J)->FindClass(J, "Example");
\layout LyX-Code


\size footnotesize 
jmethodID test = (*J)->GetStaticMethodID(J, example,
\layout LyX-Code


\size footnotesize 
                       "test", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring foo = (*J)->NewStringUTF(J, "foo");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, example, test, foo, (jint)2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Initially, we get a reference to the 
\family typewriter 
Example
\family default 
 class, from which we obtain the identifier of the desired method, based
 on its name and signature.
 Like in Ruby, the string passed as a parameter must be converted to a virtual
 machine type, but for the second argument and for the return value we explore
 the fact that 
\family typewriter 
jint
\family default 
, corresponding to the Java type 
\family typewriter 
int
\family default 
 (32-bit integer) is compatible with the C type 
\family typewriter 
long
\family default 
 (defined as an integer of at least 32 bits).
 All these API functions return local references, which will be freed automatica
lly by the end of the C function where the API calls were made.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Both in C functions launched by Lua and in Lua function calls performed
 from C code, input arguments and return values are passed through the virtual
 stack presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Verificação da ocorrência de erros
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

To call a Lua function from C, we must initially push to the stack the Lua
 object referring to it: for global functions, obtaining it with 
\family typewriter 
lua_getglobal
\family default 
, for functions stored in tables, with 
\family typewriter 
lua_gettable
\family default 
.
 Afterwards, we push its arguments and then invoke 
\family typewriter 
lua_call
\family default 
 or 
\family typewriter 
lua_pcall
\family default 
, indicating how many stack values are to be passed as a parameter.
 The difference between these two functions is in error handling: 
\family typewriter 
lua_call
\family default 
 propagates any signalled errors, using 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 captures errors, returning a status code and the error message in the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

When no errors occur, the stack will contain any values returned by the
 called function.
 The number of return values can be explicitly requested with lua_call or
 lua_pcall, or be defined at runtime, requesting the special value 
\family typewriter 
LUA_MULTRET
\family default 
.
 If a specific number of return values is requested and these are not passed
 by the called function, the number of values will be adjusted by adding
 
\family typewriter 
nil
\family default 
 elements or discarding excessive values.
 For calls with 
\family typewriter 
LUA_MULTRET
\family default 
, all values are pushed.
 In this case, the only way to find out how many values were returned is
 comparing the size of the stack before and after the call.
\layout Standard

The 
\family typewriter 
lua_cpcall
\family default 
 function allows calling C functions performing error capture like that
 which takes place on 
\family typewriter 
lua_pcall
\family default 
 without having to register them as Lua values.
 This functionality is similar to that offered by 
\family typewriter 
rb_protect
\family default 
 in Ruby.
 Ruby, however, does not offer any function analogous to 
\family typewriter 
lua_pcall
\family default 
, being sometimes necessary to wrap Ruby function calls in C functions that
 follow the signature expected by 
\family typewriter 
rb_protect
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Lua does not have a distinction between functions and methods, but features
 syntactic sugar that allows one to invoke functions stored in tables with
 a method-call-style syntax: 
\family typewriter 
t:m(x)
\family default 
 means 
\family typewriter 
t.m(t,x)
\family default 
.
 Still, there is no specific call in the C API to replicate this abbreviation.
 For functions stored in tables, the function must be obtained with 
\family typewriter 
lua_gettable
\family default 
 and the table has to be pushed explicitly alongside the other parameters.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

The example of the 
\family typewriter 
test
\family default 
 function call demonstrates the stack discipline adopted by the Lua API.
 Similarly to the Java example of Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, we will assume the existence of a 
\family typewriter 
lua_State
\family default 
 pointer called 
\family typewriter 
L
\family default 
, which will be explained later on in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "test");            
\emph on 
/* Pushes the function test */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "foo");            
\emph on 
/* Pushes the string "foo" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Pushes the number 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Calls the function with 2 arguments,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        expect 1 as the result */
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1); 
\emph on 
 /* Get the result at the top (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove it off the stack */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs no exemplo
\end_inset 


\layout Standard

With 
\family typewriter 
lua_getglobal
\family default 
, we push the global function 
\family typewriter 
test
\family default 
.
 Then, two input arguments are pushed.
 The function is invoked with 
\family typewriter 
lua_call
\family default 
, indicating two input arguments and requesting one output value.
 The return value, at the top of the stack (index\SpecialChar ~

\begin_inset Formula $-1$
\end_inset 

) is converted to C with 
\family typewriter 
lua_tointeger
\family default 
.
 This last function does not pop the value off the stack: to return it to
 its initial state, we need to remove it explicitly with 
\family typewriter 
lua_pop
\family default 
.
 As the API never returns pointers to Lua objects, there are no concerns
 related to garbage collection.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Funções vs.
 métodos
\end_inset 


\layout Standard

Calling Perl functions from C is done through a stack discipline, like in
 Lua.
 Input parameters are specified through push operations and return values
 are obtained from the stack after the function call.
 The call functions 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 and 
\family typewriter 
call_method
\family default 
 vary only in the way how the function to be called is specified: through
 an 
\family typewriter 
SV
\family default 
, a C string, or a C string describing the name of a method in some object
 or class previously inserted in the stack.
 The 
\family typewriter 
call_argv
\family default 
 function, as a convenience, receives as an additional argument a C array
 containing C strings representing arguments to be pushed.
 All of them return the number of return values available in the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: contextos Perl
\end_inset 


\layout Standard

All 
\family typewriter 
call_
\family default 
* functions receive an argument with flags to be passed that indicate how
 the function should be called and how to handle input arguments and return
 values.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 and 
\family typewriter 
G_ARRAY
\family default 
 indicate the context how the function should be called.
 In scalar contexts, for example, only one scalar is returned in the stack;
 if the called function returns a list, only its last element will be available
 on the stack.
 
\family typewriter 
G_DISCARD
\family default 
 specifies that return values should be automatically discarded; 
\family typewriter 
G_NOARGS
\family default 
 indicates that the default array of parameters, 
\family typewriter 
@_
\family default 
, should not be constructed
\begin_inset Foot
collapsed true

\layout Standard

This has the side effect that the called function inherits the value of
 
\family typewriter 
@_
\family default 
 from its caller.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

The procedure for error checking depends on the context and given flags,
 which affect how error situations are reported to the return value of 
\family typewriter 
call_
\family default 
* functions and to values returned on the stack.
 The 
\family typewriter 
G_EVAL
\family default 
 flag encapsulates the call in an 
\family typewriter 
eval
\family default 
 block, capturing errors.
 So, the occurrence of errors can be checked through the 
\family typewriter 
ERRSV
\family default 
 macro, which returns an 
\family typewriter 
SV
\family default 
 containing the error message.
 By adding the 
\family typewriter 
G_KEEPERR
\family default 
 flag, error messages do not overwrite the special variable 
\family typewriter 
$@
\family default 
, but concatenate to it, accumulating sequences of errors in diferent call
 levels.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A series of macros describe a protocol for calling functions and manipulating
 input and output parameters.
 The main ones will be explained below, as we present the Perl version of
 the 
\family typewriter 
test
\family default 
 function call:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("foo", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("test", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Controle de referências no exemplo
\end_inset 


\layout Standard

First, 
\family typewriter 
dSP
\family default 
 declares a local copy of Perl's stack pointer.
 Then, 
\family typewriter 
ENTER
\family default 
 and 
\family typewriter 
SAVETMPS
\family default 
 create a scope for mortal values.
 
\family typewriter 
PUSHMARK
\family default 
 starts the count of parameters to be passed to the function.
 These parameters are then pushed with 
\family typewriter 
XPUSHs
\family default 
.
 Values created with 
\family typewriter 
newSVpv
\family default 
 and 
\family typewriter 
newSViv
\family default 
 are converted to mortal values with 
\family typewriter 
sv_2mortal
\family default 
, so that they do not need to have their reference counts decremented explicitly
 after the function call.
 
\family typewriter 
PUTBACK
\family default 
 finishes counting parameters.
 Then, we call the global Perl function 
\family typewriter 
test
\family default 
, in scalar context, with 
\family typewriter 
call_pv
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

After this function returns, memory in Perl's stack may have been reallocated,
 changing the address of the stack pointer obtained with 
\family typewriter 
dSP
\family default 
.
 To make sure its value is correct, one must call 
\family typewriter 
SPAGAIN
\family default 
 after 
\family typewriter 
call_
\family default 
* functions.
 The 
\family typewriter 
POPl
\family default 
 function pops a value and converts it to 
\family typewriter 
long
\family default 
 (there are similar functions for other types, such as 
\family typewriter 
POPs
\family default 
 for 
\family typewriter 
SV
\family default 
s and 
\family typewriter 
POPpx
\family default 
 for strings).
 These operations pop values updating the local copy of the stack pointer.
 Thus, 
\family typewriter 
PUTBACK
\family default 
 must be called again to update the global pointer.
 Finally, 
\family typewriter 
FREETMPS
\family default 
 and 
\family typewriter 
LEAVE
\family default 
 decrement the reference count of mortal values.
\layout Subsection

Comparison
\layout Standard

In Python, Lua and Perl, functions can be accessed as language objects and
 invoked.
 In Ruby and Java, the API defines special types used to reference methods.
 Like in data manipulation, Python offers an extensive API, with several
 convenience functions allowing parameters to be passed as Python tuples,
 Python objects given as varargs, C values to be converted by the invocation
 function, etc.
 Java also offers a large number of method invocation functions and, due
 to static typing, input parameters can be passed as varargs in a direct
 way, without having to specify how their conversion should be made.
 Ruby also offers some variants for call functions.
\layout Standard

Lua, in contrast, separates the function call routine from argument passing,
 which is done previously through the stack.
 This is a very simple solution, but the resulting code is less clear than
 the equivalent calls in languages such as Ruby and Python.
 Perl also features function calls using a stack model, but unlike Lua its
 use is exceedingly complex, demanding a macro protocol to be followed which
 exposes the internal workings of the interpreter.
 Another complicating factor is the handling of return values, for these
 vary according to the Perl context in which the function is called.
\layout Standard

In Lua and Python, the occurrence of errors can be checked through the function'
s return value.
 In a similar way, Perl allows detecting errors in the most recent call
 checking a special variable; in Java, this is done calling an API function.
 In Ruby, error handling is more convoluted: strangely, the API offers a
 function for invoking C functions in protected mode, but lacks an equivalent
 for calling Ruby functions.
 It is necessary to write a wrapper function in those cases, which will
 be illustrated in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Section

Registering C functions
\layout Standard

To allow the invocation of C functions from code written in a scripting
 language, its API must provide a way to register these functions in the
 execution environment.
 In statically typed languages, such as Java, to make it possible to call
 external functions using the same syntax as native calls, the set of external
 functions must be declared 
\emph on 
a priori
\emph default 
 in some way.
 On the other hand, in dynamically typed languages, as it is the case with
 Python, Lua, Ruby and Perl, functions can be used directly; defining them
 at some point in time before their call is sufficient.
 This way, one can declare external functions at runtime through C code
 using the scripting language API.
\layout Standard

Again in this section, the presentation of each language will conclude with
 an example.
 A C function, which like in the previous section's examples, receives an
 integer and a string and returns an integer, will be registered.
 We will present as well, for each language, how to register this function
 as a global value
\begin_inset Foot
collapsed true

\layout Standard

Or in the case of Java, a static method.
\end_inset 

 
\family typewriter 
test
\family default 
 so that it can be directly invoked from the language or through the API.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

Python does not have a proper 
\begin_inset Quotes eld
\end_inset 

function
\begin_inset Quotes erd
\end_inset 

 type declarable from C.
 Class methods, however, are objects and have a specific type, which can
 be verified with the 
\family typewriter 
PyMethod_Check
\family default 
 function.
 Typically, methods are created passing an array of 
\family typewriter 
PyMethodDef
\family default 
 structures.
 These structures are composed by the name of the function, the pointer
 to the C function, a flags vector and a documentation string.
 These flags are used to indicate the convention adopted for input parameters
 in the C function.
 The most common flags are: 
\family typewriter 
METH_NOARGS
\family default 
, used for Python functions which receive no arguments, indicating that
 the C function will receive a sole 
\family typewriter 
PyObject
\family default 
 pointer which will contain the method's 
\family typewriter 
self
\family default 
; 
\family typewriter 
METH_VARARGS
\family default 
, for functions that receive as a second parameters a Python tuple containing
 a variable number of parameters passed from Python to C; and 
\family typewriter 
METH_KEYWORDS
\family default 
, to indicate that the C function receives as a third parameter a dictionary
 containing keyword arguments passed to the function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\end_inset 


\layout Standard

With this information in hand, API functions which operate on 
\family typewriter 
PyMethodDef
\family default 
 arrays can create and associate method objects to Python's space.
 
\family typewriter 
Py_InitModule
\family default 
, for example, initializes a module with functions from a 
\family typewriter 
PyMethodDef
\family default 
 array.
 Likewise, methods of a class implemented in C can be given in the tp_methods
 field of the 
\family typewriter 
PyTypeObject
\family default 
 structure relative to the class.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

C functions registered in Python must return a pointer to PyObject, or NULL
 in case of error (optionally declaring an exception with 
\family typewriter 
PyErr_SetString
\family default 
 or 
\family typewriter 
PyErr_SetObject
\family default 
).
 Functions that do not return values must return the pre-defined object
 
\family typewriter 
Py_None
\family default 
, always keeping in mind reference counting issues for returned values as
 discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

O que são funções na linguagem
\end_inset 


\layout Standard

Although methods are usually created in C using 
\family typewriter 
PyMethodDef
\family default 
 structures, it is also possible to create a method object explicitly from
 C with the 
\family typewriter 
PyMethod_New
\family default 
 function, passing as a parameter any callable Python object and the object
 or class is should refer to.
 As seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, Python object can be made callable by implementing a 
\family typewriter 
__call__
\family default 
 method in Python or associating a C function to the 
\family typewriter 
tp_call
\family default 
 field of their corresponding 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo
\end_inset 


\layout Standard

A simple implementation of a C function that can be registered in Python
 as the 
\family typewriter 
test
\family default 
 global function is given below:
\layout LyX-Code


\size footnotesize 
PyObject* test_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* foo; long n;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* In case of argument errors, PyArg_ParseTuple
\layout LyX-Code


\size footnotesize 
\emph on 
      raises the appropriate exception automatically */
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &foo, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Received: %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Since arguments were received as a tuple in the second parameter, the function
 signature corresponds to the 
\family typewriter 
METH_VARARGS
\family default 
 flag.
 Input arguments are converted to C and checked with 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 The return value is converted from the native C type to a 
\family typewriter 
PyObject
\family default 
 with 
\family typewriter 
PyInt_FromLong
\family default 
, generating a new reference.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de global
\end_inset 


\layout Standard

The Python API is designed primarily to the development of extension modules
 for the language.
 Though several functions exist for registering methods in classes and initializ
ing modules with function lists, there is no direct way for registering
 global functions in the virtual machine.
 A possible way is using the utility routing for method lookup, 
\family typewriter 
Py_FindMethod
\family default 
, and inserting the returned moethod in the dictionary of the global module
 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef test_def[] = {
\layout LyX-Code


\size footnotesize 
   { "test", (PyCFunction) test_py, METH_VARARGS, "a test" },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* test_obj = Py_FindMethod(test_def, NULL, "test");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "test", test_obj);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that 
\family typewriter 
NULL
\family default 
 was passed to 
\family typewriter 
Py_FindMethod
\family default 
, indicating that there is no object the method will be part of.
 Because of that, the 
\family typewriter 
self
\family default 
 argument received by the C function 
\family typewriter 
test_py
\family default 
 will also be 
\family typewriter 
NULL
\family default 
 and can be ignored.
 The 
\family typewriter 
test_def
\family default 
 array was declared 
\family typewriter 
static
\family default 
 to ensure that the 
\family typewriter 
PyMethodDef
\family default 
 will remain valid as long as the global function is registered, as in the
 creation of 
\family typewriter 
test_obj
\family default 
 a pointer to it is stored internally in the newly created object.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\layout Standard

Convenção para parâmetros de entrada
\end_inset 


\layout Standard

For C functions to be callable from Ruby, they must be declared as methods
 of some class or module, or as a global function.
 For that, a C function pointer and the number of arguments expected by
 the function is passed to one of the appropriate functions of the Ruby
 API: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 or 
\family typewriter 
rb_define_singleton\SpecialChar \-
_method
\family default 
.
 The number of arguments passed indicates the expected signature for the
 C function.
 Ruby supports explicitly C functions with up to 15 arguments; as an alternative
, the special values -1 and -2 indicate, respectively, that the C function
 will receive its arguments as a C array of 
\family typewriter 
VALUE
\family default 
s or as a 
\family typewriter 
VALUE
\family default 
 corresponding to a Ruby array.
\layout Standard

Resembling the 
\family typewriter 
PyArg_ParseTuple
\family default 
 function discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

, Ruby features a function designed to simplify the processing of input
 values in C functions: 
\family typewriter 
rb_scan_args
\family default 
.
 This function can be used when input arguments are received in a Ruby array.
 Like 
\family typewriter 
PyArg_ParseTuple
\family default 
, it is a vararg function which receives a format string indicating the
 number of arguments to be collected.
 Unlike its Python counterpart, though, it does not perform type checking
 in its arguments.
 The format string allows indicating the minimum and maximum number of parameter
s that will be accepted and if exceeding parameters should be collected
 into a Ruby array.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: blocos
\end_inset 


\layout Standard

Once declared in Ruby's object space, a C function can be called like any
 other method.
 The C function can check if Ruby code has passed it a code block through
 the 
\family typewriter 
rb_block_given_p
\family default 
 function.
 The block can then be invoked with 
\family typewriter 
rb_yield
\family default 
, which receives a 
\family typewriter 
VALUE
\family default 
 as an argument.
 To pass multiple arguments to 
\family typewriter 
rb_yield
\family default 
, one must pass a Ruby array.
 To obtain a 
\family typewriter 
VALUE
\family default 
 of the Proc type produced from a received code block it is necessary to
 use 
\family typewriter 
rb_scan_args
\family default 
, which provides functionality similar to that of the 
\family typewriter 
&
\family default 
 operator in Ruby function declarations.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

C functions implementing Ruby methods must always return a 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 when there is no result).
 Functions that return multiple values must do so through Ruby arrays.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Proceeding with the series of examples, the Ruby global function 
\family typewriter 
test
\family default 
 can be implemented in C as follows:
\layout LyX-Code


\size footnotesize 
VALUE test_rb(VALUE self, VALUE val_foo, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* foo = StringValuePtr(val_foo);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Received: %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Conversion of input 
\family typewriter 
VALUE
\family default 
s is done with the 
\family typewriter 
StringValuePtr
\family default 
 and 
\family typewriter 
NUM2INT
\family default 
 macros.
 There is no explicit code for error handling during these conversions because
 these macros trigger exceptions that escape the function using 
\family typewriter 
longjmp
\family default 
 in case the conversion was not possible.
 For output, a 
\family typewriter 
VALUE
\family default 
 is produced with the 
\family typewriter 
INT2NUM
\family default 
 macro.
 The first input argument is necessary because of the convention of function
 signatures adopted by the API, but for global functions it should be ignored.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de fn global
\end_inset 


\layout Standard

As Ruby offers an API function for defining global functions, the registration
 of 
\family typewriter 
test
\family default 
 is very simple:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("test", test_rb, 2); 
\layout Standard

We indicate the Ruby name of the function, the corresponding C function
 and the number of arguments it expect (not including 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: métodos native
\end_inset 


\layout Standard

Methods declared in Java that are not implemented in the language itself
 must be declared through a prototype including the 
\family typewriter 
native
\family default 
 modifier.
 Thus, 
\family typewriter 
native
\family default 
 does not refer to a native implementation in Java, but to the fact that
 the method's code will be compiler with native code of its runtime environment,
 as opposed to virtual machine bytecodes.
 The implementation of the method, usually wrapped in a C dynamic library,
 must be loaded before its execution using the 
\family typewriter 
System.loadLibrary
\family default 
 call in Java, usually in a static block of the corresponding class.
 For each 
\family typewriter 
native
\family default 
 method, a matching C function must be declared in the loaded library.
\layout Standard

The 
\family typewriter 
javah
\family default 
 utility generates C header files from Java classes, with prototypes for
 C functions following the format specified by the JNI.
 This format specifies not only the signature of input parameters and return
 types, but also the name of the function, so that the loader can link the
 C function to the proper Java method in the virtual machine.
 Functions must be called Java_
\emph on 
<class name>
\emph default 
_
\emph on 
<method name>
\emph default 
.
 In case of function overloading, a suffix is added indicating the type
 of input parameters (for example, 
\family typewriter 
Java_SomeClass_method__DI
\family default 
 for the version of 
\family typewriter 
SomeClass.method
\family default 
 which accepts a 
\family typewriter 
double
\family default 
 and an 
\family typewriter 
int
\family default 
 as arguments).
\layout Standard

The function input arguments are a pointer to 
\family typewriter 
JNIEnv
\family default 
, which represents a thread in the JVM, a 
\family typewriter 
jobject
\family default 
 representing the object on which the method was applied (or a 
\family typewriter 
jclass
\family default 
 for static methods) and the remaining arguments of the Java method in their
 C representations, discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 As the types of given arguments are defined statically both in Java and
 C, it is not necessary to perform type checking of received arguments in
 C code.
 The signatures of functions which implement methods, specified in header
 files generated by the 
\family typewriter 
javah
\family default 
 tool, already declare correct types.
\layout Standard

The return value corresponds the equivalent C type to the return type declared
 in the Java method.
 Values represented as reference types can be returned either as local or
 global references.
 Besides handling or propagating errors as discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, C functions can also generate exceptions with 
\family typewriter 
Throw
\family default 
 and 
\family typewriter 
ThrowNew
\family default 
 and return immediately.
 The return value will be ignored when the exception is captured in Java
 code.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de função global
\layout Standard

Funções da API para registrar funções (não há)
\end_inset 


\layout Standard

Since the way for exposing to the virtual machine Java functions implemented
 in C is different than that used in languages presented earlier, we will
 start by declaring the function to the Java space, and present the C implementa
tion of 
\family typewriter 
test
\family default 
 afterwards.
 In the Java class, we declare a 
\family typewriter 
native
\family default 
 method:
\layout LyX-Code


\size footnotesize 
public class Example {
\layout LyX-Code


\size footnotesize 
   static native int test(String foo, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...other class members
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Example");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

After compiling this class we can pass it to the 
\family typewriter 
javah
\family default 
 command, which will generate a C header.
 This file will contain the name and signature of the C function that the
 JVM will lookup in the library that will be loaded by 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed false

\layout Standard

The argument given to it in Java code is used as a basis when constructing
 a platform-dependent name.
 In Unix systems, for example, 
\family typewriter 
System.loadLibrary("Example")
\family default 
 loads the file 
\family typewriter 
libExample.so
\family default 
.
\end_inset 

.
 This library will implement functions relative to methods declared as 
\family typewriter 
native
\family default 
.
\layout Standard

Below, we present a C implementation, using the header generated by 
\family typewriter 
javah
\family default 
, for the 
\family typewriter 
test
\family default 
 method:
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
\emph on 
/* Header generated by javah */
\layout LyX-Code


\size footnotesize 
#include "Example.h" 
\layout LyX-Code


\size footnotesize 
 
\newline 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Example_test(JNIEnv* J, jclass c, jstring obj_foo, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* foo = (*J)->GetStringUTFChars(J, obj_foo, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_foo, foo);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 and 
\family typewriter 
JNICALL
\family default 
 are macros defined in jni.h to provide greater portability to the resulting
 C code.
 Since the method was declared 
\family typewriter 
static
\family default 
 in Java, a class reference is received as an argument to the function.
 The remaining arguments correspond to the arguments of the Java method,
 and are given in the equivalent types defined by the JNI.
 As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, the JNI handles reference types and immediate types differently.
 Because of that, only 
\family typewriter 
obj_foo
\family default 
 needs to be converted to C; both 
\family typewriter 
n
\family default 
 and the return value are used directly as basic C data types.
\layout Standard

The string obtained with 
\family typewriter 
GetStringUTFChars
\family default 
 is converted to UTF-8 from its internal Unicode representation in Java.
 The same pointer can be returned by the JVM to different threads that request
 the same string.
 This way, C code must explicitly notify its release with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

C functions exposed to Lua must match the 
\family typewriter 
lua_CFunction
\family default 
 type, receiving as a single argument a pointer to a variable of the 
\family typewriter 
lua_State
\family default 
 type and returning an 
\family typewriter 
int
\family default 
.
 A 
\family typewriter 
lua_State
\family default 
 encapsulates the entire state of a Lua virtual machine; multiple Lua states
 can be mantained in parallel.
 Every function of the core API receives a 
\family typewriter 
lua_State
\family default 
 as a first argument, except for 
\family typewriter 
lua_newstate
\family default 
, which creates a new 
\family typewriter 
lua_State
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Convenções p/ parâmetros de entrada
\end_inset 


\layout Standard

At the beginning of the C function, arguments given to it are available
 in the virtual stack.
 Like in Lua functions, there is no checking on the number of arguments
 given to a C function invoked from Lua or through the API.
 C code can check the number of received arguments inspecting the size of
 the stack.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

The auxiliary library also provides functions for checking in a more convenient
 way types of passed arguments.
 Functions of the 
\family typewriter 
luaL_check
\family default 
* family (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) check the type of a stack elements and return them, signalling error
 if the element type is not as requested.
 The 
\family typewriter 
luaL_opt
\family default 
* functions behave in a similar way, allowing also to indicate a default
 value if the requested element is absent or 
\family typewriter 
nil
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Return values are also passed by the C function back to Lua through the
 virtual stack.
 The integer value returned by the C function indicates how many elements
 of the stack should be returned to the caller function.
 Any remaining values are discarded.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API p/ registrar funções
\end_inset 


\layout Standard

A C function of the 
\family typewriter 
lua_CFunction
\family default 
 type can be passed to Lua through the 
\family typewriter 
lua_pushcfunction
\family default 
 call.
 Lua has also some convenience functions for registering a set of C functions
 at once.
 Like when using 
\family typewriter 
PyMethodDef
\family default 
 arrays in Python, the 
\family typewriter 
luaL_register
\family default 
 function registers a list of functions, receiving an array of luaL_Reg
 structures containing names and function pointers.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

A C function implemented the example function 
\family typewriter 
test
\family default 
 is given below:
\layout LyX-Code


\size footnotesize 
int test_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* foo = luaL_checkstring(L, 1); 
\emph on 
 /* Get the first argument */
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);         
\emph on 
/* Get the second argument */
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);                     
\emph on 
/* Push the return value */
\layout LyX-Code


\size footnotesize 
   return 1;               
\emph on 
/* Return one value, off the top of the stack*/
\layout LyX-Code


\size footnotesize 
}
\layout Standard

The function's signature matches the definition of 
\family typewriter 
lua_CFunction
\family default 
.
 Input parameters are obtained from stack positions 1 and 2 and their types
 are checked using the auxiliary library functions 
\family typewriter 
luaL_checkstring
\family default 
 and 
\family typewriter 
luaL_checkinteger
\family default 
.
 These functions signal error in case of conversion failure, causing a 
\family typewriter 
longjmp
\family default 
 like in Ruby.
\layout Standard

The type of the obtained string is 
\family typewriter 
const char*
\family default 
, as it points to a memory block managed by the virtual machine.
 In Lua, however, it is not necessary to notify explicitly the release of
 the string, because it remains valid as long as the value is on the stack.
 As the functions 
\family typewriter 
luaL_check
\family default 
* do not pop the parameters and the stack is emptied implicitly by the end
 of the C function, the obtained C string will remain valid during the whole
 function.
\layout Standard

At the end of 
\family typewriter 
test_lua
\family default 
, the return value passed to Lua is pushed using 
\family typewriter 
lua_push\SpecialChar \-
integer
\family default 
.
 The return value of the function in C, 
\family typewriter 
1
\family default 
, indicates to the virtual machine that there is a single output value to
 be fetched from the stack and used as a function result in Lua.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro
\end_inset 


\layout Standard

The function is registered in Lua creating a Lua object of the 
\family typewriter 
function
\family default 
 type from the C function and storing this object in a global variable.
 This could be done with 
\family typewriter 
lua_pushcclosure
\family default 
 and 
\family typewriter 
lua_setglobal
\family default 
, but Lua's header file has a macro that wraps these two calls.
 Therefor, hte function can be registered simply with:
\layout LyX-Code


\size footnotesize 
lua_register(L, "test", test_lua);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Using 
\family typewriter 
lua_pushcclosure
\family default 
, it is possible to associate to a C function Lua values that will be accessible
 to the function every time it is called, akin to local 
\family typewriter 
static
\family default 
 variables in C.
 This feature provides functionality that is similar to Lua closures, but
 in a more limited form: these values are private to C functions, while
 in Lua two closures defined in a single scope will access the same variables,
 that is, changes to values in one function will affect the other.
 This restricted form, however, is often enough for implementing in C 
\begin_inset Quotes eld
\end_inset 

stateful functions
\begin_inset Quotes erd
\end_inset 

 such as iterators and generators.
 Once registered in Lua, C functions are seen as values of the 
\family typewriter 
function
\family default 
 type, no differently than Lua functions.
 In fact, 
\family typewriter 
lua_pushcfunction
\family default 
 is a particular case of 
\family typewriter 
lua_pushcclosure
\family default 
 in which no Lua values are associated to the function.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas
\end_inset 


\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

, the interface between Perl and C was designed having in mind that the
 connection between C functions and the Perl interpreter is made through
 generated code from a description given in a higher-level language, XS.
 XS code consists of function signature declarations using a special syntax,
 indicating conversion rules for input and output parameters, and C code
 describing the implementation of these functions.
 XS was designed for the development of Perl extensions including functions
 implemented in C: the end result of the compilation of code generated by
 the XS tools (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) are C and Perl code that combined describe a Perl package (a set of variables
 and functions stored under a common namespace).
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções (não tem)
\end_inset 


\layout Standard

There is a public API for manipulating Perl data in C code, but this consists
 basically of the interpreter's internal structures exposed for use by the
 XS pre-processor, extended with some macros for programmer convenience.
 In fact, Perl does not expose a documented API for registering functions\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

.
 Because of that, it is not practical for an application to embed a Perl
 interpreter and expose to it a set of C functions using C code only.
 The alternative is to create a Perl extension using XS which exposes functions
 from the application and import the resulting package into the embedded
 interpreter.
 We observed the use of this approach in Perl scripting plugins of several
 applications
\begin_inset Foot
collapsed false

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) and Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) are some applications that implement Perl plugins through XS extensions.
 In the Perl plugin for Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), there are no 
\family typewriter 
.xs
\family default 
 files, but 
\family typewriter 
.c
\family default 
 sources include functions declared with undocumented APIs and Perl code
 equivalent to the 
\family typewriter 
.pm
\family default 
 file generated by xsubpp is declared as a C string evaluated with 
\family typewriter 
eval_pv
\family default 
, leading us to assume that the plugin was implemented as an XS extension
 and later converted to a single C source file.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

The 
\family typewriter 
h2xs
\family default 
 utility generates a directory containing the skeleton of a Perl module:
 a Makefile generator script, 
\family typewriter 
.xs
\family default 
 and 
\family typewriter 
.pm
\family default 
 files to be filled by the programmer with XS and Perl code, as well as
 auxiliary files.
 Resuming the example of the 
\family typewriter 
test
\family default 
 function, this is how it would be declared in XS:
\layout LyX-Code


\size footnotesize 
long test(foo, n)
\layout LyX-Code


\size footnotesize 
        char* foo
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

The .xs file is converted to 
\family typewriter 
.c
\family default 
 with 
\family typewriter 
xsubpp
\family default 
.
 C code for converting input and output parameters is generated automatically.
 In some cases, however, we need to manipulate values from the Perl stack
 explicitly, as described in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 In vararg functions, for example, additional arguments must be accessed
 directly from the stack.
 Code for registering module functions is also generated automatically.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

XS creates variable called 
\family typewriter 
RETVAL
\family default 
 automatically for storing the return value in C code.
 The contents of this variable are then converted to a Perl value by generated
 C code.
 To make sure that functions returning arrays will operate correctly in
 scalar contexts, their code should verify the context the function was
 called with 
\family typewriter 
GIMME_V
\family default 
 and then return an 
\family typewriter 
SV
\family default 
 or 
\family typewriter 
AV
\family default 
 accordingly.
 In those cases, a function must be declared with 
\family typewriter 
SV*
\family default 
 as the return type, and as such, C values have to be converted to Perl
 
\family typewriter 
SV
\family default 
s explicitly.
 The documentation alerts that, for the case of 
\family typewriter 
AV
\family default 
s, one must declare the return value as a mortal variable
\begin_inset Foot
collapsed false

\layout Standard

This behavior is described in the documentation as 
\begin_inset Quotes eld
\end_inset 

an unfixable bug (fixing it would break lots of existing CPAN modules)
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{roehrich06perlxs}

\end_inset 

.
 
\end_inset 

.
\layout Standard

Once a extension is compiled using Makefiles generated by 
\family typewriter 
h2xs
\family default 
, it can be loaded an used from Perl:
\layout LyX-Code


\size footnotesize 
use Example;
\layout LyX-Code


\size footnotesize 
$ret = Example::test("foo", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To expose functions from a C application to an embedded Perl interpreter,
 we have to create an extension that wraps these functions using XS, link
 the extension to the application and load it.
 The loading is performed passing to the interpeter during its initialization
 a C function containing 
\family typewriter 
newXS
\family default 
 calls.
 The 
\family typewriter 
ExtUtils::Embed
\family default 
 Perl module has a utility routine called 
\family typewriter 
xsinit
\family default 
 which generates C code for this function.
 In practice, generating code with 
\family typewriter 
xsinit
\family default 
 is the best approach, since the initialization protocol depends on undocumented
 routines (the example initialization function included in Perl's documentation\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

 is out-of-date).
\layout Subsection

Comparison
\layout Standard

Python and Ruby offer to the programmer various options for C function signature
s that are recognized by the API, which is practical, given that this way
 one can choose different C representations for the input parameters (collected
 in an array, obtained one by one, etc.) according to their use in the function.
 Lua offers only one possible signature for C functions to be registered
 in its virtual machine, but this is appropriate for the stack model adopted
 by its API.
\layout Standard

In Java, function signatures are created through the 
\family typewriter 
javah
\family default 
 tool -- due to its static type system, types of input parameters passed
 by Java are converted automatically by the JNI, which is very convenient
 as it avoids explicit operations for conversion and type checking in the
 function.
 Because of their dynamic type systems, the other languages offer specific
 API functions for performing these checks.
 Perl function signatures are created only through the XS tool, but differently
 from Java they are not exposed to the programmer.
 This brings the inconvenience that the programmer needs to pre-process
 C code as an XS extension even when they are embedding Perl in an application.
\layout Standard

Registration of functions in Ruby and Lua is simple.
 In Lua, in particular, it is an assignment, not different from any other
 object.
 In Python, there are features for batch registering, using 
\family typewriter 
PyMethodDef
\family default 
 arrays (Lua offers a similar feature with 
\family typewriter 
luaL_register
\family default 
), but there is no simple way to register a single function.
 Both in Java and Perl, function registration is done implicitly, and there
 are no API functions for registering new C functions at runtime in either
 of them.
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Case study: LibScript
\layout Standard

In previous chapters, we discussed the main issues involving language interfaces
 for C and the way these issues are handled by the languages covered by
 this study.
 In this chapter, we will make a comparison between their APIs through a
 concrete example, in order to put implementations on each of those languages
 side by side.
 The example consists of a generic scripting library called LibScript, and
 a series of plugins that interface different scripting languages.
\layout Section

LibScript
\layout Standard

LibScript is a library designed to provide extensibility to applications
 through scripting in a language-independent way.
 It is based on a plugin architecture, in order to decouple the application
 from runtime environments provided by the various languages.
 The main library provides a language-independent scripting API, allowing
 an application to register its functions and launch scripts that use these
 functions.
 This library then invokes a plugin for the appropriate language to run
 the script (for example, LibScript-Python for Python code).
 This way, application developers allow their users to employ different
 scripting languages without adding all of them as program dependencies.
\layout Standard

The main library provides features for registering C functions from the
 application and for calling these functions from the plugins (allowing
 scripts to access these functions), besides functions for transferring
 data between the application and plugins.
 It is also possible to invoke functions implemented in virtual machines
 embedded in plugins, enabling scripts written in different languages to
 interact with each other.
\layout Subsection

Architecture of LibScript
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura1.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Visão-geral}

\end_inset 

Overview of the LibScript architecture
\end_inset 


\layout Standard

LibScript is composed of a main dynamic library, 
\family typewriter 
libscript
\family default 
, and plugins for different languages (Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Visão-geral}

\end_inset 

).
 The main library is linked to an application, and exposes to it a language-inde
pendent scripting API which allows running files, strings of code and invoking
 functions.
 This library is a thin layers which forwards these operations to plugins,
 which are auxiliary dynamic libraries, loaded at runtime by the main library.
 These plugins embed the scripting languages' runtime environments.
 
\layout Standard

The application can register C functions in the main library (illustrated
 by the 
\family typewriter 
c_fun
\family default 
 function in the figure) and ask it to run scripts which register functions
 in different languages.
 However, the application does not interact directly with plugins.
 When the main library receives code to be executed in a given language,
 it loads the appropriate plugin (in case it was not already loaded) and
 forwards the code.
 The plugin will run the script in its virtual machine, which may register
 in it new functions (illustrated by functions 
\family typewriter 
py_fun
\family default 
, 
\family typewriter 
r_fun
\family default 
, 
\family typewriter 
l_fun
\family default 
 and 
\family typewriter 
pl_fun
\family default 
 in the figure).
\layout Standard

The main library decides which plugin to load through an identifier which
 specifies which is the language of the code to be executed.
 This identifier can be obtained from the filename extension of a script,
 through the 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

#!
\begin_inset Quotes erd
\end_inset 


\family default 
 identification line at the beginning of the script
\begin_inset Foot
collapsed false

\layout Standard

The 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

#!
\begin_inset Quotes erd
\end_inset 


\family default 
 line is used only to detect which language the script is written in.
 For example, a line with 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 will indicate that libscript-perl should be loaded, but the Perl interpreter
 in 
\family typewriter 
/usr/bin
\family default 
 is not used and the 
\family typewriter 
-w
\family default 
 flag is not considered.
\end_inset 

 or even passed explicitly by the application.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura2.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ambientes-virtuais}

\end_inset 

Ambientes virtuais em LibScript
\end_inset 


\layout Standard

Functions are registered in LibScript in a virtual environment.
 An application can create one or more environments in the main library,
 identifying them through a name.
 A virtual environment has, in each plugin, a language-specific data structure
 (class, module, etc.) which will represent it.
 In the example in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Ambientes-virtuais}

\end_inset 

 we have two virtual environments created by the application in the main
 library, 
\family typewriter 
X
\family default 
 and 
\family typewriter 
Y
\family default 
.
 In each of these environments, the application registered a C function
 with the name 
\family typewriter 
c_fun
\family default 
 (which may or may not correspond to the same C function).
 Scripts were executed in these environments, which prompted the loading
 of plugins.
 In the example, these scripts registered some functions (
\family typewriter 
X.py_fn
\family default 
, 
\family typewriter 
Y.py_fn
\family default 
, 
\family typewriter 
X#r_fun
\family default 
, etc.).
\layout Standard

Apart from the function for creating a virtual environment, all functions
 in the LibScript API receive as an argument a virtual environment they
 should operate on.
 This indicates in which C structure should be stored error messages and
 return values.
 For languages that allow multiple independent runtime states, like Lua
 and Perl, this also indicates in which state the script should run.
\layout Standard

When a script declares a function in a virtual environment, this function
 becomes accessible through the LibScript API.
 For example, in the Lua plugin, virtual environments are represented as
 tables named after the environment; once a Ruby method\SpecialChar ~

\family typewriter 
r
\family default 
 is declared in class 
\family typewriter 
X
\family default 
, this function becomes callable by C (using the LibScript API) or by other
 plugins.
 So, for example, even though the Lua table that implements virtual environment
 
\family typewriter 
X
\family default 
 contains only function 
\family typewriter 
l_fun
\family default 
, Lua scripts can invoke other functions through the virtual environment,
 like 
\family typewriter 
X.c_fun
\family default 
 and 
\family typewriter 
X.r_fun
\family default 
.
 These calls will be handled by the main library and resolved by itself,
 in the case of C functions such as 
\family typewriter 
X.c_fun
\family default 
, or forwarded to the appropriate plugin, as in the case of 
\family typewriter 
X.r_fun
\family default 
, performing the call in the Ruby plugin and forwarding return values back
 to the Lua plugin.
 The main library finds the function do be executed consulting each plugin,
 as it will be explained in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:A-API-de-plugins}

\end_inset 

.
\layout Standard

When implementing plugins, we used features offered by these languages to
 handle accesses to missing elements in their structures, capturing these
 accesses and forwarding them to the main library.
 These features will be discussed in Section \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

.
\layout Subsection


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

The main library API
\layout Standard

The API provided by LibScript isolates the application from the different
 APIs provided by scripting languages.
 It is not only a matter of adding a layer of indirection between calls,
 which would be appropriate only for features that are common to all of
 them, such as initialization and function calls.
 The main issue here are the various features that are particular to each
 language.
 An unpractical approach would be to define the API as the union of the
 feature sets of every supported language (such as offering features for
 sequence handling to map this Python feature, table handling features for
 Lua, and so on).
 This path would bring several problems: the API would be complex and would
 probably have to be extended as each new language is introduced; even for
 mappings that could apparently be reused (for example, mapping Python hashes
 and Lua tables to a single API of associative arrays) there is the problem
 of subtle semantic variations between the implementations of those features
 in the various languages.
 Besides, application bindings could offer functionality that is available
 for a single language, going against the model of language independence
 proposed by LibScript.
\layout Standard

Another approach is to, instead of exposing the language API to the application,
 expose only a function API of the application to the language and keep
 its data structures and features restricted to the domain where it is invoked.
 The application interacts with the virtual machine sending strings of code
 to be executed and obtains results back when the script passes parameters
 when calling application functions.
 This approach is proposed in\SpecialChar ~

\begin_inset LatexCommand \cite{thomas02ltn004}

\end_inset 

 and uses what, for example, Python calls a 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy,vanrossum06ref}

\end_inset 

.
 Primitives for running strings of code are a basic feature in scripting
 languages -- 
\family typewriter 
luaL_loadstring
\family default 
 in Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 in Python, 
\family typewriter 
rb_eval_string
\family default 
 in Ruby , 
\family typewriter 
perl_eval_sv
\family default 
 in Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename figura3.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:API-para-execução}

\end_inset 

API para execução de código em LibScript
\end_inset 


\layout Standard

LibScript adopts this minimalist approach for its API: no specific operations
 for data structure manipulation are offered, only for 
\emph on 
executing strings
\emph default 
 -- 
\family typewriter 
script_run
\family default 
 (and the convenience function 
\family typewriter 
script_run_file
\family default 
, which reads a file and sends it to script_run) -- and 
\emph on 
function calls
\emph default 
 with basic types (numbers and strings) -- 
\family typewriter 
script_call
\family default 
.
 Operations on more complex data of language-specific types, when needed,
 can be encapsulated in functions implemented in the scripting language.
 One can also reference language objects from C storing it in structures
 of the scripting language and returning to C numerical indices of these
 structures, acting as high-level handles for these objects.
\layout Standard

Figure\SpecialChar ~

\begin_inset LatexCommand \ref{fig:API-para-execução}

\end_inset 

 depicts the interaction between the application, the main library and plugins
 with regard to these two fundamental operations, represented by functions
 
\family typewriter 
script_run
\family default 
 and 
\family typewriter 
script_call
\family default 
.
 For executing strings, the main library receives input from the application
 and forwards code to be executed to the appropriate plugin.
 When using 
\family typewriter 
script_run
\family default 
, two strings are passed, one identifying the language and another containing
 code; for 
\family typewriter 
script_run_file
\family default 
, a filename
\begin_inset Foot
collapsed false

\layout Standard

For code executed with 
\family typewriter 
script_run_file
\family default 
, the language is automatically detected as discussed in the previous section.
\end_inset 

.
 The following example declares a virtual environment, registers a C function
 called 
\family typewriter 
hello
\family default 
 and invokes it from Lua code:
\layout LyX-Code


\size footnotesize 
script_env* env = script_init("example");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "example.hello()");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The virtual environment is declared with the 
\family typewriter 
script_init
\family default 
 function.
 It receives the name that will identify the environment and returns an
 identifier of the 
\family typewriter 
script_env
\family default 
 type, which is an opaque pointer that represents a virtual environment.
 The C function is registered using 
\family typewriter 
script_new_\SpecialChar \-
function
\family default 
, which receives as arguments the environment, a function to be registered
 and the name that the function will have in the virtual environment.
 In Lua code, the function is accessed as element 
\family typewriter 
hello
\family default 
 (the registered name of the function) of global table 
\family typewriter 
example
\family default 
 (name of the virtual environment).
\layout Standard

For function calls, the application should pass input parameters (how this
 is done will be discussed later on), and call 
\family typewriter 
script_call
\family default 
, indicating the name of a function registered in the virtual environment.
 This same function 
\family typewriter 
script_call
\family default 
 is used by plugins when they wish to invoke functions from the virtual
 environment registered in C or implemented by other plugins.
\layout Standard

For this reason, we adopted a generic API for data transfer, to be used
 both in input and output of data, both in the communication between the
 application and the main library and between the main library and plugins.
 We chose an approach similar to those employed by Lua (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) and Perl (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) for sending data when passing parameters and obtaining return values,
 using an internal buffer as a transfer area.
 Differently from those languages, however, we pass indices to parameters
 explicitly instead of implementing a stack discipline.
 Functions 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} are used for input and output of values.
 Functions 
\family typewriter 
script_put_
\family default 
* store values in the internal buffer and 
\family typewriter 
script_get_
\family default 
* remove them.
 A call to a function called 
\family typewriter 
test
\family default 
 passing a string and an integer as parameters and obtaining an integer
 as a result is performed like this:
\layout LyX-Code


\size footnotesize 
script_put_string(env, 0, "foo");   
\emph on 
/* index 0: "foo" */
\layout LyX-Code


\size footnotesize 
script_put_int(env, 1, 2);          
\emph on 
/* index 1: 2 */
\layout LyX-Code


\size footnotesize 
script_call(env, "test");
\layout LyX-Code


\size footnotesize 
result = script_get_int(env, 0);    
\emph on 
/* return index 0 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Function calls are offered as a primitive operation because they allow a
 minimum degree of language-independent interoperability.
 Two goals are met this way.
 The first one is that this way C programs embedding LibScript can access
 the functionality of loaded scripts without having to include in their
 source code strings of code written in some specific scripting language,
 for example, inserting in their code an invocation to a callback function
 to be defined through a script.
 Notice that in the above example, the language in which the 
\family typewriter 
test
\family default 
 function is implemented is not specified.
 If the call was made by running a string of code, this would tie the applicatio
n to at least one scripting language.
 Using script_run_file and script_call, one can implement an extensible
 application without specifying explicitly the scripting language to be
 used with it.
 The second goal is allowing the plugins themselves to invoke functions
 defined in other plugins.
 We would have to provide to plugins an invocation function anyway, to allow
 them to invoke C functions registered into LibScript.
 Making this invocation function generic enough so that it can also invoke
 functions implemented in the plugins themselves does not make, thus, the
 main library API any more complex.
\layout Standard

The LibScript buffer was designed to be used only as a temporary transfer
 area between the main library and plugins, and not as a general facility
 for data storage and manipulation.
 Therefore, its API is focused on sequential insertion and removal of elements.
 For example, the insertion of an element at position 0 automatically empties
 the buffer, avoiding in most cases the need to use the 
\family typewriter 
script_reset_buffer
\family default 
 function, which performs this operation explicitly.
\layout Standard

C functions registered with 
\family typewriter 
script_new_function
\family default 
 must receive the virtual environment as a parameter and return an error
 code.
 Functions 
\family typewriter 
script_get_
\family default 
* and 
\family typewriter 
script_put_
\family default 
* are used to receive arguments and return values when implementing functions
 that can be called through LibScript, the same way they are used to pass
 arguments and obtain return values and perform calls with 
\family typewriter 
script_call
\family default 
.
\layout LyX-Code


\size footnotesize 
script_err test_lua(script_env* env) {
\layout LyX-Code


\size footnotesize 
   char* foo = script_get_string(env, 0);  
\emph on 
/* Input, index 0: string */
\layout LyX-Code


\size footnotesize 
   int n = script_get_int(env, 1);         
\emph on 
/* Input, index 1: integer */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Escape the function with an error if any script_get* failed */
\layout LyX-Code


\size footnotesize 
   SCRIPT_CHECK_INPUTS(env);
\layout LyX-Code


\size footnotesize 
   printf("Received %s and %ld 
\backslash 
n", foo, n);
\layout LyX-Code


\size footnotesize 
   free(foo);
\layout LyX-Code


\size footnotesize 
   script_put_int(env, 0, 42);             
\emph on 
/* Output, index 0: integer */
\layout LyX-Code


\size footnotesize 
   return SCRIPT_OK;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In LibScript, strings returned by script_get_string belong to the caller,
 being their responsibility to deallocate its memory, unlike what happens
 in similar function of the APIs of languages discussed in this work.
 Such decision was made due to the temporary nature of the LibScript buffer:
 returning to the caller a pointer to a string whose validity would be ensured
 only until the next API call would be counter-intuitive, and in practice
 would force the programmer to copy strings frequently.
\layout Subsection

The plugins API
\begin_inset LatexCommand \label{sub:A-API-de-plugins}

\end_inset 


\layout Standard

A plugin embedding a scripting language must implement four operations:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 and 
\family typewriter 
done
\family default 
.
 The main library expects that the dynamic library implementing a plugin
 for a language will expose four functions, named as 
\family typewriter 
script_plugin_
\family default 
\emph on 
<operation>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<language>
\emph default 
.
\layout Standard

The 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 function is responsible for initializing a plugin, and is called by the
 
\family typewriter 
script_init
\family default 
 function of the main library.
 When initializing a plugin, the main library passes to 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 a script_env pointer and receives a 
\family typewriter 
script_plugin_state
\family default 
, which is an opaque type which is always passed back to the plugin in subsequen
t calls.
 Each plugin defines its internal representation for 
\family typewriter 
script_plugin_state
\family default 
.
 Typical the virtual machine state and the LibScript virtual environment
 should be stored so that they can be later accessible through this handle.
 In Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 we will discuss how each plugin represents the environment and its internal
 state in 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

The 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<language>
\emph default 
 function is invoked by 
\family typewriter 
script_run
\family default 
.
 It receives a string containing code in the scripting language, executes
 this code in the virtual machine and returns a status code indicating success
 or the occurrence of compile or runtime errors.
 In case of errors, plugins should capture exceptions raised by the virtual
 machine and return the constant 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
.
 If it is possible to obtain from the language an error message, it can
 be propagated using the 
\family typewriter 
script_set_error_message
\family default 
 function from the main library.
 The message can be later consulted by the application using the 
\family typewriter 
script_error_message
\family default 
 function.
\layout Standard

The function 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 is used by 
\family typewriter 
script_call
\family default 
, and is responsible for performing calls to functions implemented in the
 language embedded by the plugin.
 If the function was defined in the plugin, that is, if a function with
 the given name was registered in the data structure that describes the
 environment within the virtual machine, it will be executed, and success
 or failure will be reported like it happens with 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<language>
\emph default 
.
 If the requested function was not defined in this virtual machine, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 must return the constant 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
 Input arguments and return values are passed through the argument buffer,
 using the same functions from the main library that are used to transfer
 data between the application and the main library, 
\family typewriter 
script_get_*
\family default 
 and 
\family typewriter 
script_put_*
\family default 
.
\layout Standard

The implementation of 
\family typewriter 
script_call
\family default 
 in the main library makes use of this behavior of plugins for invoking
 functions in a language-independent way.
 Initially, it tries to find a requested function in the list of registered
 C functions.
 If there is no C function in the virtual environment with that name, 
\family typewriter 
script_call
\family default 
 tries to locate the function in loaded plugins, calling 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<language>
\emph default 
 on each plugin and trying the next one each time it receives 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
\layout Standard

Finally, the 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<language>
\emph default 
 function is called by 
\family typewriter 
script_done
\family default 
 when a virtual environment is terminated.
 Depending on the internal representation used in the plugin, the termination
 of a state may or may not imply in the termination of the virtual machine.
 Preferrably, this function should remove the data structure that describe
 the virtual environment, but as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

, this is not always possible.
\layout Section

Implementation of plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Standard

In this section we will discuss the main aspects involved in the implementation
 of the plugins developed in this case study.
 We implemented plugins for Python, Ruby, Lua and Perl.
 We will present here how the representation of virtual states is made in
 each plugin (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

), issues involving state termination (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

), passing parameters between the main library and plugins (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

), how function calls from scripts are handled by plugins (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

) and error capturing (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

).
\layout Subsection

Representation of states
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

The design of LibScript allows plugins to have multiple independent states
 of execution.
 Ideally these states would be totally isolated from each other, like for
 example with different virtual machine instances.
 However, languages offer different degrees of isolation between independent
 states.
 Lua and Perl allow multiple isolated instances of their runtime environments
 in a simple way, since their API calls include a state identifier
\begin_inset Foot
collapsed true

\layout Standard

The feature of multiple independent states is optional in Perl, and can
 be selected during compilation of the interpreter's library.
\end_inset 

.
 Language that keep state in a static manner, like Python and Ruby, don't
 allow working with multiple isolated states easily
\begin_inset Foot
collapsed true

\layout Standard

Python's threading model offers a way for alternating between virtual machine
 states obtaining 
\family typewriter 
PyThreadState
\family default 
 objects through the 
\family typewriter 
Py_NewInterpreter
\family default 
 call, but this can cause problems when extension modules written in C use
 global static variables or when modules manipulate their own dictionary,
 which is shared between states.
 The documentation states, since 1999, that 
\emph on 

\begin_inset Quotes eld
\end_inset 


\emph default 
This is a hard-to-fix bug that will be addressed in a future release.
\emph on 

\begin_inset Quotes erd
\end_inset 


\emph default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum99api,vanrossum06api}

\end_inset 


\end_inset 

.
 For languages that do not allow multiple virtual machine instances, we
 can only define separate namespaces for LibScript virtual environments,
 which share a single global state of execution within the plugin.
 We term the representation of a state of execution relative to a LibScript
 virtual environment within a plugin a 
\emph on 
virtual state
\emph default 
, which may or may not correspond to an isolated state of execution.
\layout Standard

As discussed in the previous section, the 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
 function returns a 
\family typewriter 
script_plugin_state
\family default 
 to the main library, which is the opaque representation of its virtual
 state.
 The contents if this representation vary from language to language, but
 the basic principle is that two data should be available from this value:
 a reference to the LibScript virtual environment, received as an argument
 by 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<language>
\emph default 
, so that the plugin can make calls to the main library, and an identifier
 that allows the plugin to access the data structure that represents for
 the language the namespace of LibScript-accessible functions.
 In the Lua plugin, this structure is a table; in Python, a module; in Ruby,
 a class; in Perl, a package.
\layout Standard

In LibScript-Lua, states are implemented as 
\family typewriter 
lua_State
\family default 
s (Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 This way, scripts executed in an environment are fully isolated from other
 environments.
 For example, the modification of the value of a global variable in an environme
nt does not affect the other ones.
 In fact, 
\family typewriter 
script_plugin_state
\family default 
 as returned by the Lua plugin is simply a 
\family typewriter 
lua_State
\family default 
 converted with a cast.
 The pointer to the LibScript environment is stored in Lua in the registry,
 as follows:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "LibScript.env"); 
\emph on 
  /* Pushes the index */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);        
\emph on 
/* Pushes the LibScript environment */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX);   
\emph on 
/* registry["LibScript.env"] = env */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The plugin creates in this 
\family typewriter 
lua_State
\family default 
 a table representing the virtual environment for Lua scripts.
 This table is stored in the 
\family typewriter 
lua_State
\family default 
 as a global variable with the name of the virtual environment.
\layout Standard

In LibScript-Perl states are isolated like in Lua.
 Each state created initializes a new instance of 
\family typewriter 
PerlInterpreter
\family default 
.
 In this interpreter, a package is created, which will be the visible representa
tion of the environment in Perl code.
 The 
\family typewriter 
script_plugin_state
\family default 
 type is then a typedef for 
\family typewriter 
PerlInterpreter
\family default 
*.
\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-registro}

\end_inset 

, the implementation of C functions exported to a Perl interpreter is made
 writing an extension module using the XS pre-processor, and the way to
 obtain communication in the Perl
\begin_inset Formula $\rightarrow$
\end_inset 

C direction in an embedded virtual machine is linking an extension module
 to the virtual machine.
 Thus, part of LibScript-Perl is implemente as an XS module, exposed to
 the embedded virtual machine as the 
\family typewriter 
LibScript
\family default 
 Perl package.
 During the initialization of a virtual state, the pointer to the LibScript
 virtual environment is stored in this package, in the 
\family typewriter 
$LibScript::env
\family default 
 variable.
 The package that represents the virtual environment is created by the 
\family typewriter 
script_plugin_init_perl
\family default 
 function, executing the string of code 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 using the function 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

As Python does not feature facilities for launching multiple fully isolated
 virtual machines, the Python plugin implements virtual states only as separate
 modules, sharing a single global state.
 During the initialization of a state, a Python module with the name of
 the environment is created.
 The following excerpt of the 
\family typewriter 
script_plugin_init_python
\family default 
 function shows the sequence where the module is created and imported:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Get the name of the environment */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates the module.
 The first argument is the module name,
\layout LyX-Code


\size footnotesize 
\emph on 
   the second one the module's method list, which will start empty */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Get the globals dictionary */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the module to the global with its name */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
script_plugin_state
\family default 
 type is a typedef for 
\family typewriter 
PyObject*
\family default 
.
 The object returned by the initialization function is the elements dictionary
 of the module, obtained with 
\family typewriter 
PyModule_GetDict\SpecialChar \-
(module)
\family default 
.
 In this dictionary, we store the pointer to the virtual environment as
 the private attribute 
\family typewriter 
__env
\family default 
.
\layout Standard

Similarly, in Ruby virtual states are implemented as classes that share
 a single global state, since Ruby does not allow multiple isolated runtime
 environments either.
 In the initialization function, 
\family typewriter 
script_plugin_init_ruby
\family default 
, a class with the name of the virtual environment is created using the
 
\family typewriter 
rb_define_class
\family default 
 function.
 The pointer to the virtual environment is stored in a class constant as
 a number.
 The 
\family typewriter 
VALUE
\family default 
 corresponding to the new class is returned as the 
\family typewriter 
script_plugin_state
\family default 
.
\layout LyX-Code


\size footnotesize 
VALUE state;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (initialization of the interpreter omitted) ...
 */
\layout LyX-Code


\size footnotesize 
\emph on 
/* class_name is the name of the virtual environment,
\layout LyX-Code


\size footnotesize 
\emph on 
   with its initial converted to uppercase,
\layout LyX-Code


\size footnotesize 
\emph on 
   respecting Ruby's class naming convention */
\layout LyX-Code


\size footnotesize 
state = rb_define_class(class_name, rb_cObject);
\layout LyX-Code


\size footnotesize 
\emph on 
/* This assumes void* fits in a long */
\layout LyX-Code


\size footnotesize 
rb_const_set(state, rb_intern("@@LibScriptEnv"), INT2NUM((long)env));  
  
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
return (script_plugin_state) state;
\layout Subsection

Termination of states
\begin_inset LatexCommand \label{sub:Encerramento-de-estados}

\end_inset 


\layout Standard

Because Lua and Perl represent states in an independent way, state termination
 in these plugins is simple: the language structure which wraps the complete
 runtime environment is terminated.
 The implementation of the finalization function in the Lua plugin is the
 following:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* In Lua, a state is a lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Terminates the state.
 Does not affect other environments */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In Perl, the process, although a tad more elaborate, is essentially the
 same:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Some macros assume the interpreter pointer is called my_perl */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = (PerlInterpreter*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Some operations act on the 
\begin_inset Quotes eld
\end_inset 

current state
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      so the PERL_SET_CONTEXT macro must be used to 
\layout LyX-Code


\size footnotesize 
\emph on 
      switch the active interpreter */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* This flag must be activated so that the cleaning 
\layout LyX-Code


\size footnotesize 
\emph on 
      of an environment is complete, which is needed
\layout LyX-Code


\size footnotesize 
\emph on 
      when there may be more than one active interpreter */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Terminating the interpreter */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

In Python and Ruby, plugins need to keep track of the number of active states
 to deallocate the virtual machine only when it reaches zero.
 Besides, both in Ruby and Python there are no features in their APIs (or
 in the languages, actually) to remove, respectively, classes and modules.
 In Ruby, we could assign 
\family typewriter 
nil
\family default 
 to the constant that represents the class which describes the virtual environme
nt, but after that it is not possible to define a new class in its place:
 both 
\family typewriter 
rb_define_class
\family default 
 through C and 
\family typewriter 
class
\family default 
 
\emph on 
<Name>
\emph default 
 through Ruby indicating that the value was already defined with another
 type.
 Since Ruby features open classes, a 
\family typewriter 
class
\family default 
 
\emph on 
<Name>
\emph default 
 construct for an already existing 
\emph on 
<Name>
\emph default 
 is understood as a resumption of the class description, and not as the
 redefinition of 
\emph on 
<Name>
\emph default 
.
 Python, on its turn, does not provide API features for unloading modules,
 but allows assigning 
\family typewriter 
None
\family default 
 to the global referring the module.
 The module can then be imported again, but the same instance, stored internally
 by Python, will be returned.
 The following interactive command-line session allows us to observe this
 behavior, which happens both directly in Python as well as through the
 C API:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Thus, data structures referring to LibScript states are not terminated in
 LibScript-Python and LibScript-Ruby.
 This is the implementation of the termination routine in the Ruby plugin:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrements the state counter, a static global variable */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Terminates the interpreter if this is the last state */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Standard

The Python implementation is basically the same:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Passing arguments
\begin_inset LatexCommand \label{sub:Passagem-de-parâmetros}

\end_inset 


\layout Standard

Data transfer between the main library and plugins is concentrated in two
 operations: one to pass the contents of the LibScript argument buffer to
 the virtual machine data space and another to perform the inverse operation.
 The first one is used for passing input parameters when scripting language
 functions are called from C and for obtaining return values when the scripting
 language makes calls that are handled by C.
 The second operation, complementarily, is used for filling return values
 when C calls the scripting language and for input parameters when a scripting
 language call is handled by C code.
\layout Standard

In the implementation of LibScript-Lua, the 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 function converts the contents of the Lua stack to the LibScript argument
 buffer.
 The plugin function responsible for invoking Lua functions from C, 
\family typewriter 
script_plugin_call_lua
\family default 
, uses 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 to store in the LibScript buffer return values of the invoked Lua function,
 since these are returned in Lua's virtual stack.
 When Lua code calls functions implemented in C or some other plugin, 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 is used to convert the function's input parameters, also retreived through
 the virtual stack.
 Below, we see the implementation of this function:
\layout LyX-Code


\size footnotesize 
static void script_lua_stack_to_buffer(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int nargs; int i; 
\layout LyX-Code


\size footnotesize 
   nargs = lua_gettop(L);    
\emph on 
/* Number of elements in the Lua stack */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env); 
\emph on 
/* Empties the LibScript buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 1; i <= nargs; i++) {
\layout LyX-Code


\size footnotesize 
      
\emph on 
/* Checks the Lua type of element in stack position i */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* and for each type, convert the element and store in the buffer
 */
\layout LyX-Code


\size footnotesize 
      switch(lua_type(L, i)) { 
\layout LyX-Code


\size footnotesize 
      case LUA_TNUMBER:
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, lua_tonumber(L, i)); break; 
\layout LyX-Code


\size footnotesize 
      case LUA_TSTRING:
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i-1, lua_tostring(L, i)); break;
\layout LyX-Code


\size footnotesize 
      case LUA_TBOOLEAN:
\layout LyX-Code


\size footnotesize 
         script_put_bool(env, i-1, lua_toboolean(L, i)); break;
\layout LyX-Code


\size footnotesize 
      default:
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Unhandled types are replaced by zero */
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, 0);
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os valores de tipos desconhecidos são substituídos pelo valor zero, o que
 mantém a posição dos demais valores na lista de argumentos.
 Optamos por não sinalizar erro nesta situação para evitar aqui a geração
 de exceções, o que complicaria a exposição.
 A captura e propagação de erros serão vistas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
 This design decision coincides with the goal explained earlier of restricting
 the main library API to features available in all languages.
\layout Standard

The second data transfer function from LibScript-Lua, 
\family typewriter 
script_lua_buffer_to_stack
\family default 
, obtains values from the LibScript buffer and inserts them into Lua's virtual
 stack.
 This function is used to pass input arguments to Lua in 
\family typewriter 
script_plugin_call_lua
\family default 
 and to pass to Lua return values from the 
\family typewriter 
script_call
\family default 
 function, which is internally invoked by the plugin when Lua invokes a
 C function.
\layout LyX-Code


\size footnotesize 
static int script_lua_buffer_to_stack(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int i; char* s;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env); 
\emph on 
/* Number of elements in the buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Checks the type of element in buffer position i */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* and for each type, obtains it and inserts in in Lua's stack */
\layout LyX-Code


\size footnotesize 
      type = script_get_type(env, i);
\layout LyX-Code


\size footnotesize 
      switch (type) {
\layout LyX-Code


\size footnotesize 
      case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
         lua_pushnumber(L, script_get_double(env, i)); break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
         s = script_get_string(env, i); 
\emph on 
/* The string belongs to the caller */
\layout LyX-Code


\size footnotesize 
         lua_pushstring(L, s);
\layout LyX-Code


\size footnotesize 
         free(s); 
\emph on 
/* Frees the string, since Lua stores its own copy */
\layout LyX-Code


\size footnotesize 
         break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
         lua_pushboolean(L, script_get_bool(env, i)); break;
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return len;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In LibScript-Python, it was not possible to concentrate data transfer operations
 in two functions only.
 Each operation had to be split in two parts.
 The conversion of data sent from Python to the LibScript buffer was split
 into 
\family typewriter 
script_python_put_object
\family default 
 and 
\family typewriter 
script_python_tuple_to_buffer
\family default 
.
 The first function converts a single value Python and inserts it in the
 requested buffer position:
\layout LyX-Code


\size footnotesize 
static void script_python_put_object(script_env* env, int i, PyObject* o)
 {
\layout LyX-Code


\size footnotesize 
   if (PyString_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, PyString_AS_STRING(o));
\layout LyX-Code


\size footnotesize 
   else if (PyInt_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, PyInt_AS_LONG(o));
\layout LyX-Code


\size footnotesize 
   else if (PyLong_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyLong_AsDouble(o));
\layout LyX-Code


\size footnotesize 
   else if (PyFloat_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyFloat_AS_DOUBLE(o));
\layout LyX-Code


\size footnotesize 
   else if (PyBool_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, o == Py_True ? 1 : 0);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

It is important to note that Python types 
\family typewriter 
PyInt
\family default 
 and 
\family typewriter 
PyLong
\family default 
 do not correspond to C types 
\family typewriter 
int
\family default 
 and 
\family typewriter 
long
\family default 
: 
\family typewriter 
PyInt
\family default 
 is the integer type corresponding to the machine word size (analogous to
 
\family typewriter 
int
\family default 
), but a 
\family typewriter 
PyLong
\family default 
 is an arbitrary-precision integer.
 In LibScript, we represent 
\family typewriter 
PyLong
\family default 
s as 
\family typewriter 
double
\family default 
s.
 The LibScript API offers the 
\family typewriter 
script_put_int
\family default 
 function as a convenience, but internally, as it happens for example in
 Lua, all numbers are stored as 
\family typewriter 
double
\family default 
s.
\layout Standard

The second function, 
\family typewriter 
script_python_tuple_to_buffer
\family default 
, inserts elements of a tuple in the buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_tuple_to_buffer(script_env* env, PyObject* tuple)
 {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = PyTuple_GET_SIZE(tuple); 
\emph on 
/* Number of elements in the tuple */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);          
\emph on 
/* Empties the LibScript buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = PyTuple_GET_ITEM(tuple, i); 
\emph on 
/* Get a tuple element */
\layout LyX-Code


\size footnotesize 
      script_python_put_object(env, i, o);      
\emph on 
/* Insert it in the buffer */
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The inverse operation, for transferring data from the LibScript buffer to
 Python, is also implemented in two functions, one handling objects individually
 and another handling tuples.
 The 
\family typewriter 
script_get_object
\family default 
 function converts a buffer element to an equivalent 
\family typewriter 
PyObject
\family default 
:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_get_object(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   PyObject* ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return PyFloat_FromDouble(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      PyObject* ret = PyString_FromString(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return PyBool_FromLong(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
script_python_buffer_to_tuple
\family default 
 function generates a tuple containing every element of the LibScript buffer:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_buffer_to_tuple(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   PyObject* ret = PyTuple_New(len);
\layout LyX-Code


\size footnotesize 
   for(i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = script_python_get_object(env, i);
\layout LyX-Code


\size footnotesize 
      PyTuple_SetItem(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This way, these two pairs of functions perform functions equivalent to 
\family typewriter 
script_lua_\SpecialChar \-
stack_to_buffer
\family default 
 and 
\family typewriter 
script_lua_buffer_to_stack
\family default 
 do in the Lua script.
 They were separated in two parts because of the model for return values
 in Python functions: for the case of multiple return values, they are returned
 as a tuple; for single values, they are passed directly.
 This is made evident in the following excerpt of the 
\family typewriter 
script_plugin_call_python
\family default 
 function:
\layout LyX-Code


\size footnotesize 
PyObject *ret, *args;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
args = script_python_buffer_to_tuple(env);  
\emph on 
/* Get input parameters */
\layout LyX-Code


\size footnotesize 
ret = PyEval_CallObject(func, args); 
\emph on 
       /* Call a Python function */
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
if (ret == Py_None)                         
\emph on 
/* If the function returned no values */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);                
\emph on 
/* Just empty the LibScript buffer */
\layout LyX-Code


\size footnotesize 
else if (PyTuple_Check(ret))                
\emph on 
/* If a tuple was returned */
\layout LyX-Code


\size footnotesize 
   script_python_tuple_to_buffer(env, ret); 
\emph on 
/* Insert its elements in the buffer */
\layout LyX-Code


\size footnotesize 
else                                        
\emph on 
/* If another type was returned */
\layout LyX-Code


\size footnotesize 
   script_python_put_object(env, 0, ret);   
\emph on 
/* Insert it as the only element */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In the plugin handler for calls to external functions, communication in
 the opposite direction follows a similar logic:
\layout LyX-Code


\size footnotesize 
script_python_tuple_to_buffer(env, args);    
\emph on 
/* Get input parameters */
\layout LyX-Code


\size footnotesize 
err = script_call(env, fn_name);             
\emph on 
/* Call a function through LibScript */
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
switch(script_buffer_len(env)) {
\layout LyX-Code


\size footnotesize 
case 0:                                      
\emph on 
 /* If the function returned no values */
\layout LyX-Code


\size footnotesize 
   Py_RETURN_NONE;                           
\emph on 
 /* Return the Python value 'None' */
\layout LyX-Code


\size footnotesize 
case 1:                                      
\emph on 
 /* If a single value was returned */
\layout LyX-Code


\size footnotesize 
   return script_python_get_object(env, 0);  
\emph on 
 /* Convert it and return it */
\layout LyX-Code


\size footnotesize 
default:                                      
\emph on 
/* If more than one value was returned */
\layout LyX-Code


\size footnotesize 
   return script_python_buffer_to_tuple(env); 
\emph on 
/* Return them in a tuple */
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Like in Python, Ruby functions return multiple values by wrapping them in
 an aggregate type.
 This way, data transfer operations in LibScript-Ruby are also split into
 pairs of functions, one converting a buffer value and another operating
 on a Ruby array.
 The analogous function to 
\family typewriter 
script_python_put_object
\family default 
 is 
\family typewriter 
script_ruby_put_value
\family default 
:
\layout LyX-Code


\size footnotesize 
static void script_ruby_put_value(script_env* env, int i, VALUE arg) {
\layout LyX-Code


\size footnotesize 
   switch (TYPE(arg)) {
\layout LyX-Code


\size footnotesize 
   case T_FLOAT:
\layout LyX-Code


\size footnotesize 
   case T_FIXNUM:
\layout LyX-Code


\size footnotesize 
   case T_BIGNUM:
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, NUM2DBL(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_STRING:
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, StringValuePtr(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_TRUE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 1); break;
\layout LyX-Code


\size footnotesize 
   case T_FALSE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 0); break;
\layout LyX-Code


\size footnotesize 
   default:
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Here, some problems of the Ruby API become apparent.
 Besides the inconsistency in the naming of object conversion function names,
 the meaning of the value returned by the 
\family typewriter 
TYPE
\family default 
 macro can only be understood through the internal representation of 
\family typewriter 
VALUE
\family default 
s in Ruby's implementation, and not through the type hierarchy of language
 objects.
 Classes that has special handling in the internal structure of 
\family typewriter 
VALUE
\family default 
s have constants associated to them, such as 
\family typewriter 
T_FLOAT
\family default 
 and 
\family typewriter 
T_STRING
\family default 
; the rest are identified only as 
\family typewriter 
T_OBJECT
\family default 
s.
 The use of 
\family typewriter 
T_TRUE
\family default 
 and 
\family typewriter 
T_FALSE
\family default 
 may lead to think that some specific values also return special results
 for 
\family typewriter 
TYPE
\family default 
.
 Indeed, these values are defined as 
\family typewriter 
VALUE
\family default 
s that do not correspond to Ruby heap indices and are handled especially
 by the implementation.
 From the point of view of Ruby code, however, this classification of values
 true and false as separate types in the C API is justified by defining
 them as singletons of classes 
\family typewriter 
TrueClass
\family default 
 and 
\family typewriter 
FalseClass
\family default 
, an approach probably influenced by Smalltalk.
 Unlike Smalltalk, though, where True and False are subclasses of Boolean,
 in Ruby 
\family typewriter 
TrueClass
\family default 
 and 
\family typewriter 
FalseClass
\family default 
 are direct subclasses of 
\family typewriter 
Object
\family default 
.
 This brings the inconvenience that checking if a type matches a boolean
 value two tests are needed.
\layout Standard

Like LibScript-Python has a function to store in the buffer elements from
 a tuple, LibScript-Ruby has a function to store elements of an array:
\layout LyX-Code


\size footnotesize 
static void script_ruby_array_to_buffer(script_env* env, VALUE array) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = RARRAY(array)->len;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = rb_ary_entry(array, i);
\layout LyX-Code


\size footnotesize 
      script_ruby_put_value(env, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Ruby does not have a function in its C API to return the size of an array;
 instead, the internal structure of 
\family typewriter 
VALUE
\family default 
 is exposed through the 
\family typewriter 
RARRAY
\family default 
 macro (which just wraps a cast).
\layout Standard

Operations for converting values from the LibScript buffer to Ruby are also
 similar to those implemented in the Python plugin.
 Again, where in Python there is a function for manipulating tuples, we
 have in Ruby a function that operates on arrays:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_get_value(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   VALUE ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return rb_float_new(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      ret = rb_str_new2(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return script_get_bool(env, i) ? Qtrue : Qfalse;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\newline 
static VALUE script_ruby_buffer_to_array(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   VALUE ret = rb_ary_new2(len);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = script_ruby_get_value(env, i);
\layout LyX-Code


\size footnotesize 
      rb_ary_store(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In a similar way to the Python plugin, the implementation of Ruby function
 calls from LibScript uses the 
\family typewriter 
script_ruby_buffer_to_array
\family default 
 to convert input parameters and functions 
\family typewriter 
script_ruby_put_value
\family default 
 or 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 to convert the return value, depending on the number of values returned
 (or, more precisely, if the function has returned an array or not).
 In calls to LibScript functions from Ruby, input parameters are converted
 with 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 and return values are converted with 
\family typewriter 
script_ruby_get_value
\family default 
 or 
\family typewriter 
script_ruby_buffer_to_array
\family default 
.
\layout Standard

In the Perl plugin, we have three functions: data transfer from the stack
 to the LibScript buffer was implemented in a single function like in Lua,
 but transfer in the opposite direction had to be split in two functions,
 like in Python and Ruby.
 This asymmetry comes from the fact that handling of return values is wrapped
 by the XS pre-processor through the 
\family typewriter 
RETVAL
\family default 
 variable; so, in this situation we cannot manipulate the stack directly,
 but only pass 
\family typewriter 
SV
\family default 
s as output values.
\layout Standard

Transferring data from the Perl stack to the LibScript buffer is reasonably
 simple: 
\layout LyX-Code


\size footnotesize 
void script_perl_stack_to_buffer(pTHX_ int ax, script_env* env,
\layout LyX-Code


\size footnotesize 
                                 int count, int offset) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < count; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtain a pointer to a SV from Perl's stack */
\layout LyX-Code


\size footnotesize 
      SV* o = ST(offset+i);
\layout LyX-Code


\size footnotesize 
      if (SvIOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, SvIV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvNOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i, SvNV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvPOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i, SvPV_nolen(o));
\layout LyX-Code


\size footnotesize 
      else
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This functions' input parameters deserve mention.
 Initially, we have the 
\family typewriter 
pTHX_
\family default 
 macro.
 This macro was added to the API when Perl started allowing multiple simultaneou
s interpreters per process: API functions were transformed into macros that
 wrap this first argument.
 For example, 
\family typewriter 
eval_sv
\family default 
 can be called as 
\family typewriter 
Perl_eval_sv
\family default 
, passing the 
\family typewriter 
aTHX_
\family default 
 macro as an initial parameter.
 In general the use of these macros remains implicit, but when writing functions
 that use the Perl API it becomes necessary to use the pTHX_ macro in declaratio
ns
\begin_inset Foot
collapsed true

\layout Standard

The 
\family typewriter 
pTHX_
\family default 
 is used without a comma separating it from the following argument.
 When it is the only argument, one should use 
\family typewriter 
pTHX
\family default 
.
\end_inset 

, to propagate interpreter state information through function calls, and
 
\family typewriter 
aTHX_
\family default 
 in calls.
\layout Standard

Another symptom that the Perl API was designed more for internal use of
 the XS pre-processor than for direct manipulation shows in the second argument,
 
\family typewriter 
ax
\family default 
.
 Some macros assume the existence of this value, which is not propagated
 by 
\family typewriter 
pTHX_
\family default 
, but is implictly declared when functions are wrapped with XS.
 The API seems to assume that an XS function will not invoke another C function
 which also uses the API.
 We had to propagate the variable ourselves (which is mentioned in the documenta
tion, but only as 
\begin_inset Quotes eld
\end_inset 

the 'ax' variable
\begin_inset Quotes erd
\end_inset 


\emph on 
\SpecialChar ~

\emph default 

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

, with no explanations of its purpose).
\layout Standard

The other two parameters, count and offset, are needed due to the different
 ways that the information they represent are obtained in the two contexts
 where this function is used.
 In other plugins, we can obtain the number of input elements in a uniform
 way (checking the number of elements in a Python tuple, for example).
 In Perl, in the two situations where the function is called, the number
 of elements to be read from the stack should be obtained in different ways,
 and because of that we pass it as the 
\family typewriter 
count
\family default 
 parameter.
 In the routine that calls LibScript functions, implemented in the XS file,
 the size of the stack is obtained through a special variable, 
\family typewriter 
items
\family default 
.
 When calling Perl functions, the value of 
\family typewriter 
count
\family default 
 is obtained as the result of the invocation function, 
\family typewriter 
Perl_call_pv
\family default 
.
\layout Standard

The start position from where to obtain elements (
\family typewriter 
offset
\family default 
) also varies.
 Inside the XS function, input parameters start from position 2, because
 LibScript passes the environment pointer and function name in the first
 two arguments.
 In calls to Perl functions, the value of offset is zero because, as seen
 in the protocol for invocation of Perl functions discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

, the stack bottom is adjusted after the function call by the 
\family typewriter 
SPAGAIN
\family default 
 macro.
\layout Standard

Conversion of values from the LibScript buffer to the Perl stack is implemented
 in two functions, one that generates a single 
\family typewriter 
SV
\family default 
 and another that pushes all elements:
\layout LyX-Code


\size footnotesize 
SV* script_perl_get_sv(pTHX_ script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE: return newSVnv(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* 0 indicates that the size of the string should be computed by Perl
 */
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING: return newSVpv(script_get_string(env, i), 0);
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL: return newSViv(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
  
\newline 
SV** script_perl_buffer_to_stack(pTHX_ SV** sp, script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      XPUSHs(sv_2mortal(script_perl_get_sv(aTHX_ env, i)));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return sp;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Again, a variable created internally by Perl had to be propagated explicitly:
 
\family typewriter 
sp
\family default 
, the stack pointer.
 This variable is referenced internally by the 
\family typewriter 
xPUSHs
\family default 
 macro.
 Besides, as XPUSHs can resize the stack, we need to return the updated
 value of 
\family typewriter 
sp
\family default 
 back to the caller.
 Apart from that, generation of SVs, their registration as mortal variables
 and their insertion in the stack happens as usual, as presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
\layout Standard

Like in the other plugins, the transfer of input parameters in LibScript-Perl,
 both for Perl functions and for functions called through LibScript, is
 made calling the conversion function that acts on the buffer as a whole:
 when calling Perl functions we use 
\family typewriter 
script_perl_buffer_to_stack
\family default 
 and for functions called using LibScript, 
\family typewriter 
script_perl_stack_to_buffer
\family default 
.
 For handling return values for Perl functions, we were able to use directly
 the 
\family typewriter 
script_perl_stack_to_buffer
\family default 
 function, not unlike it was done in LibScript-Lua.
 For the return value of functions called using LibScript, however, we need
 to deal with the special XS variable 
\family typewriter 
RETVAL
\family default 
 and with the different call contexts of Perl.
 The excerpt below illustrates the handling of return values in this case:
\layout LyX-Code


\size footnotesize 
err = script_call(env, function_name);
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (error handling omitted) ...
 */
\layout LyX-Code


\size footnotesize 
switch (GIMME_V) {
\layout LyX-Code


\size footnotesize 
case G_SCALAR:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Return the first item of the buffer */
\layout LyX-Code


\size footnotesize 
   RETVAL = script_perl_get_sv(aTHX_ env, 0);
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_ARRAY:
\layout LyX-Code


\size footnotesize 
   len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Create an array */
\layout LyX-Code


\size footnotesize 
   RETVAL = (SV*)newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Returned arrays have to be marked as mortal */
\layout LyX-Code


\size footnotesize 
   sv_2mortal((SV*)RETVAL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Insert the contents of the buffer in the array */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++)
\layout LyX-Code


\size footnotesize 
      av_push((AV*)RETVAL, script_perl_get_sv(aTHX_ env, i));
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_VOID:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* As the return value is discarded in void contexts, */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* we return the Perl constant undef */
\layout LyX-Code


\size footnotesize 
   RETVAL = &PL_sv_undef;
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
}
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Function calls
\layout Standard

In LibScript plugins, functions implemented externally (in C or other plugins)
 are located only in the moment when they are called.
 The goal here, besides optimizing initialization time and memory consumption
 in the scripting language runtime environment (avoiding the declaration
 of functions that will not be used), is to allow the location of functions
 declared after the environment's initialization.
 To allow function resolution in a dynamic way, it is necessary to capture
 the access to missing elements in the structure which describes the virtual
 environment to the plugin and forward the call to the main library using
 
\family typewriter 
script_call
\family default 
.
 When comparing approaches employed in each plugin to get this behavior,
 we can evaluate some meta-programming features provided by each language
 and their availability through their APIs.
\layout Standard

As seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, in Lua, during plugin initialization, a table is created and stored in
 a global variable with the same name as the environment.
 Functions are inserted dynamically in this table through a metatable associated
 to it right after its creation in 
\family typewriter 
script_plugin_init_lua
\family default 
.
 The 
\family typewriter 
__index
\family default 
 field of this metatable points to a C function internal to the plugin,
 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, which is then invoked always that a nonexistent element is requested in
 the table.
 The 
\family typewriter 
script_lua_make_caller
\family default 
 function creates a C closure, which consists of another C function internal
 to the plugin (
\family typewriter 
script_lua_caller
\family default 
) and the name of the requested function.
 This closure is associated to the proper entry in the environment table.
 This way, calls to functions implemented externally are resolved by 
\family typewriter 
script_lua_caller
\family default 
, which will pass them on to 
\family typewriter 
script_call
\family default 
.
\layout Standard

In the Python plugin, when calling a function in the virtual environment
 module, the module's 
\family typewriter 
__getattro
\family default 
 callback, defined as the internal function 
\family typewriter 
script_python_get
\family default 
, is called.
 This function searches for an entry in the module's dictionary and, if
 it is not found, creates an object of the 
\family typewriter 
script_python_object
\family default 
 type, and returns it as the result of 
\family typewriter 
__getattro
\family default 
.
 This data type is declared in the plugin as a Python class, whose instances
 contain a pointer to the virtual environment and a C string with the name
 of the function they represent.
 These objects have their 
\family typewriter 
__call
\family default 
 callback defined as 
\family typewriter 
script_python_caller
\family default 
, a function that, like 
\family typewriter 
script_lua_caller
\family default 
, converts its received parameters to the LibScript buffer, invokes 
\family typewriter 
script_call
\family default 
 and converts the return values back to Python.
 Therefore, objects of this type are 
\emph on 
functors
\emph default 
, and behave similarly to the closure defined in the Lua plugin.
\layout Standard

Function resolution is implemented in Ruby using the 
\family typewriter 
method_missing
\family default 
 method, which is a language-defined fallback, always called when a nonexistent
 method is invoked in a class.
 Unlike 
\family typewriter 
__getattro
\family default 
 in Python and 
\family typewriter 
__index
\family default 
 in Lua, which are attribute access handlers and therefore need to return
 an object which is called in a later step, 
\family typewriter 
method_missing
\family default 
 handles calls directly.
 Hence, when invoked, 
\family typewriter 
method_missing
\family default 
 receives the name of the requested method and the given parameters and
 forwards them to 
\family typewriter 
script_call
\family default 
.
\layout Standard

In the Perl plugin, like in Lua and Python, there is also a C function responsib
le for invoking 
\family typewriter 
script_call
\family default 
 and converting input parameters and return values.
 So that this function, 
\family typewriter 
script_perl_caller
\family default 
, can be exposed to the Perl interpreter, it is implemented in an XS module.
 Once the module is loaded the function is visible in Perl as 
\family typewriter 
LibScript::caller
\family default 
.
 Dynamic resolution of functions from the Perl package representing the
 LibScript virtual environment is done using the 
\family typewriter 
AUTOLOAD
\family default 
 Perl function, which behaves like 
\family typewriter 
method_missing
\family default 
 in Ruby, capturing calls to missing functions.
 In the plugin's initialization function, Perl code is executed to load
 the extension module, initialize the environment package and insert in
 it an 
\family typewriter 
AUTOLOAD
\family default 
 function which will call 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
   "bootstrap LibScript;"   
\emph on 
/* Initializes the extension module */
\layout LyX-Code


\size footnotesize 
   "package %s;" 
\emph on 
           /* Declare the environment package */
\layout LyX-Code


\size footnotesize 
   "$LibScript::env = %p;"  
\emph on 
/* Store the enviroment pointer in Perl */
\layout LyX-Code


\size footnotesize 
   "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
      "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Extract the method name from the qualified 
\begin_inset Quotes eld
\end_inset 

package::method
\begin_inset Quotes erd
\end_inset 

 name */
\layout LyX-Code


\size footnotesize 
      "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Invokes caller passing the environment pointer, */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* the method name, and the argument array */
\layout LyX-Code


\size footnotesize 
\emph on 
      
\emph default 
"LibScript::caller(%p, $AUTOLOAD, @_);"  
\layout LyX-Code


\size footnotesize 
   "}",
\layout LyX-Code


\size footnotesize 
   state->package, env, env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Evaluate the code string:
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indicates that any errors should be reported.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Subsection

Capturing errors
\begin_inset LatexCommand \label{sub:Captura-de-erros}

\end_inset 


\layout Standard

Plugins should capture the occurrence of runtime errors when executing strings
 of code and function calls.
 In Lua, both operations are performed using the 
\family typewriter 
lua_pcall
\family default 
 function, which indicates errors in its return value.
 In case of errors, the error message is obtained from the top of Lua's
 virtual stack and propagated to the main library using 
\family typewriter 
script_set_error_message
\family default 
.
 In case of execution of strings of code, compilation errors are detected
 through the return value of 
\family typewriter 
luaL_loadstring
\family default 
, which loads code to be executed by 
\family typewriter 
lua_pcall
\family default 
.
\layout Standard

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno das
 funções de execução de strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, e de chamada de funções, 
\family typewriter 
PyEval_CallObject
\family default 
.
 No caso de erros, chamamos a função 
\family typewriter 
PyErr_Occurred
\family default 
, que retorna um objeto Python representando a exceção.
 A mensagem de erro é obtida convertendo este objeto para uma string Python
 usando 
\family typewriter 
PyObject_Str
\family default 
, e finalmente para uma string C com 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

In Python, the occurrence of errors is signalled by the return value of
 functions for executing strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, and for calling functions, 
\family typewriter 
PyEval_CallObject
\family default 
.
 In case of errors, we call the 
\family typewriter 
PyErr_Occurred
\family default 
 function which returns a Python object representing the exception.
 The error message is obtained converting this object to a Python string
 using 
\family typewriter 
PyObject_Str
\family default 
, and finally to a C string with 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

In Perl, errors are signalled in the special variable 
\family typewriter 
$@
\family default 
; its contents can be checked from the C API with the 
\family typewriter 
ERRSV
\family default 
 macro.
 The presence of errors is tested with 
\family typewriter 
SvTRUE(ERRSV)
\family default 
, and the error message can be obtained converting this variable to a C
 string with the 
\family typewriter 
SvPV
\family default 
 macro.
\layout Standard

Ruby provides a function for executing strings of code, 
\family typewriter 
rb_eval_string
\family default 
, and a variant that captures errors and signals them through its return
 value, 
\family typewriter 
rb_eval_string_protect
\family default 
.
 However, for method calls, there is no protected version of 
\family typewriter 
rb_funcall
\family default 
.
 The only function provided by the API to protect calls, 
\family typewriter 
rb_protect
\family default 
, does not get as a parameter a Ruby method, but a C function instead.
 To call Ruby methods in a protected way, we had to write a C function that
 wraps the call:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_pcall(VALUE args) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extract the method name from the arguments array */
\layout LyX-Code


\size footnotesize 
   ID fn_id = SYM2ID(rb_ary_pop(args)); 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extract the class from the arguments array */
\layout LyX-Code


\size footnotesize 
   VALUE klass = rb_ary_pop(args);
\layout LyX-Code


\size footnotesize 
   return rb_apply(klass, fn_id, args);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

and then invoke it using 
\family typewriter 
rb_protect
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insert the class in the arguments array */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, klass);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insert the method name in the arguments array */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, ID2SYM(rb_intern(fn)));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Call the wrapper function */
\layout LyX-Code


\size footnotesize 
ret = rb_protect(script_ruby_pcall, args, &error); 
\layout LyX-Code


\size footnotesize 
if (error) {
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   script_set_error_message(env, StringValuePtr(ruby_errinfo));
\layout LyX-Code


\size footnotesize 
   ruby_errinfo = Qnil;
\layout LyX-Code


\size footnotesize 
   return SCRIPT_ERRLANGRUN;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

As 
\family typewriter 
rb_protect
\family default 
 passes a single 
\family typewriter 
VALUE
\family default 
 to the C function, we had to store the class, method identifier and all
 input parameters of the Ruby method to be invoked in a Ruby array.
 The occurrence of errors is signalled in a variable passed as the third
 parameter of rb_protect, and the error message is obtained in the global
 
\family typewriter 
VALUE
\family default 
 
\family typewriter 
ruby_errinfo
\family default 
.
\layout Section

Conclusions
\layout Standard

The case study presented here illustrated, through the implementation of
 plugins, the process of embedding four scripting languages interfacing
 a given C API.
 Several aspects of the interaction between C and scripting languages were
 covered, contemplating initialization and termination of their runtime
 environments, passing data and calling functions in both directions and
 signalling errors.
 From that, we can make some observations on the adequacy of those languages
 as embedded environments in applications.
\layout Standard

In many applications it is important to have isolation between each script
 executed, such as for example, when one scripts from different customers
 running in a web server.
 As we have seen, Lua and Perl allow launching multiple runtime environments,
 which gives isolation guarantees.
 Python and Ruby, on the other hand, allow only a single state, reducing
 their applicability for scenarios where scripts need to run isolated from
 each other
\begin_inset Foot
collapsed true

\layout Standard

In Python it is possible to alternate the globals table during the execution
 of different threads, which offers an alternative, even if less than straightfo
rward, to obtain isolation.
 Even then, the global state shared by extension modules in the same.
\end_inset 

.
 These two languages have yet another problem: in some cases it is not possible
 to bring its data space back to the original state during the execution
 of an application.
 In Python, imported modules cannot be unloaded.
 In Ruby, a class cannot be redefined (only extended) and 
\family typewriter 
ID
\family default 
s are not collected.
\layout Standard

In the implementation of the Perl plugin it became evident that its API
 was not designed for embedding the interpreter in applications.
 Besides demanding the development of an extension module so that Perl code
 can access C functions, we observed here that its API is incomplete with
 regard to its use as an embedded language.
 Many macros were developed assuming they would always be invoked from code
 written in XS files, or even by code generated by the XS pre-processor.
 This is confirmed by the need to pass additional undocumented parameters
 so that macros work, as presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

.
\layout Standard

Lua, on its turn, has shown to be appropriate as an embedded language, not
 sharing the limitations described here about other languages.
 Besides, it features a simple API, which handles language constructs in
 a complete and orthogonal way, which is due both to the focus of its implementa
tion as an embedded language, and to the minimalist design of the language
 itself.
 Even in small projects like the one presented here, which exercises only
 a small fraction of the APIs, we could observe that aspects where languages
 define special cases or have less uniformity leak through their C APIs.
 Both in Python and Ruby, functions returning multiple values cause implicit
 conversions to aggregate types (lists and arrays).
 In a similar way, multiple results are represented in Perl as array contexts.
 In their respective LibScript plugins, these features had to be handled
 especially.
 In the Lua plugin, in contrast, handling a single return value is no different
 from handling multiple values, like it happens in native language code.
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Conclusions
\layout Standard

Choosing a scripting language depends on a series of factors, many of them
 relative to the language itself, others relative to its implementation.
 When we deal with multi-language development scenarios, an aspect that
 should not be neglected is the design of interfaces between languages.
 Be it extending the scripting language through C code, or making a C applicatio
n extensible through a scripting language, the API offered by the language
 has a fundamental role, often influencing the design of the application.
\layout Standard

This work discussed the main issues faced in the integration between C code
 and the runtime environment of a scripting language.
 We presented how the APIs of five languages handle these issues, indicating
 positive and negative points of the various approaches used.
 We performed a practical comparison of the use of these APIs through a
 case study where scripting languages were embedded to C libraries exporting
 one single interface.
 The implementation consists of a generic scripting library, called LibScript,
 and a series of plugins which interface different languages.
 We were able, this way, to observe how they handle important aspects related
 to embedded languages, such as passing data, function calls between two
 languages, error handling and isolation of runtime environments within
 applications.
\layout Standard

Although the same general problems, such as data transfer, function registration
 and calling, are common to different usage scenarios of a scripting language
 API, applications embedding a virtual machine tend to demand more from
 the API than libraries implementing extension modules.
 This point is illustrated by the difficulties imposed by the Python API
 both in the access to global variables and registration of global functions;
 and, more evidently, by the complexity of Perl's API for function calls.
\layout Standard

The fact that the Python API makes the use of global variables and functions
 difficult, favoring the use of modules, can be justified as a way to promote
 a more structured programming discipline.
 This is interesting when using the API for developing extension modules,
 given that using global variables and functions is extremely harmful in
 those cases, as it would pollute the namespace of Python applications.
 For the case where the language is embedded to provide scripting support
 for a C application, the absence of a convenient way to define global functions
 in the scripts' namespace is questionable.
\layout Standard

The approach adopted by Perl, using a pre-processor which generates automaticall
y code for converting data when passing parameters and return values, has
 shown to be inadequate for scenarios involving embedded interpreters.
 Although the use of a pre-processor simplifies the simpler cases of declaration
 of C functions, the lack of a well-defined API for handling data transfer
 between the Perl interpreter and C code becomes apparent in more elaborate
 cases.
 Two of these situations happened in our case study: when receiving vararg
 parameters and when handling return values supporting multiple call contexts.
 Both demanded manipulation of low-level structures and constructs which
 the pre-processor aims to hide.
\layout Standard

Interesting observations resulted from the comparison of the Java API with
 that from the other four scripting languages, given than, although it shares
 several traits with those languages, Java is not considered a scripting
 language.
 While static typing does reduce considerably the need for explicit data
 conversion in C code for primitive types of the language, in practice type
 checking for objects and the linking of fields and methods happens in a
 dynamic way, as these have to be performed at runtime by the JNI.
 Thus, regarding interaction of the virtual machine with C, advantages brought
 by static typing are reduced.
 Besides, dynamic resolution of fields and methods through C has subtle
 differences in behavior when compared to what occurs in native Java code,
 which can be a source of programmer errors.
\layout Standard

When comparing APIs, we considered only their interfaces, making a qualitative
 usability analysis of each of them from the perspective of a C programmer,
 and not a quantitative analysis of their implementations.
 The performance cost added by code which performs bridging between two
 languages, for example, cannot be disconsidered.
 Many design decisions from an API are influenced by implementation requirements
 such as portability or performance restrictions.
 For example, automatic handling of scope of 
\family typewriter 
VALUE
\family default 
s in Ruby, scanning the C stack, brings great convenience to the programmer,
 but reduces the portability of its implementation.
\layout Standard

The disparity between languages with regard to the availability of documentation
 also deserves mention.
 Java, Python and Lua feature extensive documentation, both for the languages
 themselves and to their C APIs.
 For those languages, we were able to largely base our study and the implementat
ion of examples for the case study in the provided documentation.
 The documentation of Ruby relative to its C API is sparser; in\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 only part of its public API is covered.
 We had to make use of undocumented functions for tasks as fundamental as
 freeing global references registered through C.
 During the development of the Ruby plugin for the case study, we referred
 frequently to its source code to understand aspects which are not covered
 by the documentation about the behavior of its public functions.
 The documentation for Perl's C API is also incomplete, spread over several
 Unix manual pages included in its distribution, and in certain cases, out-of-da
te.
 To understand the various protocols involved in the practical use of the
 Perl API, we had to resort to the source code of applications using it.
\layout Standard

The balance between simplicity and convenience is another recurring theme
 when comparing APIs.
 Python's extensive API, containing 656 public functions, contrasts with
 the 113 functions exposed by the Lua API (79 from the core API, 34 in its
 auxiliary API).
 In many situations, Python API functions abbreviate two, three ore even
 more calls, as in the case of powerful functions such as 
\family typewriter 
Py_BuildValue
\family default 
 and 
\family typewriter 
PyObject_CallFunction
\family default 
, resulting in short and readable C code.
 The approach defended by Lua is that of a minimalistic API, offering mechanisms
 with which more elaborate functionality can be built.
 In fact, in \SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 a C function equivalent to 
\family typewriter 
PyObject_CallFunction
\family default 
 is presented, using the Lua API.
 
\layout Standard

Ruby exports 530 functions in its header and Perl 1209, but as only a small
 fraction of those is documented, it is hard to evaluate the size of their
 
\begin_inset Quotes eld
\end_inset 

public API
\begin_inset Quotes erd
\end_inset 

 and how many of these are just function for internal use exposed in their
 headers
\begin_inset Foot
collapsed true

\layout Standard

Some functions are marked as being for internal use only, but most of them
 have no indication whatsoever.
\end_inset 

.
 This also shows that the documentation is not relevant as support material
 for development, but it also indicates how well-defined an API is.
\layout Standard

The Java API is well-documented, like that from Python and Lua, but the
 number of exported function is not a good parameter for comparison with
 the other APIs as, because of statically defined types, many functions
 have a variant for each primitive type.
 Java exports its API as a structure containing function pointers; 228 functions
 in total are exported in this structure.
\layout Standard

Another aspect that could be observed in this work is that the consistency
 of an API depends greatly on the consistency of the language it exposes.
 Constructions where a language lacks orthogonality, such as code blocks
 in Ruby or the differences when manipulating scalar and array values in
 Perl, end up increasing the complexity of the API and demand from the programme
r specific handling in C code.
\layout Standard

As possibilities for future work, this work can be extended through the
 study of other aspects of scripting language.
 A possible focus is the performance impact of different API designs in
 multi-language applications.
 Another is the relation between the design of a virtual machine and its
 respective API.
 Additionally, another perspective for future work lies in the continued
 development of the LibScript library.
 Possibilities include adding new plugins, review its API and exercise it
 by embedding the library in actual applications.
 LibScript and the four plugins implemented in this work are free software
 and are available for download at\SpecialChar ~

\begin_inset LatexCommand \url{http://libscript.sourceforge.net}

\end_inset 

.
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{dissert}

\end_inset 


\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

The LibScript API
\layout Section

Startup and termination
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Initializes LibScript and returns a pointer to a virtual enviroment.
 The 
\family typewriter 
namespace
\family default 
 argument indicates the name to be used in structures to be created in the
 namespace of virtual machines to represent the virtual environment.
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Terminates the virtual environment.
\layout Section

Function registration
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Type of C functions to be registered in the virtual environment.
 When exposing an existing API to LibScript, the function will typically
 be a wrapper that loads input parameters from the environment, calls a
 program function and sends output parameters back to the environment.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registers a new C function in the virtual environment.
\layout Section

Arguments buffer
\layout Itemize


\family typewriter 
double script_get_double(script_env* env, int index)
\newline 
int script_get_int(script_env* env, int index)
\newline 
int script_get_bool(script_env* env, int index)
\newline 
const char* script_get_string(script_env* env, int index)
\family default 

\newline 
Obtain data from the buffer.
 These functions should be called by the beginning of wrapper functions.
 For each input parameter a call should be performed.
 Once done, one can invoke the 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
 macro, which terminates the function with an error code in case any of
 these function have not found data of the expected type (the API does not
 perform automatic conversion between strings and numbers).
 In 
\family typewriter 
script_get_string
\family default 
, the returned string belongs to the caller, which becomes responsible for
 deallocating it.
\layout Itemize


\family typewriter 
script_type script_get_type(script_env* env, int index)
\newline 
int script_buffer_len(script_env* env)
\newline 

\family default 
These functions allow writing C functions that perform type checking and
 verify the number of arguments at runtime.
 The 
\family typewriter 
script_get_type
\family default 
 function obtains the type of the requested buffer element and 
\family typewriter 
script_buffer_len
\family default 
 returns the number of arguments in the buffer.
\layout Itemize


\family typewriter 
void script_put_double(script_env* env, int index, double value)
\newline 
void script_put_int(script_env* env, int index, int value)
\newline 
void script_put_bool(script_env* env, int index, int value)
\newline 
void script_put_string(script_env* env, int index, const char* value)
\newline 

\family default 
Insert data in the buffer.
 By the end of a function, return values should be passed with calls to
 these functions and a 
\family typewriter 
SCRIPT_OK
\family default 
 error code as the return value of the C function.
\layout Itemize


\family typewriter 
void script_reset_buffer(script_env* env)
\family default 

\newline 
Empties the buffer.
\layout Section

Running code
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Runs a string of code in a given language.
 If necessary, the appropriate plugin is loaded and initialized.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Convenience function; loads the contents of a file and runs it with 
\family typewriter 
script_run
\family default 
.
 
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_put_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_get_*
\family default 
.
 Inicialmente, a tabela de funções C do ambiente virtual é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas na representação do ambiente virtual definido para
 a LibScript na máquina virtual da linguagem (isto é, no nome criado com
 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\newline 
void script_set_error_message(script_env* env, const char* message)
\newline 

\family default 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
 A função 
\family typewriter 
script_set_error_message
\family default 
 define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente virtual deve ser
 exposto à máquina virtual de alguma forma apropriada para a linguagem (como
 uma tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 O estado da máquina virtual e o ponteiro para o ambiente LibScript devem
 ser armazenados de modo a ser posteriormente acessíveis a partir deste
 handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_get_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_put_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\the_end
