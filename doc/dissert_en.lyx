#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{a4wide}
\usepackage{indentfirst}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Standard


\backslash 
autor{Hisham H.
 Muhammad}
\layout Standard


\backslash 
autorR{Muhammad, Hisham H.}
\layout Standard


\backslash 
orientador{Roberto Ierusalimschy}
\layout Standard


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Standard


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Standard


\backslash 
cidade{Rio de Janeiro}
\layout Standard


\backslash 
departamento{Informática}
\layout Standard


\backslash 
programa{Informática}
\layout Standard


\backslash 
centro{Centro Técnico Científico} 
\end_inset 


\layout Title

A study on scripting language APIs
\layout Author
\added_space_bottom bigskip 
Hisham H.
 Muhammad
\newline 

\newline 

\newline 

\size normal 
Advisor: Roberto Ierusalimschy
\newline 

\newline 

\newline 

\newline 
Pontifícia Universidade Católica do Rio de Janeiro
\newline 
Centro Técnico Científico
\newline 
Departamento de Informática
\layout Standard
\pagebreak_top 
\SpecialChar ~

\begin_inset ERT
status Open

\layout Standard

\backslash 
thispagestyle{empty}
\end_inset 


\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
setcounter{page}{1}
\end_inset 

Abstract
\layout Standard

Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard

This work discusses the main issues involving the design of APIs for the
 integration of language environments within C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C\SpecialChar ~
code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C\SpecialChar ~
application and that from the scripting language.
\layout Standard

We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C\SpecialChar ~
application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C\SpecialChar ~
functions and conversion of data between the environments.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\end_inset 


\layout Standard

There are many situations in which it is necessary or interesting to have
 interaction between programs written in different languages.
 A typical case is the use of external libraries, such as graphic toolkits,
 APIs for database access, or even operating system calls.
 Another scenario involves applications developed using more than one programmin
g language, in order to optimize parts where performance is critical or
 to allow extensibility through scripts written by the end-user.
\layout Standard

Regardless of purpose, communication between programs written in different
 languages brings up a number of design issues, not only in the development
 of the applications, but in the languages themselves.
 There are many ways to obtain this kind of interoperability, from translation
 of code of a language to another to the use of a common virtual machine.
 Ideally, however, a language should provide a foreign language interface
 (FLI) that allows the programmer to send and receive both calls and data
 to the other language\SpecialChar ~

\begin_inset LatexCommand \cite{finne98haskellfli}

\end_inset 

.
 Among the factors that should be taken into account when developing such
 an interface are the differences between type systems, memory management
 issues (such as garbage collection and direct access to pointers) and concurren
cy models.
 Beyond dealing with semantic differences, the design of an interface between
 languages involves pragmatic issues such as the balance between the safe
 isolation of the runtime environments, performance and the simplicity of
 the resulting API.
\layout Standard

We can observe in the existing implementations of FLIs a number of approaches
 to these problems.
 In fact, FLIs for different languages (or even different revisions of a
 single language) tend to be very different from each other.
 Still, it is possible to trace parallels among the various techniques employed,
 since the fundamental problems that they address are the same.
\layout Standard

Because of the popularity of the C\SpecialChar ~
language and the support it enjoys in
 the most popular operating systems, a considerable part of the implementations
 of foreign language interfaces are, in practice, C APIs.
 Besides, an interaction model for programming languages that has become
 especially relevant nowadays is that between statically typed compiled
 languages, such as C, and dynamically typed interpreted languages, as proposed
 by Ousterhout\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

.
 These two classes of languages have fundamentally different goals.
 Statically typed languages are usually implemented with high performance
 in mind and focus on lower level programming.
 In contrast, scripting languages tend to be implemented as interpreters
 or virtual machines, and make extensive use of high level constructs, such
 as lists and hashes, as basic types.
 These complementary features have made the two-language programming model
 popular, in which a lower level language is used for the development of
 components, which are then connected through a higher level language.
\layout Section

Objectives
\layout Standard

This work discusses the main issues involving the design of APIs for integration
 of runtime environments of scripting languages in C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as that
 from a scripting language with C\SpecialChar ~
code.
 Besides being currently the most popular class of languges for multi-language
 development, typical features of scripting languages such as garbage collection
 and dynamic typing illustrate well the problems that arise in the communication
 between different programming environment, since these features are absent
 in\SpecialChar ~
C.
 Languages with static typic may present similar needs for type conversion,
 but the problem tends to be simplified by the definition of equivalent
 types in the API and compile-time inference (as can be observed in the
 C APIs for Ada and Fortran).
 Functional languages have additional concerns related to side effects in
 C code, but this is equivalent to the paradigm break problem caused by
 the handling of I/O commonly faced by those languages.
\layout Standard

This study consists of two parts.
 In the first part, we performed an in-depth analysis of a set of C\SpecialChar ~
APIs
 provided by four scripting languages -- namely, Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06ref}

\end_inset 

, Perl\SpecialChar ~

\begin_inset LatexCommand \cite{wall00perl}

\end_inset 

, Ruby\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

, Lua\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 -- as well as the API provided by the Java language\SpecialChar ~

\begin_inset LatexCommand \cite{gosling00java}

\end_inset 

.
 Unlike the others, Java uses static typing, but like them it is based on
 a virtual machine model, features automatic memory management and allows
 dynamic loading of code.
 This allows us to observe how typing affects the design of the API.
\layout Standard

In the second part, we illustrate the differences of the APIs of those langages
 and the impact of those in the resulting code of a C application through
 a case study.
 We performed a comparison between the scripting language APIs through a
 concrete example, in order to present implementations in each of the studied
 languages side by side.
 The example consists of a generic scripting library, called LibScript,
 and a series of plugins that interface to the different languages.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures used in each language for function calls, registration
 of C\SpecialChar ~
functions and data conversion between environments.
 
\layout Section

Text structure
\layout Standard

This work is structured as follows.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, we discuss the various approaches for interaction between code written
 in different programming languages.
 Starting from an overview, the focus will then concentrate on the most
 commonly used foreign language interface: interfaces with the C\SpecialChar ~
language.
 We will discuss the problems commonly presented in the communication with
 C code and the programming models that appeared with its popularization
 in the integration with scripting languages.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

, we present in detail C\SpecialChar ~
APIs for a set of scripting languages.
 When discussing these interfaces, the different solutions employed for
 the main problems involving interaction between C and dynamic environments
 are brought up.
 Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercises these APIs through a case study: a plugin-based library that
 offers a simplified, uniform interface for scripting languages.
 By examining the implementation of each plugin, we can compare the APIs
 for each language performing equivalent operations.
 Finally, in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

 the conclusions reached through this work are presented, as well as possible
 directions for future work.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interaction between programming languages
\layout Standard

The approaches applied to the interaction of different programming languages
 vary considerably, but it is possible to identify some of the more typical
 techniques: language translation, from one language to the other or of
 both to a third; communication through an intermediate protocol or language;
 sharing a common execution environment, be it a virtual machine or through
 call conventions; and foreign language interfaces.
\layout Section

Code translation
\layout Standard

Allowing the use of two languages in a program through the translation of
 the code of one of them to the other minimizes the problem of communication
 between the parts of program written in different languages, since the
 final program will use a single data space.
 On the other hand, by having to describe a language in terms of the other,
 the semantic differences of their constructs may become a problem.
 If the target language does not have constructs offered by the source language,
 simulating them may be costly.
\layout Standard

A typical example of this problem is the complexity added by the simulation
 of higher-order functions and tail recursion when translating code from
 functional languages to one that does not have those features.
 Tarditi et al.\SpecialChar ~

\begin_inset LatexCommand \cite{tarditi92mlc}

\end_inset 

 describe the development of a translator of Standard ML to ANSI C.
 Their measurements have exposed the cost of adapting the features of ML
 to C, resulting in code that is in average 2 times slower than the that
 generated by the native ML compiler.
 In 
\begin_inset LatexCommand \cite{tolmach98mlada}

\end_inset 

, similar challenges are discussed in the translation of ML to Ada: in the
 adopted approach, the process has an intermediate step where the higher-order
 constructs are 
\begin_inset Quotes eld
\end_inset 

flattened
\begin_inset Quotes erd
\end_inset 

 to first-order constructs using records, so that they could be represented
 in Ada.
\layout Standard

Besides problems such as this, differences in the representation of data
 is also something to be handled when translating one language to another.
 In the particular case of\SpecialChar ~
C, its lower-level facilities for memory manipulation
 allow the description of data structures for higher-level languages without
 too much trouble.
 This makes\SpecialChar ~
C a frequent candidate for use as a portable low-level representation
 of code.
 The Glasgow Haskell Compiler offers, as an alternative to the generation
 of native code, generation of C code for use with GCC\SpecialChar ~

\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 One of the advantages of this feature is to allow the bootstrapping of
 the compiler in new architecture, given that GHC itself is written in Haskell.
 In fact, the ubiquity of C compilers has prompted the use of this language
 as a 
\emph on 
lingua franca
\emph default 
 between different languages, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Sharing virtual machines
\layout Standard

Another approach for the interaction between languages involves the use
 of a common execution environment, such as a virtual machine.
 The code of different languages is compiled to produce compatible representatio
ns, according to the data types provided by the execution environment.
 Many implementations use the Java Virtual Machine\SpecialChar ~

\begin_inset LatexCommand \cite{lindholm99jvm}

\end_inset 

 for this end.
 Jython\SpecialChar ~

\begin_inset LatexCommand \cite{hugunin97python}

\end_inset 

 is an implementation of the Python language that produces Java bytecodes.
 SMLj\SpecialChar ~

\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 is a Standard ML compiler that generates Java bytecodes and provides access
 to Java classes and methods to ML structures and vice versa.
 The fact that the Java Virtual Machine was not designed to support different
 programming languages, however, shows in the limitations presented by these
 projects.
 SMLj defines extensions to the ML language to allow access to constructs
 that are specific to Java; Jython poses limitations to the interface between
 Python and the Java APIs for reflection and dynamic class loading.
 Besides, the instruction set of the virtual machine focuses on operations
 that match Java's semantics, which makes, for example, the implementation
 of arrays with different semantics less efficient.
\layout Standard

The .NET Framework\SpecialChar ~

\begin_inset LatexCommand \cite{box02net}

\end_inset 

 is a runtime environment based on virtual machine that is being presented
 by Microsoft as their programming platform of choice in Windows system.
 Although the C#\SpecialChar ~
language 
\begin_inset LatexCommand \cite{csharp06spec}

\end_inset 

 has been introduced specifically for it, this environment has as one of
 its goals multi-language support -- evidenced by the very name of its Common
 Language Runtime (CLR) -- contrasting with the limitations imposed by the
 Java enviroment to those who try to use it with other languages.
 Hovewer, adaptations to the languages remain necessary in the .NET environment:
 the .NET version of Visual Basic includes changes to the language to make
 its semantics match those from C#; a new dialect of C++, C++/CLI, was introduce
d adapting its memory management model to that from the CLR\SpecialChar ~

\begin_inset LatexCommand \cite{cppcli05spec}

\end_inset 

; similarly, a new dialect of ML called F# was developed, to, among other
 reasons, provide better integration with .NET components written in other
 languages\SpecialChar ~

\begin_inset LatexCommand \cite{syme06fsharp}

\end_inset 

.
\layout Standard

Another implementation of a virtual machine for multiple languagens is being
 pursued by the Parrot project\SpecialChar ~

\begin_inset LatexCommand \cite{randal04perl6}

\end_inset 

.
 The scope of this project is narrower, aiming to serve as a common back-end
 for dynamic languages such as Perl and Python.
 The focus of the project, however, is currently on the implementation of
 Perl 6.
\layout Standard

A kind of communication that can also be considered the use of a common
 runtime environment is the communication between executables and native
 libraries through call conventions: rules for passing parameters in the
 runtime stack, use of registers and name mangling.
 This can be considered the lowest-level method method for interaction between
 code in different languages.
 Calling conventions, however, are a limited form of communication, as they
 assume data types with identical memory representation in both languages.
 Such compatibility is hardly the case, unless one of the languages explicitly
 considers this kind of interaction in its definition: the Ada standard,
 for example, requires its implementations to be compatible with the calling
 conventions of C, COBOL and Fortran\SpecialChar ~

\begin_inset LatexCommand \cite{ada95manual}

\end_inset 

.
 Likewise, C++ allows to specify functions with C-compatible linkage, through
 the 
\family typewriter 
extern "C"
\family default 
 directive.
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Language-independent object models
\layout Standard

Adopting a language-independent type model is another way to handle the
 issues of data interoperability between languages.
 This way, in the definition of the data for an application, their interfaces
 are described in a neutral way, typically using some language designed
 specifically for this end (an Interface Description Language, IDL), while
 the implementations are made using the specific languages.
 The CORBA (Common Object Request Broker Architecture) architecture\SpecialChar ~

\begin_inset LatexCommand \cite{omg02corba}

\end_inset 

 is one of the main examples of this model.
 The central motivation for the development of CORBA was to allow the developmen
t of distributed applications in heterogeneous environments; language heterogene
ity was one of the aspects taken into consideration.
\layout Standard

The challanges existing when designing a 
\begin_inset Quotes eld
\end_inset 

language independent
\begin_inset Quotes erd
\end_inset 

 model for data or objects, however, are similar to those in the design
 of an interface between any two languages, since this model too describes
 a type system.
 When implementing bindings for any of those object models, it is necessary
 to define a correspondence between the types defined by the model and those
 offered by the target language, and provide an API for interaction with
 the runtime environment -- in the case of CORBA, with the ORB (Object Request
 Broker).
\layout Standard

If on one hand the task may be easier since the model has been designed
 with language interaction in mind (unlike, for example, the C\SpecialChar ~
type system),
 on the other one would usually expect a higher level of transparency in
 the representation of data.
 For example, while in an application intergrating\SpecialChar ~
C++ and Python the distinction
 between C++\SpecialChar ~
objects and Python objects is clear and the Python API defines
 the limits between these two universes, in an application developed using
 CORBA one would expect, in both languages, the manipulation of objects
 to be the same whether they were implemented in C++ or in Python.
 For that, the common solution is to use 
\emph on 
stubs
\emph default 
, objects that give a uniform native appearance to data, regardless of the
 language in which they were implemented, and in the case of distributed
 models such as CORBA, of the location of the objects in the network.
 The correspondence between the lifecycles of the stubs and that of the
 objects they represent is another factor that should be taken into account.
 In the Java bindings, for instance, this is done with the help of the language'
s own garbage collector.
 In languages such as C++ the control of references is explicit.
\layout Standard

Other higher-level approaches have been proposed for the integration of
 applications developed in multiple languages.
 Coordination languages such as Linda\SpecialChar ~

\begin_inset LatexCommand \cite{gelernter85linda}

\end_inset 

 and Opus\SpecialChar ~

\begin_inset LatexCommand \cite{chapman97opus}

\end_inset 

 define mechanisms for message passing and a restricted set of constructs
 to indicate the flow of those between agents implemented in other languages.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C as an intermediate language
\layout Standard

The wish for a universal intermediate language is an old one in the world
 of computing.
 Several proposals have surfaced through the years, from the UNCOL project\SpecialChar ~

\begin_inset LatexCommand \cite{conway58uncol}

\end_inset 

 to the languages with extensible syntax of the 70s\SpecialChar ~

\begin_inset LatexCommand \cite{metzner79extensible}

\end_inset 

 to the most recent virtual machine environments such as .NET.
 In practice, the needs that these projects aimed to fulfill are being handled
 through the years in a more pragmatic, if less than ideal, way by using
 C.
 Two reasons make C a common choice as an intermediate language.
 First, its 
\begin_inset Quotes eld
\end_inset 

medium-level
\begin_inset Quotes erd
\end_inset 

 nature, by providing at the same time hardware independence and direct
 manipulation of memory.
 Second, the large availability of C\SpecialChar ~
compilers, leveraged by the proliferation
 of Unix systems in the most varied architectures.
 So, as time went by, to offer an interface for interoperability with other
 languages gradually became synonymous with offering an interface for communicat
ion with C\SpecialChar ~
code.
 This is especially true for dynamic languages that offer features for applicati
on extensibility.
 Not surprisingly, these languages are typically implemented in C.
 
\layout Standard

The availability of C APIs provided by different languages also causes C
 to be widely used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

.
 The integration between Python and Fortran takes place through a Python
 module written in C that accesses a Fortran library, which on its turn
 exposes functions using a call convention compatible with C\SpecialChar ~

\begin_inset LatexCommand \cite{peterson01fortranpy}

\end_inset 

.
 LunaticPython\SpecialChar ~

\begin_inset LatexCommand \cite{niemeyer06lunaticpython}

\end_inset 

 offers bridges from Lua to Python and from Python to Lua, implemented through
 a pair of extension modules for each source language written in\SpecialChar ~
C.
\layout Standard

However, generic intermediate languages continue to be proposed as alternatives
 to C.
 C-
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1pt}
\end_inset 

-\SpecialChar ~

\begin_inset LatexCommand \cite{jones99cminusminus}

\end_inset 

 is a project that attempts to overcome the limitations of C as an intermediate
 language making the memory representation of data types more explicit and
 adding support to constructs that are not easily represented in C, such
 as tail recursion.
 Recent versions of the GCC compiler suite have standardized an intermediate
 language for communication between its various back-ends and front-ends\SpecialChar ~

\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces to C
\layout Standard

The C language has, nowadays, a special role in the world of programming
 languages.
 Besides being widely used in the implementation of compilers, interpreters
 and virtual machines (the main implementations of Perl, Python, Ruby and
 Lua are just some examples), it is also used in compilers as an output
 format in the generation of portable code (two notable examples are the
 GHC and SmartEiffel\SpecialChar ~

\begin_inset LatexCommand \cite{collin97smalleiffel}

\end_inset 

 compilers, which generate C from Haskell and Eiffel, respectively).
 This pravelence of C makes the C API a convenient format for a foreign
 language interface.
\layout Standard

In the vast majority of cases, the internal representation of code produced
 by compilers for other languages is not compatible with C, be it because
 of differences in call or name conventions, or because they produce code
 for execution in virtual machines.
 This way, to allow a C program to access this code, the language has to
 expose a library of C functions that will perform the necessary translations.
 In virtual machine environments, this library is normally generic, offering
 facilities for communication with the virtual machine itself.
 For static languages, it is usually necessary to create a specific library
 to perform the conversion of calls, as it happens in interfaces that expose
 C++ libraries to C.
 An example of this is QtC\SpecialChar ~

\begin_inset LatexCommand \cite{kdebindings}

\end_inset 

, a library of C bindings to the Qt graphic toolkit, which is implemented
 in C++.
\layout Standard

For non-imperative languages, there is still the problem of C code potentially
 generating side effects.
 Some feature for isolating calls has to be offered.
 In GHC, the construction for C calls, 
\family typewriter 
_ccall_
\family default 
, is defined in the IO monad; in the addendum for the Haskell 98 standard,
 the 
\family typewriter 
ccall
\family default 
 directive was integrated, but the use of the monad is optional, requiring
 the programmer to ensure that the functions that use it are not pure
\begin_inset Foot
collapsed true

\layout Standard

A number of additional convention calls are defined (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
), but 
\family typewriter 
ccall
\family default 
 is the only one declared mandatory by the document.
\end_inset 

.
\layout Standard

Another possible source of incompatibility between languages that has to
 be handled when they interact is the difference between concurrency models.
 C, in particular, does not define any concurrency constructs; they are
 implemented through libraries.
 At the same time that it brings great flexibility to the language, this
 also imposes portability problems for languages that depend on the availability
 of concurrency mechanisms in C that are compatible with the models they
 use.
\layout Standard

For example, APIs between C and Java must take into account the preemptive
 multithreading model adopted by Java.
 The JNI (Java Native Interface)\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

 defines functions to control mutual exclusion between data shared between
 the two languages.
 The programmer must take care to strike a balance between time spent blocking
 the virtual machine accessing shared data and time spent copying data between
 the environments to reduce sharing.
 Another situation in which the concurrency model of the language demands
 special care when integrating with C happens in the use of co-routines
 in Lua.
 The combination of two features of Lua, cooperative multitasking with multiple
 execution stacks and the ability to alternate between calls to C and Lua
 functions in a single stack, brings a limitation: a co-routine cannot execute
 a 
\emph on 
yield
\emph default 
 operation in case there is a C function in its stack, as there is no portable
 way to alternate between multiple stacks in C\SpecialChar ~

\begin_inset LatexCommand \cite{moura04colua}

\end_inset 

.
\layout Standard

One of the most frequent motivations in the integration with C code is the
 use of external libraries.
 Exposing a C library through the FLI for access by another language may
 incur in the registration of hundreds of functions.
 It is also usual to define data types that give to structures defined by
 the library a more native appearance, such as, for example, converting
 C functions that register callbacks into Ruby methods that accept code
 blocks as a parameter.
 These initializations and adaptations are usually defined as a bindings
 library, that serves as a bridge between the language and the C library
 encapsulating the interaction with the FLI.
\layout Standard

The patterns that arise when producing bindings are so common that they
 motivated the development of programs that attempt to automate the process.
 These bindings generators tend to work using some representation prepared
 for their use, since analyzing raw C headers may show itself to be insufficient
: for example, often the program wouldn't be able to interpret the intention
 of a construct such as 
\family typewriter 
int**
\family default 
.
 SWIG\SpecialChar ~

\begin_inset LatexCommand \cite{beazley96swig}

\end_inset 

 is a popular multi-language tool for generation of bindings for C and C++
 libraries which defines its own format for description of interfaces.
 FLIs may as well use stubs generators to save the programmer from having
 to write repetitive or non-portable C\SpecialChar ~
code.
 Java features a generator for C headers containing prototypes for native
 methods to be implemented.
 Pyrex\SpecialChar ~

\begin_inset LatexCommand \cite{ewing06pyrex}

\end_inset 

 is a generator for C modules for Python from a syntax based on the Python
 language itself.
 Another example is toLua++\SpecialChar ~

\begin_inset LatexCommand \cite{manzur06tolua}

\end_inset 

, a tool for integrating C and C++ code to Lua, which generates stubs from
 C headers prepared for use by the program, which may contain special annotation
 to help in the conversion process.
\layout Section

Scripting languages
\layout Standard

A model for interaction between languages that has shown to be especially
 relevant nowadays is that between statically typed compiled languages,
 such as C and C++, and dynamically typed interpreted languages, such as
 Perl and Python.
 In\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

, Ousterhout categorizes these two groups as 
\emph on 
systems programming languages
\emph default 
 and 
\emph on 
scripting languages
\emph default 
.
\layout Standard

These two categories of languages have fundamentally different goals.
 Systems programming languages emerged as an alternative to assembly in
 the development of applications, having as main features static typing,
 which eases the understanding of data structures in large systems, and
 the implemantation as compilers, due to concerns with performance.
 In contrast, scripting languages are dynamically typed and are implemented
 as interpreters or virtual machines.
 Dynamic typing and the extensive use of higher level constructs as basic
 types, such as lists and hashes, brings greater flexibility in the interaction
 between components; in static languages, the type system imposes restrictions
 to those interactions, often requiring the programmer to write adaptation
 interfaces, which makes the reuse of components harder.
\layout Standard

Ousterhout points out that, in a model integrating these two kinds of languages,
 the tendency is that systems programming languages will no longer be used
 to write whole applications, but will instead be used in the implementation
 of components, which are then connected through code written with scripting
 languages.
 The convenience offered by high-level interpreted languages allows rapid
 prototyping and encourages the reuse of components.
\layout Standard

The integration of programs developed in systems programming languages coordinat
ed through scripting languages has been common practice for a long time
 now.
 Shell scripting in Unix systems is probably the most notable example, where
 constructs such as pipes (which connect the output of a process to the
 input of another one) allow one to perform tasks combining a series of
 programs implemented in different languages, or even other scripts.
 With the introduction of Tcl\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout94tcl}

\end_inset 

, this kind of coordination of components through scripting languages started
 to take place 
\emph on 
within
\emph default 
 applications.
 In this model, the scripting language is implemented as a library and is
 embedded in an application written in a lower-level language, such as C.
 Data structures of the application are exposed to the scripting environment
 as objects; conversely, the application can launch functions in the scripting
 language and access its data.
 Programmable applications have existed long before that, typically using
 little languages created specifically for each application, but the concept
 introduced by Tcl of implementing scripting languages as C libraries has
 propelled strongly the development of extensible applications.
\layout Standard

The development model based in two languages does not limit itself to applicatio
ns that provide customization through scripts written by the end-user.
 In many scenarios, there is a clear distinction between a lower-level layer
 where performance is a critical factor and a higher-level layer comprised
 by coordination operations between elements of the lower layer.
 Typical examples are graphic applications where the interface is described
 by scripting languages controlling components implemented in C and games
 where the logic is described in scripts and the rendering engine is implemented
 in lower-level languages.
 This greater prominence of scripting languages, where they stop being just
 an application extension mechanism and start having a more central role
 in the coordination of the execution of the program, has also promoted
 an inverted model of interaction between languages, where the application
 itself is written using the scripting language and libraries written in
 lower-level languages are loaded as extension modules.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

Scripting language APIs
\layout Standard

Interfaces provided by scripting languages are usually understood as 
\begin_inset Quotes eld
\end_inset 

extension APIs
\begin_inset Quotes erd
\end_inset 

: they extend the virtual machine with features not originally offered by
 it, or alternatively, they extend an external application with the features
 offered by the runtime environment of the language, embedding it to the
 application.
 The first scenario is the one used in the programming model where the high-leve
l coordination is made by an interpreted language and modules written in
 languages such as C and C++ are used to access external libraries or to
 implement performance-critical parts.
 The second scenario, in general, will also encompass the first one, when
 exposing to the embedded virtual machine extensions that will allow it
 to talk to the host application.
\layout Standard

Both scenarios involve the same general problems: data transfer between
 the two languages, including how to allow the scripting language to manipulate
 structures declared in C and vice versa; handling the difference between
 the memory management models, more specifically the interaction between
 garbage collection in the virtual machine and explicit deallocation in
 C; calling functions declared by the scripting language from C; and the
 registration of C functions so that they can be invoked by scripts.
 The following sections discuss the main issues involved in the communication
 between C code and scripting languages, and present the approaches employed
 by the Python, Ruby, Java, Lua and Perl APIs when handling these issues.
 Each section concludes with a comparison where the different designs presented
 in the exposition of each language are reviewed side by side and thus put
 into perspective.
\layout Section

Data transfer
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

The main complexity in the interaction between programming languages is
 not the differences in syntax or semantics from their control flow structures,
 but in their data representations.
 In the communication between code written in two different languages, data
 flow in various forms: as parameters, object attributes, elements in data
 structures, etc.
\layout Standard

Often, the format how these data are represented differ.
 In those cases, there are three alternatives to perform data transfer between
 the languages.
 The simplest is to expose the data to the target language as an opaque
 entity.
 The target language receives only some kind of handle that allows it to
 identify the datum uniquely in operations requested later.
 This approach is useful, for example, if a language is just storing data
 for the other one, in order to make use of higher-level data structures
 offered by the language.
\layout Standard

Another approach involves perform some conversion to the data from the type
 system of one language to that of the other.
 The duplication that takes place in this conversion limits the applicability
 of this method, restricting its use typically to numeric types and, in
 minor scale, strings.
 Finally, the source language may explicitly offer facilities in the target
 language to manipulate these data, that is, one language would offer an
 API for the other.
 The difference between this approach and the first one is that, while in
 the former the contents of the data remain opaque, here the API defines
 some means to manipulate their contents.
\layout Standard

Because of its focus on the manipulation of pointers and structures, C provides
 a small set of basic types.
 Besides, C is very liberal with regard to the internal representation of
 its structured types, with each different platform having to define its
 own application binary interface (ABI).
 So, even in cases where it is possible to link C code directly using compatible
 basic types and appropriate calling conventions (such as in Free Pascal
 or several Fortran compilers), bindings libraries are still usually needed
 to make the manipulation of complex types more convenient.
\layout Standard

Even in the fundamental numeric types, there are several precautions that
 must be taken.
 Some languages, like Smalltalk and Ruby, perform automatic conversion of
 integers to 
\begin_inset Quotes eld
\end_inset 

big integers
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 In Ruby, in particular, primitive integers have 1 bit less of precision
 than the machine's word size.
 There may also be the need to handle conversion of endianness and format
 of floating point numbers.
\layout Standard

For types such as strings, the size of values brings also concerns with
 performance.
 In many cases the internal representation used for strings is the same
 as used in C, so an option is to simply pass to the C code a pointer to
 the address where the string is stored, which avoids copying of data, under
 risk of allowing the C code to modify the contents of the string.
 Exposing to the C code pointers to memory areas within the runtime environment
 of the other language may also bring concurrency problems, in case the
 environment uses multiple threads.
\layout Standard

When exposing to the C code data of structured types, the conversion to
 a native C type, in many cases, is not an option.
 Besides the issue of quantity of data to be converted, structured types
 in C are defined statically, therefore not serving to represent conveniently
 data of dynamic structures, such as objects that may gain or lose attributes
 or even change class during runtime.
 Even in languages with static types, like Java, the copy of objects is
 not usually an interesting option due to the volume of data.
 The copy of structured objects tends to be restricted to specific operations
 like the manipulation of arrays of primitive types.
\layout Standard

The alternative to allow C code to operate over structured data, thus, is
 to provide to it an API that exposes as functions the operations defined
 over those types.
 This also avoids the need to control the consistency between two copies
 of a given structure.
 Consistency problems, however, may occur if the API allows the C code to
 store pointers to objects from the language -- this makes it necessary
 for the programmer to manage explicitly the synchronicity between pointers
 and the lifecycles of objects that may be subject to garbage collection.
 Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discusses this issue in greater detail.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

All values in the Python virtual machine are represented as objects, mapped
 to the C API as the 
\family typewriter 
PyObject
\family default 
\SpecialChar ~
structure 
\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 More specific types such as 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 and 
\family typewriter 
PyListObject
\family default 
 are 
\family typewriter 
PyObject
\family default 
s by structural equivalence, that is, they can be converted through a C
 cast.
 Reflecting the dynamic typing model of Python, the API functions use 
\family typewriter 
PyObject*
\family default 
 as a type every time they refer to Python objects, even when they are designed
 to act on Python values of more specific types, such as for example the
 
\family typewriter 
PyString_Size
\family default 
, that returns the length of a string.
 Each specific type has a verification function in the API, such as 
\family typewriter 
PyNumber_Check
\family default 
 and 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python is a strongly typed language: each object is tied to a type.
 Types are represented by 
\family typewriter 
PyTypeObject
\family default 
 structures, which are also structurally equivalent to 
\family typewriter 
PyObject
\family default 
.
 Each Python type has a predefined 
\family typewriter 
PyTypeObject
\family default 
 in the API, such as 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 and 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compares the type of a 
\family typewriter 
PyObject
\family default 
 to a 
\family typewriter 
PyTypeObject
\family default 
 passed as an argument.
\layout Standard

For the conversion of data from C to Python, the language offers a series
 of functions that receive values of primitive C types as an argument, such
 as 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 and 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Each of those functions returns to the C code a pointer to a new 
\family typewriter 
PyObject
\family default 
.
 Strings passed are copied by Python.
 The following example illustrates the creation of a Python object through
 the conversion of a C value:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The two examples below are equivalent, and illustrate the verification of
 a type through the API, first through a convenience function, and then
 explicitly, comparing the type of a string Python with 
\family typewriter 
PyString_Type
\family default 
:
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Yes.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Yes.
\backslash 
n");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For returning data from Python to C, a complementary set of functions is
 offered, mapping the basic types of Python back to C types.
 Some examples of those functions that take a 
\family typewriter 
PyObject
\family default 
 pointer as an argument and return the correspondent C datum are 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 and 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Differently from the input functions, in these output functions no string
 copying takes place: the strings returned are pointers to memory stored
 internally by Python.
 The documentation recommends not to modify the content of the string except
 if the memory area was returned by a call to 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
size
\family typewriter 
\emph default 
)
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
 This way, it is possible to allocate a string for storage in Python and
 fill its contents later through C code, as in the following example:
\layout LyX-Code


\size footnotesize 
\emph on 
/* allocating an uninitialized string in Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtaining the pointer to the string memory area */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Now, we can fill the string in C.
 An example: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For some of its basic types that do not have direct correspondence in ANSI
 C 89, Python defines equivalent C types: 
\family typewriter 
Py_UNICODE
\family default 
 and 
\family typewriter 
Py_complex
\family default 
.
 These types were added in order to expose the internal representation of
 data used by Python in numeric manipulation and Unicode text modules implemente
d in C, avoiding frequent conversions to and from 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python also offers some versions of its C conversion functions as macros
 without type checking, assuming that the given 
\family typewriter 
PyObject
\family default 
 will be compatible, offering better performance in expense of safety.
 These functions can be identified by their uppercase names.
 Among the conversion macros provided are 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 and 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Besides functions for type conversions between Python and C, the Python
 API also offers some conversion functions between Python types.
 These functions receive a 
\family typewriter 
PyObject
\family default 
 as an argument and return a new 
\family typewriter 
PyObject
\family default 
 with the result of the conversion, and are equivalent to Python functions
 that perform these conversions (actually calls to 
\family typewriter 
PyTypeObject
\family default 
 types that answer to the 
\family typewriter 
__call__
\family default 
 method).
 For example, the 
\family typewriter 
PyObject_Str
\family default 
 function is equivalent to the Python function 
\family typewriter 
str
\family default 
.
\layout Standard

In Python, objects are stored in modules, which are namespaces declared
 globally, or as attributes of objects.
 Variables are stored in an 
\emph on 
environment
\emph default 
, represented as a dictionary.
 Functions such as 
\family typewriter 
PyRun_File
\family default 
 receive, among their parameters, a dictionary of global variables and another
 of local variables.
 The set of global variables and functions is represented as the dictionary
 of the 
\family typewriter 
__main__
\family default 
 module.
 Built-in objects are accessible through the 
\family typewriter 
__builtin__
\family default 
 module.
 For example, to obtain the 
\family typewriter 
str
\family default 
 object, we will initially obtain a reference to the 
\family typewriter 
__builtin__
\family default 
 module using the 
\family typewriter 
PyImport_AddModule
\family default 
 function and then the module's dictionary with the 
\family typewriter 
PyModule_GetDict
\family default 
 function.
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

In Python, 
\family typewriter 
str
\family default 
 is a callable object, which acts as the string conversion function.
 So, once we obtained a reference to the PyObject equivalent to 
\family typewriter 
str
\family default 
, the following call is the same as calling 
\family typewriter 
PyObject_Str
\family default 
 on a given Python object 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* This is a vararg function that receives as additional arguments a
\layout LyX-Code


\size footnotesize 
\emph on 
   NULL-terminated list with PyObjects to be passed to the Python function
\layout LyX-Code


\size footnotesize 
\emph on 
   given in the first argument.
 */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The storage of C data in the Python object space can be done in two ways.
 One way is to create an object of the 
\family typewriter 
CObject
\family default 
 type encapsulating a C pointer, building this way a value that will be
 opaque to Python.
 The allocation functions for objects of this type allow to associate to
 the datum a C function to be called when the 
\family typewriter 
CObject
\family default 
 is deallocated.
 According to the Python documentation, 
\family typewriter 
CObjects
\family default 
 have as their main goal to allow the passing of C data between extension
 modules\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
\layout Standard

The other way is to declare new Python types through C structures.
 In C, a Python type is described in two parts: a struct type, from which
 instances of the type will be produced, and an instance of the 
\family typewriter 
PyTypeObject
\family default 
 struct, which will describe the type to Python.
 The following example illustrates the creating of a new Python type in
 C.
 Initially, we have point, which will be the C type of the instances of
 objects:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
PyObject_HEAD
\family default 
 macro ensures structural equivalence with 
\family typewriter 
PyObject
\family default 
.
 When functions return the object to C code as a 
\family typewriter 
PyObject*
\family default 
, this will be able to be converted back to 
\family typewriter 
point
\family default 
 through a cast, giving then access to the 
\family typewriter 
x
\family default 
 and 
\family typewriter 
y
\family default 
 attributes.
 We will also define a function that operates on objects of this type:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(p->x*p->x + p->y*p->y) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function was defined with a 
\family typewriter 
PyObject
\family default 
* return type so that it can be registered in the Python virtual machine.
 To associate the function to the Python type, we will initially store it
 in an array of 
\family typewriter 
PyMethodDef
\family default 
 structures, which will lits the type's methods:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To make the attributes of the type are visible from Python, we will have
 to implement an access routine, that receives the object and the name of
 the accessed attribute.
 Its implementation is given below:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once it is registered in the type description, this function will be responsible
 for returning the type's attributes and methods.
 This way, we can expose to the Python environment attributes stored in
 the C struct.
 The 
\family typewriter 
Py_FindMethod
\family default 
 function locates a function in the array given as its parameter and returns
 it as a method
\begin_inset Foot
collapsed false

\layout Standard

Registration of Python functions will be discussed in detail in Section
 \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

Finally, we will define 
\family typewriter 
point_type
\family default 
, which will be the 
\family typewriter 
PyTypeObject
\family default 
 that will describe the Python type relative to 
\family typewriter 
point
\family default 

\begin_inset Foot
collapsed false

\layout Standard

For brevity, we will present the example using the C99 syntax for structs,
 saving us from listing the elements that will be initialized with 
\family typewriter 
NULL
\family default 
, as the 
\family typewriter 
PyTypeObject
\family default 
 struct has 54 fields in total.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",             
\emph on 
/* The name of the class */
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  
\emph on 
/* The size of the memory area to be allocated */
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    
\emph on 
/* The attribute access function */
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT  
\emph on 
/* This class does not require special treatment */
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Again, a macro was used at the top of the definition to ensure structural
 equivalence.
 
\family typewriter 
PyTypeObject
\family default 
 has many other fields, but we will keep them 
\family typewriter 
NULL
\family default 
 so that they will be filled with default values during the construction
 of the type at runtime.
 The 
\family typewriter 
PyTypeObject
\family default 
 type contains a number of fields that allow to describe the behavior of
 the declared type.
 In the 
\family typewriter 
tp_getattr
\family default 
 field of 
\family typewriter 
point_type
\family default 
, we specified that the C function to be used to handle access to attributes
 will be 
\family typewriter 
point_getattr
\family default 
.
 We specified 
\family typewriter 
Py_TPFLAGS_DEFAULT
\family default 
 in the flags field to indicate that this is a class with a default behavior,
 without the need for special treatements such as cycle checking during
 garbage collection.
\layout Standard

While the in-memory representation of 
\family typewriter 
Python
\family default 
 objects of the user-defined type are instances of 
\family typewriter 
point
\family default 
, to create a new object it is not enough to allocate an instance of 
\family typewriter 
point
\family default 
 and use it as a 
\family typewriter 
PyObject
\family default 
 through casting.
 It is necessary to initialize the object so that it is registered in the
 garbage collection mechanism and it has the fields of its 
\family typewriter 
PyObject
\family default 
 header properly initialized.
 The allocation in C of new objects of a user-defined type must be done
 through the 
\family typewriter 
PyObject_New
\family default 
 macro, which receives as arguments the type of the struct to be allocated
 and the 
\family typewriter 
PyTypeObject
\family default 
 that corresponds to the type.
 The documentation recommends assigning the default construction function,
 
\family typewriter 
PyType_GenericNew
\family default 
, during runtime for portability reasons\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Finally, the undefined fields of the struct are filled by the 
\family typewriter 
PyType_Ready
\family default 
 function.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

From there on, instances can be created with 
\family typewriter 
PyObject_New
\family default 
, as in the example below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates an instance */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Stores the instance in the Python global 'P',
\layout LyX-Code


\size footnotesize 
\emph on 
   assuming the globals dictionary was stored in 'globals'.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Once declared in C, this value can be used by Python code:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The Python API has a large number of functions for manipulation of predefined
 types in the language.
 
\emph on 
Tuples
\emph default 
 deserve a special mention with regard to data transfer between Python and
 C, as they are used in several contexts: when passing arguments to Python
 functions from C, when receiving input arguments in C functions and also
 when passing and receiving multiple return values, as we will see in Sections\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 and\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

As tuples are frequently used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

 between Python and C, the API offers a convenience function, 
\family typewriter 
PyArg_ParseTuple
\family default 
, that saves the programmer from having to perform access and type checking
 of the tuple elements one by one.
 This is a vararg C function that receives as arguments the tuple, a string
 indicating the types of expected arguments and the addresses where the
 values, converted to C types, should be stored.
 The function defines a syntax for expected type identifiers in the given
 string and the correspondent C types.
 For example: 
\family typewriter 
"s#"
\family default 
 indicates that the tuple should contain a Python object of the 
\family typewriter 
string
\family default 
 or 
\family typewriter 
Unicode
\family default 
 type and that two parameters should be passed to the C function, with types
 
\family typewriter 
const char**
\family default 
 and 
\family typewriter 
int*
\family default 
, that will return the string pointer and its size, respectively.
 In a more elaborate example, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indicates that the function expects two integer addresses (
\family typewriter 
"ii"
\family default 
), followed by the address of a 
\family typewriter 
PyObject
\family default 
 pointer
\family typewriter 
\SpecialChar ~

\family default 
(
\family typewriter 
"O"
\family default 
) and a PyTypeObject to be used when type checking the received object\SpecialChar ~
(
\family typewriter 
"!"
\family default 
) and optionally\SpecialChar ~
(
\family typewriter 
"|"
\family default 
), two addresses of 
\family typewriter 
double
\family default 
 values given to Python through another tuple\SpecialChar ~
(
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

In a similar fashion, the Python API has the 
\family typewriter 
Py_BuildValue
\family default 
, which allows the construction of structured objects, such as tuples, lists
 and dictionaries, in a single call.
 This function is frequently used both in the construction of the argument
 tuple when calling functions and in the construction of return values.
 The syntax of the parameter string is similar to that of 
\family typewriter 
PyArg_ParseTuple
\family default 
, but it features a different set of type indicators, and allows to describe
 lists and dictionaries.
 For example, the following call creates a list containing an integer, a
 floating point number and a dictionary containing an element with a string
 key and an integer value:
\layout LyX-Code


\size footnotesize 
PyObject* list = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

This is equivalent to the following Python construct:
\layout LyX-Code


\size footnotesize 
list = [123, 12.30, {"foo": 1234}]
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-dados}

\end_inset 


\layout Standard

For the communication of data between Ruby and C, the Ruby API defines a
 C data type called 
\family typewriter 
VALUE
\family default 
, which represents a Ruby object.
 
\family typewriter 
VALUE
\family default 
 may represent both a reference to an object (that is, a pointer to the
 Ruby heap) as well as an immediate value.
 In particular, the constants 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 and 
\family typewriter 
Qnil
\family default 
 are defined as immediate values, allowing them to be compared in C using
 the 
\family typewriter 
==
\family default 
 operator.
\layout Standard

For type checking, Ruby provides the 
\family typewriter 
Check_Type
\family default 
 and 
\family typewriter 
TYPE
\family default 
 macros.
 
\family typewriter 
Check_Type
\family default 
 allows one to compare the type of values to constants that describe basic
 types of Ruby such as
\family typewriter 
 T_OBJECT
\family default 
 and 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 returns the constant relative to the type of a given value.
 To check the class of an object, one should use 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

When transferring numeric values, the conversion between C and Ruby is made
 through macros such as 
\family typewriter 
INT2NUM
\family default 
 and functions such as 
\family typewriter 
rb_float_new
\family default 
, which receive or return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

For passing strings to Ruby from C, the API provides the 
\family typewriter 
rb_str_new
\family default 
 function, which receives a pointer and a numeric size argument, allowing
 the use of strings containing null characters, and the 
\family typewriter 
rb_str_new2
\family default 
 function, which assumes a standard C string, with the null character as
 a terminator.
 These functions make a copy of the C string to the data space of Ruby.
 
\family typewriter 
VALUE
\family default 
s that point to Ruby strings allow C code to access and modify their contents
 through the 
\family typewriter 
RSTRING(a_string)->ptr
\family default 
 cast.
 However, the API recommends the use of the 
\family typewriter 
StringValue
\family default 
 macro, which returns the 
\family typewriter 
VALUE
\family default 
 itself in case it is a string, or a new 
\family typewriter 
VALUE
\family default 
 of the 
\family typewriter 
String
\family default 
 class produced through the 
\family typewriter 
to_s
\family default 
 conversion method applied to the given object (or raises a 
\family typewriter 
TypeError
\family default 
 exception in case the conversion was not possible).
\layout LyX-Code


\size footnotesize 
void show_value(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* This would make an illegal access if TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Works for any type that accepts obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         otherwise, raises an exception */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Value: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Under the justification of increasing performance on access, some other
 Ruby types such as 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 and 
\family typewriter 
File
\family default 
 allow low-level access to the members of structures used in the implementation
 of their objects.
 For example, with 
\family typewriter 
RARRAY(an_array)->len
\family default 
 one can read the size of an array directly.
 The recommendation of the API is to use this kind of access for reads only,
 since the modification of these values can easily make the internal state
 of objects inconsistent.
\layout Standard

For storing C data in the Ruby object space, the API provides a macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, which receives a C pointer and creates a Ruby object which encapsulates
 this pointer.
 The pointer can be accessed from C code using 
\family typewriter 
Data_Get_Struct
\family default 
, bet not from Ruby.
 A C function to be executed when the object is collected is also passed
 to 
\family typewriter 
Data_Wrap_Struct
\family default 
.
 For example, we will create a 
\family typewriter 
Point
\family default 
 class, similar to the Python type defined in the previous section.
 We will initially define a C type:
\layout LyX-Code


\begin_inset LatexCommand \label{struct-point}

\end_inset 


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Allocation and deallocation functions for the 
\family typewriter 
Point
\family default 
 class (
\family typewriter 
point_alloc
\family default 
 and 
\family typewriter 
point_free
\family default 
) follow:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

 
\newline 

\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* The 2nd argument is the mark function for garbage collection
\layout LyX-Code


\size footnotesize 
\emph on 
      (NULL here as the type doesn't store VALUES), see Sec.
 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

 */
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, NULL, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that 
\family typewriter 
Data_Wrap_Struct
\family default 
 makes use of a 
\family typewriter 
VALUE
\family default 
 that represents the 
\family typewriter 
Point
\family default 
 class in Ruby.
 Classes are created in C with the 
\family typewriter 
rb_define_class
\family default 
 function.
 This function gets a C string with the name of the new class and a VALUE
 to be used as a superclass (such as for example the 
\family typewriter 
rb_cObject
\family default 
 constant, which represents the 
\family typewriter 
Object
\family default 
 Ruby class) and returns a 
\family typewriter 
VALUE
\family default 
 representing the new class.
 For classes such as 
\family typewriter 
Point
\family default 
, whose instances will contain C data, it is possible to register a C function
 that will be responsible for allocating memory of instances using the 
\family typewriter 
rb_define_alloc_func
\family default 
 function.
 The creation of the class and the registration of the allocation function,
 thus, are done as follows:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Like in Ruby code, the declaration of object attributes is done in the 
\family typewriter 
initialize
\family default 
 method, which can be implemented in C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The method is registered in the class at runtime with the 
\family typewriter 
rb_define_method
\family default 
 function (the registration of C functions in Ruby will be discussed in
 detail in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To ensure that the copy of objects through Ruby's 
\family typewriter 
dup
\family default 
 and 
\family typewriter 
clone
\family default 
 methods will handle correctly the data stored through C, it is necessary
 to register the 
\family typewriter 
initialize_copy
\family default 
 method.
 A possible implementation in C is given below:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby may call this function with the same object in both args;
\layout LyX-Code


\size footnotesize 
\emph on 
      in this case, ignore the call and return the object */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the pointers stored in the objects */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Copy of the 
\begin_inset Quotes eld
\end_inset 

C part
\begin_inset Quotes erd
\end_inset 

 of the object */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Returns the copy */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

We will complete the example with a C function implementing the 
\family typewriter 
distance
\family default 
 method, like it was done in the previous section for Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(p->x*p->x + p->y*p->y)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

These functions are also registered as methods of 
\family typewriter 
Point
\family default 
:
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
rb_class_new_instance
\family default 
 function produces new Ruby objects that are instances of the class, receiving
 a C array of 
\family typewriter 
VALUE
\family default 
s to be passed during object initialization and the class 
\family typewriter 
VALUE
\family default 
.
\layout Standard

Access of Ruby values is done through the 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
 family of functions, which return 
\family typewriter 
VALUE
\family default 
s relative to attributes of objects or classes, global variables and constants.
 For each of those there is an analogous 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 function
\begin_inset Foot
collapsed true

\layout Standard

Constants can be created with the 
\family typewriter 
Qundef
\family default 
 value and have their value defined later 
\emph on 
once
\emph default 
 with 
\family typewriter 
rb_const_set
\family default 
.
\end_inset 

.
 The 
\family typewriter 
rb_iv_get
\family default 
 and 
\family typewriter 
rb_ivar_get
\family default 
 functions, for example, obtain object attributes (
\emph on 
instance variables
\emph default 
).
 The first form uses C strings as names, the latter uses 
\family typewriter 
ID
\family default 
s, identifiers that replace interned strings in Ruby's symbol table, that
 can be obtained using the 
\family typewriter 
rb_intern
\family default 
 function.
 In fact, 
\family typewriter 
ID
\family default 
s correspond to the 
\emph on 
symbol
\emph default 
 Ruby type, which in practice are immutable strings.
 The following example obtains the value of a global variable 
\family typewriter 
g
\family default 
 and sets it to the field 
\family typewriter 
f
\family default 
 of an object, and then sets the value of the global variable to zero:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtains the global variable */
\layout LyX-Code


\size footnotesize 
VALUE g = rb_gv_get("g");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Sets the field f of object obj */
\layout LyX-Code


\size footnotesize 
VALUE obj = rb_gv_get("obj");
\layout LyX-Code


\size footnotesize 
rb_iv_set(obj, "f", g);
\emph on 
 /* Same as: rb_ivar_set(obj, rb_intern("f"), g); */
\layout LyX-Code


\size footnotesize 
\emph on 
/* Zeroes the global variable */
\layout LyX-Code


\size footnotesize 
rb_gv_set("g", INT2NUM(0));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard


\family typewriter 
ID
\family default 
s are never collected: we observed that the symbol table is not cleaned
 up even after 
\family typewriter 
ruby_finalize
\family default 
.
 So, a C application that offers a scripting interface creating supposedly
 isolated environments, surrounding each script execution with 
\family typewriter 
ruby_init
\family default 
 and 
\family typewriter 
ruby_finalize
\family default 
, may have its memory consumption increased indefinitely as scripts create
 symbols.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

The JNI defines in the 
\family typewriter 
jni.h
\family default 
 header C types equivalent to each of Java's primitive types (
\family typewriter 
jint
\family default 
 for 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 for 
\family typewriter 
float
\family default 
, and so on).
 The 
\begin_inset Quotes eld
\end_inset 

reference types
\begin_inset Quotes erd
\end_inset 

, such as classes and objects, are exposed to C as opaque references, instances
 of 
\family typewriter 
jobject
\family default 
.
 Strings and arrays are also objects in Java and are thus exposed as instances
 of 
\family typewriter 
jobject
\family default 
.
 However, the JNI defines as a convenience some C types that act as 
\begin_inset Quotes eld
\end_inset 

subtypes
\begin_inset Quotes erd
\end_inset 

 of jobject: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, and an array type for each primitive type (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 The 
\family typewriter 
jvalue
\family default 
 type is a union of primitive and reference types.
 The 
\family typewriter 
NULL
\family default 
 C value corresponds to Java's 
\family typewriter 
null
\family default 
.
\layout Standard

Different methods are employed for reading primitive types, strings, arrays
 and other objects.
 Reading the contents of a 
\family typewriter 
jstring
\family default 
 in C requires the conversion from the internal format used by Java, UTF-16.
 The API offers a utility function that allocates a string containing the
 representation of the text in UTF-8 (which is an ASCII-compatible format),
 
\family typewriter 
GetStringUTFChars
\family default 
.
 This string must be later deallocated with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
 The 
\family typewriter 
GetStringChars
\family default 
 function provides direct access to the string in UTF-16 format; it has
 an output argument that indicates if the returned string is the JVM's own
 internal buffer or if it is a copy.
 At the same time that this saves the C code from duplicating the string
 in cases when one wants to modify it and the JVM has returned a copy, this
 parameter exposes to the API low-level issues of the JVM string management.
 Alternatively, the 
\family typewriter 
GetStringRegion
\family default 
 and 
\family typewriter 
GetStringUTFRegion
\family default 
 functions perform a copy of the string to a pre-allocated buffer provided
 by the programmer.
 
\family typewriter 
GetStringCritical
\family default 
 returns a pointer to the JVM internal buffer, but this involves special
 care with regard to garbage collection, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays of primitive elements are handled in a similar way to strings, differentl
y from object arrays
\begin_inset Foot
collapsed true

\layout Standard

Multi-dimensional arrays are considered as 
\begin_inset Quotes eld
\end_inset 

arrays of arrays
\begin_inset Quotes erd
\end_inset 

 and, as such, are also object arrays.
\end_inset 

.
 There are functions for performing array copies (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), functions that return pointers to the array that may or may not perform
 copies, similarly to 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<type
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) and functions that can access the JVM internal buffer, like in 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 For object arrays, it is not possible to obtain a pointer to an array's
 internal buffer.
 Access to elements is performed one at a time, through 
\family typewriter 
jobject
\family default 
 references, with 
\family typewriter 
Get
\family default 
/
\family typewriter 
SetObject\SpecialChar \-
ArrayElement
\family default 
.
\layout Standard

The retrieval of values and attributes is done through functions such as
 
\family typewriter 
GetObjectField
\family default 
 and 
\family typewriter 
GetStaticField
\family default 
, which return reference of the 
\family typewriter 
jobject
\family default 
 type.
 For each primitive type there is an equivalent type, such as 
\family typewriter 
GetIntField
\family default 
 and 
\family typewriter 
GetStaticIntField
\family default 
.
 Like in Ruby, the Java API defines a specific C type to avoid the frequent
 use of C strings in the description of fields.
 However, while ruby uses 
\family typewriter 
ID
\family default 
s which are merely interned strings, in Java field identifiers, of the 
\family typewriter 
jfieldID
\family default 
 type, contain type information and are specific for a field of a given
 class.
 These values are obtained with the 
\family typewriter 
GetFieldID
\family default 
 call, which receives among its arguments a string called the 
\begin_inset Quotes eld
\end_inset 

JNI field descriptor
\begin_inset Quotes erd
\end_inset 

 with a special syntax.
 For example, the Java type 
\family typewriter 
int[][]
\family default 
 is described with 
\family typewriter 
"[[I"
\family default 
 and the 
\family typewriter 
java.lang.String
\family default 
 type as 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This is another place where implementation details leak through the API.
 Not coincidently, this syntax is the same used in the internal representation
 of types in JVM bytecodes.
\end_inset 

.
 It is also possible to obtain a 
\family typewriter 
jfieldID
\family default 
 from a 
\family typewriter 
java.lang.reflect.Field
\family default 
 object using the 
\family typewriter 
FromReflectedField
\family default 
 function.
\layout Standard

JNI calls are done in C with 
\family typewriter 
(*J)->
\family default 
\emph on 
function
\family typewriter 
\emph default 
(J,
\family default 
 ...
\family typewriter 
)
\family default 
: JNI functions are accessed through function pointers stored in a table
 pointed by a 
\family typewriter 
JNIEnv
\family default 
 structure, which is then propagated in calls.
 The goal of these two levels of indirection is to decouple the linkage
 of calls in C code from the library that implements the JNI, allowing to
 link the code at runtime to different implementations of the JVM\SpecialChar ~

\begin_inset LatexCommand \cite{stepanian05inliningjava}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExampleJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elements = { "Earth", "Air", "Fire", "Water" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaration of the externally implemented method */
\layout LyX-Code


\size footnotesize 
   private native void secondElement();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Creates an instance and invokes the native method */
\layout LyX-Code


\size footnotesize 
      new ExampleJNI().secondElement();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Loads in the JVM the external code that will implement
\layout LyX-Code


\size footnotesize 
\emph on 
         the secondElement method */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExampleJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Java class containing an externally implemented method
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExampleJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExampleJNI_secondElement(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the class of 'this': ExampleJNI */
\layout LyX-Code


\size footnotesize 
   jclass klass = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get ExemploJNI.elements, a String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, klass,
\layout LyX-Code


\size footnotesize 
      "elements", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the contents of ExemploJNI.elements */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elements[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the representation of elems_1 as a C string */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Show the string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Free the memory of the string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

C code implementing a Java method
\end_inset 


\layout Standard

The access to Java attributes in C code is illustrated through the following
 example.
 Initially, in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, we implement a Java class that has a private attribute, the elements 
\family typewriter 
array
\family default 
, and defines a function, 
\family typewriter 
secondElement
\family default 
, to be implemented in C
\begin_inset Foot
collapsed true

\layout Standard

Details about the declaration and registration of functions implemented
 in C will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

The implementation of 
\family typewriter 
secondElement
\family default 
 is presented in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, showing the sequence of calls needed to obtain in C the element of the
 Java array.
 To access the 
\family typewriter 
elements
\family default 
 attribute, the function has to obtain the field identifier.
 For that, we need first to obtain a reference of the current class with
 
\family typewriter 
GetObjectClass
\family default 
 from the object reference (
\family typewriter 
this
\family default 
) passed a parameter to the function.
 Once we have the class reference (
\family typewriter 
klass
\family default 
), we obtain the field identifier with 
\family typewriter 
GetFieldID
\family default 
.
 The content of the field is then obtained with 
\family typewriter 
GetObjectField
\family default 
: a reference to the array.
 Using it, the element of the array is obtained with 
\family typewriter 
GetObjectArrayElement
\family default 
.
 A copy of the element, converted to a UTF-8-encoded C string, is returned
 with 
\family typewriter 
GetStringUTFChars
\family default 
.
 As previously discussed, after its use, the string must be freed with 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

The manipulation of objects of the 
\family typewriter 
Class
\family default 
 type is also done through specific functions.
 It is not possible to create Java classes through the C API, but it is
 possible to load classes at runtime using the 
\family typewriter 
DefineClass
\family default 
 function, which receives a buffer containing the representation of a pre-compil
ed Java class.
 References of the 
\family typewriter 
jclass
\family default 
 type can be obtained from the class name using 
\family typewriter 
FindClass
\family default 
, which uses a syntax for descriptors similar to that used by 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

In both field and class descriptors, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 represents 
\family typewriter 
String[]
\family default 
.
 For the 
\family typewriter 
String
\family default 
 type, however, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 is the field descriptor and 
\family typewriter 
"java/lang/String"
\family default 
 the class descriptor.
\end_inset 

.
\layout Standard

For assigning C values that can be converted to Java primitive types, the
 JNI provides functions such as 
\family typewriter 
SetIntField
\family default 
 and 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 For other types, there are no specific provisions for storing C data in
 the Java object space.
 In those cases, the documentation suggests the storage of pointers in numeric
 types\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

, in spite of the portability problems brought by this approach.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

The Lua API defines a different approach for manipulating data in C: no
 pointers or handles to Lua objects are ever exposed to C code.
 Operations are defined in terms of indices of a virtual stack.
 So, data transfer from C to Lua takes place through functions that receive
 C types, convert them to Lua values and stack them, such as 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 and 
\family typewriter 
lua_pushlstring
\family default 
.
 Several operations of the API operate on the value at the top of the stack,
 such as, for example, 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

API functions that operate on a Lua execution state receive an initial argument
 (in our examples, called 
\family typewriter 
L
\family default 
), indicating the state they refer to.
 This will be discussed later, in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Inserts the number 123 in the stack */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Sets the number 123 to global 
\emph default 
foo
\emph on 
 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Most lookup functions, however, allow one to specific any stack index (with
 positive values for indexing from the bottom and negative values for indexing
 from the top).
\layout Standard

Conversion of data from Lua to C is made through functions such as 
\family typewriter 
lua_tonumber
\family default 
 and 
\family typewriter 
lua_tolstring
\family default 
, which receive a stack index, convert the value at the given index to the
 specified Lua type if necessary, and return the value converted to the
 equivalent C type.
 Numbers have the 
\family typewriter 
lua_Number
\family default 
 C type, which corresponds to 
\family typewriter 
double
\family default 
 by default but is a compile-time parameter for the Lua virtual machine.
 Strings, in particular, are immutable objects and are interned: any two
 identical strings share the same internal representation.
\layout Standard

So, unlike languages such as Python and Ruby, it is not possible to modify
 the contents of a Lua string from C through its memory representation as
 a 
\family typewriter 
char*
\family default 
.
 To make the incremental construction of Lua strings from C more efficient,
 the Lua auxiliary library defines a C type called 
\family typewriter 
luaL_Buffer
\family default 
 and functions such as 
\family typewriter 
luaL_addstring
\family default 
 and 
\family typewriter 
luaL_addvalue
\family default 
, which allow the construction of a string in stages until it can be finally
 converted to a Lua string with 
\family typewriter 
luaL_pushresult
\family default 
.
 This way, one avoids consecutive string concatenation operations through
 the Lua API.
\layout Standard

Lua defines two specific data types for storing C data, 
\emph on 
full userdata
\emph default 
 and 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 describe memory blocks managed by Lua and used by C code.
 They exist in Lua as opaque objects, and are created by 
\family typewriter 
lua_newuserdata
\family default 
, which inserts the new object in the Lua stack and returns to C a pointer
 to the memory area of the requested size.
 Objects of the 
\emph on 
light userdata
\emph default 
 type, created through 
\family typewriter 
lua_pushlightuserdata
\family default 
, allow storing C pointers in Lua; allocation and management of the memory
 block are to be handled by C code.
 The following example illustrates the use of userdata, assuming the same
 
\family typewriter 
point
\family default 
 struct defined in page\SpecialChar ~

\begin_inset LatexCommand \pageref{struct-point}

\end_inset 

.
 The userdata object is created this way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a full userdata, inserts it in the stack and returns
\layout LyX-Code


\size footnotesize 
\emph on 
   the pointer to C.
 The memory is allocated by Lua.
 */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* We then use the pointer in C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the object to the global variable 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard

Now, accessing it:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Pushes the global 
\emph default 
Point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the C pointer from the userdata at the top of the stack (-1) */
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d)
\backslash 
n", p->x, p->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restores the stack to its original position, removing the item.
\layout LyX-Code


\size footnotesize 
\emph on 
   It won't be collected, as it is tied to the global variable.
 */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assuming that the global 
\family typewriter 
Point
\family default 
 is the only reference to this block, to free it all we have to do is overwrite
 
\family typewriter 
Point
\family default 
 with, for example, 
\family typewriter 
nil
\family default 
; the memory of the full userdata will then be eligible for retrieval by
 the garbage collector, like that of any Lua value with no references.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Point");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The stack storage area does not adjust itself dynamically and the API functions
 do not perform overflow checks.
 So, the programmer is responsible for controlling the stack size, through
 the 
\family typewriter 
lua_checkstack
\family default 
 function.
 In practice, the stack size will only grow in loops pushing elements, since
 typical sequences of operations tend to push values and pop them later.
\layout Standard

Tables are the only type available for construction of data structures in
 Lua.
 Lua offers a complete API for manipulation of tables from C.
 Tables can be created with 
\family typewriter 
lua_newtable
\family default 
 or 
\family typewriter 
lua_createtable
\family default 
; the second form allows one to pre-allocate memory for table elements.
 The 
\family typewriter 
lua_gettable
\family default 
 and 
\family typewriter 
lua_settable
\family default 
 implement the semantics of reading and writing fields to a Lua table, including
 eventual calls to metamethods; for calls without metamethod invocation
 there are 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, which are equivalent to 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 in Lua (besides two convenience variants, 
\family typewriter 
lua_rawgeti
\family default 
 and 
\family typewriter 
lua_rawseti
\family default 
).
 There is also the 
\family typewriter 
lua_next
\family default 
 function, equivalent to the Lua function 
\family typewriter 
next
\family default 
, which is designed for traversing elements of a table.
 An example of table manipulation is given below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tbl["key"] = 12345, in C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tbl");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "key");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable inserts the item at the top of the stack
\layout LyX-Code


\size footnotesize 
\emph on 
   to the table given as a parameter,
\layout LyX-Code


\size footnotesize 
\emph on 
   using as a key the item right below the top: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Many Lua concepts are represented through tables -- the global environment,
 metatables, registry -- are are thus handled in C using the API functions
 for table manipulation.
 The global environment table of the currently executing thread can be accessed
 through a special index of the virtual stack, 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 One can also define a function environment table, indexed with 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, to isolate data to be shared internally by functions in modules written
 in C.
 For example, the global environment can be manipulated as a table this
 way:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "Point");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Standard

This is equivalent to:
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Point");
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

The procedures for extending and embedding Perl are very different from
 each other.
 For extensions, Perl provides an interface description language called
 XS.
 Instead of isolating the access to Perl's internal structures through a
 public API, the proposed approach is to encapsulate the process of generating
 wrapper code for the communication of functions written in C to the internal
 structures of Perl using interfaces written in XS.
 Files of the 
\family typewriter 
.xs
\family default 
 type contain C code along with annotation that simplifies the handling
 of input and output parameters.
 These are fed to the 
\family typewriter 
xsubpp
\family default 
 pre-processor, which generate then code using the API provided by the Perl
 library.
 This library offers low-level access to the inner workings of the interpreter,
 allowing one, for exemple, to manipulate its internal stack pointer.
 The goal of XS is to hide these details from the extension developer.
\layout Standard

To embed the Perl interpreter to an application, the library that implements
 it offers some functions that allow one to launch an interpreter.
 In the higher-level API, one can build an array of arguments to be passed
 to the interpreter in the same way as options are given to the Perl command-lin
e interpreter, even using the 
\family typewriter 
"-e"
\family default 
 flag to execute pieces of code.
\layout Standard

The types of Perl variables are mapped to C structs: 
\family typewriter 
SV
\family default 
 for scalars, 
\family typewriter 
AV
\family default 
 for arrays, 
\family typewriter 
HV
\family default 
 for hashes.
 These C values are better understood as 
\emph on 
containers
\emph default 
 to Perl values: a scalar variable in Perl has an 
\family typewriter 
SV
\family default 
 associated to itself; however, one can create in C an 
\family typewriter 
SV
\family default 
 that is not associated to any Perl variable name.
\layout Standard

Primitive types of Perl are represented as C values through typedefs: 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 and 
\family typewriter 
PV
\family default 
 correspond, respectively, to signed and unsigned integers, floating-point
 values and strings.
 These values can be copied to 
\family typewriter 
SV
\family default 
s.
 Perl references are represented as 
\family typewriter 
RV
\family default 
, and are also a kind of 
\family typewriter 
SV
\family default 
.
 There is also the 
\family typewriter 
GV
\family default 
 type, which represents any type representable through a Perl variable.
\layout Standard

Variables from the Perl data space are accessed with 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 and 
\family typewriter 
get_hv
\family default 
.
 These functions receive a C string with the variable name (possibly qualified
 through the 
\family typewriter 
"package::variable"
\family default 
 syntax).
 The content of scalar values are converted back to C ytpes with the 
\family typewriter 
Sv
\family default 
* macros: 
\family typewriter 
SvIV
\family default 
 returns an integer, 
\family typewriter 
SvPV
\family default 
 returns a 
\family typewriter 
char*
\family default 
 and the string length in the second argument, etc.
 The following C code prints the contents of the Perl variable 
\family typewriter 
$a
\family default 
, assuming it contains an integer value:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The flag given as a second argument for 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 indicates whether the variable should be created if the given name does
 not correspond to an existing varible.
 Passing an unexisting name and using 
\family typewriter 
TRUE
\family default 
 as the second argument is a convenient way to create a new variable accessible
 from the C space and at the same making its binding in the Perl space.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates a variable of the array type,
\layout LyX-Code


\size footnotesize 
\emph on 
   accessible in Perl as the global @arr and in C as the AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

An 
\family typewriter 
SV
\family default 
 can be created in C with the 
\family typewriter 
newSV
\family default 
* family of functions: 
\family typewriter 
newSViv
\family default 
 generates a new SV storing a signed integer; 
\family typewriter 
newSVpv
\family default 
 stores a string, and so on.
 The 
\family typewriter 
newSV
\family default 
 function creates a 
\family typewriter 
SV
\family default 
 with an uninitialized memory area, accessible through the 
\family typewriter 
SvPVX
\family default 
 function, providing a way to create scalars with arbitrary values generated
 by C code.
 Using the same example of the 
\family typewriter 
point
\family default 
 struct from previous sections, we can store a C object in a Perl value
 in the following way:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Allocates an unitialized SV, the size of a 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the pointer to the SV's memory area */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipulates the 
\emph default 
point
\emph on 
 in C.
 When v is returned to Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
it will be an opaque variable (its contents won't be accessible).
 */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Values are assigned to 
\family typewriter 
SV
\family default 
s using the 
\family typewriter 
sv_set
\family default 
* family of functions: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 Functions for string handling have variants such as 
\family typewriter 
newSVpvn
\family default 
 and 
\family typewriter 
sv_setpvf
\family default 
, which receive the string length or perform 
\family typewriter 
sprintf
\family default 
-style formatting.
 For strings, there are also the 
\family typewriter 
sv_cat
\family default 
* functions, which act like 
\family typewriter 
sv_set
\family default 
* but concatenate the value given to the current content of the string instead
 of replacing it.
 The 
\family typewriter 
sv_setsv
\family default 
 function copies the value of an 
\family typewriter 
SV
\family default 
 to another.
 The 
\family typewriter 
SV
\family default 
 created in the previous example can be assigned to a global variable like
 this:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Gets the SV from the global 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* pnt = get_sv("point", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Assigns the value of 
\emph default 
v
\emph on 
 to 
\emph default 
$point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
sv_setsv(pnt, v);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The type of data stored in 
\family typewriter 
SV
\family default 
s is checked with the 
\family typewriter 
SvIOK
\family default 
 macro for integers, 
\family typewriter 
SvNOK
\family default 
 for floating-point values, and 
\family typewriter 
SvPOK
\family default 
 for strings.
 These functions return success if the scalar is convertible to the specified
 type -- the variants 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verify if the value stored in the 
\family typewriter 
SV
\family default 
 is actually of that type.
\layout Standard

Arrays and hashes are created with 
\family typewriter 
newAV
\family default 
 and 
\family typewriter 
newHV
\family default 
.
 Arrays can be populated with a C array of 
\family typewriter 
SV
\family default 
 pointers through 
\family typewriter 
av_make
\family default 
.
 Operations such as 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 and 
\family typewriter 
hv_exists
\family default 
 operate on elements of these structures.
 In 
\family typewriter 
av_fetch
\family default 
 and 
\family typewriter 
hv_fetch
\family default 
, the return type is 
\family typewriter 
SV**
\family default 
, to differentiate between returning an existing element which points to
 
\family typewriter 
NULL
\family default 
 from returning 
\begin_inset Quotes eld
\end_inset 

element not found
\begin_inset Quotes erd
\end_inset 

.
 In the following example, we create a Perl array containing the 10 first
 elements of the Fibonacci series:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Create a new array.
 */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Store two values, 0 and 1, at its first positions.
 */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviously, it would be more efficient to store these values in
\layout LyX-Code


\size footnotesize 
\emph on 
      temporary values in C, but we'll obtain the last two values
\layout LyX-Code


\size footnotesize 
\emph on 
      back from the Perl array for illustration purposes: */
\layout LyX-Code


\size footnotesize 
   SV** next_to_last_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** last_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtain the integers stored in those SVs */
\layout LyX-Code


\size footnotesize 
   int next_to_last = SvIV(*next_to_last_sv);
\layout LyX-Code


\size footnotesize 
   int last = SvIV(*last_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Create a new SV and insert it in the end of the array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( next_to_last + last ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once this 
\family typewriter 
AV
\family default 
 is created, however, there is no way to associate it to a Perl variable.
 Its contents must be copied item by item.
 To make it accessible from Perl, we should have created it with 
\family typewriter 
get_av
\family default 
, and not 
\family typewriter 
newAV
\family default 
.
 
\family typewriter 
AV
\family default 
s that are not associated to variables are useful, however, when passing
 arguments in function calls and as return values.
\layout Standard

Some functions for hash manipulation expose the key/value pairs as 
\family typewriter 
HE
\family default 
 pointers.
 The 
\family typewriter 
HeSVKEY
\family default 
 and 
\family typewriter 
HeVAL
\family default 
 macros extract the key and value from an 
\family typewriter 
HE
\family default 
.
 The following C function prints the elements of a Perl hash:
\layout LyX-Code


\size footnotesize 
void print_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Each HV keeps its own internal iteration control */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Get the next key/value pair in the iteration */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Get the string representation of scalars
\layout LyX-Code


\size footnotesize 
\emph on 
         representing key and value of the item */
\layout LyX-Code


\size footnotesize 
      char* key = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* value = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", key, value);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Special care should be taken when using the values 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 and 
\family typewriter 
false
\family default 
 in arrays and hashes, even though Perl exposes these constants in its C
 API (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 The constant 
\family typewriter 
PL_sv_undef
\family default 
 is used internally in the implementation of 
\family typewriter 
AV
\family default 
s and 
\family typewriter 
HV
\family default 
s, and the update of values in 
\family typewriter 
HV
\family default 
s happens in-place, which generates problems when updating elements containing
 these constants.
 The documentation recommends generating copies of these values when using
 them in 
\family typewriter 
AV
\family default 
 and 
\family typewriter 
HV
\family default 
 structures\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlguts}

\end_inset 

.
\layout Standard

Perl references are created with 
\family typewriter 
newRV_inc
\family default 
 and 
\family typewriter 
newRV_noinc
\family default 
, which receive an 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 pointer as a parameter (these two functions differ in how they handle reference
 counted, which will be discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 The value pointed by a reference is obtained with 
\family typewriter 
SvRV
\family default 
.
 The return value of this macro must be converted through a cast to the
 appropriate type (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), which can be checked with 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Many functions of the API have argument or return types declared as 
\family typewriter 
SV
\family default 
 when in fact they accept 
\family typewriter 
AV
\family default 
s or 
\family typewriter 
HV
\family default 
s; this is analogous to the concept of Perl 
\emph on 
contexts
\emph default 
, in which the same value can be treated as a list (array or hash) or scalar
 depending on the expression where it is inserted\SpecialChar ~

\begin_inset LatexCommand \cite{marquess06perlcall}

\end_inset 

.
 In Perl code, the context where a function is executed can be inspected
 with 
\family typewriter 
wantarray
\family default 
.
 In C, the context can be checked with the 
\family typewriter 
GIMME_V
\family default 
 macro, which returns 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 or 
\family typewriter 
G_ARRAY
\family default 
.
\layout Subsection

Comparison
\layout Standard

The basic set of functions for manipulating data in the five languages presented
 here is similar: all of them provide functions for converting values from
 the language to basic C types and vice versa.
 All of them also offer functions for manipulating their fundamental structured
 types (tables in Lua, arrays in Java, arrays and hashes in Ruby and Perl,
 lists and dictionaries in Python).
 Python, in particular, defines an extensive function API for operations
 on its built-in classes; most of these functions could be performed using
 the generic API for method invocation, but they are offered directly in
 C as a convenience.
\layout Standard

Lua stands out for having, with its stack model, the simplest and most orthogona
l data manipulation API among the ones studied.
 However, the resulting code often loses in readability when the stack indices
 are not obvious.
 It is commonplace to see C code using the Lua API commented line by line,
 to save the programmer from having to simulate mentally the stack operations
 while reading the program.
\layout Standard

In Java, static typing reduces greatly the need of explicit data conversion
 in C code.
 On the other hand, treatment of multi-threading complicates the access
 of types such as strings and arrays.
\layout Standard

A negative point in the Ruby API is the exposure of implementation details
 of the struct fields that describe its fundamental 
\family typewriter 
VALUE
\family default 
 type.
 This restricts the flexibility of the language implementation and fosters
 unsafe programming practices.
 Perl also exposes a good deal of its internal structures; not as directly
 as Ruby, but through macros.
 These macros, however, assume the adherence to usage protocols so strict
 that in practice they also largely limit the possibilities of changes in
 the implementation (an example of this is the sequence for function calls,
 which will be presented in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

).
\layout Standard

The creation of data containing C structures stored by the scripting language
 is an easy task in Perl, Ruby and Lua: Perl allows one to create 
\family typewriter 
SV
\family default 
s containing arbitrary memory blocks for use in C; Ruby offers the 
\family typewriter 
Data_Wrap_Struct
\family default 
 macro which generates a Ruby object which encapsulates a C structure; Lua
 defines a basic type in the language especially for this end.
 In Python, on its turn, the process is not as straightforward.
 Creating a Python class from C involves declaring parts of it statically
 and other parts dynamically, being usually necessary to define three different
 C structures.
 In Java, it is not possible to create new types from C, one can only load
 classes.
\layout Standard

Another common task when interacting with C is the need to store pointers
 in the data space of the scripting language.
 Python, Lua and Perl offer features to do this directly: creating a 
\family typewriter 
PyCObject
\family default 
 in Python; a light userdata in Lua; or storing a pointer in the data area
 of an 
\family typewriter 
SV
\family default 
 in Perl.
 In Java and Ruby, the alternative is to convert pointers and store them
 as numbers.
 In fact, this happens internally in the implementation of Ruby, and the
 portability limitations of this approach are made evident by the fact that
 the compilation of Ruby fails if 
\family typewriter 
sizeof(void*) != sizeof(long)
\family default 
.
\layout Standard

Finally, an aspect that deserves being mentioned is the concern on not polluting
 the C namespace.
 Python, Java and Lua define all its functions and C types with prefixes
 that aim to avoid conflicts with names defined by the application.
 Perl and Ruby define names in a disorganized fashin, which occasionally
 causes problems
\begin_inset Foot
collapsed true

\layout Standard

For example, conflicts of this kind happened in the Ruby bindings of the
 Subversion revision control system in Win32 platforms (
\begin_inset LatexCommand \url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}

\end_inset 

).
\end_inset 

.
 Perl has options to disable a series of macros and force a common prefix
 in its functions, but this feature is incomplete and using it hampers the
 functionality of its headers
\begin_inset Foot
collapsed true

\layout Standard

In the case study presented in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

, when using the Perl API we tried to restrict ourselves to the 
\family typewriter 
Perl_
\family default 
-prefixed versions of the API functions, but many necessary macros are only
 available in versions with no prefix.
\end_inset 

.
\layout Section

Garbage collection
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

From the moment when C code gains access to references to data stored in
 the storage space of another language, be them pointers or identifiers,
 the programmer must take into consideration the differences between the
 memory management models involved, since code executed in the other language
 may free the data.
 For example, the C program may deallocate an object referenced by data
 in the scripting language, or the scripting language may remove an element
 from a structure causing it to be collected.
 In principle, this task of maintaining consistency between these two environmen
ts is no different from manual memory management normally taken care by
 C programmers.
 However, the interaction with some languages adds an important factor of
 complexity: the garbage collection mechanisms perform deallocation of data
 from memory in an implicity manner.
 The fundamental principle of garbage collection dictates that an object
 is not collected in case there is some element (variable, data structure)
 pointing to it.
 However, the same is not valid for the C environment: the presence of a
 pointer pointing to an object does not guarantee that it will not be collected,
 given that the garbage collector does not manage pointers from C code.
\layout Standard

It is necessary, then, to indicate from C code that the data remain accessible
 from it and must not be collected.
 In a complementary way, when transferring the control of C objects to the
 domain of the other language -- for example, when storing them in a data
 structure of the other language -- it is necessary to indicate to the language
 how to deallocate the memory of the structure when the garbage collector
 detects that it is no longer in use.
 The way how the API will provide these functionalities depends not only
 of the design of the C API, but also of the garbage collection mode employed
 by the implementation of the language.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

The Python virtual machine features a garbage collector based on reference
 counting.
 As the Python API returns to C code pointers to 
\family typewriter 
PyObject
\family default 
s, the programmer must have the care of ensuring that they will remain valid.
 For such, it is necessary to increment and decrement the pointed object's
 reference count according to how one wants to control the validity of the
 pointers in C code.
\layout Standard

In general, once the C code needs to retain a 
\family typewriter 
PyObject*
\family default 
, it should use the 
\family typewriter 
Py_INCREF
\family default 
 macro to increment its reference count and so prevent it from being collected.
 Once the value is no longer needed, the reference count is similarly decremente
d with 
\family typewriter 
Py_DECREF
\family default 
.
 Python works with the concept of 
\emph on 

\begin_inset Quotes eld
\end_inset 

reference ownership
\begin_inset Quotes erd
\end_inset 


\emph default 
 to define when the programmer needs to increment or decrement the counter
 of references returned by API functions.
 Most API functions that return pointers to 
\family typewriter 
PyObject
\family default 
s transfer references to the caller; the reference becomes the caller's
 responsibility -- it can either pass it on or it will have to decrement
 it with 
\family typewriter 
Py_DECREF
\family default 
 when it is not needed anymore (C code can store owned references in its
 data structures; they will remain valid even after the return of the function,
 until they are explicitly decremented).
 Other functions 
\emph on 
lend
\emph default 
 references; the code that borrows the reference does not need to decrement
 it after using it, but the validity of the object is attached to the validity
 of the reference in the object that returned it to C.
 For example, 
\family typewriter 
PyList_GetItem
\family default 
 lends a reference to an element of the list.
 The pointer returned will remain valid while the the item remains stored
 in the list.
 It is possible to obtain 
\begin_inset Quotes eld
\end_inset 

ownership
\begin_inset Quotes erd
\end_inset 

 of a borrowed reference by incrementing the object count with 
\family typewriter 
Py_INCREF
\family default 
: the validity of the pointer becomes independent from the container object
 that returned it, but the C code becomes responsible for decrementing the
 reference later with 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

For object references passed from C back to Python, there are two cases
 in the API where functions 
\emph on 

\begin_inset Quotes eld
\end_inset 

steal
\begin_inset Quotes erd
\end_inset 


\emph default 
 references, that is, in which the reference no longer belongs to the calling
 C function: 
\family typewriter 
PyList_SetItem
\family default 
 and 
\family typewriter 
PyTuple_SetItem
\family default 
.
 The given reference, which belonged to the caller, becomes owned by the
 list or tuple.
 In the context of the caller, it is now a borrowed reference, which does
 not have to be decremented anymore.
 The point of this is to allow nested function calls where, for example,
 the argument for 
\family typewriter 
PyList_SetItem
\family default 
 is a call that generates a new object to be stored in the list.
 So, this avoids having to store a pointer to the object only to decrement
 its reference later.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Possibly invalid access in 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 is definitely valid in 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Possibly invalid access in a reference to a 
\family typewriter 
PyObject
\family default 
 in C code
\end_inset 


\layout Standard

The interaction with the reference counter can be very subtle.
 The example in Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extracted from the Python documentation, demonstrates that a reference
 can be invalidated by apparently unrelated code
\begin_inset Foot
collapsed true

\layout Standard

In fact, the documentation informs that older versions of Python contained
 variants of this bug in some of its modules.
\end_inset 

.
 At first sight, the insertion of an element in 
\family typewriter 
list[1]
\family default 
 seems not to affect the 
\family typewriter 
item
\family default 
 reference, which corresponds to 
\family typewriter 
list[0]
\family default 
.
 However, the insertion of 
\family typewriter 
list[1]
\family default 
 may have removed from the list an element that was in this position.
 In case the list was the last valid reference to the element, it might
 be collected.
 The collection of the object can invoke its finalizer method 
\family typewriter 
__del__
\family default 
, that can run arbitrary Python code.
 If this code removes the element from position 0 of 
\family typewriter 
list
\family default 
 and this triggers its collection, 
\family typewriter 
item
\family default 
 becomes invalid, because 
\family typewriter 
PyList_GetItem
\family default 
 returns a borrowed reference.
\layout Standard

When implementing C functions that return references to 
\family typewriter 
PyObject
\family default 
s, the same care of defining the lifetime policy of the reference should
 be taken.
 To return a new reference to be owned by the caller, it may be necessary
 to increment the object's count.
 This manifests itself, for example, in the correct way for a C function
 to return the value None, which involves calling 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed true

\layout Standard

This pattern is so common that the sequence 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 was encapsulated in the 
\family typewriter 
Py_RETURN_NONE
\family default 
 macro.
\end_inset 

.
 Even Python objects representing numbers need to have their reference count
 controlled by the C programmer.
\layout Standard

It is possible to define a deallocation function in the 
\family typewriter 
tp_dealloc
\family default 
 field of the 
\family typewriter 
PyTypeObject
\family default 
 structure so that C code can perform finalization operations over data
 stored in a Python type defined in C.
 This function is normally responsible for freeing resources allocated through
 C code (open files, pointers to memory areas unaccessible from Python,
 etc.) and decrementing references to other Python objects maintained by
 the object.
\layout Standard

When deallocating data structures such as lists it is possible to trigger
 an arbitrarily large chain of deallocations, as each element causes the
 deallocation of the next element of the structure.
 This launches the deallocation function recursively and could easily cause
 a stack overflow in C.
 To work around this problem, Python includes a pair of macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 and 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, that control the accepted number of recursion levels.
 At each execution of 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 an internal counter is incremented.
 While this counter does not reach the limit value defined in the 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 constant (50 by default), the function runs normally.
 When the limit is reached, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 stores the object in an internal list and jumps straight to 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, avoiding the deallocation the object and another recursion.
 At the end of each level of the recursion, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 decrements the counter.
 When the counter reaches zero, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 launches again 
\family typewriter 
tp_dealloc
\family default 
 on the elements stored in the internal list, restarting then the recursion
 on the structure.
 So, a chain of 
\begin_inset Formula $n$
\end_inset 

 deallocations is broken into 
\begin_inset Formula $n/$
\end_inset 


\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 chains, none of them exceeding 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 levels of recursion in the C stack.
 The implementation of the main structured types of Python, such as lists,
 tuples and dictionaries, make use of this mechanism.
\layout Standard

Garbage collection using reference counts brings with it concerns about
 circular references: a chain of objects maintaining references to each
 other keeps the count of each of its elements greater than zero, even if
 they are not reachable from any other object.
 Python includes a cycle detector, but special measures must be taken to
 ensure that types implemented in C behave correctly if they can generate
 cycles.
 One must implement a function to traverse references contained in the object
 and a function to decrement their reference counts.
 These functions must be registered in the 
\family typewriter 
tp_traverse
\family default 
 and 
\family typewriter 
tp_clear
\family default 
 fields of the 
\family typewriter 
PyTypeObject
\family default 
 structure.
 The 
\family typewriter 
tp_clear
\family default 
 function has to take the precaution of clearing the value of its 
\family typewriter 
PyObject*
\family default 
 fields to 
\family typewriter 
NULL
\family default 
 before decrementing each reference, since the decrement operation may start
 the deallocation of the object and launch a call to 
\family typewriter 
tp_traverse
\family default 
 which, due to the cycle, may return to the previous object.
 The type must be, then, identified with the 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 flage in the 
\family typewriter 
tp_flags
\family default 
 field of 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard

Besides, the implementation of Python objects that support cyclic collection
 in C implies in yet more care.
 Objects must be allocated with 
\family typewriter 
PyObject_GC_New
\family default 
 or 
\family typewriter 
PyObject_\SpecialChar \-
GC_NewVar
\family default 
 instead of the usual functions 
\family typewriter 
PyObject_New
\family default 
 and 
\family typewriter 
PyObject_NewVar
\family default 
.
 During the construction of the object, after the fields to be visited by
 
\family typewriter 
tp_traverse
\family default 
 are filled, it is still necessary to call a notification function, 
\family typewriter 
PyObject_GC_Track
\family default 
, and during deallocation, before invalidating the object's fields, to call
\family typewriter 
 PyObject_GC_UnTrack
\family default 
.
 For objects that need the 
\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 

 mechanism to avoid stack overflow, it is also necessary to take the precaution
 of unmarking the object with 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 before entering the 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
 block.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\end_inset 


\layout Standard

In spite of offering a cycle detection mechanism, Python is unable to collect
 cycles whose objects contain finalizers implemented in Python itself (
\family typewriter 
__del__
\family default 
 methods); the only way to access those objects is then through the 
\family typewriter 
garbage
\family default 
 list in the 
\family typewriter 
gc
\family default 
 module.
 This module (accessible to C through Python function calls using the C
 API) offers an interface to the garbage collector, including 
\family typewriter 
enable
\family default 
 and 
\family typewriter 
disable
\family default 
 functions, to activate and deactivate the garbage collector; 
\family typewriter 
collect
\family default 
, to run a collection; 
\family typewriter 
get_objects
\family default 
, which returns a list containing all objects controlled by the collector
 (except the list itself); 
\family typewriter 
get_referrers
\family default 
 and 
\family typewriter 
get_referents
\family default 
, which return the list of object that refer or are referred by a given
 object -- these lists are obtained using the 
\family typewriter 
tp_traverse
\family default 
 function, which may not point to all objects actually reachable, or may
 still return objects in an invalid state (such as objects in cycles that
 were not yet collected or objects still not fully constructed) and therefore
 should be used only for debugging purposes.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby uses a mark-and-sweep garbage collector\SpecialChar ~

\begin_inset LatexCommand \cite{wilson92gc}

\end_inset 

.
 This technique avoids the problem of cyclic references faced by Python;
 having valid objects correctly indicated as reachable is sufficient.
\layout Standard

Objects that are reachable from the Ruby data space -- assigned to a Ruby
 global variable or inserted in some data structure reachable in Ruby --
 will not be subjected to garbage collection.
 In addition, we have objects returned by Ruby to the C space, since many
 API functions return 
\family typewriter 
VALUE
\family default 
s.
 The documentation warns that, to store Ruby objects in C, either in global
 variables or in data structures, it is necessary to notify the virtual
 machine that the 
\family typewriter 
VALUE
\family default 
 must not be collected using the 
\family typewriter 
rb_global_variable
\family default 
 function\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 (although not mentioned in the documentation, it is possible to unmark
 a global value with 
\family typewriter 
rb_gc_unregister_address
\family default 
).
\layout Standard

Objects in the local scope of a C function, however, do not need to be notified.
 The way how Ruby ensures the validity of local 
\family typewriter 
VALUE
\family default 
s is remarkably peculiar: when performing the mark phase, the garbage collector
 scans the C stack looking for values that look like 
\family typewriter 
VALUE
\family default 
 addresses, that is, numeric sequences that correspond to valid 
\family typewriter 
VALUE
\family default 
 addresses.
 These addresses can be identified because objects are always allocated
 within heaps maintained by the Ruby interpreter.
 Each 
\family typewriter 
VALUE
\family default 
 found in the stack is then marked.
 This ensures that any 
\family typewriter 
VALUE
\family default 
 locally accessible by C code becomes invalidated, but may generate 
\begin_inset Quotes eld
\end_inset 

false positives
\begin_inset Quotes erd
\end_inset 

 stopping data that could be collected from being so.
\layout Standard

In spite of programmer convenience, such approach is extremely non-portable.
 The implementation of the garbage collector in Ruby 1.8.2 has 
\family typewriter 
#ifdef
\family default 
s for IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC and Motorola 68000.
 Besides, the collector forces the discharge of registers to the stack using
 
\family typewriter 
setjmp
\family default 
, to prevent variables of the 
\family typewriter 
VALUE
\family default 
 type that may have been optimized into registers by the compiler from being
 missed.
\layout Standard

As we have seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-dados}

\end_inset 

, Ruby objects created with 
\family typewriter 
Data_Wrap_Struct
\family default 
 contain C structs, and those may contain references to Ruby 
\family typewriter 
VALUE
\family default 
s.
 The encapsulated struct, however, is opaque to the Ruby universe.
 So, to ensure that these 
\family typewriter 
VALUE
\family default 
s are marked as reachable during garbage collection this has to be done
 through C code.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 accepts, beside the struct to be wrapped, pointers to a mark function and
 to a deallocation function.
 When the garbage collector visits the object in the mark phase, it invokes
 the registered function, which must call 
\family typewriter 
rb_gc_mark
\family default 
 on each 
\family typewriter 
VALUE
\family default 
 stored in the object's struct, informing thus that these objects are reachable.
 When an object wrapped with 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 is considered unreachable, its deallocation function is called.
 On structures that do not store other 
\family typewriter 
VALUE
\family default 
s, the mark function can be set to 
\family typewriter 
NULL
\family default 
 and the deallocation function to 
\family typewriter 
free
\family default 
.
\layout Standard

Ruby has a 
\family typewriter 
GC
\family default 
 module featuring functions to turn the collector on and off (
\family typewriter 
GC.enable
\family default 
 and 
\family typewriter 
GC.disable
\family default 
), as well as to launch a collection immediately (
\family typewriter 
GC.start
\family default 
).
 There are equivalent functions in the C API: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 The C API includes also a function that inserts an object immediately in
 the list of objects to be recycled by Ruby's memory allocator, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 This function should be used with caution, since if there are still any
 references pointing to the recycled object, they will point to the new
 object when the memory area is reclaimed by the Ruby allocator.
\layout Standard

Ruby also offers as a convenience to the C programmer some wrappers to the
 malloc and realloc functions that interact with the garbage collector,
 forcing its execution during large allocations
\begin_inset Foot
collapsed false

\layout Standard

The definition of 
\begin_inset Quotes eld
\end_inset 

large
\begin_inset Quotes erd
\end_inset 

 is adjusted dynamically, based on the execution of the collector and previously
 performed allocations.
\end_inset 

 or in low-memory situations.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Like in Python and Ruby, the Java API returns references to objects from
 the virtual machine that can be stored in C variables.
 The JNI defines three types of references, 
\emph on 
local
\emph default 
, 
\emph on 
global
\emph default 
 and 
\emph on 
weak global
\emph default 
 references, to aid in controlling their lifetime and their interaction
 with the garbage collector.
\layout Standard

Most functions of the JNI return local references, which are valid until
 the return of the C function that has obtained them.
 It is not necessary to deallocate a local reference explicitly: during
 the execution of a C function, the JVM maintains a list of local references
 passed to the function and frees them all when control returns to the virtual
 machine.
 This way, in general, the programmer does not need to worry about garbage
 collection when manipulating values returned during a function.
 On the other hand, in code that may use a large number of local references
 it is more efficient to free local references explicitly, using 
\family typewriter 
DeleteLocalRef
\family default 
.
 In Java version 1.2, functions were added to manage local references in
 blocks.
 
\family typewriter 
PushLocalFrame
\family default 
 and 
\family typewriter 
PopLocalFrame
\family default 
 allow one to create nested scopes of local references, which are freed
 all at once.
 
\family typewriter 
PushLocalFrame
\family default 
 receives also an argument indicating a number of slots to be pre-allocated,
 as an optimization.
 This value can also be configured with 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Global references are generated from local references using 
\family typewriter 
NewGlobalRef
\family default 
.
 References of this kind remain valid until they are explicitly deallocated
 with 
\family typewriter 
DeleteGlobalRef
\family default 
.
 A global reference stops the object from being collected; it can therefore
 be used to store Java objcets in C space beyond the duration of a function,
 for example, in global or static variables.
\layout Standard

Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 shows an example of the kind of reference management that is needed when
 a loop creates temporary references for an arbitrary number of objects.
\layout Standard

In the example, the 
\family typewriter 
Java_Example_concatArray
\family default 
 function (equivalent, therefore to the 
\family typewriter 
concatArray
\family default 
 method from class 
\family typewriter 
Example
\family default 
) converts the elements of an array to strings using 
\family typewriter 
Object.toString
\family default 
 and concatenates them using 
\family typewriter 
String.concat
\family default 
.
 Notice that, as the number of iterations of the loop depends on the size
 of the given array, one should prevent the number of references from increasing
 on each iteration.
 For that, the options would be either to use 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, or to destroy references one by one with 
\family typewriter 
DeleteLocalRef
\family default 
.
 If we used 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 in the example, we would have to keep the temporary string holding the
 concatenation in a global reference.
 Further, this reference would have to be destroyed and recreated on each
 iteration, since strings are immutable in Java.
 As the number of locals is small, it is more convenient in this case to
 control them explicitly with 
\family typewriter 
DeleteLocalRef
\family default 
 than resorting to global references.
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 allows, through an additional argument, transferring a local reference
 from the set that is being popped to the external scope of local reference,
 creating this way a new reference.
 For the example of Figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, this would still not avoid the need of freeing references explicitly on
 each iteration of the loop, since each 
\family typewriter 
PopLocalFrame
\family default 
 would create a new local reference.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
\emph on 
/* Caching jmethodIDs in C code is a common technique.
\layout LyX-Code


\size footnotesize 
\emph on 
   It's worth mentioning that jmethodIDs are not Java objects,
\layout LyX-Code


\size footnotesize 
\emph on 
   and are therefore not subjected to garbage collection.
 */
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Example_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);     
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);     
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\emph on 
   /* os = o.toString() */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\emph on 
 /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Routine for concatenating elements of an array represented as strings.
\end_inset 


\layout Standard

Since Java 1.2, the JNI includes weak global references, with the goal of
 offering a simplified version of Java's weak references (
\family typewriter 
java.lang.ref
\family default 
) -- an object pointed only by weak global references can be collected.
 Originally, the API defined the 
\family typewriter 
IsSameObject
\family default 
 function as a way to check the validity of a weak reference, but evidently
 this method is insufficient: since Java is multi-threaded, the garbage
 collector may invalidate the reference between the test and the following
 instruction in C code.
 The revised documentation warns about this limitation and recommends the
 use of global references, as well as alerting on undefined behaviors in
 the relationship between weak global references in C and Java's own weak
 reference types\SpecialChar ~

\begin_inset LatexCommand \cite{jni1503spec}

\end_inset 

.
\layout Standard

More issues arise from the combination of Java's multi-threaded model with
 the exposure of references of virtual machine objects to C code.
 To reduce the volume of data copying between Java and C, the JNI offers
 some functions that return and release pointers to the internal representation
 of strings and arrays of primitive types: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 and 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 The use of these functions, however, has important restrictions.
 The API specifies that, once a pointer is obtained through these functions,
 the C code must not call other JNI functions or perform calls that may
 block the current thread and make it wait for another Java thread, under
 risk of a deadlock.
 It is recommended that memory blocks held using these functions are not
 retained for a long time, since one of the possible techniques fro implementing
 this 
\begin_inset Quotes eld
\end_inset 

critical section
\begin_inset Quotes erd
\end_inset 

 consists in disabling the garbage collector.
 It is also important to note that local references and the pointer to the
 JNI environment passed to native functions are valid only in the thread
 where they were created; global references can be shared among threads.
\layout Standard

Besides the weak reference mechanism provided by the 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
 package, the only way provided by Java to interact in a more direct way
 with the garbage collector is through the 
\family typewriter 
System.gc()
\family default 
 call, which asks the virtual machine to launch the collection thread as
 soon as possible so that it deallocate unreachable objects.
 There is no equivalent C function in the JNI, but this method can be invoked
 from C with 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

The interaction of native C code with the Lua garbage collector is greatly
 simplified by the fact that the Lua API does not return explicit references
 to Lua objects to the C space.
 Operations on Lua objects are always specified through indices of the virtual
 stack.
 This way, the virtual machine retains all control over which objects are
 accessible from C at any given moment.
\layout Standard

Although pointers to objects are not manipulated in the API, some functions
 return pointers to structures managed by Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
 and 
\family typewriter 
lua_touserdata
\family default 
.
 The validity of pointers returned by these functions is dependent on the
 lifetime of the object they correspond to; for strings in particular, a
 returned pointer is only decidedly valid as long as the string is in the
 stack.
 Lua offers still the 
\family typewriter 
lua_topointer
\family default 
 function, which returns pointers to some kinds of objects (userdata, tables,
 threads and functions), but only with the intention of providing debugging
 information, as it is not possible to convert such pointers back into Lua
 values.
\layout Standard

The virtual stack is emptied when the C function returns control to the
 Lua virtual machine.
 This way, it is not possible to retain pointers returned by Lua for later
 use in global variables or C structures.
 Alternatively, the API offers a mechanism for storing Lua values in a location
 that is known to C code and that cannot be altered by Lua code: the registry.
 The registry is a table made available through the Lua API for the storage
 of Lua values from C; this table is not normally accessible from Lua.
 Since the table that implements the registry is part of the root set of
 the garbage collector, the inclusion of an object in this table prevents
 it from being collected, keeping it in the registry until it is explicitly
 removed through C code.
\layout Standard

Using the registry, a possible way to describe data from the Lua space in
 C data structures is to store data in the registry and store the used indices
 in the C structure.
 Lua's auxiliary library encapsulates such idiom through two functions,
 
\family typewriter 
luaL_ref
\family default 
 and 
\family typewriter 
luaL_unref
\family default 
.
 The 
\family typewriter 
luaL_ref
\family default 
 function associates the given Lua value to an integer numeric key in the
 registry, and returns this number.
 This value can then be seen as a high-level handle to the object: C code
 can store it in variables and structures and use it to refer to the object
 through its registry field.
 The 
\family typewriter 
luaL_unref
\family default 
 function removes the Lua value from the registry and frees the index for
 reuse.
 To ensure this mechanism works properly, integer keys should not be used
 directly be the programmer to store data in the registry.
\layout Standard

The API allows associating a deallocation function, 
\family typewriter 
__gc
\family default 
, to the metatable of full userdata objects.
 When present, this function will be typically implemented in C, performing
 resource finalization.
 For example, the 
\family typewriter 
__gc
\family default 
 metamethod of objects returned by the 
\family typewriter 
io.open
\family default 
 Lua function is a C function that closes the corresponding file descriptor
 using the 
\family typewriter 
fclose
\family default 
 function.
\layout Standard

In principle, the fact that its possible to obtain and modify the metatable
 of userdata through Lua code may seem problematic, as one could replace
 its finalizer in 
\family typewriter 
__gc
\family default 
.
 However, collection functions implemented in C typically validate received
 userdata checking its 
\begin_inset Quotes eld
\end_inset 

type
\begin_inset Quotes erd
\end_inset 

, identified through its metatable.
 So, even if Lua code manipulates the table, a collection function implemented
 in C which uses 
\family typewriter 
luaL_checkudata
\family default 
 will not be made to operate on userdata of incorrect type.
 To stop Lua code from modifying the collection function of a userdata object,
 one can assign some value, such as false, to the 
\family typewriter 
__metatable
\family default 
 field of the metatable; this will be returned in place of the metatable,
 making the metatable itself unaccessible.
\layout Standard

Another resource related to memory management provided by Lua is the possiblity
 of configuring, at runtime, the allocation function to be used by the virtual
 machine.
 In the creation of a new Lua state, an allocation function is passed as
 a its first argument.
 This function must offer functionality similar to the C functions 
\family typewriter 
free
\family default 
 and 
\family typewriter 
realloc
\family default 
, depending if the given block size is equal or greater than zero.
\layout Standard

Lua offers an interface to the garbage collector through the 
\family typewriter 
lua_gc
\family default 
 function in C and 
\family typewriter 
collectgarbage
\family default 
 in Lua.
 The collector implements incremental mark-and-sweep and allows the programmer
 to configure parameters related to collection intervals, as well as enable,
 disable, launch full cycles and executing collection steps.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Like Python, Perl performs garbage collection based on reference counting.
 The API provides functions for explicit control of reference counts: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 and a getter, 
\family typewriter 
SvREFCNT
\family default 
.
 Another way to modify the reference count of a value is to assign it to
 a Perl reference with 
\family typewriter 
newRV_inc
\family default 
.
 The count of the referenced value will be incremented, keeping it valid
 -- unless it has its count altered explicitly -- as long as it is referenced
 by the 
\family typewriter 
RV
\family default 
.
 It is important to note, however, that API functions that create values,
 such as 
\family typewriter 
newSViv
\family default 
, initialize their reference counts with 1.
 This has the effect that if a value is created in a C function, stored
 in an 
\family typewriter 
RV
\family default 
 with 
\family typewriter 
newRV_inc
\family default 
 and this reference is returned to Perl, the value will never be collected,
 because its counter will not reach 0 when the reference is destroyed.
 The correct form, then, is to use 
\family typewriter 
newRV_noinc
\family default 
 for RVs containing newly-created values and 
\family typewriter 
newRV_inc
\family default 
 when an 
\family typewriter 
RV
\family default 
 needs to retain an already existing value.
\layout Standard

Initializing reference counts with 1 ensures that values created will remain
 valid during the execution of a C function without storing the value in
 Perl space.
 These values can also be stored in C global variables and data structures
 and will remain valid until their reference count is decremented.
 For values with a lifetime restricted to a single function, the Perl API
 defines the concept of 
\begin_inset Quotes eld
\end_inset 

mortal
\begin_inset Quotes erd
\end_inset 

 variables as a way of deallocating all temporary values of a function at
 once.
 An 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 or 
\family typewriter 
HV
\family default 
 can be created with 
\family typewriter 
sv_newmortal
\family default 
 or, more commonly, converted to a mortal with 
\family typewriter 
sv_2mortal
\family default 
.
 In practice, marking a value as mortal corresponds to indicating that it
 should have its reference count decremented by the 
\family typewriter 
FREETMPS
\family default 
 macro by the end of a function, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Some functions of the API return mortal values: for example, 
\family typewriter 
hv_delete
\family default 
 removes an element of a hash and, unless the 
\family typewriter 
G_DISCARD
\family default 
 is passed, returns the removed element as a mortal 
\family typewriter 
SV
\family default 
.
\layout Standard

The Perl API does not provide facilites for interfacing with the garbage
 collector, but features some debugging support functions that report informatio
n about the state of garbage collection.
 The 
\family typewriter 
sv_report_used
\family default 
 function displays the contents of every 
\family typewriter 
SV
\family default 
 stored in the interpreter.
 The 
\family typewriter 
Devel::Peek
\family default 
 module allows examining from Perl the content of values (reference counts,
 flags, etc.) -- from C, these informations are directly available, since
 their structures are not opaque.
\layout Subsection

Comparison
\layout Standard

Garbage collection aims to isolate, as much as possible, the programmer
 from memory management.
 This way, ideally an API should also be as independent as possible from
 the garbage collection algorithm used in the implementation of the virtual
 machine.
 Perl and Python perform garbage collection based on reference counting,
 and this shows through in the reference increment and decrement operations
 frequently needed during the use of their APIs.
\layout Standard

Ruby uses a mark-and-sweep garbage collector.
 Its API manages to abstract this fact well for manipulation of native Ruby
 objects, but the implementation of the collector is evident in the creation
 of Ruby types in C, where we need to declare a mark function when there
 are C structures that store reference to Ruby objects.
 The Lua API goes further when isolating itself from the implementation
 of the garbage collector: the only point of the API where the use of an
 incremental garbage collection is apparent is in the routine for direct
 interaction with the collector, 
\family typewriter 
lua_gc
\family default 
, where its parameters can be configured.
\layout Standard

Of the five languages studied, the only whose API abstracts entirely the
 implementation of the garbage collector is Java.
 The only intarfacing operation provided by the language, 
\family typewriter 
System.gc()
\family default 
, does not receive any arguments and does not specify how or when the collection
 should be done
\begin_inset Foot
collapsed true

\layout Standard

The documentation is purposely vague, stating only that this method 
\emph on 

\begin_inset Quotes eld
\end_inset 

suggests that the Java Virtual Machine expend effort toward recycling unused
 objects
\begin_inset Quotes erd
\end_inset 


\emph default 
 .
\end_inset 

.
 In fact, the various implementations of the JVM use different algorithms
 for garbage collection.
\layout Standard

For manipulating data through the API, Lua and Ruby are the languages that
 demand the least concerns from the programmer about managing references.
 Ruby keeps control of references returned to C functions scanning the C
 stack during garbage collection, detecting the presence of references stored
 in local variables.
 Lua avoids the problem altogether, by keeping its objects in the virtual
 stack and not returning references to C code.
\layout Standard

The issue of references stored in local variables is handled by Perl and
 Java in a similar way, by defining two types of references, global and
 local (local references are called 
\begin_inset Quotes eld
\end_inset 

mortal variables
\begin_inset Quotes erd
\end_inset 

 in Perl).
 Local references have implicit management (save a few cases, as discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

).
 API functions in Java return local references by default, which can be
 converted to global ones with 
\family typewriter 
NewGlobalRef
\family default 
.
 In Perl, the opposite happens, and global references can be converted to
 local ones with 
\family typewriter 
sv_2mortal
\family default 
.
 Java's approach is more interesting, as normally more locally-scoped than
 globally-scoped variables are used.
 Values stored globally always need to have some for of explicit management
 to them, even in Ruby and Lua, through 
\family typewriter 
rb_global_variable
\family default 
 and 
\family typewriter 
luaL_ref
\family default 
/
\family typewriter 
luaL_unref
\family default 
.
\layout Section

Calling functions from C
\layout Standard

The API must provide a form of invoking from C functions to be executed
 by the scripting language.
 This involves passing data between these two 
\begin_inset Quotes eld
\end_inset 

spaces
\begin_inset Quotes erd
\end_inset 

, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 and the implications that this brings about the objects' lifetime, discussed
 in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Because of the static typing of C, it is not possible to use a transparent
 syntax for calling functions registered at runtime.
 It is therefore necessary for the API to define functions for performing
 calls to the scripting language.
\layout Standard

In this section, we will discuss the facilities provided by each API for
 invoking functions to be executed by its virtual machine.
 The main issues involved are how to reference the function to be called,
 how to pass arguments to it and how to obtain the return value, including
 forms of notification in case of errors.
 For illustration purposes, for each language we will present an example
 of a simple function call.
 Assume that in the space of each scripting language a 
\family typewriter 
test
\family default 
 function was defined, which receives an integer and a string as arguments
 and returns an integer as a result.
 For brevity, error handling will be omitted in the examples.
 
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

When calling a Python function from C, one should initially obtain a pointer
 to the 
\family typewriter 
PyObject
\family default 
 corresponding to the function, as seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Besides functions implemented in Python and C functions registered through
 the Python API, any data type that implements the 
\family typewriter 
__call__
\family default 
 method (or declares a function in the 
\family typewriter 
tp_call
\family default 
 field of its 
\family typewriter 
PyTypeObject
\family default 
 structure) can be called as a function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções para chamar funções
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

The Python API offers several functions for performing calls from C.
 The most general function, 
\family typewriter 
PyObject_Call
\family default 
, receives as arguments the object to be called, a Python tuple containing
 the arguments to be passed and optionally a dictionary of keyword arguments.
 As a convenience, other functions allow passing arguments in other ways.
 For example, 
\family typewriter 
PyObject_CallFunction
\family default 
 ncapsulates the call to 
\family typewriter 
Py_BuildValue
\family default 
 (seen in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), accepting directly the format string and the value to be converted.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 is a vararg function that accepts a sequence of pointers to 
\family typewriter 
PyObject
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

There are also many convenience functions for method invocation.
 The 
\family typewriter 
PyObject_CallMethod
\family default 
 is a variant of 
\family typewriter 
PyObject_CallFunction
\family default 
 that receives as arguments a 
\family typewriter 
PyObject
\family default 
 and a C string containing the method name.
 So, for example, both forms below are equivalent to the Python statement
 
\family typewriter 
ret = some_string.split(" ")
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* "s" indicates that the next parameter is a string.
 */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(some_string, "split", "s", " ");
\newline 
 
\newline 
PyObject* split = PyObject_GetAttrString(some_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

It is interesting to note that when a method is called as a function, the
 
\family typewriter 
self
\family default 
 argument is not passed explicitly.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

The return value in all invocation functions is a 
\family typewriter 
PyObject
\family default 
 pointer.
 As it happens in Python code, when Python functions return multiple values,
 they are encapsulated in a tuple.
 For functions that do not return a value, C functions must return 
\family typewriter 
Py_None
\family default 
.
 In case of errors in the call, these functions return 
\family typewriter 
NULL
\family default 
.
 The occurrence of exceptions can then be verified with the 
\family typewriter 
PyErr_Occurred
\family default 
 function.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A typical way of calling a Python function called 
\family typewriter 
test
\family default 
, including retrieval of the function and conversion of input and output
 values between Python and C, is shown below:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* test = PyDict_GetItemString(globals, "test");
\layout LyX-Code


\size footnotesize 
\emph on 
/* "si" indicates string and integer arguments */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(test, "si", "foo", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converts the value to C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Frees the temporary PyObject that was returned.
 */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

A global function is obtain through the dictionary in the 
\family typewriter 
__main__
\family default 
 module.
 The conversion of input data from C to Python is made through a format
 string received by 
\family typewriter 
PyObject_CallFunction
\family default 
.
 This call is equivalent to 
\family typewriter 
obj_result = test("foo", 2)
\family default 
 in Python.
 The output value is returned as a new reference to a Python object and,
 as such, needs to have its reference count decremented after its use.
 The 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 and 
\family typewriter 
PyDict_GetItemString
\family default 
 return borrowed references, therefore the reference count of 
\family typewriter 
PyObject
\family default 
s returned by them do not need to be decremented after their use.
 However, after calling the Python function, there is no guarantee that
 the 
\family typewriter 
globals
\family default 
 and 
\family typewriter 
test
\family default 
 pointers still point to valid objects -- we would have to have incremented
 their reference counts if we wanted to use them again.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções para chamar funções
\end_inset 


\layout Standard

Since methods are not first-class values in Ruby, they are not represented
 as 
\family typewriter 
VALUE
\family default 
s in their C API.
 For calling Ruby methods in C, the API offers the 
\family typewriter 
rb_funcall
\family default 
 function and some variations.
 In common, all of them receive as an argument the 
\family typewriter 
VALUE
\family default 
 indicating to the object the method refers to, an 
\family typewriter 
ID
\family default 
 referring to the interned string containing the method name and an integer
 informing the number of arguments.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

Like in Python, the API functions for method invocation differ in how arguments
 are passed.
 For example, rb_funcall receives arguments as 
\family typewriter 
VALUE
\family default 
s passed as C varargs; 
\family typewriter 
rb_funcall2
\family default 
 receives a C array of 
\family typewriter 
VALUE
\family default 
s; rb_apply receives a 
\family typewriter 
VALUE
\family default 
 that must be a Ruby array containing arguments.
 All of them return a 
\family typewriter 
VALUE
\family default 
 as an argument.
 Like in Ruby code, multiple return values are represented as a Ruby array.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

All function call routines from the API refer to methods, expecting thus
 an object on which the method should be applied.
 Global functions are defined in Ruby as methods of the 
\family typewriter 
Kernel
\family default 
 module, which is included by the class 
\family typewriter 
Object
\family default 
 and are, therefore, accessible from every object, including 
\family typewriter 
nil
\family default 
.
 This way, one can invoke global functions passing the C constant 
\family typewriter 
Qnil
\family default 
 as the method's target object.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Below, we present the typical way a Ruby global function 
\family typewriter 
test
\family default 
 is called from C, again including conversion of input and output values
 between C and the interpreter.
\layout LyX-Code


\size footnotesize 
ID test = rb_intern("test");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, test, 2, rb_str_new2("foo"), INT2NUM(2));
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Unlike it happens in Python, it is not necessary to obtain a reference to
 the function, sufficing to pass its name as an 
\family typewriter 
ID
\family default 
 and the object it refers to (in this case, 
\family typewriter 
Qnil
\family default 
, indicating a global function).
 Conversion of input data from C to Ruby is done through the 
\family typewriter 
rb_str_new2
\family default 
 function and the 
\family typewriter 
INT2NUM
\family default 
 macro, which return 
\family typewriter 
VALUE
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs.
 no exemplo
\end_inset 


\layout Standard

As discussed in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, the control of validity of 
\family typewriter 
VALUE
\family default 
s is done implicitly.
 So, we can call functions that create 
\family typewriter 
VALUE
\family default 
s directly when passing parameters to 
\family typewriter 
rb_funcall
\family default 
.
 In fact, all three lines above could have been condensed, passing 
\family typewriter 
rb_funcall
\family default 
 as a parameter to 
\family typewriter 
NUM2LONG
\family default 
 and 
\family typewriter 
rb_intern
\family default 
 as the second argument of 
\family typewriter 
rb_funcall
\family default 
; they were separated here for greater readability.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: blocos Ruby
\end_inset 


\layout Standard

A data type that is treated in a quite irregular way in Ruby is that from
 code blocks.
 Ruby features special syntax for declaring blocks: they can only be defined
 as the last argument of a method call.
 This way, they are not first-class values and cannot be, for example, declared
 in a variable assignment.
 They can, however, be promoted to first-class values, as objects of the
 
\family typewriter 
Proc
\family default 
 class.
 This can be done in two ways: explicitly, passing a block to the 
\family typewriter 
Proc.new
\family default 
 method, or implicitly, when a block is passed to a method that declares
 a final formal argument preceded by 
\family typewriter 
&
\family default 
.
 This variable will contain the block converted to a 
\family typewriter 
Proc
\family default 
.
 When calling functions that expect blocks, 
\family typewriter 
&
\family default 
 converts a 
\family typewriter 
Proc
\family default 
 to a block.
 
\family typewriter 
Proc
\family default 
 objects can be manipulated through the C API as any other Ruby object,
 but there is no match in the C API to the functionality of the 
\family typewriter 
&
\family default 
 operator in function calls.
\layout Standard

The special status of code blocks complicates their use from C code, and
 in particular the invocation of methods that expect them as a parameter.
 Say we want to invoke the following Ruby method from C:
\layout LyX-Code


\size footnotesize 
def a_ruby_function()
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function will invoke the block.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function is done.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

This function expects a code block to be passed to it, so it can be invoked
 by the 
\family typewriter 
yield
\family default 
 command.
 Since we will invoke the function from C, we also want to pass C code as
 a block, represented by the following function:
\layout LyX-Code


\size footnotesize 
VALUE a_C_block() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "a_C_block is running.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The conversion of 
\family typewriter 
Proc
\family default 
 objects to blocks performed by the 
\family typewriter 
&
\family default 
 operator in Ruby has no equivalent in the C API.
 Therefore, 
\family typewriter 
rb_funcall
\family default 
 is unable to pass 
\family typewriter 
Proc
\family default 
s to functions expecting blocks.
 The intuitive way of doing Ruby function calls from C, in this case then,
 does not work:
\layout LyX-Code


\size footnotesize 
ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
\emph on 
/* The second argument is an additional argument to be
\layout LyX-Code


\size footnotesize 
\emph on 
   optionally passed when invoking a Proc */
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Doesn't work! A Proc is not a code block.
 */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_funcall(Qnil, a_ruby_function, 1, a_proc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The only ways of invoking a Ruby method passing a code block are through
 
\family typewriter 
rb_eval_string
\family default 
 and 
\family typewriter 
rb_iterate
\family default 
.
 The first approach, besides the performance penalty caused by parsing a
 string of code, has the inconvenience of requiring temporary variables
 so that one can obtain return values back to the C data space.
 In the model using 
\family typewriter 
rb_eval_string
\family default 
, the C function that will act as a block must be declared in the Ruby space.
 There are two alternatives on how to do this: registering the method in
 Ruby and invoking it in a wrapper block declared in the string of Ruby
 code:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Declares a global function with 0 input parameters */
\layout LyX-Code


\size footnotesize 
rb_define_global_function("a_C_block", a_C_block, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function { a_C_block() }");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard

Or encapsulating the function in a 
\family typewriter 
Proc
\family default 
 object from C with 
\family typewriter 
rb_proc_new
\family default 
 and then using the 
\family typewriter 
&
\family default 
 notation in the string of Ruby code:
\layout LyX-Code


\size footnotesize 
VALUE a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$a_proc", a_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function(&$a_proc)");
\layout LyX-Code


\size footnotesize 
VALUE result = rb_gv_get("$result");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The second approach makes use of the fact that the only API function that
 is capable of producing code blocks directly is 
\family typewriter 
rb_iterate
\family default 
.
 This function receives two function pointers, one to the function to be
 invoked and another to the function that will act as a block; calls to
 
\family typewriter 
yield
\family default 
 withing the first function will invoke the second one.
 The block may break the flow of execution with 
\family typewriter 
rb_iter_break
\family default 
.
 By passing as a 
\begin_inset Quotes eld
\end_inset 

iteration function
\begin_inset Quotes erd
\end_inset 

 to rb_iterate a wrapper function that simply calls the desired Ruby method
 with 
\family typewriter 
rb_funcall
\family default 
, it is possible to simulate a call to 
\family typewriter 
rb_funcall
\family default 
 that receives a C function as a code block.
\layout LyX-Code


\size footnotesize 
VALUE call_a_ruby_function() {
\layout LyX-Code


\size footnotesize 
   ID a_ruby_function = rb_intern("a_ruby_function");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, a_ruby_function, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
\emph on 
/* The Qnil arguments indicate that there are no parameters
\layout LyX-Code


\size footnotesize 
\emph on 
   to be passed to either function.
 */
\layout LyX-Code


\size footnotesize 
VALUE result = rb_iterate(call_a_ruby_function, Qnil, a_C_block, Qnil);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Notice that no arguments are passed to 
\family typewriter 
rb_funcall
\family default 
 -- 
\family typewriter 
rb_iterate
\family default 
 defines 
\family typewriter 
a_C_block
\family default 
 as the 
\begin_inset Quotes eld
\end_inset 

current code block
\begin_inset Quotes erd
\end_inset 

 and this definition is inherited implicitly by 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

For the common case of performing iteration on the 
\family typewriter 
each
\family default 
 method of collections, Ruby offers a wrapper function, 
\family typewriter 
rb_each
\family default 
.
 This function was designed to be passed as a first argument to 
\family typewriter 
rb_iterate
\family default 
.
 C functions executing as a code block can break the control flow with 
\family typewriter 
rb_iter_break
\family default 
.
 The yielding mechanism, for both C code and native Ruby calls, is implemented
 using the 
\family typewriter 
setjmp
\family default 
 and 
\family typewriter 
longjmp
\family default 
 C functions.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

For correct error handling, C functions that perform calls to Ruby functions
 must be encapsulated by a 
\family typewriter 
rb_protect
\family default 
 call or one of its variants, 
\family typewriter 
rb_ensure
\family default 
 and 
\family typewriter 
rb_rescue
\family default 
.
 If a program does not use 
\family typewriter 
rb_protect
\family default 
, Ruby exceptions will result in fatal errors.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

De forma similar ao acesso a atributos, na chamada de métodos em Java deve-se
 inicialmente obter um identificador para o método, do tipo 
\family typewriter 
jmethodID
\family default 
.
 Estes identificadores são tipicamente obtidos com a função 
\family typewriter 
GetMethodID
\family default 
, que recebe como parâmetros a classe (instância de 
\family typewriter 
jclass
\family default 
) e duas strings, uma com o nome do método e outra com a assinatura do método.
 A sintaxe que descreve assinaturas de métodos é similar à de descritores
 de campos discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Parâmetros são listados entre parênteses, seguidos do tipo de retorno.
 Por exemplo, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 indica uma função com parâmetros 
\family typewriter 
String[], int, int
\family default 
 e retorno 
\family typewriter 
void
\family default 
.
 Alternativamente ao uso de 
\family typewriter 
GetMethodID
\family default 
, a partir de Java 1.2 é possível obter um 
\family typewriter 
jmethodID
\family default 
 correspondente a um método aplicando a função 
\family typewriter 
FromReflectedMethod
\family default 
 sobre um objeto Java do tipo 
\family typewriter 
Method
\family default 
 -- isto é, um método reificado através da API de reflexão de Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API para invocar funções
\end_inset 


\layout Standard

Uma vez obtido o 
\family typewriter 
jmethodID
\family default 
, um método pode ser invocado através de alguma das 90 funções da família
 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
*.
 Os nomes das funções seguem a forma
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<tipo><retorno>
\family default 
\emph default 
Method
\family roman 
\emph on 
<argumentos>
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

O 
\emph on 
<tipo>
\emph default 
 pode ser 
\family typewriter 
Static
\family default 
 para funções estáticas, passando na chamada uma 
\family typewriter 
jclass
\family default 
 como parâmetro; 
\family typewriter 
Nonvirtual
\family default 
 para invocar implementações de um método em uma classe específica sobre
 um determinado objeto, passando uma 
\family typewriter 
jclass
\family default 
 e um 
\family typewriter 
jobject
\family default 
 como parâmetros; ou omitido para métodos de instância, passando o 
\family typewriter 
jobject
\family default 
 sobre o qual o método será aplicado.
 O tipo de retorno é indicado em 
\emph on 
<retorno>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Os argumentos do método podem ser passados de três formas: como 
\emph on 
varargs
\emph default 
, como um array C de 
\family typewriter 
jvalue
\family default 
s, ou propagando uma 
\family typewriter 
va_list
\family default 
 recebida.
 Por exemplo, na forma mais simples, um método de instância sem retorno
 e sem parâmetros é invocado com 
\family typewriter 
CallVoidMethod
\family default 
.
 Já 
\family typewriter 
CallStaticIntMethodA
\family default 
 chama um método estático que retorna um 
\family typewriter 
jint
\family default 
 com a lista de parâmetros passada em um array de 
\family typewriter 
jvalue
\family default 
s.
 Como Java é uma linguagem estaticamente tipada, não é preciso especificar
 o número ou o tipo dos parâmetros passados nas funções de chamada de métodos.
 Estas informações já estão especificadas nos 
\family typewriter 
jmethodID
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\end_inset 


\layout Standard

É importante notar que, ao obter identificadores de métodos e campos fazendo
 a resolução a partir do 
\family typewriter 
jobject
\family default 
 recebido na variável 
\family typewriter 
this
\family default 
 e do nome do método ou campo, com 
\family typewriter 
GetObjectClass
\family default 
 e 
\family typewriter 
GetFieldID
\family default 
, estamos efetivamente resolvendo nomes através de escopo dinâmico.
 Isto implica que, por exemplo, caso um método 
\family typewriter 
Pai.metodo
\family default 
 implementado em C acesse um atributo privado 
\family typewriter 
umAtributo
\family default 
 e uma subclasse 
\family typewriter 
Filho
\family default 
 também defina um atributo privado 
\family typewriter 
umAtributo
\family default 
, a chamada a esse método em uma instância 
\family typewriter 
f
\family default 
 de 
\family typewriter 
Filho
\family default 
 acabaria por acessar 
\family typewriter 
Filho.umAtributo
\family default 
 e não 
\family typewriter 
Pai.umAtributo
\family default 
.
 Este comportamento é diferente do que ocorreria se 
\family typewriter 
Pai.metodo
\family default 
 fosse implementado em Java, onde o 
\emph on 
binding
\emph default 
 de membros privados é definido lexicamente.
 Para garantir à implementação em C de 
\family typewriter 
Pai.metodo
\family default 
 que o atributo 
\family typewriter 
umAtributo
\family default 
 acessado é realmente 
\family typewriter 
Pai.umAtributo
\family default 
, deve-se armazenar no espaço de C o identificador do campo obtido a partir
 da 
\family typewriter 
jclass
\family default 
 de 
\family typewriter 
Pai
\family default 
 -- obtida, por exemplo, em uma função 
\family typewriter 
static native
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

O código C pode verificar a ocorrência de exceções através de 
\family typewriter 
ExceptionCheck
\family default 
 e optar por tratá-la, obtendo uma referência local da exceção com 
\family typewriter 
ExceptionOccurred
\family default 
 e posteriormente zerando-a com 
\family typewriter 
ExceptionClear
\family default 
, ou então mantê-la ativa de modo que seja propagada ao código Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Para realizar o exemplo da função 
\family typewriter 
teste
\family default 
, já que Java não possui funções globais, vamos assumir que teste é um método
 estático de uma classe chamada 
\family typewriter 
Exemplo
\family default 
 e que estamos rodando o código C a seguir em um contexto onde possuímos
 uma referência a um ambiente de execução Java chamado 
\family typewriter 
J
\family default 
 (este ponteiro, do tipo 
\family typewriter 
JNIEnv
\family default 
, será discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass exemplo = (*J)->FindClass(J, "Exemplo");
\layout LyX-Code


\size footnotesize 
jmethodID teste = (*J)->GetStaticMethodID(J, exemplo,
\layout LyX-Code


\size footnotesize 
                        "teste", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring entrada = (*J)->NewStringUTF(J, "entrada");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, exemplo, teste, entrada, (jint)2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Inicialmente, é obtida uma referência à classe 
\family typewriter 
Exemplo
\family default 
, a partir da qual é obtido o identificador do método desejado, baseado
 no seu nome e assinatura.
 Como em Ruby, a string passada como parâmetro deve ser convertida para
 um tipo da máquina virtual.
 Já para o segundo argumento e para o valor de retorno, exploramos o fato
 de que o tipo 
\family typewriter 
jint
\family default 
, correspondente ao tipo Java 
\family typewriter 
int
\family default 
 (inteiro de 32 bits), é compatível com o tipo 
\family typewriter 
long
\family default 
 de C (inteiro de pelo menos 32 bits).
 Todas estas funções da API retornam referências locais, que serão liberadas
 automaticamente ao final da função C onde as chamadas à API foram feitas.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Tanto em funções C disparadas por Lua como em chamadas de funções Lua realizadas
 a partir de código C, os parâmetros de entrada e os valores de retorno
 são passados através da pilha virtual apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Verificação da ocorrência de erros
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Para chamar uma função Lua a partir de C, devemos inicalmente empilhar o
 objeto Lua referente a ela: para funções globais, obtendo-a com 
\family typewriter 
lua_getglobal
\family default 
, para funções armazenadas em tabelas, com 
\family typewriter 
lua_gettable
\family default 
.
 A seguir, empilhamos os seus parâmetros e então invocamos 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, indicando quantos valores da pilha devem ser passados como parâmetro.
 A diferença entre as duas funções está no tratamento de erros: 
\family typewriter 
lua_call
\family default 
 propaga os erros sinalizados, usando 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 captura os erros, retornando um código de 
\emph on 
status
\emph default 
 e a mensagem de erro na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

No caso de execução sem erros, a pilha conterá os valores de retorno da
 função chamada.
 O número de valores de retorno pode ser explicitamente requisitado na chamada
 de 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, ou ser definido em tempo de execução, requisitando o valor especial 
\family typewriter 
LUA_MULTRET
\family default 
.
 Se um número de valores de retorno for solicitado e este não for passado
 pela função chamada, o número de valores será ajustado adicionando elementos
 
\family typewriter 
nil
\family default 
 ou descartando valores em excesso.
 Para chamadas com 
\family typewriter 
LUA_MULTRET
\family default 
, todos os valores são empilhados.
 Nesse caso, a única forma de descobrir quantos valores foram retornados
 é comparando o tamanho da pilha antes e depois da chamada.
\layout Standard

A função 
\family typewriter 
lua_cpcall
\family default 
 permite chamar funções C realizando captura de erros de forma similar a
 
\family typewriter 
lua_pcall
\family default 
 sem precisar registrá-las como valores Lua.
 Esta funcionalidade é similar à oferecida por 
\family typewriter 
rb_protect
\family default 
 em Ruby.
 Ruby, todavia, não oferece função análoga a 
\family typewriter 
lua_pcall
\family default 
, sendo às vezes necessário encapsular a chamada de funções Ruby em funções\SpecialChar ~
C
 que obedeçam à assinatura esperada por 
\family typewriter 
rb_protect
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Lua não possui distinção entre funções e métodos, mas possui açúcar sintático
 que permite invocar funções armazenadas em tabelas com uma sintaxe de chamada
 de métodos: 
\family typewriter 
t:m(x)
\family default 
 significa 
\family typewriter 
t.m(t,x)
\family default 
.
 Todavia, não há na API de C uma chamada específica para replicar esta abreviaçã
o.
 Para funções armazenadas em tabela, a função deve ser obtida com 
\family typewriter 
lua_gettable
\family default 
 e a tabela deve ser empilhada explicitamente juntamente com os demais parâmetro
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

O exemplo da chamada da função 
\family typewriter 
teste
\family default 
 demonstra a disciplina de pilha adotada na API de Lua.
 De forma similar a Java, iremos assumir a existência de um ponteiro 
\family typewriter 
L
\family default 
 do tipo 
\family typewriter 
lua_State
\family default 
, que será explicado mais adiante na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "teste");           
\emph on 
/* Empilha a função teste */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "entrada");        
\emph on 
/* Empilha a string "entrada" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Empilha o número 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Chama a função com 2 parâmetros,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        e espera 1 como retorno */
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1);  
\emph on 
/* Obtém o resultado no topo da pilha (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove-o da pilha */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs no exemplo
\end_inset 


\layout Standard

Com 
\family typewriter 
lua_getglobal
\family default 
, é empilhada a função global 
\family typewriter 
teste
\family default 
.
 Em seguida, os dois argumentos de entrada são empilhados.
 A função é então invocada com 
\family typewriter 
lua_call
\family default 
, indicando dois parâmetros de entrada e um de saída.
 O valor de retorno, no topo da pilha (índice\SpecialChar ~

\begin_inset Formula $-1$
\end_inset 

) é convertido para C com 
\family typewriter 
lua_tointeger
\family default 
.
 Esta última função não remove o valor da pilha: para retorná-la ao seu
 estado inicial, precisamos removê-lo explicitamente com 
\family typewriter 
lua_pop
\family default 
.
 Como em nenhum momento a API retorna ponteiros para objetos Lua, não há
 preocupações com coleta de lixo.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Funções vs.
 métodos
\end_inset 


\layout Standard

A chamada de funções Perl a partir de C se dá através de uma disciplina
 de pilha, como em Lua.
 Parâmetros de entrada são especificados através de operações de empilhamento
 e valores de retorno são obtidos na pilha após a chamada da função.
 As funções 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 e 
\family typewriter 
call_method
\family default 
 variam apenas na forma como a função a ser chamada é especificada: através
 de um 
\family typewriter 
SV
\family default 
, de uma string C ou de uma string C descrevendo o nome de um método de
 algum objeto ou classe inserido na pilha.
 A função 
\family typewriter 
call_argv
\family default 
, como conveniência, recebe como um argumento adicional um array C contendo
 strings C representando parâmetros a serem empilhados.
 Todas retornam o número de valores de retorno disponíveis na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: contextos Perl
\end_inset 


\layout Standard

As funções 
\family typewriter 
call_
\family default 
* possuem um argumento indicando flags a serem passadas que indicam a forma
 que a função deve ser chamada e como tratar os argumentos e valores de
 retorno.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 e 
\family typewriter 
G_ARRAY
\family default 
 especificam o contexto como a função deve ser chamada.
 Em contextos escalares, por exemplo, somente um escalar é retornado na
 pilha; se a função chamada retornar uma lista, somente o último elemento
 desta estará disponível na pilha.
 
\family typewriter 
G_DISCARD
\family default 
 indica que os valores de retorno devem ser automaticamente descartados;
 
\family typewriter 
G_NOARGS
\family default 
 indica que o array padrão de parâmetros 
\family typewriter 
@_
\family default 
 não deve ser construído
\begin_inset Foot
collapsed true

\layout Standard

Isto tem o efeito colateral de que a função chamada herda o valor de 
\family typewriter 
@_
\family default 
 da função chamadora.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

O precedimento para verificação de erros depende do contexto e das flags
 passadas, que afetam como situações de erro são reportadas no valor de
 retorno das funções 
\family typewriter 
call_
\family default 
* e nos valores retornados na pilha.
 A flag 
\family typewriter 
G_EVAL
\family default 
 encapsula a chamada em um bloco 
\family typewriter 
eval
\family default 
, capturando erros.
 Assim, a ocorrência de erros pode ser verificada através da macro 
\family typewriter 
ERRSV
\family default 
, que retorna o 
\family typewriter 
SV
\family default 
 contendo a mensagem de erro.
 Acrescentando a flag 
\family typewriter 
G_KEEPERR
\family default 
, mensagens de erro não sobrescrevem a variável especial 
\family typewriter 
$@
\family default 
, mas são concatenadas a ela, acumulando seqüências de erros em níveis de
 chamada diferentes.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Uma série de macros descrevem um protocolo para a chamada de funções e a
 manipulação de parâmetros de entrada e saída.
 As principais serão explicadas a seguir, na apresentação da versão Perl
 da chamada da função 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("entrada", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("teste", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Controle de referências no exemplo
\end_inset 


\layout Standard

Inicialmente 
\family typewriter 
dSP
\family default 
 declara uma cópia local do ponteiro da pilha de Perl.
 Em seguida, 
\family typewriter 
ENTER
\family default 
 e 
\family typewriter 
SAVETMPS
\family default 
 criam um escopo para valores mortais.
 
\family typewriter 
PUSHMARK
\family default 
 inicia a contagem de parâmetros a serem passados para a função.
 Estes parâmetros são então empilhados com 
\family typewriter 
XPUSHs
\family default 
.
 Os valores criados com 
\family typewriter 
newSVpv
\family default 
 e 
\family typewriter 
newSViv
\family default 
 são convertidos para valores mortais com 
\family typewriter 
sv_2mortal
\family default 
, para que não tenham que ter sua contagem de referências decrementada explicita
mente após a chamada da função.
 
\family typewriter 
PUTBACK
\family default 
 encerra a contagem de parâmetros.
 É feita então a chamada da função global Perl 
\family typewriter 
teste
\family default 
, em contexto escalar, com 
\family typewriter 
call_pv
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Após o retorno desta função, a memória da pilha de Perl pode ter sido realocada,
 mudando o endereço do ponteiro de pilha obtido inicialmente com 
\family typewriter 
dSP
\family default 
.
 Para certificar-se que o seu valor está correto, deve-se chamar 
\family typewriter 
SPAGAIN
\family default 
 após funções 
\family typewriter 
call_
\family default 
*.
 A função 
\family typewriter 
POPl
\family default 
 desempilha um valor e o converte para 
\family typewriter 
long
\family default 
 (há funções similares para outros tipos, como 
\family typewriter 
POPs
\family default 
 para 
\family typewriter 
SV
\family default 
s e 
\family typewriter 
POPpx
\family default 
 para strings).
 Estas operações desempilham valores atualizando a cópia local do ponteiro
 de pilha.
 Assim, 
\family typewriter 
PUTBACK
\family default 
 deve ser chamado novamente para atualizar o ponteiro global.
 Finalmente, 
\family typewriter 
FREETMPS
\family default 
 e 
\family typewriter 
LEAVE
\family default 
 decrementam a contagem de referências dos valores mortais.
 
\layout Subsection

Comparação
\layout Standard

Em Python, Lua e Perl, funções podem ser acessadas como objetos da linguagem
 e invocadas.
 Em Ruby e Java, a API define tipos especiais usados para referenciar métodos.
 Como na manipulação de dados, Python oferece uma API extensa, com diversas
 funções de conveniência permitindo passar argumentos como tuplas Python,
 objetos Python passados como 
\emph on 
varargs
\emph default 
, valores C a serem convertidos pela função de chamada, etc.
 Java também oferece um grande número de funções para invocação de métodos
 e, devido à tipagem estática da linguagem, os parâmetros de entrada podem
 ser passados como 
\emph on 
varargs
\emph default 
 de forma bastante simples, sem precisar especificar a forma como a conversão
 deles deve ser realizada.
 Ruby também oferece algumas variantes de funções de chamada.
\layout Standard

Lua, em contraste, separa a rotina da chamada da função da passagem dos
 parâmetros, que é feita anteriormente através da pilha.
 Isto é uma solução bastante simples, mas o código resultante é menos claro
 que as chamadas equivalentes em linguagens como Ruby e Python.
 Perl também faz chamadas de função utilizando um modelo de pilha, mas ao
 contrário de Lua o seu uso é demasiadamente complexo, por exigir um protocolo
 de macros que expõem o funcionamento interno do interpretador.
 Outro complicador é o tratamento de valores de retorno, pois estes variam
 de comportamento conforme o contexto Perl em que a função é chamada.
\layout Standard

Em Lua e Python, a ocorrência de erros pode ser verificada com o valor de
 retorno da função.
 De forma similar, Perl permite detectar erros na chamada mais recente verifican
do uma variável especial; em Java, isto é feito chamando uma função da API.
 Somente o tratamento de erros em Ruby é mais convoluto, pois estranhamente
 a API oferece uma função que permite invocar funções C em modo protegido,
 mas não uma equivalente que permita chamar funções Ruby.
 Torna-se necessário escrever uma função 
\emph on 
wrapper
\emph default 
 nestes casos, o que será ilustrado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Section

Registro de funções C
\layout Standard

Para permitir a invocação de funções C a partir de código da linguagem de
 script, a API deve fornecer uma forma de registrar estas funções no ambiente
 de execução.
 Em linguagens de tipagem estática, como Java, para que seja possível chamar
 funções externas usando uma sintaxe igual à de funções nativas, o conjunto
 de funções externas deve ser declarado 
\emph on 
a priori
\emph default 
 de alguma forma.
 Já em linguagens com tipagem dinâmica, como é o caso de Python, Lua, Ruby
 e Perl, as funções podem ser usadas diretamente, bastando que sejam definidas
 em algum momento da execução antes de sua chamada.
 Assim, pode-se declarar as funções externas em tempo de execução através
 de código C usando a API da linguagem de script.
\layout Standard

Também nesta seção, a apresentação de cada linguagem encerrará com o exemplo
 de função C a ser registrada, que assim como nos exemplos da seção anterior,
 recebe um inteiro e uma string e retorna um inteiro.
 Será apresentada também, para cada linguagem, a forma de registrar a função
 como a global
\begin_inset Foot
collapsed false

\layout Standard

Ou no caso de Java, método estático.
\end_inset 

 
\family typewriter 
teste
\family default 
 de modo que ela possa ser invocada diretamente a partir da linguagem ou
 através da API.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

Python não possui um tipo 
\begin_inset Quotes eld
\end_inset 

função
\begin_inset Quotes erd
\end_inset 

 propriamente dito declarável em C.
 Métodos de classes, no entanto, são objetos e possuem um tipo específico,
 que pode ser verificado com a função 
\family typewriter 
PyMethod_Check
\family default 
.
 Tipicamente, métodos são criados passando-se um array de estruturas 
\family typewriter 
PyMethodDef
\family default 
.
 Estas estruturas são compostas do nome da função, o ponteiro da função
 C, um vetor de flags e uma string de documentação.
 As flags são usadas para indicar a convenção adotada para os parâmetros
 de entrada na função C.
 As flags mais comuns são: 
\family typewriter 
METH_NOARGS
\family default 
, usada para funções Python que não recebem parâmetros, indicando que a
 função C deve receber um único ponteiro para 
\family typewriter 
PyObject
\family default 
, que irá conter o 
\family typewriter 
self
\family default 
 do método; 
\family typewriter 
METH_VARARGS
\family default 
, para funções que recebem como segundo parâmetro uma tupla Python que conterá
 um número variável de parâmetros passados de Python para C; e 
\family typewriter 
METH_KEYWORDS
\family default 
, para indicar que a função C recebe ainda como terceiro parâmetro um dicionário
 contendo os argumentos 
\emph on 
keywords
\emph default 
 passados à função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\end_inset 


\layout Standard

De posse destas informações, funções da API que operam sobre arrays de 
\family typewriter 
PyMethodDef
\family default 
 podem criar e associar objetos do tipo método no espaço de Python.
 
\family typewriter 
Py_InitModule
\family default 
, por exemplo, inicializa um módulo com funções de um array de 
\family typewriter 
PyMethodDef
\family default 
.
 Similarmente, os métodos de uma classe implementada em C podem ser dados
 no campo 
\family typewriter 
tp_methods
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 relativa à classe.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C registradas em Python devem retornar um ponteiro para 
\family typewriter 
PyObject
\family default 
, ou 
\family typewriter 
NULL
\family default 
 em caso de erro (opcionalmente declarando uma exceção com 
\family typewriter 
PyErr_SetString
\family default 
 ou 
\family typewriter 
PyErr_SetObject
\family default 
).
 Funções que não retornam valores devem retornar o objeto pré-definido 
\family typewriter 
Py_None
\family default 
, lembrando das questões de contagem de referência de valores retornados
 discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

O que são funções na linguagem
\end_inset 


\layout Standard

Embora métodos sejam usualmente criados em C usando estruturas 
\family typewriter 
PyMethodDef
\family default 
, é possível ainda criar um objeto do tipo método explicitamente a partir
 de C com a função 
\family typewriter 
PyMethod_New
\family default 
, passando como parâmetro um objeto Python 
\begin_inset Quotes eld
\end_inset 

chamável
\begin_inset Quotes erd
\end_inset 

 e o objeto ou classe a que ele deve se referir.
 Como visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, objetos Python podem ser tornados 
\begin_inset Quotes eld
\end_inset 

chamáveis
\begin_inset Quotes erd
\end_inset 

 implementando um método 
\family typewriter 
__call__
\family default 
 em Python ou associando uma função C ao campo 
\family typewriter 
tp_call
\family default 
 do seu 
\family typewriter 
PyTypeObject
\family default 
 correspondente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo
\end_inset 


\layout Standard

Uma implementação simples de uma função C que pode ser registrada em Python
 como a função global 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* teste_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* entrada; long n;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Em caso de erro nos argumentos, PyArg_ParseTuple
\layout LyX-Code


\size footnotesize 
\emph on 
      gera uma exceção apropriada automaticamente */
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &entrada, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Como os argumentos são recebidos em uma tupla no segundo parâmetro, a assinatura
 de função empregada corresponde à flag 
\family typewriter 
METH_VARARGS
\family default 
.
 Os parâmetros de entrada são convertidos para C e verificados com 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 O valor de retorno é convertido do tipo nativo C para um 
\family typewriter 
PyObject
\family default 
 com 
\family typewriter 
PyInt_FromLong
\family default 
, gerando uma nova referência.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de global
\end_inset 


\layout Standard

A API de Python é projetada primariamente para o desenvolvimento de módulos
 de extensão para a linguagem.
 Embora existam diversas funções para registrar métodos em classes e inicializar
 módulos com listas de funções, não há uma forma direta para registrar funções
 globais na máquina virtual.
 Uma maneira possível é usando a rotina utilitária para lookup de métodos
 
\family typewriter 
Py_FindMethod
\family default 
 e inserindo o método retornado no dicionário do módulo global 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef teste_def[] = {
\layout LyX-Code


\size footnotesize 
   { "teste", (PyCFunction) teste_py, METH_VARARGS, "um teste" },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* teste_obj = Py_FindMethod(teste_def, NULL, "teste");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "teste", teste_obj);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que foi passado 
\family typewriter 
NULL
\family default 
 para 
\family typewriter 
Py_FindMethod
\family default 
, indicando que não há um objeto do qual o método faz parte.
 O argumento 
\family typewriter 
self
\family default 
 recebido pela função C 
\family typewriter 
teste_py
\family default 
 será também 
\family typewriter 
NULL
\family default 
 e pode ser ignorado.
 O array 
\family typewriter 
teste_def
\family default 
 foi declarado 
\family typewriter 
static
\family default 
 para garantir que o 
\family typewriter 
PyMethodDef
\family default 
 continuará válido enquanto a função global estiver registrada, pois na
 criação de 
\family typewriter 
teste_obj
\family default 
 um ponteiro para ele é armazenado internamente no objeto criado.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\layout Standard

Convenção para parâmetros de entrada
\end_inset 


\layout Standard

Para que funções C possam ser chamadas a partir de Ruby, elas devem ser
 declaradas como métodos de alguma classe ou módulo, ou ainda como uma função
 global.
 Para isto, passa-se um ponteiro de uma função C e o número de argumentos
 que a função espera para uma das funções apropriadas da API de Ruby: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 ou 
\family typewriter 
rb_define_singleton\SpecialChar \-
_method
\family default 
.
 O número de parâmetros passado indica a assinatura esperada para a função\SpecialChar ~
C.
 Ruby suporta explicitamente funções C com até 15 argumentos; como alternativa,
 os valores especiais -1 e -2 indicam, respectivamente, que a função C irá
 receber os parâmetros na forma de um array C de 
\family typewriter 
VALUE
\family default 
s ou na forma de um 
\family typewriter 
VALUE
\family default 
 correspondente a um array Ruby.
\layout Standard

De forma similar à função 
\family typewriter 
PyArg_ParseTuple
\family default 
 discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

, Ruby possui uma função projetada para simplificar o processamento dos
 valores de entrada em funções\SpecialChar ~
C: 
\family typewriter 
rb_scan_args
\family default 
.
 Esta função pode ser usada quando os parâmetros de entrada são recebidos
 em um array Ruby.
 Como 
\family typewriter 
PyArg_ParseTuple
\family default 
, ela é uma função vararg que recebe uma string de formato indicando o número
 de parâmetros a serem coletados.
 Por outro lado, ela não realiza verificação de tipo dos argumentos.
 A string de formato permite indicar o número mínimo e máximo de parâmetros
 aceitos e se os parâmetros excedentes devem ser coletados em um array Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: blocos
\end_inset 


\layout Standard

Uma vez declarada no espaço de objetos de Ruby, uma função C pode ser chamada
 como qualquer outro método.
 A função C pode verificar se o código Ruby lhe passou um bloco de código
 através da função 
\family typewriter 
rb_block_given_p
\family default 
.
 O bloco pode então ser invocado com 
\family typewriter 
rb_yield
\family default 
, que recebe um 
\family typewriter 
VALUE
\family default 
 como argumento.
 Para passar múltiplos argumentos para 
\family typewriter 
rb_yield
\family default 
, deve-se passar um array Ruby.
 Para obter um 
\family typewriter 
VALUE
\family default 
 do tipo 
\family typewriter 
Proc
\family default 
 produzido a partir do bloco de código recebido é preciso usar 
\family typewriter 
rb_scan_args
\family default 
, que possui funcionalidade similar à do operador 
\family typewriter 
&
\family default 
 em declarações de funções Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C implementado métodos Ruby devem sempre retornar um 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 quando não há retorno).
 Funções que retornam múltiplos valores devem fazê-lo através de um array
 Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Dando continuidade à série de exemplos, a função global Ruby 
\family typewriter 
teste
\family default 
 pode ser implementada da seguinte forma em C:
\layout LyX-Code


\size footnotesize 
VALUE teste_rb(VALUE self, VALUE val_entrada, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* entrada = StringValuePtr(val_entrada);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A conversão dos 
\family typewriter 
VALUE
\family default 
s de entrada é feita com as macros 
\family typewriter 
StringValuePtr
\family default 
 e 
\family typewriter 
NUM2INT
\family default 
.
 Não há código explícito para tratamento de erros na conversão pois estas
 macros disparam exceções que saem da função via 
\family typewriter 
longjmp
\family default 
 caso a conversão não seja possível.
 Para a saída, é produzido um 
\family typewriter 
VALUE
\family default 
 com a macro 
\family typewriter 
INT2NUM
\family default 
.
 O primeiro parâmetro de entrada é necessário segundo a convenção de assinaturas
 de função da API, mas para funções globais ele deve ser ignorado.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de fn global
\end_inset 


\layout Standard

Como Ruby oferece uma função na API para a definição de funções globais,
 o registro de 
\family typewriter 
teste
\family default 
 é bastante simples:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("teste", teste_rb, 2); 
\layout Standard

É indicado o nome da função no espaço de Ruby, a função C correspondente
 e o número de parâmetros que ela espera (não incluindo o parâmetro 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: métodos native
\end_inset 


\layout Standard

Métodos declarados em Java que não são implementados na própria linguagem
 devem ser declarados através de um protótipo incluindo o modificador 
\family typewriter 
native
\family default 
.
 Assim, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 A implementação do método, usualmente encapsulada em uma biblioteca dinâmica
 C, deve ser carregada antes de sua execução usando a chamada 
\family typewriter 
System.loadLibrary
\family default 
 em Java, usualmente em um bloco 
\family typewriter 
static
\family default 
 da classe correspondente.
 Para cada método 
\family typewriter 
native
\family default 
, uma função C correspondente deve ser definida na biblioteca carregada.
\layout Standard

O utilitário 
\family typewriter 
javah
\family default 
 gera arquivos de cabeçalho C a partir de classes Java, com os protótipos
 de funções C no formato especificado pela JNI.
 Este formato especifica não apenas a assinatura dos parâmetros de entrada
 e tipo de retorno, mas também o nome da função, para que o 
\emph on 
loader
\emph default 
 realize a ligação entre a função C e o método Java na máquina virtual.
 As funções devem se chamar 
\family typewriter 
Java_
\family default 
\emph on 
<nome da classe>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<nome do método>
\emph default 
.
 No caso de sobrecarga de funções, um sufixo é adicionado indicando o tipo
 dos parâmetros de entrada (por exemplo, 
\family typewriter 
Java_Classe_metodo__DI
\family default 
 para a versão de 
\family typewriter 
Classe.metodo
\family default 
 que aceita um 
\family typewriter 
double
\family default 
 e um 
\family typewriter 
int
\family default 
 como parâmetros).
\layout Standard

Os parâmetros de entrada da função são um ponteiro para 
\family typewriter 
JNIEnv
\family default 
, que representa uma thread da JVM, um 
\family typewriter 
jobject
\family default 
 representando o objeto sobre o qual o método é aplicado (ou uma 
\family typewriter 
jclass
\family default 
 para métodos estáticos) e os demais parâmetros da função Java em suas represent
ações C, discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Como o tipos dos parâmetros passados são definidos estaticamente tanto
 em Java como em C, não é preciso realizar a verificação dos tipos dos dados
 recebidos no código C.
 A assinatura das funções que implementam métodos, especificados nos arquivos
 de cabeçalho gerados pela ferramento 
\family typewriter 
javah
\family default 
, já declaram os tipos corretos.
\layout Standard

O tipo de retorno corresponde ao tipo\SpecialChar ~
C equivalente ao tipo de retorno do
 método Java.
 O valor retornado pode ser uma referência local ou global.
 Além de tratar ou propagar erros como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, funções C podem também gerar exceções com 
\family typewriter 
Throw
\family default 
 e 
\family typewriter 
ThrowNew
\family default 
 e retornar imediatamente.
 O valor de retorno será ignorado quando a exceção for capturada no código
 Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de função global
\layout Standard

Funções da API para registrar funções (não há)
\end_inset 


\layout Standard

Como o modo de expor à máquina virtual de Java funções implementadas em
 C é diferente do empregado nas linguagens vistas anteriormente, pela forma
 de declarar a função para o espaço de Java, para só então mostrar a implementaç
ão de 
\family typewriter 
teste
\family default 
 em C.
 Na classe em Java, declaramos um método 
\family typewriter 
native
\family default 
:
\layout LyX-Code


\size footnotesize 
public class Exemplo {
\layout LyX-Code


\size footnotesize 
   static native int teste(String entrada, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...demais membros da classe
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Exemplo");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Após compilar esta classe podemos passá-la para o comando 
\family typewriter 
javah
\family default 
, que gerará um arquivo de cabeçalho C.
 Este arquivo conterá o nome e assinatura da função C que a JVM irá procurar
 na biblioteca que será carregada por 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed false

\layout Standard

O parâmetro passado no código Java é usado como base na construção de um
 nome dependente de plataforma.
 Em sistemas Unix, por exemplo, o comando 
\family typewriter 
System.loadLibrary("Exemplo")
\family default 
 carrega o arquivo 
\family typewriter 
libExemplo.so
\family default 
.
\end_inset 

.
 Esta biblioteca deve implementar funções relativas aos métodos declarados
 como 
\family typewriter 
native
\family default 
.
\layout Standard

Abaixo, é dada uma implementação em C, usando o cabeçalho gerado por 
\family typewriter 
javah
\family default 
, para o método 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cabeçalho gerado por javah */
\layout LyX-Code


\size footnotesize 
#include "Exemplo.h" 
\layout LyX-Code


\size footnotesize 
 
\newline 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_teste(JNIEnv* J, jclass c, jstring obj_entrada, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = (*J)->GetStringUTFChars(J, obj_entrada, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_entrada, entrada);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 e 
\family typewriter 
JNICALL
\family default 
 são macros definidas em 
\family typewriter 
jni.h
\family default 
 para dar maior portabilidade ao código C gerado.
 Como o método foi declarado como 
\family typewriter 
static
\family default 
 em Java, uma referência para a classe é recebida como parâmetro para a
 função.
 Os demais parâmetros correspondem aos parâmetros do método Java, e são
 dados nos tipos equivalentes da JNI.
 Conforme discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, a JNI dá tratamentos diferentes para tipos de referência e tipos imediatos.
 Desta forma, somente o parâmetro 
\family typewriter 
obj_entrada
\family default 
 precisa ser convertido para C; tanto 
\family typewriter 
n
\family default 
 como o valor de retorno podem ser usados diretamente como tipos básicos
 de C.
\layout Standard

A string obtida com 
\family typewriter 
GetStringUTFChars
\family default 
 é convertida para UTF-8 a partir da representação Unicode interna de Java.
 O mesmo ponteiro pode ser retornado pela JVM a diferentes threads que solicitem
 a mesma string.
 Deste modo, o código C deve notificar a sua liberação explicitamente com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

Neste exemplo, a função retorna um valor imediato.
 Valores representados com tipos de referência podem ser retornados tanto
 com referências locais como globais.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

Funções C expostas ao espaço de Lua devem ter o tipo 
\family typewriter 
lua_CFunction
\family default 
, recebendo como único parâmetro um ponteiro para uma variável do tipo 
\family typewriter 
lua_State
\family default 
 e retornando um 
\family typewriter 
int
\family default 
.
 Um 
\family typewriter 
lua_State
\family default 
 encapsula todo o estado da máquina virtual de Lua; múltiplos estados Lua
 podem ser mantidos em paralelo.
 Todas as funções da API 
\emph on 
core
\emph default 
 de Lua recebem um 
\family typewriter 
lua_State
\family default 
 como primeiro parâmetro, exceto 
\family typewriter 
lua_newstate
\family default 
, que cria um 
\family typewriter 
lua_State
\family default 
 novo.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Convenções p/ parâmetros de entrada
\end_inset 


\layout Standard

Ao início da função C, os argumentos passados a ela encontram-se inseridos
 na pilha virtual.
 Como em funções Lua, não há verificação sobre o número de argumentos passados
 para uma função C invocada a partir de Lua ou através da API.
 O código C pode verificar o número de argumentos passados inspecionando
 o tamanho da pilha recebida.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A biblioteca auxiliar provê ainda funções para verificar de forma mais convenien
te o tipo dos argumentos passados.
 Funções da família 
\family typewriter 
luaL_check
\family default 
* (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) verificam o tipo de um elemento da pilha e o retornam, sinalizando
 erro caso o tipo do elemento não seja o requisitado.
 As funções 
\family typewriter 
luaL_opt
\family default 
* se comportam de forma similar, permitindo ainda indicar um valor padrão
 caso o elemento esteja ausente ou seja 
\family typewriter 
nil
\family default 
.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Valores de retorno também são passados pela função C de volta para Lua através
 da pilha virtual.
 O valor inteiro retornado da função C indica quantos elementos da pilha
 devem ser retornados à função chamadora.
 Os demais valores da pilha são descartados.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API p/ registrar funções
\end_inset 


\layout Standard

Uma função C do tipo 
\family typewriter 
lua_CFunction
\family default 
 pode ser passada para o espaço de Lua através da função 
\family typewriter 
lua_pushcfunction
\family default 
.
 Lua possui também algumas funções de conveniência para registrar um conjunto
 de funções C de uma só vez.
 De forma similar ao uso de arrays 
\family typewriter 
PyMethodDef
\family default 
 em Python, a função 
\family typewriter 
luaL_register
\family default 
 registra uma lista de funções, recebendo um array de estruturas 
\family typewriter 
luaL_Reg
\family default 
 contendo nomes e ponteiros de função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

A função C implementando a função de exemplo 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
int teste_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = luaL_checkstring(L, 1); 
\emph on 
/* Obtém o primeiro parâmetro */
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);             
\emph on 
/* Obtém o segundo parâmetro */
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);                       
\emph on 
/* Empilha o valor de retorno */
\layout LyX-Code


\size footnotesize 
   return 1;                             
\emph on 
/* Retorna um valor, do topo da pilha */
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A função tem assinatura idêntica à definição de 
\family typewriter 
lua_CFunction
\family default 
.
 Os parâmetros de entrada são obtidos das posições 1 e 2 da pilha e os seus
 tipos são verificados usando as funções da biblioteca auxiliar 
\family typewriter 
luaL_checkstring
\family default 
 e 
\family typewriter 
luaL_checkinteger
\family default 
.
 Estas funções sinalizam erro em caso de falha na conversão, causando um
 
\family typewriter 
longjmp
\family default 
 como em Ruby.
\layout Standard

A string retornada o tipo da string obtida é do tipo 
\family typewriter 
const char*
\family default 
, pois ela aponta um bloco de memória gerenciado pela máquina virtual.
 Em Lua, no entanto, não é preciso notificar a liberação da string explicitament
e, pois esta permanece válida enquanto o valor estiver na pilha.
 Como as funções 
\family typewriter 
luaL_check
\family default 
* não desempilham os parâmetros e a pilha é esvaziada implicitamente ao
 final da função C, a string C obtida permanecerá válida ao longo da função.
\layout Standard

Ao fim da função 
\family typewriter 
teste_lua
\family default 
, o valor de retorno para Lua é empilhado usando 
\family typewriter 
lua_push\SpecialChar \-
integer
\family default 
.
 O valor de retorno da função em C, 
\family typewriter 
1
\family default 
, indica à máquina virtual que há um único valor de saída a ser obtido da
 pilha e usado como retorno da função em Lua.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro
\end_inset 


\layout Standard

A função é registrada em Lua criando um objeto Lua do tipo 
\family typewriter 
function
\family default 
 a partir da função C e armazenando este objeto em uma variável global.
 Isto poderia ser feito com 
\family typewriter 
lua_pushcclosure
\family default 
 e 
\family typewriter 
lua_setglobal
\family default 
, mas o arquivo de cabeçalho 
\family typewriter 
lua.h
\family default 
 possui uma macro que encapsula estas duas chamadas.
 Assim, a função pode ser registrada simplesmente com:
\layout LyX-Code


\size footnotesize 
lua_register(L, "teste", teste_lua);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Usando a função 
\family typewriter 
lua_pushcclosure
\family default 
, é possível associar a uma função C valores Lua que serão acessíveis à
 função sempre que esta for chamada, de forma similar a variáveis locais
 
\family typewriter 
static
\family default 
 C.
 Este recurso provê uma funcionalidade similar às 
\emph on 
closures
\emph default 
 de Lua, porém mais limitado: os valores associados são privados às funções
 C, enquanto em Lua duas 
\emph on 
closures
\emph default 
 definidas num mesmo escopo terão acesso às mesmas variáveis, isto é, alterações
 nos valores em uma afetarão a outra.
 Esta forma restrita, porém, já permite a implementação em C de 
\begin_inset Quotes eld
\end_inset 

funções com estado
\begin_inset Quotes erd
\end_inset 

, como iteradores e geradores.
 Uma vez registrada no espaço de Lua, funções C passam a ser vistos como
 valores do tipo 
\family typewriter 
function
\family default 
, de forma igual a funções Lua.
 De fato, 
\family typewriter 
lua_pushcfunction
\family default 
 é um caso particular de 
\family typewriter 
lua_pushcclosure
\family default 
 onde nenhum valor Lua é associado à função.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas
\end_inset 


\layout Standard

Como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

, a interface entre Perl e C foi projetada tendo em mente que a ligação
 entre as funções C e o interpretador Perl é feita através de código gerado
 a partir de uma descrição feita em uma linguagem de mais alto nível, XS.
 Código\SpecialChar ~
XS consiste de declarações de assinaturas de função com uma sintaxe
 especial, indicando regras para conversão dos parâmetros de entrada e saída,
 e código C descrevendo a implementação das funções.
 XS é projetada para o desenvolvimento de extensões Perl incluindo funções
 implementadas em C: o resultado final da compilação do código gerado pelas
 ferramentas\SpecialChar ~
XS (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) são código C e Perl que juntos descrevem um pacote Perl (um conjunto de
 variáveis e funções armazenados sob um 
\emph on 
namespace
\emph default 
 comum).
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções (não tem)
\end_inset 


\layout Standard

Existe uma API pública para manipulação de dados Perl no código C, mas esta
 consiste basicamente das estruturas internas da implementação do interpretador
 expostas para uso pelo pré-processador XS, acrescida de macros para maior
 conveniência do programador.
 De fato, Perl não expõe uma API documentada para o registro de funções\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

.
 Assim, não é prático para uma aplicação embutir um interpretador Perl e
 expor a ele um conjunto de funções C usando apenas código C.
 A saída é criar uma extensão Perl usando XS que expõe funções da aplicação
 e importar o pacote resultante no interpretador embutido.
 O emprego desta abordagem foi observada nos plugins para scripting Perl
 de diversas aplicações 
\begin_inset Foot
collapsed false

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) e Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) são algumas aplicações que implementam plugins Perl através de extensões
 XS.
 No plugin de Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), não há arquivos 
\family typewriter 
.xs
\family default 
, mas os fontes 
\family typewriter 
.c
\family default 
 incluem funções declaradas com a API não documentada e o código Perl equivalent
e ao arquivo 
\family typewriter 
.pm
\family default 
 gerado por 
\family typewriter 
xsubpp
\family default 
 declarado como uma string C avaliada com 
\family typewriter 
eval_pv
\family default 
, dando a entender que o plugin foi implementado como uma extensão usando
 XS e depois convertido para um único arquivo-fonte C.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

O utilitário 
\family typewriter 
h2xs
\family default 
 gera um diretório contendo o esqueleto de um módulo Perl: um script gerador
 de Makefiles, arquivos 
\family typewriter 
.xs
\family default 
 e 
\family typewriter 
.pm
\family default 
 a serem acrescidos de código XS e Perl, além de arquivos auxiliares.
 Retomando o exemplo da função teste, ela seria declarada da seguinte forma
 em XS:
\layout LyX-Code


\size footnotesize 
long teste(entrada, n)
\layout LyX-Code


\size footnotesize 
        char* entrada
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

O arquivo 
\family typewriter 
.xs
\family default 
 é convertido para 
\family typewriter 
.c
\family default 
 com 
\family typewriter 
xsubpp
\family default 
.
 O código C para a conversão dos parâmetros de entrada e saída é gerado
 automaticamente.
 Em alguns casos, entretanto, precisamos manipular os valores da pilha de
 Perl explicitamente, como descrito na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 Em funções vararg, por exemplo, os argumentos adicionais devem ser acessados
 diretamente na pilha.
 O código para registrar as funções do módulo também é gerado automaticamente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

XS cria uma variável 
\family typewriter 
RETVAL
\family default 
 automaticamente para armazenamento do valor de retorno em código C.
 O conteúdo desta variável é convertido para um valor Perl pelo código C
 gerado.
 Para que funções que retornam arrays possam operar corretamente em contextos
 escalares, deve-se verificar o contexto em que a função é chamada com 
\family typewriter 
GIMME_V
\family default 
 e então retornar um 
\family typewriter 
SV
\family default 
 ou 
\family typewriter 
AV
\family default 
 conforme o caso.
 A função, nestes casos, deve ser declarada com tipo de retorno 
\family typewriter 
SV*
\family default 
, fazendo com que os valores de C devam ser convertidos para 
\family typewriter 
SV
\family default 
s Perl explicitamente.
 A documentação alerta que, para o caso de 
\family typewriter 
AV
\family default 
s, deve-se declarar o valor de retorno como variável mortal
\begin_inset Foot
collapsed false

\layout Standard

Este comportamento é descrito na documentação como 
\emph on 

\begin_inset Quotes eld
\end_inset 

an unfixable bug (fixing it would break lots of existing CPAN modules)
\begin_inset Quotes erd
\end_inset 


\emph default 
 
\begin_inset LatexCommand \cite{roehrich06perlxs}

\end_inset 

.
 
\end_inset 

.
\layout Standard

Uma vez compilada a extensão usando os Makefiles gerados por 
\family typewriter 
h2xs
\family default 
, a extensão pode ser carregada e usada a partir de Perl:
\layout LyX-Code


\size footnotesize 
use Teste;
\layout LyX-Code


\size footnotesize 
$ret = Teste::teste("entrada", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para expor funções de uma aplicação C a um interpretador Perl embutido nela,
 devemos criar uma extensão que encapsula estas funções usando XS, ligar
 a extensão à aplicação e carregá-la.
 A carga é feita passando para o interpretador uma função C contendo chamadas
 
\family typewriter 
newXS
\family default 
 durante a sua inicialização.
 O módulo Perl 
\family typewriter 
ExtUtils::Embed
\family default 
 possui uma rotina 
\family typewriter 
xsinit
\family default 
 para gerar o código C desta função.
 Na prática, gerar o código da função com 
\family typewriter 
xsinit
\family default 
 é a melhor abordagem, já que a inicialização depende de rotinas não documentada
s (o exemplo de função de inicialização incluído na documentação de Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

 está desatualizado).
\layout Subsection

Comparação
\layout Standard

Python e Ruby oferecem ao programador diferentes opções de assinaturas de
 função\SpecialChar ~
C reconhecidas pela API, o que é prático, uma vez que pode-se escolher
 assim diferentes representações em C para os parâmetros de entrada (agregados
 em um array, recebidos um a um, etc.) conforme o seu uso na função.
 Lua oferece apenas uma assinatura de função possível para funções C a serem
 registradas na máquina virtual, mas isto é apropriado para o modelo de
 pilha usado por sua API.
\layout Standard

Em Java, as assinaturas de função são criadas através da ferramenta 
\family typewriter 
javah
\family default 
 -- devido à tipagem estática, os tipos dos parâmetros de entrada passados
 por Java são convertidos automaticamente pela JNI, o que é bastante conveniente
 uma vez que evita operações explícitas de conversão e verificação de tipos
 na função.
 Por terem tipagem dinâmica, as demais linguagens oferecem funções na API
 específicas para realizar estas verificações.
 As assinaturas de função em Perl são criadas apenas através da ferramenta
 XS, mas diferentemente de Java elas não são expostas ao programador.
 Isto traz a inconveniência de termos que pré-processar o código C como
 uma extensão XS mesmo quando estamos embutindo Perl em uma aplicação.
\layout Standard

O registro de funções em Ruby e Lua é simples.
 Em Lua, em particular, trata-se de uma atribuição igual à de qualquer outro
 objeto.
 Já em Python, existem recursos para o registro de funções em lote, usando
 arrays 
\family typewriter 
PyMethodDef
\family default 
 (Lua oferece recurso similar com 
\family typewriter 
luaL_register
\family default 
), mas não há uma forma simples de registrar uma única função.
 Tanto em Java como em Perl o registro de funções é feito de forma implícita,
 e em nenhuma das duas APIs há funções para registrar novas funções C durante
 a execução do programa.
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de caso: LibScript
\layout Standard

No capítulo anterior, foram discutidas as principais questões envolvendo
 interfaces de linguagens para C e a forma como estas questões são tratadas
 pelas linguagens abordadas neste estudo.
 Neste capítulo, realizaremos uma comparação entre as APIs através de um
 exemplo concreto, de modo a colocar implementações em cada uma das linguagens
 lado a lado.
 O exemplo consiste em uma biblioteca genérica para scripting, chamada LibScript
, e uma série de plugins que realizam a interface com as diferentes linguagens
 de script.
\layout Section

LibScript
\layout Standard

LibScript é uma biblioteca projetada para tornar aplicações extensíveis
 através de scripting de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo a desacoplar a aplicação dos ambientes de execução providos pelas
 diversas linguagens.
 A biblioteca principal provê uma API para scripting independente de linguagem,
 permitindo a uma aplicação registrar as suas funções e disparar scripts
 que as utilizem.
 Esta biblioteca então invoca o plugin da linguagem apropriada para rodar
 o script (por exemplo, LibScript-Python para código Python).
 Desta forma, o desenvolvedor da aplicação permite ao seu usuário utilizar
 diferentes linguagens para scripting sem adicionar todas elas como dependências
 do programa.
\layout Standard

A biblioteca principal disponibiliza recursos para o registro de funções
 C por parte da aplicação e para a chamada destas funções por parte dos
 plugins (permitindo aos scripts acessar as funções), além de funções para
 a transferência de dados entre as duas partes.
 É possível também invocar funções implementadas nas máquinas virtuais embutidas
 nos plugins, possibilitando assim que scripts escritos em diferentes linguagens
 possam interagir.
\layout Subsection

Arquitetura de LibScript
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura1.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Visão-geral}

\end_inset 

Visão geral da arquitetura de LibScript
\end_inset 


\layout Standard

LibScript é composta de uma biblioteca dinâmica principal, 
\family typewriter 
libscript
\family default 
, e 
\emph on 
plugins
\emph default 
 para diferentes linguagens (Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Visão-geral}

\end_inset 

).
 A biblioteca principal é ligada a uma aplicação, e expõe a ela uma API
 de scripting independente de linguagem, que permite executar arquivos,
 strings de código e invocar funções.
 Esta biblioteca é uma fina camada que encaminha estas operações para os
 plugins, que são bibliotecas dinâmicas auxiliares, carregadas em tempo
 de execução pela biblioteca principal.
 Estes plugins embutem os ambientes de execução das linguagens de script.
\layout Standard

A aplicação pode registrar funções C na biblioteca principal (ilustrado
 pela função 
\family typewriter 
c_fun
\family default 
 na figura) e solicitar a ela que execute scripts que registram funções
 nas diferentes linguagens.
 Todavia, a aplicação não interage diretamente com os plugins.
 Quando a biblioteca principal recebe código a ser executado em uma determinada
 linguagem, ela carrega o plugin adeqüado (caso este ainda não esteja carregado)
 e encaminha o código.
 O plugin irá executar o script em sua máquina virtual, o que pode registrar
 nela novas funções (ilustrado pelas funções 
\family typewriter 
py_fun
\family default 
, 
\family typewriter 
r_fun
\family default 
, 
\family typewriter 
l_fun
\family default 
 e 
\family typewriter 
pl_fun
\family default 
 na figura).
\layout Standard

A biblioteca principal decide qual plugin carregar através de um identificador
 que especifica qual a linguagem do código a ser executado.
 Este identificador pode ser obtido a partir da extensão de arquivo de um
 script carregado, da linha de identificação 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 no início do script
\begin_inset Foot
collapsed true

\layout Standard

A linha 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 é usada apenas para detectar a linguagem em que o script é escrito.
 Por exemplo, uma linha 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 indicará a carga do plugin 
\family typewriter 
libscript-perl
\family default 
, mas o interpretador Perl em 
\family typewriter 
/usr/bin
\family default 
 não é usado e nem a flag 
\family typewriter 
-w
\family default 
 passada é considerada.
\end_inset 

 ou mesmo passado explicitamente pela aplicação.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura2.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ambientes-virtuais}

\end_inset 

Ambientes virtuais em LibScript
\end_inset 


\layout Standard

Funções são registradas em LibScript em um 
\emph on 
ambiente virtual
\emph default 
.
 A aplicação pode criar um ou mais ambientes na biblioteca principal, identifica
ndo-os com um nome.
 Um ambiente virtual ganha em cada plugin uma estrutura de dados específica
 da linguagem (classe, módulo, etc.) que o representará.
 No exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Ambientes-virtuais}

\end_inset 

 temos dois ambientes virtuais criados pela aplicação na biblioteca principal,
 
\family typewriter 
X
\family default 
 e 
\family typewriter 
Y
\family default 
.
 Em cada um destes ambientes, a aplicação registrou uma função C com o nome
 
\family typewriter 
c_fun
\family default 
 (que podem ou não corresponder à mesma função C).
 Scripts foram executados nestes ambientes, o que causou a carga dos plugins.
 No exemplo, estes scripts registraram algumas funções (
\family typewriter 
X.py_fn
\family default 
, 
\family typewriter 
Y.py_fn
\family default 
, 
\family typewriter 
X#r_fun
\family default 
, etc.).
\layout Standard

À parte da função para criação de ambientes virtuais, todas as demais funções
 da API de LibScript recebem como parâmetro um ambiente virtual sobre a
 qual elas devem operar.
 Isto indica em qual estrutura de C devem ser armazenadas mensagens de erro
 e valores de retorno.
 No caso de linguagens que permitem múltiplos estados de execução independentes,
 como Lua e Perl, isto indica também em qual estado o script deve executar.
\layout Standard

Quando um script declara uma função no ambiente virtual, esta função passa
 a ser acessível através da API de LibScript.
 Por exemplo, no plugin Lua, o ambiente virtual é representado por uma tabela
 com o nome do ambiente; uma vez que um método Ruby\SpecialChar ~

\family typewriter 
r
\family default 
 é declarado na classe 
\family typewriter 
X
\family default 
, esta função passa a poder ser invocada por C (através da API de LibScript)
 ou pelos outros plugins.
 Assim, por exemplo, embora na tabela Lua que implementa o ambiente virtual
 
\family typewriter 
X
\family default 
 só conste a função 
\family typewriter 
l_fun
\family default 
, scripts Lua podem invocar as demais funções através do ambiente virtual,
 como 
\family typewriter 
X.c_fun
\family default 
 e 
\family typewriter 
X.r_fun
\family default 
.
 Estas chamadas serão tratadas pela biblioteca principal e resolvidas por
 ela, no caso de funções C como 
\family typewriter 
X.c_fun
\family default 
, ou repassadas para o plugin apropriado, como no caso de 
\family typewriter 
X.r_fun
\family default 
, realizando a chamada no plugin Ruby e passando os valores de retorno para
 o plugin Lua.
 A biblioteca principal localiza a função a ser executada consultando os
 plugins, conforme será explicado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:A-API-de-plugins}

\end_inset 

.
\layout Standard

Na implementação dos plugins, utilizamos recursos oferecidos pelas linguagens
 para tratar acessos a elementos inexistentes nas estruturas, capturando
 estes acessos e repassando-os para a biblioteca principal.
 Estes recursos serão discutidos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

.
\layout Subsection


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

A API da biblioteca principal
\layout Standard

A API oferecida por LibScript isola a aplicação das diferentes APIs oferecidas
 pelas linguagens de script.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas,
 o que seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Outra abordagem é, ao invés de expor a API da linguagem à aplicação, expor
 apenas uma API de funções da aplicação para a linguagem e manter as estruturas
 de dados e recursos desta restrito ao domínio que será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas02ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy,vanrossum06ref}

\end_inset 

.
 Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby , 
\family typewriter 
perl_eval_sv
\family default 
 em Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename figura3.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:API-para-execução}

\end_inset 

API para execução de código em LibScript
\end_inset 


\layout Standard

LibScript adota esta abordagem mais minimalista para sua API: não são oferecidas
 operações específicas para manipulação de estruturas de dados, apenas para
 a 
\emph on 
execução de strings
\emph default 
 -- 
\family typewriter 
script_run
\family default 
 (e a função de conveniência 
\family typewriter 
script_run_file
\family default 
, que lê um arquivo e o envia para 
\family typewriter 
script_run
\family default 
) -- e 
\emph on 
chamadas de função
\emph default 
 com tipos básicos (números e strings) -- 
\family typewriter 
script_call
\family default 
.
 Operações sobre dados mais complexos de tipos específicos de cada linguagem,
 quando necessárias, podem ser encapsuladas em funções implementadas nas
 linguagens de script.
 Pode-se ainda referenciar objetos da linguagem a partir de C armazenando-as
 em estruturas na linguagem de script e retornando a C índices numéricos
 destas estruturas, servindo como 
\emph on 
handles
\emph default 
 de alto nível para os objetos.
\layout Standard

A Figura\SpecialChar ~

\begin_inset LatexCommand \ref{fig:API-para-execução}

\end_inset 

 ilustra a interação entre a aplicação, a biblioteca principal e os plugins
 em relação a estas duas operações fundamentais, simbolizadas pelas funções
 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_call
\family default 
.
 Para a execução de strings, a biblioteca principal recebe da aplicação
 a entrada e repassa o código a ser executado para o plugin apropriado.
 Em 
\family typewriter 
script_run
\family default 
, são passadas duas strings, uma identificando a linguagem e outra contendo
 o código; em 
\family typewriter 
script_run_file
\family default 
, um nome de arquivo
\begin_inset Foot
collapsed false

\layout Standard

Para código executado com 
\family typewriter 
script_run_file
\family default 
, a linguagem é automaticamente detectada como discutido na seção anterior.
\end_inset 

.
 O exemplo a seguir declara um ambiente virtual, registra uma função C chamada
 
\family typewriter 
hello
\family default 
 e a invoca a partir de código Lua:
\layout LyX-Code


\size footnotesize 
script_env* env = script_init("exemplo");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "exemplo.hello()");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O ambiente virtual é declarado com a função 
\family typewriter 
script_init
\family default 
, que recebe o nome que identificará o ambiente e retorna um identificador
 do tipo 
\family typewriter 
script_env
\family default 
, um ponteiro opaco que representa um ambiente virtual.
 A função C é registrada usando a função 
\family typewriter 
script_new_\SpecialChar \-
function
\family default 
, que recebe como parâmetros o ambiente, a função a ser registrada e o nome
 que a função terá no ambiente virtual.
 No código Lua, a função é acessada como um elemento 
\family typewriter 
hello
\family default 
 (nome registrado da função) da tabela 
\family typewriter 
exemplo
\family default 
 (nome do ambiente virtual).
\layout Standard

Para a chamada de funções, a aplicação deve passar os parâmetros de entrada
 (a forma será discutida mais adiante), e chamar 
\family typewriter 
script_call
\family default 
, indicando o nome de uma função registrada no ambiente virtual.
 A mesma função 
\family typewriter 
script_call
\family default 
 é usada pelos plugins quando eles desejam invocar funções do ambiente virtual
 registradas em C ou implementadas por outros plugins.
\layout Standard

Por este motivo, procuramos usar uma API para transferência de dados genérica,
 a ser usada tanto na entrada como na saída de dados, tanto na comunicação
 entre a aplicação e a biblioteca principal como entre a biblioteca principal
 e os plugins.
 Optamos por uma abordagem similar às empregadas em Lua (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) e Perl (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) para o envio de dados na passagem de parâmetros e obtenção de valores
 de retorno, usando um buffer interno como área de transferência.
 Diferentemente destas linguagens, entretanto, passamos índices para os
 parâmetros explicitamente ao invés de empregar uma disciplina de pilha.
 As funções 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} são usadas na entrada e saída de valores.
 As funções 
\family typewriter 
script_put_
\family default 
* armazenam valores no buffer interno e 
\family typewriter 
script_get_
\family default 
* os removem.
 Uma chamada a uma função teste passando uma string e um inteiro como parâmetros
 e obtendo um inteiro como resultado é realizada da seguinte forma:
\layout LyX-Code


\size footnotesize 
script_put_string(env, 0, "entrada"); /* índice 0: "entrada" */
\layout LyX-Code


\size footnotesize 
script_put_int(env, 1, 2);            /* índice 1: 2 */
\layout LyX-Code


\size footnotesize 
script_call(env, "teste");
\layout LyX-Code


\size footnotesize 
resultado = script_get_int(env, 0);   /* retorna índice 0 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Chamadas de função são disponibilizadas como uma operação primitiva pois
 elas permitem um grau mínimo de interoperabilidade de forma independente
 de linguagem.
 Dois objetivos são atingidos desta forma.
 O primeiro é que assim programas C embutindo LibScript podem acessar a
 funcionalidade de scripts carregados sem precisar incluir no seu código
 strings de texto em alguma linguagem específica, por exemplo, inserindo
 em seu código uma chamada a uma função de 
\emph on 
callback
\emph default 
 a ser definida via script.
 Note que no exemplo acima, não é especificada a linguagem em que a função
 
\family typewriter 
teste 
\family default 
é implementada.
 Se a chamada fosse feita via execução de string de código, isto atrelaria
 a aplicação a pelo menos uma linguagem de script.
 Usando 
\family typewriter 
script_run_file
\family default 
 e 
\family typewriter 
script_call
\family default 
, pode-se implementar uma aplicação extensível sem especificar explicitamente
 a linguagem de script a ser usada.
 O segundo objetivo é permitir que os próprios plugins possam invocar funções
 definidas em outros plugins.
 De qualquer forma, necessariamente teríamos que prover aos plugins uma
 função de chamada, para que eles pudessem invocar as funções C registradas
 em LibScript.
 Tornar a função de chamada genérica o suficiente para que possa invocar
 também funções implementadas nos próprios plugins não torna, então, a API
 da biblioteca principal mais complexa.
\layout Standard

O buffer de LibScript foi projetado para ser usado apenas como uma área
 de transferência temporária entre a biblioteca principal e os plugins,
 e não como uma facilidade geral para armazenamento e manipulação de dados.
 Assim, a sua API é voltada para a inserção e remoção seqüencial de elementos.
 Por exemplo, a inserção de um elemento na posição 0 automaticamente zera
 o buffer, evitando em muitos casos a necessidade de usar a função 
\family typewriter 
script_reset_buffer
\family default 
, que realiza tal operação explicitamente.
\layout Standard

Funções C registradas com 
\family typewriter 
script_new_function
\family default 
 devem receber o ambiente virtual como parâmetro e retornar um código de
 erro.
 As funções 
\family typewriter 
script_get_
\family default 
* e 
\family typewriter 
script_put_
\family default 
* são usadas para receber parâmetros e retornar valores ao implementar funções
 que podem ser chamadas via LibScript, da mesma forma que são usadas para
 passar parâmetros e obter valores de retorno ao realizar chamadas com 
\family typewriter 
script_call
\family default 
.
\layout LyX-Code


\size footnotesize 
script_err teste_lua(script_env* env) {
\layout LyX-Code


\size footnotesize 
   char* entrada = script_get_string(env, 0);  
\emph on 
/* Entrada, índice 0: string */
\layout LyX-Code


\size footnotesize 
   int n = script_get_int(env, 1);             
\emph on 
/* Entrada, índice 1: inteiro */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Sai da função com erro se algum script_get_* falhou */
\layout LyX-Code


\size footnotesize 
   SCRIPT_CHECK_INPUTS(env);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   free(entrada);
\layout LyX-Code


\size footnotesize 
   script_put_int(env, 0, 42);                 
\emph on 
/* Retorno, índice 0: inteiro */
\layout LyX-Code


\size footnotesize 
   return SCRIPT_OK;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript as strings retornadas por 
\family typewriter 
script_get_string
\family default 
 pertencem à função chamadora, sendo responsabilidade dela desalocar a memória,
 diferentemente do que ocorre nas funções similares das APIs das linguagens
 discutidas neste trabalho.
 Tal decisão foi tomada devido ao caráter temporário do buffer de LibScript:
 retornar ao chamador um ponteiro para uma string cuja validade seria restrita
 até a próxima chamada da API seria algo pouco intuitivo, e na prática forçaria
 freqüentemente o programador a fazer uma cópia da string.
\layout Subsection

A API de plugins
\begin_inset LatexCommand \label{sub:A-API-de-plugins}

\end_inset 


\layout Standard

Um plugin que embute uma linguagem de script deve implementar quatro operações:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 e 
\family typewriter 
done
\family default 
.
 A biblioteca principal espera que a biblioteca dinâmica que implementa
 o plugin de uma linguagem exporte quatro funções, com nomes do tipo
\family typewriter 
 script_plugin_
\family default 
\emph on 
<operação>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<linguagem>
\emph default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável pela inicialização de um plugin, e é chamada pela função
 
\family typewriter 
script_init
\family default 
 da biblioteca principal.
 Na inicialização de um plugin, a biblioteca principal passa à função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 um ponteiro 
\family typewriter 
script_env
\family default 
 e recebe um 
\family typewriter 
script_plugin_state
\family default 
, que é um tipo opaco que é sempre passado de volta ao plugin nas demais
 chamadas.
 Cada plugin define a sua representação interna para 
\family typewriter 
script_plugin_state
\family default 
.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
 Na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 discutiremos como cada plugin representa o ambiente e o seu estado interno
 em 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
 é invocada por 
\family typewriter 
script_run
\family default 
.
 Ela recebe uma string contendo código da linguagem de script, executa este
 código na máquina virtual e retorna um valor de status indicando sucesso
 ou a ocorrência de erros de compilação ou execução.
 No caso de erros, os plugins devem capturar exceções disparadas pela máquina
 virtual e retornar a constante 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
.
 Caso seja possível obter da linguagem uma mensagem de erro, esta pode ser
 propagada usando a função 
\family typewriter 
script_set_error_message
\family default 
 da biblioteca principal.
 A mensagem armazenada por ela poderá ser posteriormente consultada pela
 aplicação com a função 
\family typewriter 
script_error_message
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 é usada por 
\family typewriter 
script_call
\family default 
, e é responsável por realizar chamadas a funções implementadas na linguagem
 embutida pelo plugin.
 Se a função foi definida no plugin, isto é, se uma função com o nome solicitado
 foi registrada na estrutura de dados que descreve o ambiente na máquina
 virtual, ela será executada, e o sucesso ou falha da execução será reportado
 de forma igual a 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
.
 Caso a função solicitada não tenha sido definida na máquina virtual, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
\SpecialChar \-
<linguagem>
\emph default 
 deve retornar a constante 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
 Parâmetros de entrada e valores de retorno são passados através do buffer
 de parâmetros, usando as mesmas funções 
\family typewriter 
script_get_*
\family default 
 e 
\family typewriter 
script_put_*
\family default 
 da biblioteca principal que são usadas para a passagem de dados entre a
 aplicação e a biblioteca principal.
\layout Standard

A implementação da função 
\family typewriter 
script_call
\family default 
 na biblioteca principal faz uso deste comportamento dos plugins para invocar
 funções de modo independente de linguagem.
 Inicialmente, ela tenta encontrar uma função solicitada na lista de funções
 C registradas.
 Caso não haja uma função C no ambiente virtual com este nome, 
\family typewriter 
script_call
\family default 
 tenta localizar a função nos plugins carregados, chamando a função com
 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 em cada plugin, e tentando o próximo a cada vez que recebe 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
\layout Standard

Finalmente, a função 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<linguagem>
\emph default 
 é chamada por 
\family typewriter 
script_done
\family default 
 quando um ambiente virtual é encerrado.
 Dependendo da representação interna usada no plugin, a finalização de um
 estado pode ou não implicar na finalização da máquina virtual.
 Preferencialmente, esta função deve remover a estrutura que descreve o
 ambiente virtual, mas, como veremos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

, isto nem sempre é possível.
\layout Section

Implementação dos plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Standard

Nesta seção discutiremos os principais aspectos envolvidos na implementação
 dos plugins desenvolvidos neste estudo de caso.
 Implementamos plugins para as linguagens Python, Ruby, Lua e Perl.
 Apresentaremos aqui como é feita a representação dos estados virtuais em
 cada plugin (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

), questões envolvendo o encerramento de estados (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

), passagem de parâmetros entre a biblioteca principal e os plugins (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

), como a chamada de funções a partir de scripts é tratada pelos plugins
 (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

) e a captura de erros (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

).
\layout Subsection

Representação de estados
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

O design de LibScript permite que plugins mantenham múltiplos estados de
 execução independentes.
 Idealmente estes estados seriam totalmente isolados entre si, como por
 exemplo diferentes instâncias da máquina virtual, oferecendo maior segurança
 ao ambiente de execução dos scripts.
 Todavia, as linguagens oferecem diferentes graus de isolamento possível
 entre estados independentes.
 Lua e Perl permitem múltiplas instâncias isoladas do ambiente de execução
 de forma simples, uma vez que as chamadas à API incluem um identificador
 de estado
\begin_inset Foot
collapsed false

\layout Standard

O recurso de múltiplos estados independentes é opcional em Perl, selecionado
 durante a compilação da biblioteca do interpretador.
\end_inset 

.
 Já linguagens que mantêm estado de forma estática, como Python e Ruby,
 não permitem trabalhar com múltiplos estados isolados facilmente
\begin_inset Foot
collapsed false

\layout Standard

O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados.
 A documentação diz, desde 1999, que 
\begin_inset Quotes eld
\end_inset 


\emph on 
This is a hard-to-fix bug that will be addressed in a future release.
\emph default 

\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum99api,vanrossum06api}

\end_inset 


\end_inset 

.
 Nas linguagens que não permitem múltiplas instâncias da máquina virtual,
 podemos definir apenas espaços de nomes separados para os ambientes virtuais
 LibScript, que compartilham um único estado global de execução dentro do
 plugin.
 À representação de um estado de execução relativo a um ambiente virtual
 LibScript dentro de um plugin damos o nome de 
\emph on 
estado virtual
\emph default 
, que pode ou não corresponder a um estado de execução isolado.
\layout Standard

Como comentado na seção anterior, a função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 retorna à biblioteca principal um 
\family typewriter 
script_plugin_state
\family default 
, que é a representação opaca do seu estado virtual.
 O conteúdo desta representação varia de linguagem para linguagem, mas o
 princípio básico é que dois dados devem estar disponíveis a partir deste
 valor: uma referência para o ambiente virtual LibScript, recebido como
 parâmetro para 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
, para que o plugin possa fazer chamadas à biblioteca principal, e um identifica
dor que permita ao plugin acessar a estrutura de dados que representa na
 linguagem o espaço de nome de funções acessíveis via LibScript.
 No plugin Lua, esta estrutura é uma tabela; em Python, um módulo; em Ruby,
 uma classe; e em Perl, um pacote.
\layout Standard

Em LibScript-Lua, estados são implementados como 
\family typewriter 
lua_State
\family default 
s (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 Desta forma, scripts executados em um ambiente são plenamente isolados
 dos demais ambientes.
 Por exemplo, a alteração do valor de uma variável global em um ambiente
 não afeta os demais.
 De fato, o 
\family typewriter 
script_plugin_state
\family default 
 retornado pelo plugin Lua é simplesmente o 
\family typewriter 
lua_State
\family default 
 convertido via cast.
 O ponteiro para o ambiente LibScript é armazenado em Lua no registro, da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "LibScript.env"); 
\emph on 
  /* Empilha o índice */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);        
\emph on 
/* Empilha o ambiente LibScript */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX);   
\emph on 
/* registro["LibScript.env"] = env */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O plugin cria neste 
\family typewriter 
lua_State
\family default 
 uma tabela que representará o ambiente virtual para scripts Lua.
 Esta tabela é armazenada no 
\family typewriter 
lua_State
\family default 
 como uma variável global com o nome do ambiente virtual.
\layout Standard

Em LibScript-Perl os estados são isolados como em Lua.
 Cada estado criado inicializa uma nova instância de 
\family typewriter 
PerlInterpreter
\family default 
.
 Neste interpretador, é criado um pacote que será a representação do ambiente
 visível a partir de código Perl.
 O tipo 
\family typewriter 
script_plugin_state
\family default 
, então, é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PerlInterpreter
\family default 
*.
\layout Standard

Como discutido na seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-registro}

\end_inset 

, a implementação de funções C exportadas para um interpretador Perl é feita
 escrevendo um módulo de extensão usando o pré-processador XS, e a forma
 de obter comunicação no sentido Perl
\begin_inset Formula $\rightarrow$
\end_inset 

C em uma máquina virtual embutida é ligando um módulo de extensão juntamente
 com a máquina virtual.
 Assim, parte do plugin LibScript-Perl é implementado como um módulo XS,
 exposto na máquina virtual embutida como o pacote Perl 
\family typewriter 
LibScript
\family default 
.
 Durante a inicialização de um estado virtual, o ponteiro para o ambiente
 virtual LibScript é armazenado neste pacote, na variável 
\family typewriter 
$LibScript::env
\family default 
.
 O pacote que representa o ambiente virtual é criado pela função 
\family typewriter 
script_plugin_init_perl
\family default 
, executando a string de código 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 com a função 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

Como Python não dispõe de facilidades para disparar múltiplas máquinas virtuais
 plenamente isoladas, o plugin Python implementa estados virtuais apenas
 como módulos separados, compartilhando um mesmo estado global.
 Durante a inicialização de um estado, é criado um módulo Python com o nome
 do ambiente.
 O seguinte trecho da função 
\family typewriter 
script_plugin_init_python
\family default 
 exibe a seqüência onde o módulo é criado e importado:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o nome do ambiente */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o módulo.
 O primeiro parâmetro é o nome do módulo,
\layout LyX-Code


\size footnotesize 
\emph on 
   o segundo a lista de métodos do módulo, que será inicialmente vazio.
 */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém dicionário de globais */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o módulo à variável global com o seu nome.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O tipo 
\family typewriter 
script_plugin_state
\family default 
 é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PyObject*
\family default 
.
 O objeto retornado pela função de inicialização é o dicionário de elementos
 do módulo, obtido com 
\family typewriter 
PyModule_GetDict\SpecialChar \-
(module)
\family default 
.
 Neste dicionário, armazenamos o ponteiro do ambiente virtual como o atributo
 privado 
\family typewriter 
__env
\family default 
.
\layout Standard

De forma similar, em Ruby estados virtuais são implementados como classes
 que compartilham um mesmo estado global, já que Ruby também não permite
 múltiplos ambientes de execução isolados.
 Na função de inicialização 
\family typewriter 
script_plugin_init_ruby
\family default 
, uma classe com o nome do ambiente virtual é criada usando a função 
\family typewriter 
rb_define_class
\family default 
.
 O ponteiro do ambiente virtual é armazenado em uma constante da classe
 como um número.
 O 
\family typewriter 
VALUE
\family default 
 referente à classe é retornado como o 
\family typewriter 
script_plugin_state
\family default 
.
\layout LyX-Code


\size footnotesize 
VALUE state;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (inicialização do interpretador omitida) ...
 */
\layout LyX-Code


\size footnotesize 
\emph on 
/* class_name é o nome do ambiente virtual,
\layout LyX-Code


\size footnotesize 
\emph on 
   com a inicial convertida para maiúsculas,
\layout LyX-Code


\size footnotesize 
\emph on 
   respeitando a convenção de nomes de classe Ruby */
\layout LyX-Code


\size footnotesize 
state = rb_define_class(class_name, rb_cObject);
\layout LyX-Code


\size footnotesize 
/* Isto assume que void* cabe em um long */
\layout LyX-Code


\size footnotesize 
rb_const_set(state, rb_intern("@@LibScriptEnv"), INT2NUM((long)env));  
  
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
return (script_plugin_state) state;
\layout Subsection

Encerramento de estados
\begin_inset LatexCommand \label{sub:Encerramento-de-estados}

\end_inset 


\layout Standard

Como Lua e Perl representam estados de forma independente, o encerramento
 de um estado nestes plugins é simples: a estrutura da linguagem que encapsula
 o ambiente completo de execução é encerrada.
 A implementação da função de finalização no plugin Lua é a seguinte:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Em Lua, um state é um lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Encerra o estado.
 Não afeta outros ambientes.
 */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Perl, o processo, embora um tanto mais elaborado, é essencialmente similar:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas macros assumem que o ponteiro do interpretador
\layout LyX-Code


\size footnotesize 
\emph on 
      se chama my_perl.
 */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = (PerlInterpreter*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas operações operam sobre o 
\begin_inset Quotes eld
\end_inset 

estado atual
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      então a macro PERL_SET_CONTEXT deve ser usada para
\layout LyX-Code


\size footnotesize 
\emph on 
      alternar o interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Esta flag deve ser ativada para que a limpeza do
\layout LyX-Code


\size footnotesize 
\emph on 
      ambiente seja completa, o que é necessário quando
\layout LyX-Code


\size footnotesize 
\emph on 
      pode haver mais de um interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Encerramento do interpretador */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Em Python e Ruby, o plugin precisa manter o controle do número de estados
 ativos para desalocar a máquina virtual somente quando este chegar a zero.
 Além disso, tanto em Ruby como em Python não há recursos nas APIs (ou nas
 linguagens, de fato) para remover, respectivamente, classes ou módulos.
 Em Ruby, poderíamos atribuir 
\family typewriter 
nil
\family default 
 à constante que representa a classe que descreve o ambiente virtual, mas
 depois disso não é possível definir uma nova classe em seu lugar: tanto
 
\family typewriter 
rb_define_class
\family default 
 via C como 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 via Ruby geram um erro indicando que o valor já foi definido com outro
 tipo.
 Como Ruby possui classes abertas, uma construção 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 para um 
\emph on 
<Nome>
\emph default 
 já existente é entendida como a continuação da descrição da classe, e não
 como a redefinição de 
\emph on 
<Nome>
\emph default 
.
 Python, por sua vez, não disponibiliza recursos na API para a descarga
 de módulos, mas permite atribuir 
\family typewriter 
None
\family default 
 à global referente ao módulo.
 O módulo pode ser importado novamente, mas a mesma instância dele, armazenada
 internamente por Python, será retornada.
 A seguinte sessão interativa de linha de comando permite observar este
 comportamento, que ocorre tanto diretamente em Python como via a API de
 C:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, as estruturas de dados referentes aos estados LibScript não são encerrado
s nos plugins Python e Ruby.
 Esta é a implementação da rotina de encerramento no plugin Ruby:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrementa o contador de estados, uma variável global 
\emph default 
static
\emph on 
 do plugin.
 */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Finaliza o interpretador se este for o último estado.
 */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A implementação no plugin Python é basicamente igual:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Passagem de parâmetros
\begin_inset LatexCommand \label{sub:Passagem-de-parâmetros}

\end_inset 


\layout Standard

A transferência de dados entre a biblioteca principal e os plugins é concentrada
 em duas operações: uma para passar o conteúdo do buffer de parâmetros de
 LibScript para o espaço de dados da máquina virtual e outra para realizar
 a operação inversa.
 A primeira é usada na passagem de parâmetros de entrada quando funções
 da linguagem de script são chamadas por C e para a obtenção dos valores
 de retorno quando a linguagem de script faz chamadas que são tratadas C.
 A segunda operação, de forma complementar, é usada para os valores de retorno
 quando C chama a linguagem de script e para os parâmetros de entrada quando
 uma chamada feita pela linguagem de script é tratada por código C.
\layout Standard

Na implementação do plugin LibScript-Lua, a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 converte o conteúdo da pilha de Lua para o buffer de parâmetros de LibScript.
 A função do plugin responsável por invocar funções Lua a partir de C, 
\family typewriter 
script_plugin_call_lua
\family default 
, usa a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 para armazenar no buffer LibScript os valores de retorno da função Lua
 invocada, já que estes são retornados na pilha virtual.
 Quando o código Lua chama funções implementadas em C ou em outro plugin,
 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 é usada para converter os parâmetros de entrada da função, também recebidos
 na pilha virtual.
 A seguir, vemos a implementação desta função:
\layout LyX-Code


\size footnotesize 
static void script_lua_stack_to_buffer(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int nargs; int i; 
\layout LyX-Code


\size footnotesize 
   nargs = lua_gettop(L);    
\emph on 
/* Número de elementos na pilha de Lua */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env); 
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 1; i <= nargs; i++) {
\layout LyX-Code


\size footnotesize 
      
\emph on 
/* Verifica o tipo Lua do elemento na posição i da pilha */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, converte o elemento e o armazena no buffer */
\layout LyX-Code


\size footnotesize 
      switch(lua_type(L, i)) { 
\layout LyX-Code


\size footnotesize 
      case LUA_TNUMBER:
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, lua_tonumber(L, i)); break; 
\layout LyX-Code


\size footnotesize 
      case LUA_TSTRING:
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i-1, lua_tostring(L, i)); break;
\layout LyX-Code


\size footnotesize 
      case LUA_TBOOLEAN:
\layout LyX-Code


\size footnotesize 
         script_put_bool(env, i-1, lua_toboolean(L, i)); break;
\layout LyX-Code


\size footnotesize 
      default:
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Tipos não tratados são substituídos por zero.
 */
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, 0);
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumimos em LibScript strings no formato de C: a função 
\family typewriter 
script_put_string
\family default 
 copia a string passada até o primeiro 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Assim, ao obter strings de linguagens que permitem conteúdo arbitrário,
 estas serão truncadas caso contenham 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Por isso, no plugin Lua usamos diretamente a função 
\family typewriter 
lua_tostring
\family default 
, e não a função mais geral 
\family typewriter 
lua_tolstring
\family default 
 (que retorna também o tamanho do buffer).
\layout Standard

Os valores de tipos desconhecidos são substituídos pelo valor zero, o que
 mantém a posição dos demais valores na lista de argumentos.
 Optamos por não sinalizar erro nesta situação para evitar aqui a geração
 de exceções, o que complicaria a exposição.
 A captura e propagação de erros serão vistas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Standard

A segunda função de transferência de dados de LibScript-Lua, 
\family typewriter 
script_lua_buffer_to_stack
\family default 
, obtém os valores do buffer LibScript e os insere na pilha virtual de Lua.
 Esta função é usada para passar os parâmetros de entrada para Lua em 
\family typewriter 
script_plugin_call_lua
\family default 
 e para passar para Lua os valores obtidos pelo retorno da função 
\family typewriter 
script_call
\family default 
, que é invocada internamente pelo plugin quando Lua invoca uma função C.
\layout LyX-Code


\size footnotesize 
static int script_lua_buffer_to_stack(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int i; char* s;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env); 
\emph on 
/* Número de elementos no buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Verifica o tipo do elemento na posição i do buffer */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, o obtém e o insere na pilha de Lua */
\layout LyX-Code


\size footnotesize 
      type = script_get_type(env, i);
\layout LyX-Code


\size footnotesize 
      switch (type) {
\layout LyX-Code


\size footnotesize 
      case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
         lua_pushnumber(L, script_get_double(env, i)); break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
         s = script_get_string(env, i); 
\emph on 
/* A string pertence ao chamador.
 */
\layout LyX-Code


\size footnotesize 
         lua_pushstring(L, s);
\layout LyX-Code


\size footnotesize 
         free(s); 
\emph on 
/* Libera a string, já que Lua armazena sua própria cópia.
 */
\layout LyX-Code


\size footnotesize 
         break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
         lua_pushboolean(L, script_get_bool(env, i)); break;
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return len;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript-Python, não foi possível concentrar as operações de transferência
 de dados em apenas duas funções.
 Cada operação teve que ser dividida em duas partes.
 A conversão de dados recebidos de Python para o buffer de LibScript foi
 divida nas funções 
\family typewriter 
script_python_put_object
\family default 
 e 
\family typewriter 
script_python_tuple_to_buffer
\family default 
.
 A primeira função converte um único valor Python e o insere na posição
 solicitada no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_put_object(script_env* env, int i, PyObject* o)
 {
\layout LyX-Code


\size footnotesize 
   if (PyString_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, PyString_AS_STRING(o));
\layout LyX-Code


\size footnotesize 
   else if (PyInt_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, PyInt_AS_LONG(o));
\layout LyX-Code


\size footnotesize 
   else if (PyLong_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyLong_AsDouble(o));
\layout LyX-Code


\size footnotesize 
   else if (PyFloat_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyFloat_AS_DOUBLE(o));
\layout LyX-Code


\size footnotesize 
   else if (PyBool_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, o == Py_True ? 1 : 0);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É importante notar que os tipos Python 
\family typewriter 
PyInt
\family default 
 e 
\family typewriter 
PyLong
\family default 
 não correspondem aos tipos C 
\family typewriter 
int
\family default 
 e 
\family typewriter 
long
\family default 
: 
\family typewriter 
PyInt
\family default 
 é o tipo inteiro correspondente ao tamanho da palavra da máquina (análogo
 a 
\family typewriter 
int
\family default 
), mas 
\family typewriter 
PyLong
\family default 
 é um inteiro de precisão arbitrária.
 Em LibScript, representamos 
\family typewriter 
PyLong
\family default 
s como 
\family typewriter 
double
\family default 
s.
 A API de LibScript oferece a função 
\family typewriter 
script_put_int
\family default 
 como conveniência, mas internamente, como ocorre por exemplo em Lua, todos
 os números são armazenados como 
\family typewriter 
double
\family default 
s.
\layout Standard

A segunda função, 
\family typewriter 
script_python_tuple_to_buffer
\family default 
, insere os elementos de uma tupla no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_tuple_to_buffer(script_env* env, PyObject* tuple)
 {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = PyTuple_GET_SIZE(tuple); 
\emph on 
/* Número de elementos da tupla */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);          
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = PyTuple_GET_ITEM(tuple, i); 
\emph on 
/* Obtém elemento da tupla */
\layout LyX-Code


\size footnotesize 
      script_python_put_object(env, i, o);      
\emph on 
/* Insere-o no buffer.
 */
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A operação inversa, de transferência de dados do buffer LibScript para Python,
 também é implementada em duas funções, uma tratando objetos individualmente
 e outra tratando tuplas.
 A função 
\family typewriter 
script_get_object
\family default 
 converte um elemento do buffer para um 
\family typewriter 
PyObject
\family default 
 equivalente:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_get_object(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   PyObject* ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return PyFloat_FromDouble(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      PyObject* ret = PyString_FromString(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return PyBool_FromLong(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
script_python_buffer_to_tuple
\family default 
 gera uma tupla contendo todos os elementos do buffer LibScript:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_buffer_to_tuple(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   PyObject* ret = PyTuple_New(len);
\layout LyX-Code


\size footnotesize 
   for(i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = script_python_get_object(env, i);
\layout LyX-Code


\size footnotesize 
      PyTuple_SetItem(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, estes dois pares de funções realizam funções equivalentes às que
 
\family typewriter 
script_lua_\SpecialChar \-
stack_to_buffer
\family default 
 e 
\family typewriter 
script_lua_buffer_to_stack
\family default 
 exercem no plugin Lua.
 Elas foram separadas em duas partes em função do modelo de retorno de valores
 em funções Python: no caso de múltiplos valores de retorno, eles são retornados
 como uma tupla; para valores simples, eles são passados diretamente.
 Isto é evidenciado no seguinte trecho da função 
\family typewriter 
script_plugin_call_python
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject *ret, *args;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
args = script_python_buffer_to_tuple(env);  
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
ret = PyEval_CallObject(func, args); 
\emph on 
       /* Chama uma função Python */
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
if (ret == Py_None)                         
\emph on 
/* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);                
\emph on 
/* Apenas zere o buffer LibScript */
\layout LyX-Code


\size footnotesize 
else if (PyTuple_Check(ret))                
\emph on 
/* Se retornou uma tupla */
\layout LyX-Code


\size footnotesize 
   script_python_tuple_to_buffer(env, ret); 
\emph on 
/* Insira seus elementos no buffer */
\layout LyX-Code


\size footnotesize 
else                                        
\emph on 
/* Se retornou outro tipo de objeto */
\layout LyX-Code


\size footnotesize 
   script_python_put_object(env, 0, ret);   
\emph on 
/* Insira-o como único elemento */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

No tratador de chamadas a funções externas do plugin, a comunicação no sentido
 inverso emprega uma lógica similar:
\layout LyX-Code


\size footnotesize 
script_python_tuple_to_buffer(env, args);    
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
err = script_call(env, fn_name);             
\emph on 
/* Chama um função via LibScript */
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
switch(script_buffer_len(env)) {
\layout LyX-Code


\size footnotesize 
case 0:                                      
\emph on 
 /* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   Py_RETURN_NONE;                           
\emph on 
 /* Retorne o valor Python 'None' */
\layout LyX-Code


\size footnotesize 
case 1:                                      
\emph on 
 /* Se retornou um único valor */
\layout LyX-Code


\size footnotesize 
   return script_python_get_object(env, 0);  
\emph on 
 /* Converta e retorne-o */
\layout LyX-Code


\size footnotesize 
default:                                      
\emph on 
/* Se retornou mais de um valor */
\layout LyX-Code


\size footnotesize 
   return script_python_buffer_to_tuple(env); 
\emph on 
/* Retorne-os em uma tupla */
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim como em Python, funções em Ruby retornam múltiplos valores encapsulando-os
 em um tipo agregado.
 Desta forma, as operações de transferências de dados de LibScript-Ruby
 também são divididas em pares de funções, uma convertendo um valor do buffer,
 e outra operando sobre um array Ruby.
 A função análoga a 
\family typewriter 
script_python_put_object
\family default 
 é 
\family typewriter 
script_ruby_put_value
\family default 
:
\layout LyX-Code


\size footnotesize 
static void script_ruby_put_value(script_env* env, int i, VALUE arg) {
\layout LyX-Code


\size footnotesize 
   switch (TYPE(arg)) {
\layout LyX-Code


\size footnotesize 
   case T_FLOAT:
\layout LyX-Code


\size footnotesize 
   case T_FIXNUM:
\layout LyX-Code


\size footnotesize 
   case T_BIGNUM:
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, NUM2DBL(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_STRING:
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, StringValuePtr(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_TRUE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 1); break;
\layout LyX-Code


\size footnotesize 
   case T_FALSE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 0); break;
\layout LyX-Code


\size footnotesize 
   default:
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Aqui, alguns problemas da API de Ruby são aparentes.
 Além da inconsistência na nomenclatura das funções de conversão de objetos,
 o significado do valor retornado pela macro 
\family typewriter 
TYPE
\family default 
 só pode ser compreendido através da representação interna de 
\family typewriter 
VALUE
\family default 
s na implementação de Ruby, e não através da hierarquia de tipos dos objetos
 da linguagem.
 As classes que têm tratamento especial na estrutura interna de 
\family typewriter 
VALUE
\family default 
s possuem constantes associadas a si, como 
\family typewriter 
T_FLOAT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
; as demais são identificados apenas como 
\family typewriter 
T_OBJECT
\family default 
s.
 O uso de 
\family typewriter 
T_TRUE
\family default 
 e 
\family typewriter 
T_FALSE
\family default 
 pode dar a entender que alguns valores específicos também retornam resultados
 especiais para 
\family typewriter 
TYPE
\family default 
.
 De fato, estes valores são definidos como 
\family typewriter 
VALUE
\family default 
s que não correspondem a índices da heap de objetos de Ruby e são tratados
 de forma especial na implementação.
 Do ponto de vista de código Ruby, entretanto, esta classificação dos valores
 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em tipos separados na API C é justificada definindo-os como 
\emph on 
singletons
\emph default 
 das classes 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
, abordagem provavelmente influenciada por Smalltalk.
 Porém, diferentemente de Smalltalk, onde 
\family typewriter 
True
\family default 
 e 
\family typewriter 
False
\family default 
 são subclasses de 
\family typewriter 
Boolean
\family default 
, em Ruby 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
 são subclasses diretas de 
\family typewriter 
Object
\family default 
.
 Isto traz a inconveniência de que verificar se um tipo é um valor booleano
 incorre sempre em dois testes.
\layout Standard

Assim como LibScript-Python tem uma função para armazenar no buffer os elementos
 de uma tupla, LibScript-Ruby possui uma função para armazenar os elementos
 de um array:
\layout LyX-Code


\size footnotesize 
static void script_ruby_array_to_buffer(script_env* env, VALUE array) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = RARRAY(array)->len;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = rb_ary_entry(array, i);
\layout LyX-Code


\size footnotesize 
      script_ruby_put_value(env, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Ruby não possui uma função na API C para retornar o tamanho de um array;
 ao invés disso, a estrutura interna do 
\family typewriter 
VALUE
\family default 
 é exposta através da macro 
\family typewriter 
RARRAY
\family default 
 (que apenas encapsula um cast).
 
\layout Standard

As operações para conversão de valores do buffer LibScript para Ruby também
 são similares às implementadas no plugin Python.
 Novamente, onde em Python há uma função para manipulação de tuplas, temos
 em Ruby uma função que opera sobre arrays:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_get_value(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   VALUE ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return rb_float_new(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      ret = rb_str_new2(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return script_get_bool(env, i) ? Qtrue : Qfalse;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\newline 
static VALUE script_ruby_buffer_to_array(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   VALUE ret = rb_ary_new2(len);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = script_ruby_get_value(env, i);
\layout LyX-Code


\size footnotesize 
      rb_ary_store(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

De forma similar ao plugin Python, a implementação da chamada de funções
 Ruby a partir de LibScript usa a função 
\family typewriter 
script_ruby_buffer_to_array
\family default 
 para converter os parâmetros de entrada e as funções 
\family typewriter 
script_ruby_put_value
\family default 
 ou 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 para converter o valor de retorno, dependendo se a função retornou um ou
 mais valores (ou mais precisamente, se a função retornou ou não um array).
 Em chamadas de funções LibScript a partir de Ruby, os parâmetros de entrada
 são convertidos com 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 e os valores de retorno com 
\family typewriter 
script_ruby_get_value
\family default 
 ou 
\family typewriter 
script_ruby_buffer_to_array
\family default 
.
\layout Standard

No plugin Perl, temos três funções: a transferência de dados da pilha para
 o buffer LibScript pôde ser implementada em uma única função como em Lua,
 mas a transferência no sentido oposto teve que ser dividida em duas funções,
 como em Python e Ruby.
 Esta assimetria vem do fato de que o tratamento de valores de retorno é
 encapsulado pelo pré-processador XS através da variável especial 
\family typewriter 
RETVAL
\family default 
; assim, nesta situação não podemos manipular a pilha diretamente, mas apenas
 passar 
\family typewriter 
SV
\family default 
s como valores de saída.
 
\layout Standard

A transferência de dados da pilha de Perl para o buffer LibScript é razoavelment
e simples:
\layout LyX-Code


\size footnotesize 
void script_perl_stack_to_buffer(pTHX_ int ax, script_env* env,
\layout LyX-Code


\size footnotesize 
                                 int count, int offset) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < count; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém um ponteiro para o SV */
\layout LyX-Code


\size footnotesize 
      SV* o = ST(offset+i);
\layout LyX-Code


\size footnotesize 
      if (SvIOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, SvIV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvNOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i, SvNV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvPOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i, SvPV_nolen(o));
\layout LyX-Code


\size footnotesize 
      else
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os parâmetros de entrada desta função merecem comentário.
 Inicialmente, temos a macro 
\family typewriter 
pTHX_
\family default 
.
 Esta macro foi adicionada à API quando Perl passou a permitir múltiplos
 interpretadores simultâneos por processo: as funções da API foram transformadas
 em macros que encapsulam a passagem deste primeiro parâmetro.
 Por exemplo, a função 
\family typewriter 
eval_sv
\family default 
 pode ser chamada como 
\family typewriter 
Perl_eval_sv
\family default 
, passando a macro 
\family typewriter 
aTHX_
\family default 
 como parâmetro inicial.
 De maneira geral o uso destas macros fica implícito, mas ao escrever funções
 que usam a API de Perl torna-se necessário usar a macro 
\family typewriter 
pTHX_
\family default 
 na declaração
\begin_inset Foot
collapsed true

\layout Standard

A macro 
\family typewriter 
pTHX_
\family default 
 é usada sem a vírgula separando-a do argumento seguinte.
 Quando ela é o único argumento, deve-se usar 
\family typewriter 
pTHX
\family default 
.
\end_inset 

, para propagar a informação de estado do interpretador através de chamadas
 de função, e 
\family typewriter 
aTHX_
\family default 
 nas chamadas.
\layout Standard

Outro sintoma de que a API de Perl foi projetada mais para uso interno do
 pré-processador XS do que para manipulação direta transparece no segundo
 argumento, 
\family typewriter 
ax
\family default 
.
 Algumas macros assumem a existência deste valor, que não é propagado via
 
\family typewriter 
pTHX_
\family default 
, mas é declarado implicitamente quando funções são encapsuladas via XS.
 A API parece assumir que uma função XS não irá invocar outra função C que
 também use a API.
 Tivemos então que propagar esta variável (que é citada na documentação,
 mas apenas como 
\emph on 
"the 'ax' variable"\SpecialChar ~

\emph default 

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

, sem explicações do seu propósito).
\layout Standard

Os outros dois parâmetros, 
\family typewriter 
count
\family default 
 e 
\family typewriter 
offset
\family default 
, são necessários devido às diferentes formas que as informações que eles
 representam são obtidas nos dois contextos onde esta função é usada.
 Nos outros plugins, podemos obter a quantidade de elementos de entrada
 de forma uniforme (consultando o número de elementos da tupla em Python,
 por exemplo).
 Em Perl, nas duas situações onde a função é chamada, o número de elementos
 a serem lidos da pilha deve ser obtido de formas diferentes, e por isso
 o passamos como parâmetro 
\family typewriter 
count
\family default 
.
 Na rotina chamadora de funções LibScript, implementada no arquivo XS, o
 tamanho da pilha é obtido através de uma variável especial, 
\family typewriter 
items
\family default 
.
 Já na chamada de funções Perl, o valor de 
\family typewriter 
count
\family default 
 é obtido como retorno da função que realiza a invocação, 
\family typewriter 
Perl_call_pv
\family default 
.
 
\layout Standard

A posição inicial da pilha a partir da qual devemos obter os elementos (
\family typewriter 
offset
\family default 
) também varia.
 Dentro da função XS, os parâmetros de entrada começam a partir da posição
 2, pois LibScript passa o ponteiro do ambiente e o nome da função nos dois
 primeiros argumentos.
 Na chamada de funções Perl, o valor de 
\family typewriter 
offset
\family default 
 é zero pois, como visto no protocolo de chamada de funções Perl discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

, a base da pilha é ajustada após a chamada da função pela macro 
\family typewriter 
SPAGAIN
\family default 
.
 
\layout Standard

A conversão de valores do buffer LibScript para a pilha de Perl é dada em
 duas funções, uma que gera um único SV e outra que empilha todos os elementos:
\layout LyX-Code


\size footnotesize 
SV* script_perl_get_sv(pTHX_ script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE: return newSVnv(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* 0 indica que o tamanho da string deve ser calculado por Perl.
 */
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING: return newSVpv(script_get_string(env, i), 0);
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL: return newSViv(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
  
\newline 
SV** script_perl_buffer_to_stack(pTHX_ SV** sp, script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      XPUSHs(sv_2mortal(script_perl_get_sv(aTHX_ env, i)));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return sp;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Novamente, uma variável criada internamente por Perl teve que ser propagada
 explicitamente: 
\family typewriter 
sp
\family default 
, o 
\emph on 
stack pointer
\emph default 
.
 Esta variável é referenciada internamente pela macro 
\family typewriter 
xPUSHs
\family default 
.
 Além disso, como 
\family typewriter 
XPUSHs
\family default 
 pode redimensionar a pilha, precisamos retornar o valor atualizado de 
\family typewriter 
sp
\family default 
 de volta para o chamador.
 No mais, a geração de 
\family typewriter 
SV
\family default 
s, o registro destes como variáveis mortais e o seu empilhamento ocorre
 da forma usual, já apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
\layout Standard

Assim como nos demais plugins, a passagem de parâmetros de entrada em LibScript-
Perl, tanto para a chamada de funções Perl como de funções via LibScript,
 é feita chamando a função de conversão que opera sobre o buffer como um
 todo: na chamada de funções Perl usamos 
\family typewriter 
script_perl_buffer_to_stack
\family default 
 e na de funções via LibScript, 
\family typewriter 
script_perl_stack_to_buffer
\family default 
.
 Para tratar os valores de retorno de funções Perl, pudemos utilizar diretamente
 a função 
\family typewriter 
script_perl_stack_to_buffer
\family default 
, de forma similar à realizada em LibScript-Lua.
 Para o retorno de funções chamadas via LibScript, porém, precisamos lidar
 com a variável especial 
\family typewriter 
RETVAL
\family default 
 de XS e com os diferentes contextos de chamada de Perl.
 O trecho abaixo ilustra o tratamento de valores de retorno neste caso:
\layout LyX-Code


\size footnotesize 
err = script_call(env, function_name);
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (tratamento de erro omitido) ...
 */
\layout LyX-Code


\size footnotesize 
switch (GIMME_V) {
\layout LyX-Code


\size footnotesize 
case G_SCALAR:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna o primeiro item do buffer */
\layout LyX-Code


\size footnotesize 
   RETVAL = script_perl_get_sv(aTHX_ env, 0);
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_ARRAY:
\layout LyX-Code


\size footnotesize 
   len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um array */
\layout LyX-Code


\size footnotesize 
   RETVAL = (SV*)newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Arrays retornados devem ser marcados como mortais */
\layout LyX-Code


\size footnotesize 
   sv_2mortal((SV*)RETVAL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Insere o conteúdo do buffer no array */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++)
\layout LyX-Code


\size footnotesize 
      av_push((AV*)RETVAL, script_perl_get_sv(aTHX_ env, i));
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_VOID:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O valor de retorno é descartado em contextos void.
 */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retornamos então a constante Perl undef.
 */
\layout LyX-Code


\size footnotesize 
   RETVAL = &PL_sv_undef;
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
}
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Chamada de funções
\layout Standard

Nos plugins de LibScript, funções implementadas externamente (em C ou outros
 plugins) são localizadas somente no momento em que elas são chamadas.
 O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória no ambiente de execução da linguagem de script (ao evitar a declaração
 de funções que não serão utilizadas), é permitir a localização de funções
 declaradas após a inicialização do ambiente.
 Para permitir esta resolução de funções de forma dinâmica, é preciso capturar
 o acesso a elementos inexistentes na estrutura que descreve o ambiente
 virtual no plugin e encaminhar a chamada à biblioteca principal via 
\family typewriter 
script_call
\family default 
.
 Ao comparar as abordagens empregadas em cada plugin para obter tal comportament
o, podemos avaliar alguns recursos de meta-programação oferecidos por cada
 linguagem e a sua disponibilidade através das suas APIs.
\layout Standard

Como vimos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, em Lua, durante a inicialização do plugin, é criada uma tabela armazenada
 em uma variável global com o nome do ambiente.
 Funções são inseridas dinamicamente nesta tabela através da metatabela
 associada a ela logo após a sua criação em 
\family typewriter 
script_plugin_init_lua
\family default 
.
 O campo 
\family typewriter 
__index
\family default 
 da metatabela aponta para uma função\SpecialChar ~
C interna ao plugin, 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, que é então invocada sempre que um elemento inexistente for solicitado
 na tabela.
 A função 
\family typewriter 
script_lua_make_caller
\family default 
 cria uma 
\emph on 
closure
\emph default 
\SpecialChar ~
C, que consiste de outra função\SpecialChar ~
C interna ao plugin (
\family typewriter 
script_lua_caller
\family default 
) e o nome da função solicitada.
 Esta closure é associada à entrada da tabela do ambiente.
 Assim, chamadas a funções implementadas externamente serão resolvidas por
 
\family typewriter 
script_lua_caller
\family default 
, que as passará adiante para 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Python, ao chamar uma função no módulo do ambiente virtual, o
 
\emph on 
callback
\emph default 
 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_python_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 cria um objeto do tipo 
\family typewriter 
script_python_object
\family default 
, e o retorna como resultado de 
\family typewriter 
__getattro
\family default 
.
 Este tipo de dado é declarado no plugin como uma classe Python, cujas instância
s contêm um ponteiro para o ambiente virtual e uma string C com o nome da
 função que eles representam.
 Estes objetos possuem o seu 
\emph on 
callback
\emph default 
 
\family typewriter 
__call
\family default 
 definido como 
\family typewriter 
script_python_caller
\family default 
, uma função que, assim como 
\family typewriter 
script_lua_caller
\family default 
, converte os parâmetros recebidos para o buffer de LibScript, invoca 
\family typewriter 
script_call
\family default 
 e converte os valores de retorno de volta a Python.
 Assim, objetos deste tipo são 
\emph on 
functors
\emph default 
, e se comportam de forma similar à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
\layout Standard

A resolução de funções sob demanda em Ruby é implementada utilizando o método
 
\family typewriter 
method_missing
\family default 
, que é um fallback definido pela linguagem, chamado sempre que um método
 inexistente é invocado em uma classe.
 Diferentemente de 
\family typewriter 
__getattro
\family default 
 em Python e 
\family typewriter 
__index
\family default 
 em Lua, que são tratadores de acesso a atributos e portanto precisam retornar
 um objeto que é chamado em um passo seguinte, o método 
\family typewriter 
method_missing
\family default 
 trata chamadas diretamente.
 Assim, ao ser invocado, 
\family typewriter 
method_missing
\family default 
 recebe o nome do método solicitado e os parâmetros passados e os encaminha
 para a função 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Perl, como em Lua e Python, também há uma função C responsável
 por realizar a conversão de parâmetros e valores de retorno a invocação
 de 
\family typewriter 
script_call
\family default 
.
 Esta função, 
\family typewriter 
script_perl_caller
\family default 
, para que possa ser exposta ao interpretador Perl, é implementada em um
 módulo XS.
 Uma vez carregado o módulo, a função é visível em Perl como a função 
\family typewriter 
LibScript::caller
\family default 
.
 A resolução dinâmica de funções do pacote Perl que representa o ambiente
 virtual é feita usando a função 
\family typewriter 
AUTOLOAD
\family default 
 de Perl, que se comporta como 
\family typewriter 
method_missing
\family default 
 em Ruby, capturando chamadas a funções inexistentes.
 Na função de inicialização do plugin, código Perl é executado para carregar
 o módulo de extensão, inicializar o pacote do ambiente e inserir nele uma
 função 
\family typewriter 
AUTOLOAD
\family default 
 que chamará 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
   "bootstrap LibScript;"   
\emph on 
/* Inicializa o módulo de extensão */
\layout LyX-Code


\size footnotesize 
   "package %s;" 
\emph on 
           /* Declara o pacote do ambiente */
\layout LyX-Code


\size footnotesize 
   "$LibScript::env = %p;"  
\emph on 
/* Armazena o ponteiro do ambiente em Perl */
\layout LyX-Code


\size footnotesize 
   "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
      "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Extrai o nome do método do nome qualificado 
\begin_inset Quotes eld
\end_inset 

pacote::método
\begin_inset Quotes erd
\end_inset 

 */
\layout LyX-Code


\size footnotesize 
      "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Invoca caller passando o endereço do ambiente, */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o nome do método, e o array de argumentos */
\layout LyX-Code


\size footnotesize 
\emph on 
      
\emph default 
"LibScript::caller(%p, $AUTOLOAD, @_);"  
\layout LyX-Code


\size footnotesize 
   "}",
\layout LyX-Code


\size footnotesize 
   state->package, env, env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Avalia a string de código;
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indica que erros devem ser sinalizados.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Subsection

Captura de erros
\begin_inset LatexCommand \label{sub:Captura-de-erros}

\end_inset 


\layout Standard

Os plugins devem capturar a ocorrência de erros na execução de strings de
 código e em chamadas de função.
 Em Lua, ambas as operações são realizadas usando a função 
\family typewriter 
lua_pcall
\family default 
, cujo valor de retorno indica a ocorrência de erros.
 No caso de erros, a mensagem de erro é obtida no topo da pilha virtual
 de Lua e propagada para a biblioteca principal usando 
\family typewriter 
script_set_error_message
\family default 
.
 No caso da execução de strings de código, erros de compilação são detectados
 através do valor de retorno da função 
\family typewriter 
luaL_loadstring
\family default 
, que carrega o código a ser executado por 
\family typewriter 
lua_pcall
\family default 
.
\layout Standard

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno das
 funções de execução de strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, e de chamada de funções, 
\family typewriter 
PyEval_CallObject
\family default 
.
 No caso de erros, chamamos a função 
\family typewriter 
PyErr_Occurred
\family default 
, que retorna um objeto Python representando a exceção.
 A mensagem de erro é obtida convertendo este objeto para uma string Python
 usando 
\family typewriter 
PyObject_Str
\family default 
, e finalmente para uma string C com 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

Em Perl, erros são sinalizados na variável especial 
\family typewriter 
$@
\family default 
, cujo conteúdo pode ser verificado através da API de C com a macro 
\family typewriter 
ERRSV
\family default 
.
 O teste para ocorrência de erros é 
\family typewriter 
SvTRUE(ERRSV)
\family default 
, e a mensagem de erro pode ser obtida convertendo esta variável para uma
 string C com a macro 
\family typewriter 
SvPV
\family default 
.
\layout Standard

Ruby disponibiliza uma função para execução de strings de código, 
\family typewriter 
rb_eval_string
\family default 
, e uma versão desta que captura erros e sinaliza a sua ocorrência através
 do valor de retorno, 
\family typewriter 
rb_eval_string_protect
\family default 
.
 Entretanto, para chamadas de método, não há uma versão protegida da função
 
\family typewriter 
rb_funcall
\family default 
.
 A função disponibilizada pela API para proteger chamadas, 
\family typewriter 
rb_protect
\family default 
, não recebe como parâmetro um método Ruby, mas sim uma função\SpecialChar ~
C.
 Para chamar métodos Ruby de forma protegida, precisamos escrever uma função
 C que encapsula a chamada:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_pcall(VALUE args) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai nome do método do array de argumentos */
\layout LyX-Code


\size footnotesize 
   ID fn_id = SYM2ID(rb_ary_pop(args)); 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai a classe do array de argumentos */
\layout LyX-Code


\size footnotesize 
   VALUE klass = rb_ary_pop(args);
\layout LyX-Code


\size footnotesize 
   return rb_apply(klass, fn_id, args);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

e então invocá-la usando 
\family typewriter 
rb_protect
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere a classe no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, klass);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere o nome do método no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, ID2SYM(rb_intern(fn)));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Chama a função wrapper */
\layout LyX-Code


\size footnotesize 
ret = rb_protect(script_ruby_pcall, args, &error); 
\layout LyX-Code


\size footnotesize 
if (error) {
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   script_set_error_message(env, StringValuePtr(ruby_errinfo));
\layout LyX-Code


\size footnotesize 
   ruby_errinfo = Qnil;
\layout LyX-Code


\size footnotesize 
   return SCRIPT_ERRLANGRUN;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como a função 
\family typewriter 
rb_protect
\family default 
 passa apenas um 
\family typewriter 
VALUE
\family default 
 para a função C, precisamos armazenar a classe, o identificador do método
 e os parâmetros de entrada do método Ruby a ser invocado em um array Ruby.
 A ocorrência de erros é sinalizada em uma variável passada no terceiro
 parâmetro de 
\family typewriter 
rb_protect
\family default 
, e a mensagem de erro é obtida no 
\family typewriter 
VALUE
\family default 
 global 
\family typewriter 
ruby_errinfo
\family default 
.
\layout Section

Conclusões
\layout Standard

O estudo de caso apresentado aqui ilustrou, através da implementação dos
 plugins, o processo de embutir quatro linguagens de script realizando interface
 com uma mesma API C.
 Diversos aspectos da interação entre C e as linguagens de script foram
 abordados, contemplando inicialização e encerramento do ambiente de execução,
 passagem de dados e chamadas de função nos dois sentidos e a sinalização
 de erros.
 A partir disto, podemos fazer algumas observações sobre a adequabilidade
 destas linguagens como ambientes embutidos em aplicações.
\layout Standard

Em muitas aplicações é importante que haja isolamento entre os scripts executado
s, como por exemplo, em scripts de diferentes clientes rodando em um servidor
 web.
 Como vimos, Lua e Perl permitem disparar múltiplos ambientes de execução,
 o que garante isolamento.
 Já Python e Ruby permitem apenas um estado, reduzindo sua aplicabilidade
 para cenários onde os scripts devem executar isolados uns dos outros
\begin_inset Foot
collapsed true

\layout Standard

Em Python é possível alternar a tabela de globais durante a execução de
 diferentes threads, o que oferece uma alternativa, um tanto mais trabalhosa,
 para obter isolamento.
 Ainda assim, o estado global compartilhado por módulos de extensão é o
 mesmo.
 
\end_inset 

.
 Estas duas linguagens trazem ainda outro problema: em alguns casos não
 é possível trazer o seu espaço de dados de volta ao estado original durante
 a execução de uma aplicação.
 Em Python, módulos importados não podem ser descarregados.
 Em Ruby, uma classe não pode ser redefinida (somente estendida) e 
\family typewriter 
ID
\family default 
s não são coletados.
\layout Standard

Na implementação do plugin de Perl fica evidente que a sua API não foi projetada
 visando embutir o interpretador em aplicações.
 Além de exigir o desenvolvimento de um módulo de extensão para que o código
 Perl possa ter acesso a funções C, observamos aqui que a sua API é incompleta
 no que diz respeito ao seu uso como linguagem embutida.
 Muitas macros foram desenvolvidas assumindo que seriam sempre invocadas
 a partir de código escrito em arquivos XS, ou mesmo por código gerado pelo
 pré-processador XS.
 Isto é confirmado pela necessidade de passar parâmetros adicionais não-document
ados para que as macros funcionem, como pôde ser observado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

.
\layout Standard

Lua, por sua vez, mostrou-se apropriada como linguagem embutida, não compartilha
ndo das limitações aqui descritas sobre as outras linguagens.
 Além disso, ela possui uma API simples, que trata as construções da linguagem
 de forma completa e ortogonal, o que se deve tanto ao foco da implementação
 de Lua como linguagem embutida, quanto ao projeto minimalista da linguagem
 em si.
 Mesmo em exemplos pequenos como os apresentados aqui, que exercitam apenas
 uma parte pequena das APIs, podemos observar que aspectos onde as linguagens
 definem tratamentos especiais ou possuem menor uniformidade transparecem
 nas APIs para C.
 Tanto em Python como em Ruby, funções que retornam múltiplos valores geram
 conversões implícitas para tipos agregados (listas e arrays).
 De forma similar, múltiplos retornos são representados em Perl através
 de contextos do tipo array.
 Nos seus respectivos plugins LibScript, estas características tiveram que
 ser tratadas de forma especial.
 No plugin Lua, em contraste, o tratamento para um valor único de retorno
 é igual ao de valores múltiplos, assim como ocorre na linguagem.
 
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Conclusões
\layout Standard

A escolha de uma linguagem de script depende de uma série de fatores, varios
 deles relativos à linguagem em si, outros relativos à sua implementação.
 Quando lidamos com cenários de desenvolvimento multi-linguagem, um aspecto
 que não deve ser negligenciado é o projeto das interfaces entre as linguagens.
 Seja estendendo a linguagem de script através de código C, ou tornando
 uma aplicação C extensível através de uma linguagem de script, a API oferecida
 pela linguagem tem um papel fundamental, muitas vezes influenciando o projeto
 da aplicação.
\layout Standard

Este trabalho traçou um panorama dos problemas gerais enfrentados na interação
 entre código C e o ambiente de execução de uma linguagem de script.
 Apresentamos as formas como as APIs de cinco linguagens tratam estes problemas,
 apontando pontos positivos e negativos das diferentes abordagens utilizadas.
 Realizamos uma comparação prática do uso destas APIs através de um estudo
 de caso onde as linguagens de script foram embutidas em bibliotecas C exportand
o uma mesma interface.
 A implementação consiste de uma biblioteca genérica para scripting, chamada
 LibScript, e uma série de plugins que realizam a interface com as diferentes
 linguagens.
 Pudemos assim observar como elas tratam aspectos importantes relativos
 a linguagens embutidas, como a passagem de dados, chamadas de funções entre
 as duas linguagens, tratamento de erros e o isolamento dos ambientes de
 execução em aplicações.
\layout Standard

Embora os mesmos problemas gerais, como transferência de dados, registro
 e chamada de funções, sejam comuns aos diferentes cenários de uso de uma
 API de linguagem de script, aplicações embutindo uma máquina virtual tendem
 a demandar mais da API do que bibliotecas implementando módulos de extensão.
 Este ponto é ilustrado pelas dificuldades impostas pela API de Python tanto
 no acesso a variáveis como no registro de funções globais; e principalmente
 pela complexidade da API de chamada de funções de Perl.
\layout Standard

O fato de que a API de Python dificulta o uso de variáveis e funções globais,
 favorecendo o uso de módulos, pode ser justificado como uma forma de promover
 um modelo de programação mais estruturada.
 Isto é interessante para o uso da API no desenvolvimento de módulos de
 extensão, uma vez que o uso de variáveis e funções globais é extremamente
 prejudicial nestes casos, já que poluiria o espaço de nomes das aplicações
 Python.
 Já para o caso onde a linguagem é embutida para prover suporte à execução
 de scripts em uma aplicação C, a ausência de uma forma conveniente para
 definir funções globais no espaço de nomes dos scripts é questionável.
\layout Standard

A abordagem empregada por Perl, usando um pré-processador com o objetivo
 de gerar automaticamente o código para a conversão de dados na passagem
 de parâmetros e valores de retorno, se mostrou inadequada para o cenário
 envolvendo interpretadores embutidos.
 Embora o uso do pré-processador simplifique os casos simples de declaração
 de funções C, a falta de uma API bem definida para tratar a transferência
 de dados entre o interpretador Perl e o código C se faz perceber nos casos
 mais elaborados.
 Duas destas situações se fizeram presentes no estudo de caso: o recebimento
 de parâmetros 
\emph on 
varargs
\emph default 
 e a passagem de valores de retorno tratando múltiplos contextos de execução.
 Ambas exigiram manipulações de estruturas e construções de mais baixo nível,
 que o pré-processador tem por objetivo ocultar.
\layout Standard

Observações interessantes resultaram da comparação da API de Java com a
 das demais quatro linguagens de script, uma vez que, embora possua diversas
 características em comum com estas linguagens, Java não seja considerada
 uma linguagem de script.
 Enquanto a tipagem estática reduz bastante a necessidade de conversões
 de dados explícitas no código C para tipos primitivos da linguagem, na
 prática a verificação de tipos para objetos e a ligação de campos e métodos
 acontece de forma dinâmica, já que estes têm que ser realizados em tempo
 de execução pela JNI.
 Assim, no contexto da interação de uma máquina virtual com código C, as
 vantagens trazidas pela tipagem estática são reduzidas.
 Além disso, a resolução dinâmica de campos e métodos faz com que a manipulação
 de objetos via C tenha diferenças sutis de comportamento em relação ao
 que ocorre em código Java, o que pode ser uma fonte de erros do programador.
\layout Standard

Ao comparar as APIs, consideramos apenas as suas interfaces, fazendo uma
 análise qualitativa da usabilidade de cada uma da perspectiva do programador
 C, e não uma análise quantitativa das suas implementações.
 O custo de desempenho adicionado pelo código que realiza a ligação entre
 duas linguagens, por exemplo, não pode ser desprezado.
 Muitas decisões de projeto de uma API são influenciadas por requisitos
 da implementação como restrições de portabilidade ou desempenho.
 Por exemplo, o tratamento automático de controle de escopo de 
\family typewriter 
VALUE
\family default 
s em Ruby, varrendo a pilha de C, traz grande conveniência para o programador,
 mas reduz a portabilidade da implementação.
\layout Standard

Merece comentário também a disparidade entre as linguagens no que concerne
 à disponibilidade de documentação.
 Java, Python e Lua possuem extensa documentação, tanto para a linguagem
 como para as suas APIs para C.
 Para estas linguagens, pudemos basear largamente nosso estudo e a implementação
 dos exemplos para o estudo de caso na documentação fornecida.
 A documentação de Ruby relativa à sua API de C é mais escassa; em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 é coberta apenas parte da API pública.
 Precisamos fazer uso de funções não documentadas para tarefas fundamentais
 como liberar referências globais registradas via C.
 Durante o desenvolvimento do plugin Ruby no estudo de caso, consultamos
 freqüentemente o código-fonte de Ruby para compreender os aspectos que
 não são cobertos pela documentação do comportamento das suas funções públicas.
 A documentação da API de C de Perl também é incompleta, espalhada através
 de diversas 
\emph on 
man pages
\emph default 
 incluídas na sua distribuição e em certos casos desatualizada.
 Para compreender os diversos protocolos envolvidos no uso prático da API
 de Perl, precisamos recorrer ao código-fonte de aplicações que fazem uso
 dela.
\layout Standard

O equilíbrio entre simplicidade e conveniência é outro tema recorrente ao
 compararmos as APIs.
 A extensa API de Python, contendo 656 funções públicas, contrasta com as
 113 funções expostas pela API de Lua (79 na API 
\emph on 
core
\emph default 
, 34 na API auxiliar).
 Em diversas situações, funções na API de Python abreviam duas, três ou
 até mais chamadas, como no caso de funções poderosas como 
\family typewriter 
Py_BuildValue
\family default 
 e 
\family typewriter 
PyObject_CallFunction
\family default 
, tornando o código C sucinto e legível.
 A abordagem defendida por Lua é a de uma API minimalista, oferecendo mecanismos
 sobre os quais funcionalidades mais elaboradas possam ser construídas.
 De fato, em\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 é apresentada uma função C equivalente a 
\family typewriter 
PyObject_CallFunction
\family default 
 usando a API de Lua.
\layout Standard

Ruby exporta 530 funções em seu cabeçalho e Perl 1209, mas como apenas uma
 pequena fração destas é documentada, torna-se difícil avaliar o tamanho
 da 
\begin_inset Quotes eld
\end_inset 

API pública
\begin_inset Quotes erd
\end_inset 

 destas linguagens e quantas destas são apenas funções para uso interno
 expostas nos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

Algumas funções são marcadas como sendo de uso interno, mas a maioria não
 possui qualquer indicação.
\end_inset 

.
 Isto mostra também que a documentação não é relevante apenas enquanto material
 de apoio para o desenvolvimento, mas também indica o quão bem definida
 é uma API.
\layout Standard

A API de Java é bem documentada como a de Python e Lua, mas o número de
 funções exportadas não é um bom parâmetro para comparações com as demais
 APIs porque, em função dos tipos estaticamente definidos, muitas funções
 possuem uma variante para cada tipo primitivo.
 Java exporta sua API como uma estrutura contendo ponteiros para função;
 228 funções ao todo são exportadas nesta estrutura.
\layout Standard

Outro aspecto que pôde ser observado neste trabalho é que a consistência
 da API depende largamente da consistência da linguagem que ela expõe.
 Construções onde a linguagem tem pouca ortogonalidade, como o tratamento
 de blocos em Ruby ou as diferenças nos tratamentos de valores escalares
 e arrays em Perl, acabam por aumentar a complexidade da API da linguagem
 e demandam tratamento específico por parte do programador no código C.
\layout Standard

Como possibilidades de trabalhos futuros, este trabalho pode ser estendido
 através do estudo de outros aspectos de APIs de linguagens de script.
 Um foco possível é o impacto de desempenho de diferentes projetos de API
 em aplicações multi-linguagem.
 Outro é a relação entre o projeto de uma máquina virtual e o de sua respectiva
 API.
 Além disso, outra perspectiva de trabalho é a continuação do desenvolvimento
 da biblioteca LibScript.
 Possibilidades incluem adicionar novos plugins, revisar a sua API e exercitá-la
 embutindo a biblioteca em aplicações reais.
 LibScript e os quatro plugins implementados são software livre e estão
 disponíveis para download em\SpecialChar ~

\begin_inset LatexCommand \url{http://libscript.sourceforge.net}

\end_inset 

.
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{dissert}

\end_inset 


\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

API de LibScript
\layout Section

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ponteiro para o ambiente virtual.
 O parâmetro 
\family typewriter 
namespace
\family default 
 indica o nome a ser usado nas estruturas a serem criadas no espaço de nomes
 das máquinas virtuais para representar o ambiente virtual.
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente virtual.
\layout Section

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo das funções C a serem registradas no ambiente virtual.
 Ao expor uma API existente para LibScript, a função tipicamente será uma
 função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente virtual.
\layout Section

Buffer de parâmetros
\layout Itemize


\family typewriter 
double script_get_double(script_env* env, int index)
\newline 
int script_get_int(script_env* env, int index)
\newline 
int script_get_bool(script_env* env, int index)
\newline 
const char* script_get_string(script_env* env, int index)
\family default 

\newline 
Obtêm dados do buffer.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_get_string
\family default 
, a string retornada pertence ao chamador, que passa a ser responsável por
 desalocá-la.
\layout Itemize


\family typewriter 
script_type script_get_type(script_env* env, int index)
\newline 
int script_buffer_len(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_get_type
\family default 
 obtém o tipo do elemento do buffer solicitado e 
\family typewriter 
script_buffer_len
\family default 
 retorna o número de parâmetros no buffer.
\layout Itemize


\family typewriter 
void script_put_double(script_env* env, int index, double value)
\newline 
void script_put_int(script_env* env, int index, int value)
\newline 
void script_put_bool(script_env* env, int index, int value)
\newline 
void script_put_string(script_env* env, int index, const char* value)
\newline 

\family default 
Inserem dados no buffer.
 Ao final de uma função, os valores de retorno devem ser passados com chamadas
 a estas funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Itemize


\family typewriter 
void script_reset_buffer(script_env* env)
\family default 

\newline 
Esvazia o buffer.
\layout Section

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_put_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_get_*
\family default 
.
 Inicialmente, a tabela de funções C do ambiente virtual é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas na representação do ambiente virtual definido para
 a LibScript na máquina virtual da linguagem (isto é, no nome criado com
 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\newline 
void script_set_error_message(script_env* env, const char* message)
\newline 

\family default 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
 A função 
\family typewriter 
script_set_error_message
\family default 
 define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente virtual deve ser
 exposto à máquina virtual de alguma forma apropriada para a linguagem (como
 uma tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 O estado da máquina virtual e o ponteiro para o ambiente LibScript devem
 ser armazenados de modo a ser posteriormente acessíveis a partir deste
 handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_get_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_put_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\the_end
