
Espaço de nomes

Python	+ espaço de nomes limpo e legível (Py, PyObject_, PyDict_, etc.)
Ruby	- Espaço de nomes poluído (RSTRING, rb_funcall, VALUE, StringValuePtr...)
Java	+ espaçó de nomes limpo (JVM_, j*, (*J)->)
Lua	+ espaço de nomes limpo (lua_, luaL_, LUA_)
Perl	- espaço de nomes poluído. há macros para limpá-lo, mas perde-se funcionalidade.

Manipulação de dados

Python	+ API extensa: manipular dados é fácil, muitas funções de conveniência (GetItemString, CallFunctionObjArgs, etc)
Ruby	- pouco consistente. API expõe detalhes de implementação dos tipos
Java	+ tipagem estática evita muitas conversões
Java	- threading complica o acesso a strings e arrays
Lua	- construções simples, mas índices de pilha ficam pouco óbvios no código
Perl	- 

Criação de tipos

Python	- criar tipos em C é complicado. partes declaradas em C estaticamente, partes dinamicamente, 
Ruby	+ criar tipos em C é fácil. tanto para tipos contendo dados C, como para tipos puramente Ruby
Ruby	- sutilezas da linguagem: exige função que implementa cópia de objetos, código Ruby pode evitar o construtor
Java	- não é possível criar tipos em Java via C, apenas carregar classes
Lua	+ criar tipos em Lua é fácil. userdata são construções pensadas especificamente na interação com C

Armazenar ponteiros de C

Python	+ PyCObject
Java	- armazenar ponteiros de C em números
Ruby	- armazenar ponteiros de C em números
Lua	+ light userdata

Observações

Python	- sub-linguagem para declaração de tipos estruturados (ParseTuple, BuildArg) pode ser pouco óbvia
Java	- fieldIDs usa sub-linguagem para declaração de tipos nada óbvia
Lua	- controlar tamanho da pilha com lua_checkstack

Problemas

Ruby	- IDs nunca são coletados
