#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 11
\spacing single 
\papersize a4paper
\paperpackage widemarginsa4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Section*

LibScript, visão geral
\layout Standard


\emph on 
(Tradução do parágrafo enviado como 
\begin_inset Quotes eld
\end_inset 

project description
\begin_inset Quotes erd
\end_inset 

 para o cadastro do projeto no SourceForge...)
\layout Standard


\color red
LibScript é uma biblioteca projetada para permitir a adição de extensibilidade
 a aplicações através de 
\emph on 
scripting
\emph default 
 de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo que desacopla a aplicação em si das máquinas virtuais providas
 pelas diversas linguagens.
 A biblioteca principal, 
\family typewriter 
libscript
\family default 
, é uma fina camada que provê uma API para 
\emph on 
scripting
\emph default 
 independente de linguagem, permitindo à aplicação registrar as suas funções
 e invocar código a ser executado.
 Esta biblioteca, então invoca o 
\emph on 
plugin
\emph default 
 apropriado (
\family typewriter 
libscript-python
\family default 
, 
\family typewriter 
libscript-ruby
\family default 
, 
\family typewriter 
libscript-lua
\family default 
, etc.) para rodar o código.
 Desta forma, a aplicação permite ao usuário utilizar qualquer uma destas
 linguagens para scripting sem adicionar todas elas como suas dependências.
\layout Section*


\color red
A API independente de linguagem
\layout Standard


\color red
A API oferecida pela biblioteca deve ser independente de linguagem e isolar
 a aplicação das diferentes APIs oferecidas pelas linguagens de scripting.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas.
 Isto seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard


\color red
Uma abordagem mais interessante é, ao invés de expor a API da linguagem
 à aplicação, expor apenas uma API de funções da aplicação para a linguagem
 e manter as estruturas de dados e recursos desta restrito ao domínio que
 será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em 
\begin_inset LatexCommand \cite{ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{pyvhll_ext,pyvhll_ref}

\end_inset 

.
\layout Standard


\color red
Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python 
\begin_inset LatexCommand \cite{pyvhll_ref}

\end_inset 

, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby 
\begin_inset LatexCommand \cite{ext_ruby}

\end_inset 

, 
\family typewriter 
perl_eval_sv
\family default 
 em Perl 
\begin_inset LatexCommand \cite{perlembed}

\end_inset 

 , 
\family typewriter 
TclEval
\family default 
 em Tcl 
\begin_inset LatexCommand \cite{tcl}

\end_inset 

.
 No caso de Java, uma vez que o compilador e a máquina virtual não são combinado
s, não há uma primitiva deste tipo, embora seja possível carregar dinamicamente
 arquivos pré-compilados para execução através da classe 
\family typewriter 
ClassLoader
\family default 
.
 Alternativamente, scripting em Java pode ser oferecido adicionando-se um
 compilador Java 
\emph on 
embedded
\emph default 
 como o Janino 
\begin_inset LatexCommand \cite{janino}

\end_inset 

.
\layout Section*


\color red
API atual de LibScript, 
\emph on 
work-in-progress
\layout Subsection*


\color red
Inicialização e término
\layout Itemize


\family typewriter 
\color red
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ambiente.
 Um ambiente define um espaço de funções a serem expostas à biblioteca e
 de 
\begin_inset Quotes eld
\end_inset 

estados
\begin_inset Quotes erd
\end_inset 

 de plugins carregados.
 Assim, várias máquinas virtuais podem estar carregadas em um ambiente.
 O parâmetro 
\family typewriter 
namespace
\family default 
 refere-se ao identificador a ser inicializado no espaço de nomes da máquina
 virtual para armazenar as funções expostas.
 
\layout Itemize


\family typewriter 
\color red
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente.
\layout Subsection*


\color red
Registro de funções
\layout Itemize


\family typewriter 
\color red
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo de funções a serem registradas no ambiente.
 Tipicamente será uma função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
\color red
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente.
\layout Itemize


\family typewriter 
\color red
double script_in_double(script_env* env)
\newline 
int script_in_int(script_env* env)
\newline 
const char* script_in_string(script_env* env)
\family default 

\newline 
Obtêm parâmetros do ambiente.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada, em ordem.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_in_string
\family default 
, é retornada uma referência que pertence ao ambiente.
 O código deve realizar uma cópia caso queira modificar a string.
\layout Itemize


\family typewriter 
\color red
script_type script_in_type(script_env* env)
\newline 
int script_param_count(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_in_type
\family default 
 obtém o tipo do próximo parâmetro a ser obtido com a função 
\family typewriter 
script_in_*
\family default 
 e 
\family typewriter 
script_param_count
\family default 
 retorna o número de parâmetros disponíveis para consumo.
\layout Itemize


\family typewriter 
\color red
void script_out_double(script_env* env, double value)
\newline 
void script_out_int(script_env* env, int value)
\newline 
void script_out_string(script_env* env, const char* value)
\newline 

\family default 
Inserem parâmetros no ambiente.
 Estas funções permitem retornar os valores de saída.
 Ao final de uma função 
\emph on 
wrapper
\emph default 
, os valores de retorno da função devem ser passados com chamadas a estas
 funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Standard


\color red
As funções 
\family typewriter 
script_{in,out}_*
\family default 
 também devem são utilizadas na implementação dos plugins, de maneira inversa:
 antes de chamar o 
\emph on 
wrapper
\emph default 
, o plugin registra no ambiente os valores de entrada (devidamente convertidos
 para C) usando as funções 
\family typewriter 
out
\family default 
, e após a chamada, repassa o retorno para a máquina virtual obtendo os
 valores usando as funções 
\family typewriter 
in
\family default 
.
\layout Subsection*


\color red
Executando código
\layout Itemize


\family typewriter 
\color red
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
\color red
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
\color red
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_out_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_in_*
\family default 
.
 
\emph on 
[Na implementação atual,]
\emph default 
 Inicialmente, a tabela de funções C é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas no namespace definido para a LibScript na máquina
 virtual da linguagem (isto é, no nome criado com 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
\color red
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\family default 

\newline 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
\layout Subsection*


\color red
Funções para implementação de plugins
\layout Itemize


\family typewriter 
\color red
script_fn script_get_function(script_env* env, const char* name)
\family default 

\newline 
Localiza uma função no ambiente.
 Na implementação atual, todos os plugins estão fazendo o registro de funções
 na máquina virtual sob demanda: na inicialização, um objeto é criado com
 o nome do 
\emph on 
namespace
\emph default 
 do ambiente (uma tabela em Lua, um módulo em Python e Ruby) e acessos a
 funções deste objeto são resolvidas chamando esta função.
\layout Itemize


\family typewriter 
\color red
void script_set_error_message(script_env* env, const char* message)
\family default 

\newline 
Define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
\color red
void script_start_params(script_env* env)
\family default 

\newline 
Usada para zerar a lista interna de parâmetros de entrada e saída.
 Deve ser usada na implementação da chamada de funções para garantir que
 parâmetros que não tenham sido consumidos sejam removidos.
\layout Itemize


\family typewriter 
\color red
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Standard


\color red
Para linguagens que precisem carregar todas as funções na máquina virtual
 durante a inicialização do plugin, será necessário adicionar alguma funcionalid
ade que permita iterar sobre a lista de funções registradas.
\layout Section*


\color red
API exportada por plugins
\layout Standard


\color red
As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
\color red
script_plugin_state script_plugin_init_
\emph on 
lang
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente deve ser exposto
 à máquina virtual de alguma forma apropriada para a linguagem (como uma
 tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
\layout Itemize


\family typewriter 
\color red
script_err script_plugin_run_
\emph on 
lang
\emph default 
(script_plugin_state state, char* programtext)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
\color red
script_err script_plugin_call_
\emph on 
lang
\emph default 
(script_plugin_state state, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_in_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_out_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
\color red
void script_plugin_done_
\emph on 
lang
\emph default 
(script_plugin_state state)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\layout Section*


\color red
Múltiplos estados independentes
\layout Standard


\color red
O 
\emph on 
design
\emph default 
 atual da API oferece suporte a múltiplos estados independentes, ao permitir
 a manipulação de diversos ambientes, cada um possivelmente contendo um
 estado diferente de um dado plugin.
 Isto pode trazer problemas para linguagens que não dão suporte a múltiplos
 estados.
 Lua, Perl e Tcl são linguagens que permitem múltiplos estados de forma
 simples, uma vez que as chamadas à API incluem um identificador de estado
\begin_inset Foot
collapsed true

\layout Standard


\color red
Perl precisa ser compilado com -DMULTIPLICITY para permitir múltiplos estados.
\end_inset 

.
 Já linguagens que mantêm estado da máquina virtual de forma estática, como
 Python, não permitem trabalhar com múltiplos estados facilmente.
 O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter()
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados 
\emph on 
[a documentação diz 
\begin_inset Quotes eld
\end_inset 

This is a hard-to-fix bug that will be addressed in a future release
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{py-hardtofix}

\end_inset 

]
\emph default 
.
\layout Standard


\emph on 
\color red
[ Há ainda a questão da 
\emph default 
thread-safety
\emph on 
 da API resultante, que é dependente da 
\emph default 
thread-safety
\emph on 
 dos plugins e, por extensão, das máquinas virtuais.
 É uma questão prática importante, mas pode estar saindo de escopo.
 Abordar isto? ]
\layout Section*


\color red
Múltiplos valores de retorno
\layout Standard


\color red
A API para implementação de funções em C a serem expostas às máquinas virtuais
 permite declarar funções com múltiplos valores de retorno.
 Muitas linguagens não possuem este recurso, mas é possível, ao detectar
 no plugin que mais de um valor foi retornado, construir um tipo de dado
 agregado (tupla em Python, array em Ruby, etc.) e armazenar nele os valores,
 retornando à máquina virtual um valor de retorno único.
\layout Section*


\color red
Resolução de funções sob demanda
\layout Standard


\color red
Uma técnica que vem sendo implementada nos plugins de LibScript, quando
 permitido pela linguagem, consiste em realizar o binding entre a função
 C declarada e uma função 
\emph on 
stub
\emph default 
 nativa somente no momento em que ela é chamada.
 
\layout Standard


\color red
O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória da máquina virtual (ao evitar a criação de 
\emph on 
stubs
\emph default 
 que não serão utilizados), é permitir a localização de funções declaradas
 após a inicialização do ambiente -- possivelmente funções implementadas
 em outras linguagens, declaradas em outros plugins.
 Ao comparar as abordagens empregadas em cada plugin, isto nos permitirá
 avaliar os recursos de introspecção oferecidos por cada API.
\layout Subsection*


\color red
Lua
\layout Standard


\emph on 
\color red
[Parágrafo carregado de jargão Lua...] 
\emph default 
Durante a inicialização do plugin, é criada uma tabela armazenada em uma
 variável global, com o nome do 
\emph on 
namespace
\emph default 
 declarado.
 Esta tabela tem associada a si uma 
\emph on 
metatable
\emph default 
 cujo índice 
\family typewriter 
__index
\family default 
 aponta para uma função C interna ao plugin, 
\family typewriter 
script_lua_find_function
\family default 
, que localiza a função 
\begin_inset Formula $f$
\end_inset 

 solicitada na lista de funções registradas no ambiente.
 Após localizar a função, 
\family typewriter 
script_lua_find_function
\family default 
 associa à entrada da tabela do namespace outra função C interna, 
\family typewriter 
script_lua_call
\family default 
, criando uma 
\emph on 
C closure
\emph default 
 e associando a ela o endereço de 
\begin_inset Formula $f$
\end_inset 

 como um 
\emph on 
upvalue
\emph default 
.
 Ao ser invocada, a função 
\family typewriter 
script_lua_call
\family default 
 lê os valores da pilha de Lua (parâmetros de entrada) e os registra no
 ambiente LibScript, invoca a função C armazenada no 
\emph on 
upvalue
\emph default 
 e obtém os valores de retorno.
\layout Subsection*


\color red
Python
\layout Standard


\color red
Na inicialização em Python, o 
\emph on 
namespace
\emph default 
 é declarado como um módulo.
 É declarado também um tipo de dado, 
\family typewriter 
script_py_object
\family default 
, definido como um objeto Python contendo um ponteiro de função C e com
 um callback 
\family typewriter 
__call
\family default 
 definido 
\family typewriter 
script_py_object_call
\family default 
, uma função equivalente a 
\family typewriter 
script_lua_call
\family default 
.
 Assim, objetos deste tipo correspondem à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
 O módulo é automaticamente importado na inicialização do plugin, executando
 uma string de código Python 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

import 
\emph on 
namespace
\emph default 

\begin_inset Quotes erd
\end_inset 


\family default 
.
 
\emph on 
[Parece não ser possível importar um módulo de outra forma pela API Python/C;
 o opcode responsável na máquina virtual carrega as funções iterando o dicionári
o do módulo.
 Preciso conferir isso na lista de Python.]
\layout Standard


\color red
Ao chamar 
\family typewriter 
\emph on 
namespace
\emph default 
.f()
\family default 
, o callback 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_py_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 obtém o endereço de 
\begin_inset Formula $f$
\end_inset 

 da lista de funções do ambiente.
 É declarado então um objeto 
\family typewriter 
script_py_object
\family default 
 contendo o atributo 
\begin_inset Formula $f$
\end_inset 

, que é em seguida armazenado em 
\family typewriter 
\emph on 
namespace
\emph default 
.f
\family default 
.
 A função callback do módulo retorna e o rotina 
\family typewriter 
__call
\family default 
 do objeto é invocada em seguida, executando 
\family typewriter 
script_py_object_call
\family default 
, que registra os parâmetros de entrada no ambiente LibScript, invoca a
 função C armazenada no atributo interno do objeto e retorna a Python os
 valores de saída da função.
\layout Subsection*


\color red
Ruby
\layout Standard


\color red

\begin_inset Note
collapsed false

\layout Standard


\color red
TODO: update this
\end_inset 


\layout Standard


\color red
A implementação atual em Ruby ainda não está realizando a resolução de funções
 de forma transparente, mas ela já o faz de forma dinâmica.
 A inicialização do plugin em Ruby define uma classe com o nome do namespace,
 contendo dois métodos, 
\family typewriter 
get
\family default 
 e 
\family typewriter 
call
\family default 
.
 O método get opera de modo similar a 
\family typewriter 
script_lua_find_function
\family default 
 e 
\family typewriter 
script_py_get
\family default 
, mas não é chamado automaticamente quando um método inexistente é chamado;
 ele precisa ser invocado explicitamente.
 Após uma chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.get(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
, o método 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
 passa a estar disponível na classe.
\layout Standard


\color red
O método 
\family typewriter 
get
\family default 
 declara uma função wrapper Ruby que invoca 
\family typewriter 
\emph on 
Namespace
\emph default 
.call
\family default 
 passando como parâmetros o endereço da função C 
\begin_inset Formula $f$
\end_inset 

 (convertido para tipo numérico) e os parâmetros passados na chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
.
 Para fixar esse valor de 
\begin_inset Formula $f$
\end_inset 

 na função declarada, esta declaração é feita gerando uma string de código
 Ruby.
 Uma vez declarada a função, o método padrão 
\family typewriter 
\emph on 
Namespace
\emph default 
.method(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
 é chamado de modo a obter uma referência para o método recém-criado, para
 que ele seja retornado por 
\family typewriter 
get
\family default 
.
 O método 
\family typewriter 
call
\family default 
, por sua vez, equivale a 
\family typewriter 
script_lua_call
\family default 
 e 
\family typewriter 
script_py_object_call
\family default 
., realizando a conversão dos parâmetros e chamada da função 
\begin_inset Formula $f$
\end_inset 

.
\layout Section*


\color red
Manipulação do estado de nomes
\layout Standard


\color red
Para que o ambiente descreva um espaço de nomes consistente entre todos
 os plugins, é necessário contemplar o caso onde os plugins adicionam funções
 a ele, possivelmente sobrescrevendo funções previamente definidas.
\layout Standard


\emph on 
\color red
Atualmente, os plugins armazenam funções registradas em uma cache (Lua e
 Python no primeiro acesso, Ruby com a função explícita 
\family typewriter 
get
\family default 
).
 Como manter a consistência entre os espaços de nomes das máquinas virtuais?
 Deixar de usar a cache e cada chamada então deve consultar a lista de funções
 em libscript? Ou o registro de uma nova função deve notificar os plugins?
 Pode ser necessário utilizar soluções diferentes em cada plugin.
 Lua, por exemplo, não chama o metamétodo 
\family typewriter 
__newindex
\family default 
 uma vez que o primeiro valor já foi armazenado.
 Em Ruby, ao chamar um método inexistente, é chamado o callback method_missing,
 mas chamada a Classe.method(
\begin_inset Quotes eld
\end_inset 

inexistente
\begin_inset Quotes erd
\end_inset 

) não ativa o callback.
\layout Section*

Random jots
\layout Subsection*

Random jot #1
\layout Standard


\emph on 
[Bug 
\begin_inset Quotes eld
\end_inset 

interessante
\begin_inset Quotes erd
\end_inset 

 durante a implementação Python: PyObject_GetItem/PyObject_SetItem funcionava
 
\begin_inset Quotes eld
\end_inset 

às vezes
\begin_inset Quotes erd
\end_inset 

 para o dicionário do método.
 Trocar para PyDict_GetItem/PyDict_SetItem resolveu o problema.
 Contagem de referências de PyDict_ e PyObject_ funcionam de formas diferentes.]
\layout Subsection*


\color red
Random jot #2
\layout Standard


\color red
Uma FLI age como uma ponte de dois sentidos: ela deve expor os tipos de
 dados e permitir chamada de código de C à linguagem, e expor os tipos de
 dados e permitir chamada de código da linguagem a C.
 [Serão esses os 
\begin_inset Quotes eld
\end_inset 

quatro objetivos
\begin_inset Quotes erd
\end_inset 

 principais de uma FLI? Mapear APIs das linguagens estudadas dentro desses
 2 grandes grupos (cada um com 2 sub-grupos)?]
\layout Standard


\color red
O objetivo geral de LibScript é tornar aplicações 
\begin_inset Quotes eld
\end_inset 

scriptable
\begin_inset Quotes erd
\end_inset 

 de modo independente de linguagem.
 Os objetivos específicos são: (a) expor os dados e permitir chamada de
 código de C de uma aplicação aos scripts; (b) construir um espaço de nomes
 que possa ser acessado de forma comum entre as diferentes máquinas virtuais,
 para que scripts escritos em diferentes linguagens possam interagir.
\layout Standard


\color red
Para que o segundo objetivo seja atingido, é necessário que mudanças no
 espaço de nomes ocorridas externamente a uma VM, seja pelo código C ou
 por outra máquina virtual, sejam refletidas transparentemente na representação
 local do espaço de nomes desta VM.
 Para que isto ocorra, deve ser possível realizar um certo grau de metaprogramaç
ão através da FLI.
 Em particular, deve ser possível capturar chamadas a funções não definidas
 e resolver estas chamadas através de código C.
 
\layout Standard


\color red
O primeiro objetivo implementa um dos sentidos da comunicação realizada
 por uma FLI.
 O segundo objetivo é similar ao sentido inverso no que permite a chamada
 de código da linguagem, mas não contempla a exposição dos tipos de dados:
 estruturas de dados não oferecidas por C podem ser manipulados apenas como
 tipos opacos, já que os conjuntos de funcionalidades a ser exposta ao mapear
 os tipos de dados específicos de cada linguagem variam muito entre si.
 
\layout Standard


\color red
[Um aspecto ainda um tanto nebuloso nessa classificação é a 
\begin_inset Quotes eld
\end_inset 

definição de novos tipos para a linguagem a partir de C
\begin_inset Quotes erd
\end_inset 

.
 Python e Ruby permitem criar em C classes que por sua vez produzem instâncias
 na VM.
 Lua permite criar tabelas, mas estas 
\emph on 
são
\emph default 
 instâncias na VM.
 Mesmo uma FLI simplista do tipo 'tudo via string' permite criar tipos complexos
 (
\begin_inset Quotes eld
\end_inset 

x = { foo=4, bar=2 }
\begin_inset Quotes erd
\end_inset 

), mas possivelmente não obtê-los, a não ser que ganhem uma representação
 como 
\emph on 
handle
\emph default 
 (registro de Lua como exemplo de manipulação de objetos da VM via 
\emph on 
handles
\emph default 
).]
\layout Subsection*

Random jot #3
\layout Standard


\emph on 
[Onde citar LuaJava? A parte Java de LibScript pode ser baseada em LuaJava.]
\layout Subsection*


\color red
Random jot #4: Intro do Cap.
 4?
\layout Standard


\color red
FLIs providas por máquinas virtuais são usualmente compreendidas como 
\begin_inset Quotes eld
\end_inset 

APIs de extensão
\begin_inset Quotes erd
\end_inset 

: elas servem ou para estender a máquina virtual com recursos não oferecidos
 por esta, ou para estender uma aplicação externa com os recursos oferecidos
 pela máquina virtual, embarcando-a nesta aplicação.
 O primeiro cenário é o utilizado no modelo de programação onde a coordenação
 de alto nível é realizada em uma linguagem interpretada e módulos compilados
 em linguagens como C e C++ são usados para acesso a bibliotecas externas
 ou implementação de partes onde o desempenho é crítico.
 O segundo cenário, via de regra, irá englobar também o primeiro, ao expor
 à máquina virtual embarcada extensões que a permitam comunicar-se com a
 aplicação hospedeira.
\layout Subsection*

Random jot #4: Perl
\layout Standard

Os processos de estender e embutir Perl são bastante distintos.
 Para extensões, Perl oferece uma linguagem para descrição de interfaces
 chamada XS.
 Ao invés de isolar o acesso às estruturas internas de Perl através de uma
 API pública, a abordagem proposta é encapsular o processo de geração de
 código 
\emph on 
wrapper
\emph default 
 para a comunicação entre funções escritas em C e as estruturas internas
 de Perl usando interfaces escritas em XS.
 Arquivos 
\family typewriter 
.xs
\family default 
 são então alimentados ao pré-processador 
\family typewriter 
xsubpp
\family default 
, que geram então o código usando a API oferecida pela biblioteca de Perl.
 Esta biblioteca oferece acesso de baixo nível ao funcionamento da máquina
 virtual, permitindo, por exemplo, manipular o ponteiro da sua pilha interna.
\layout Standard

Para embutir a máquina virtual de Perl em uma aplicação, a biblioteca que
 a implementa oferece algumas funções que permitem disparar um interpretador.
 Na API de mais alto nível, pode-se construir um array de parâmetros a serem
 passados para o interpretador de forma equivalente às opções do interpretador
 Perl de linha de comando, inclusive usando a opção 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

-e
\begin_inset Quotes erd
\end_inset 


\family default 
 para executar trechos de código.
 
\layout Standard


\emph on 
\color red
[Quando é necessário fazer o 'glue' diretamente no código C (em que casos?),
 é necessário usar as macros para acesso às estruturas internas de Perl,
 de modo similar ao código gerado por XS (exemplo em perlembed).
\layout Standard


\emph on 
\color red
Para acessar funções da aplicação onde Perl foi embutido, é possível escrever
 um módulo usando XS e linká-lo? Testar.
\layout Standard


\emph on 
\color red
XS oferece ainda algum suporte explícito a C++.
 Citar.
\layout Standard


\emph on 
\color red
Linkando, além do interpretador, módulos na aplicação.
 ExtUtils::Embed.
 DynaLoader.
 Outros ExtUtils na CPAN.
\layout Standard


\emph on 
\color red
Permite múltiplas instâncias da VM: -Dusemultiplicity
\layout Standard

Funções em Perl são ocultas por macros [warn() é Perl_warn()].
 Ao compilar Perl com 
\begin_inset Quotes eld
\end_inset 

multiplicity
\begin_inset Quotes erd
\end_inset 

, Perl adiciona um primeiro parâmetro a todas as funções, com o handle para
 o estado atual [como Lua_State* L].
 Para evitar conflitos de nomes, é possível desabilitar essas macros utilizado
 -DPERL_NO_SHORT_NAMES.
 Torna-se necessário então, passar 
\begin_inset Quotes eld
\end_inset 

aTHX_
\begin_inset Quotes erd
\end_inset 

 no início de cada chamada.
\layout Standard


\emph on 
\color red
Material: perlxs, perlembed, perlguts, perlapi, perlcall.]
\layout Standard

Perl -> 
\layout Subsection*

Random jot #5: Strings
\layout Standard

lua_pushstring, PyString_FromString e rb_str_new{,2} fazem cópias da string.
\layout Subsection*

Random jot #8: Tainted Objects em Ruby 
\layout Standard

http://www.rubycentral.com/book/taint.html
\layout Subsection*

Random jot #9: Java
\layout Standard

No caso de Java, uma vez que o compilador e a máquina virtual não são combinados
, não há uma primitiva deste tipo, embora seja possível carregar dinamicamente
 arquivos pré-compilados para execução através da classe 
\family typewriter 
ClassLoader
\family default 
.
 Alternativamente, scripting em Java pode ser oferecido adicionando-se um
 compilador Java 
\emph on 
embedded
\emph default 
 como o Janino 
\begin_inset LatexCommand \cite{janino}

\end_inset 

.
\layout Bibliography
\bibitem {ltn004}

http://www.lua.org/notes/ltn004.html
\layout Bibliography
\bibitem {pyvhll_ext}

http://www.python.org/doc/ext/high-level-embedding.html
\layout Bibliography
\bibitem {pyvhll_ref}

http://www.python.org/doc/api/veryhigh.html
\layout Bibliography
\bibitem {ext_ruby}

http://www.rubycentral.com/book/ext_ruby.html
\layout Bibliography
\bibitem {perlembed}

http://www.perl.com/doc/manual/html/pod/perlembed.html
\layout Bibliography
\bibitem {tcl}

http://wiki.tcl.tk/2074
\layout Bibliography
\bibitem {janino}

http://www.janino.net
\layout Bibliography
\bibitem {py-hardtofix}

http://www.python.org/doc/api/initialization.html
\the_end
