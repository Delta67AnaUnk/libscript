#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass ThesisPUC
\begin_preamble
\titulo{Estudo sobre APIs para Máquinas Virtuais}
\autor{Hisham H. Muhammad}
\autorR{Muhammad, Hisham H.}
\orientador{Roberto Ierusalimschy}
\orientadorR{Ierusalimschy, Roberto}
\dia{11} \mes{Junho} \ano{2006}
\cidade{Rio de Janeiro}
\departamento{Informática}
\programa{Informática}
\centro{Centro Técnico Científico}
\end_preamble
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Estudo sobre APIs para máquinas virtuais
\layout Author

Hisham H.
 Muhammad
\layout Chapter

Introdução
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\layout Standard

Existem muitas situações onde é necessário ou interessante que haja interação
 entre programas escritos em diferentes linguagens.
 Um caso típico é o emprego de bibliotecas externas, como 
\emph on 
toolkits
\emph default 
 gráficos, APIs de acesso a banco de dados, ou até mesmo chamadas ao sistema
 operacional.
 Outro cenário ainda envolve aplicações desenvolvidas usando mais de uma
 linguagem de programação a fim de otimizar partes onde o desempenho é crítico
 ou permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
\layout Standard

Independentemente da finalidade, a comunicação entre programas escritos
 em linguagens diferentes traz consigo uma série de questões de projeto,
 não apenas no desenvolvimento das aplicações, mas das linguagens em si.
 Há várias formas de se obter esse tipo de interoperabilidade, desde tradução
 de código de uma linguagem para outra até o uso de uma máquina virtual
 comum.
 Idealmente, entretanto, uma linguagem deve prover uma interface de acesso
 externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem 
\begin_inset LatexCommand \cite{finne-fli}

\end_inset 

.
 Entre os fatores que devem ser levados em consideração no desenvolvimento
 de tal interface estão as diferenças entre os sistemas de tipos, problemas
 de gerência de memória (como coleta de lixo e acesso direto a ponteiros)
 e modelos de concorrência.
 Além de lidar com diferenças semânticas, o projeto de uma interface envolve
 questões pragmáticas como o equilíbrio entre o isolamento seguro dos ambientes
 de execução, o desempenho e a simplicidade da API resultante.
\layout Standard

Pode-se observar nas implementações existentes de FLIs um número de abordagens
 para estes problemas.
 De fato, FLIs de diferentes linguagens (ou mesmo de diferentes revisões
 de uma mesma linguagem) tendem a ser bastante distintas entre si.
 Ainda assim é possível traçar paralelos entre as técnicas utilizadas, uma
 vez que os problemas fundamentais que elas atacam são os mesmos.
 Além disso, em função da popularidade da linguagem C e do suporte oferecido
 a ela pelos sistemas operacionais mais utilizados, grande parte das implementaç
ões de interfaces de acesso externo são, na prática, APIs para C, o que
 também facilita a sua comparação.
 Adicionalmente, C se tornou também uma popular 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 na interação entre FLIs.
\layout Section

Objetivo
\layout Standard

Este trabalho realiza, a partir da pesquisa de implementações de FLIs, um
 estudo e comparação de interfaces entre diferentes linguagens de programação.
 Partindo de uma análise das abordagens gerais para interação entre linguagens,
 o estudo é baseado na análise de um conjunto de interfaces com C providas
 por linguagens imperativas baseadas em máquina virtual.
 Além de se tratar da classe de linguagens mais popular atualmente para
 desenvolvimento multi-linguagem, características típicas de máquinas virtuais
 como coleta de lixo e tipagem dinâmica, por não estarem presentes em C,
 ilustram bem os problemas envolvendo a comunicação de dados entre diferentes
 ambientes de programação.
 Linguagens com tipagem estática podem apresentar necessidades de conversão
 de tipos semelhantes, mas o problema tende a ser simplificado pela definição
 de tipos equivalentes na API e inferência em tempo de compilação (vide
 exemplos nas API com C de Ada e Fortran).
 Linguagens funcionais possuem preocupações adicionais com efeitos colaterais
 no código C, mas isto é equivalente ao problema de quebra do paradigma
 causada tratamento de entrada e saída que todas elas enfrentam.
\layout Standard

O estudo consiste da análise em profundidade de um conjunto de FLIs -- especific
amente, Python, Perl, Ruby, Lua e Java -- e um estudo de caso onde estas
 FLIs são exercitadas em tarefas semelhantes.
 Diferentemente das demais, Java possui tipagem estática, mas com a sua
 biblioteca de reflexão, que oferece recursos de intercessão como carga
 de classes em tempo de execução e invocação dinâmica de métodos, é possível
 encará-la, para os fins de interação com código C, como uma linguagem dinâmica.
\layout Standard


\emph on 
\color red
[TODO: Continuar essa seção, botar um 
\begin_inset Quotes eld
\end_inset 

fecho
\begin_inset Quotes erd
\end_inset 

 na coisa.]
\layout Section

Estrutura do Texto
\layout Standard

O trabalho está organizado da seguinte forma.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, é dada uma visão geral sobre as várias abordagens para interação entre
 código escrito em diferentes linguagens de progamação.
 A partir daí, o foco se concentra no método de interface externa mais comum
 nas linguagens da atualidade: interfaces com a linguagem C.
 São abordados no Capítulo 
\begin_inset LatexCommand \ref{cha:Interfaces-com-C}

\end_inset 

 os problemas comumente envolvidos na comunicação com código escrito em
 C.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

 são apresentadas em detalhe APIs para C de um conjunto de máquinas virtuais.
 Ao discutir estas interfaces, as diferentes soluções empregadas para os
 problemas levantados no capítulo anterior são comparadas.
 O Capítulo 
\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercita estas diferentes APIs através de um estudo de caso: uma biblioteca
 baseada em plug-ins que oferece uma interface uniforme simplificada entre
 máquinas virtuais e C.
 Ao examinar a implementação de cada plug-in, podemos comparar as APIs de
 cada linguagem realizando operações equivalentes.
 Finalmente, no Capítulo 
\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

, são apresentadas as conclusões do trabalho, bem como apontados caminhos
 para trabalhos futuros.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interação entre Linguagens de Programação
\layout Standard

As abordagens aplicadas na interação entre diferentes linguagens de programação
 variam bastante entre si, mas é possível identificar algumas técnicas tipicamen
te utilizadas: tradução de linguagens, seja de uma para outra ou de ambas
 para uma terceira; comunicação através de protocolo ou linguagem intermediária;
 compartilhamento de um ambiente de execução comum, seja de máquina virtual
 ou através de convenção de chamadas.
\layout Section

Tradução de Código
\layout Standard

Permitir o uso de duas linguagens diferentes em um programa traduzindo o
 código de uma delas para a outra minimiza o problema de comunicação entre
 as partes do programa escritas em linguagens diferentes, uma vez que o
 programa final utilizará um espaço único de dados.
 Em contrapartida, ao ter de se descrever uma linguagem em termos de outra,
 a diferença de semântica das construções pode se tornar um problema.
 Se a linguagem de destino não possui construções oferecidas pela linguagem
 de origem, simulá-las pode ser custoso.
\layout Standard

Um exemplo típico é a complexidade adicionada pela simulação de funções
 de alta ordem e recursão final ao traduzir-se o código de linguagens funcionais
 para outra que não possui estes recursos.
 Em 
\begin_inset LatexCommand \cite{tarditi92no}

\end_inset 

 é descrito o desenvolvimento de um tradutor de Standard ML para ANSI C;
 medições evidenciaram o custo de adaptação destes recursos de ML para C,
 resultando em código em média 2 vezes mais lento que o gerado pelo compilador
 ML nativo.
 Em 
\begin_inset LatexCommand \cite{tolmach-from}

\end_inset 

, são discutidos desafios similares na tradução de ML para Ada: na solução
 adotada, o processo possui um passo intermediário onde as construções de
 alta ordem são 
\begin_inset Quotes eld
\end_inset 

aplainadas
\begin_inset Quotes erd
\end_inset 

 para construções de primeira ordem envolvendo registros, para que pudessem
 assim ser representados em Ada.
\layout Standard

Além de problemas como este, diferenças na representação dos dados ainda
 é algo a ser tratado no processo de tradução de uma linguagem para outra.
 No caso particular de C, as facilidades de baixo nível para manipulação
 de memória permitem a descrição de estruturas de dados de linguagens de
 mais alto nível sem maiores problemas.
 Isto faz de C uma candidata freqüente para uso como representação de baixo
 nível portável.
 O compilador de Haskell GHC oferece, como alternativa à geração de código
 nativo, geração de código C para uso com o GCC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 Uma das vantagens deste recurso é permitir o 
\emph on 
bootstrapping
\emph default 
 do compilador em novas arquiteturas, dado que o próprio GHC é escrito em
 Haskell.
 De fato, a ubiqüitude dos compiladores C faz com que a linguagem seja utilizada
 também como 
\emph on 
lingua franca
\emph default 
 entre diferentes linguagens, como será visto na Seção 
\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Compartilhamento de Máquinas Virtuais
\layout Standard

Outra abordagem envolve o uso de um ambiente de execução comum, como uma
 máquina virtual.
 O código das diferentes linguagens é compilado de modo a produzir representaçõe
s compatíveis entre si, de acordo com os tipos de dados oferecidos pelo
 ambiente de execução.
 Diversas implementações utilizam a Java Virtual Machine 
\begin_inset LatexCommand \cite{gosling-java}

\end_inset 

 com essa finalidade.
 Jython 
\begin_inset LatexCommand \cite{hugunin-jython}

\end_inset 

 é uma implementação da linguagem Python 
\begin_inset LatexCommand \cite{lutz-python}

\end_inset 

 que produz bytecodes Java.
 SMLj 
\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 é um compilador Standard ML que gera bytecodes Java e permite acesso de
 classes e métodos Java a estruturas e funções ML e vice-versa.
 O fato da Java Virtual Machine não ter sido projetada para comportar diferentes
 linguagens de programação, entretanto, transparece nas limitações apresentadas
 por estes projetos.
 SMLj define extensões à linguagem ML para permitir acesso a construções
 específicas de Java; Jython possui limitações ao realizar a interface de
 Python com a API de reflexão e carga dinâmica de classes de Java.
 Além disso, o conjunto de instruções da máquina virtual privilegia operações
 que condizem com a semântica de Java, tornando, por exemplo, implementações
 de 
\emph on 
arrays
\emph default 
 com semântica diferente menos eficientes.
\layout Standard

O .NET Framework 
\begin_inset LatexCommand \cite{box-net}

\end_inset 

 é um ambiente de execução baseado em máquina virtual que vem sendo indicado
 pela Microsoft como plataforma de programação preferencial em sistemas
 Windows.
 Apesar de com ele ter sido introduzida a linguagem C# 
\begin_inset LatexCommand \cite{hejlsberg-csharp}

\end_inset 

, o ambiente tem como um de seus objetivos oferecer suporte a múltiplas
 linguagens---evidenciado pelo próprio nome Common Language Runtime (CLR)---em
 contraste com as limitações que o ambiente de Java impõe àqueles que tentam
 utilizá-lo com outras linguagens.
 Todavia, adaptações às linguagens continuam necessárias com o ambiente
 .NET: A versão .NET de Visual Basic inclui alterações na linguagem de modo
 a tornar a sua semântica mais similar à de C#; um novo dialeto de C++,
 Managed C++, foi introduzido adaptando o modelo de gerenciamento de memória
 ao do CLR 
\begin_inset LatexCommand \cite{managedcpp}

\end_inset 

; de forma similar, foi desenvolvido um novo dialeto de ML chamado F#, para,
 entre outros motivos, proporcionar melhor integração com componentes .NET
 desenvolvidos em outras linguagens 
\begin_inset LatexCommand \cite{syme-fsharp}

\end_inset 

.
\layout Standard

Outra implementação de uma máquina virtual para múltiplas linguagens vem
 sendo feita pelo projeto Parrot 
\begin_inset LatexCommand \cite{randal-perl6}

\end_inset 

.
 O escopo deste projeto é mais restrito, visando ser um 
\emph on 
back-end
\emph default 
 comum para linguagens dinâmicas como Perl e Python.
 O foco do projeto, entretanto, está atualmente na implementação de Perl
 6.
\layout Standard

Um tipo de comunicação que pode ser considerada ainda uma forma de ambiente
 de execução comum é a comunicação entre executáveis e bibliotecas nativos
 através de convenções de chamada: regras para a passagem de parâmetros
 na pilha de execução, uso de registradores e 
\emph on 
mangling
\emph default 
 de nomes.
 Este pode ser considerado o método de interação entre código em diferentes
 linguagens de mais baixo nível.
 Convenções de chamada, entretanto, são um recurso limitado de comunicação,
 já que assumem tipos de dados com representação em memória idêntica nas
 as duas linguagens.
 Tal compatibilidade dificilmente ocorre a não ser que uma das linguagens
 explicitamente considere este tipo de interação na sua definição: o padrão
 de Ada, por exemplo, requer que as suas implementações sejam compatíveis
 com as convenções de C, COBOL e Fortran 
\begin_inset LatexCommand \cite{ada95}

\end_inset 

.
 De forma similar, C++ permite especificar funções com linkagem compatível
 com C (
\family typewriter 
extern 
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 

C
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 


\family default 
).
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Modelos de Objetos Independentes de Linguagem
\layout Standard

Adotar um modelo de tipos independente de linguagem é uma outra forma de
 tratar as questões de interoperabilidade de dados entre linguagens.
 Assim, na definição dos dados de uma aplicação, as suas interfaces são
 definidas de forma neutra, tipicamente utilizando alguma linguagem projetada
 especificamente para este fim (uma IDL, 
\emph on 
interface description language
\emph default 
) enquanto as implementações são feitas nas linguagens específicas.
 A arquitetura CORBA (
\emph on 
Common Object Request Broker Architecture
\emph default 
) 
\begin_inset LatexCommand \cite{omg-corba}

\end_inset 

 é uma das principais representantes deste modelo.
 A motivação principal para o desenvolvimento de CORBA foi permitir o desenvolvi
mento de aplicações distribuídas em ambientes heterogêneos; a heterogeneidade
 de linguagens foi um dos aspectos levados em consideração.
\layout Standard

Os desafios existentes ao projetar um modelo de dados ou objetos 
\begin_inset Quotes eld
\end_inset 

independente de linguagens
\begin_inset Quotes erd
\end_inset 

, entretanto, são similares aos de uma interface entre duas linguagens quaisquer
, já que esse modelo, por sua vez, descreve também um sistema de tipos.
 Ao implementar 
\emph on 
bindings
\emph default 
 para algum destes modelos de objetos é necessário definir uma correspondência
 entre os tipos definidos pelo modelo e os oferecidos pela linguagem destino
 e prover a esta uma API para interação com o ambiente de execução---no
 caso de CORBA, com o ORB (
\emph on 
Object Request Broker
\emph default 
).
 
\layout Standard

Se por um lado a tarefa pode ser facilitada pelo fato de o modelo ter sido
 projetado visando interação com outras linguagens (diferentemente, por
 exemplo, do sistema de tipos de C), por outro espera-se usualmente um grau
 de transparência maior na representação dos dados.
 Por exemplo, enquanto em uma aplicação integrando C++ e Python a distinção
 entre objetos C++ e objetos Python é clara e a API Python define o limite
 entre os dois universos, em uma aplicação desenvolvida utilizando CORBA
 espera-se que, tanto em uma linguagem como em outra, a manipulação dos
 objetos seja igual, sejam eles implementados em C++ ou Python.
 Para isso, a solução adotada é o uso de 
\emph on 
stubs
\emph default 
, objetos que dão uma aparência nativa uniforme aos dados, indepentemente
 da linguagem em que foram implementados e no caso de modelos distribuídos
 como CORBA, da localização dos mesmos na rede.
 A correspondência entre os ciclos de vida dos 
\emph on 
stubs
\emph default 
 e dos objetos que eles representam é outro fator que deve ser levado em
 consideração.
 Nos 
\emph on 
bindings
\emph default 
 Java, por exemplo, isto é realizado com o auxílio do coletor de lixo da
 própria linguagem.
 Já em linguagens como C++ o controle das referências é explícito.
\layout Standard

Outras abordagens de mais alto nível têm sido propostas para a integração
 de aplicações desenvolvidas em múltiplas linguagens.
 Linguagens de coordenação como Linda 
\begin_inset LatexCommand \cite{gelernter-linda}

\end_inset 

 e Opus 
\begin_inset LatexCommand \cite{chapman-opus}

\end_inset 

 definem mecanismos para troca de mensagens e um conjunto restrito de construçõe
s para indicar o fluxo destas entre agentes implementados em outras linguagens.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C como Linguagem Intermediária
\layout Standard

O desejo de uma linguagem intermediária universal é antigo no mundo da computaçã
o.
 Diversas propostas surgiram ao longo dos anos, desde o projeto UNCOL 
\begin_inset LatexCommand \cite{conway-uncol}

\end_inset 

 às linguagens de sintaxe extensível da década de 70 
\begin_inset LatexCommand \cite{metzner-xl}

\end_inset 

 até os mais recentes ambientes de máquina virtual como .NET.
 Na prática, as necessidades que estes projetos visavam atender vêm sendo
 supridas ao longo dos anos de forma mais pragmática, ainda que menos ideal:
 usando C.
 Dois motivos fazem de C uma escolha comum como linguagem intermediária.
 Primeiro, a sua característica de linguagem de 
\begin_inset Quotes eld
\end_inset 

médio nível
\begin_inset Quotes erd
\end_inset 

, ao permitir ao mesmo tempo independência de hardware e manipulação direta
 de memória.
 Segundo, a grande disponibilidade de compiladores C, alavancada pela proliferaç
ão dos sistemas Unix nas mais diferentes arquiteturas.
 Assim, com o passar do tempo, oferecer uma interface para interoperabilidade
 com outras linguagens passou a significar oferecer uma interface para comunicaç
ão com código C.
 Isto é especialmente verdadeiro para linguagens dinâmicas que oferecem
 recursos para extensibilidade de aplicações.
 Não por acaso, estas são tipicamente implementadas em C.
\layout Standard

A disponibilidade de APIs para C oferecidas pelas diferentes linguagens
 faz com que C seja bastante usada também como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

.
 A integração entre Python e Fortran se dá através de um módulo Python escrito
 em C que acessa uma biblioteca Fortran, que por sua vez expõe funções com
 convenção de chamada compatível com C 
\begin_inset LatexCommand \cite{peterson-fpy}

\end_inset 

.
 LunaticPython 
\begin_inset LatexCommand \cite{lunatic-python}

\end_inset 

 oferece pontes de Lua para Python e de Python para Lua, implementadas através
 de um par de módulos de extensão para cada linguagem de origem escritos
 em C.
\layout Standard

Todavia, linguagens intermediárias genéricas continuam a ser propostas como
 alternativas a C.
 C-- 
\begin_inset LatexCommand \cite{jones99portable}

\end_inset 

 é um projeto que tenta superar as limitações de C enquanto linguagem intermediá
ria tornando mais explícita a representação em memória dos tipos de dados
 e adicionando suporte a construções não facilmente representáveis em C,
 como recursão final.
 Versões recentes da suíte de compiladores GCC padronizaram uma linguagem
 intermediária para comunicação entre os seus diversos 
\emph on 
back-ends
\emph default 
 e 
\emph on 
front-ends
\emph default 
 
\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces com C
\layout Standard


\emph on 
\color red
[TODO: OBJETIVO DESTE CAPÍTULO -> (texto a seguir do Plano de Trabalho da
 proposta) Inicialmente, pretendemos identificar o conjunto de problemas
 tratados por uma FLI implementada como uma API para C.
 Além de apontar classes gerais de problemas como coleta de lixo e passagem
 de parâmetros, queremos aqui chegar a uma lista de problemas específicos,
 como por exemplo a validade de referências mantidas em estruturas de dados
 C entre invocações de funções, a exposição ao código C de funcionalidades
 implementadas em operadores sobrecarregados e o suporte a hierarquias de
 subtipos envolvendo tipos declarados em ambas as linguagens.]
\layout Standard

A linguagem C tem, na atualidade, um papel especial no mundo das linguagens
 de programação.
 Além de ser bastante utilizada na implementação de compiladores, interpretadore
s e máquinas virtuais (as principais implementações de Perl, Python, Ruby,
 Tcl/Tk e Lua são apenas alguns exemplos), é tambem usada em compiladores
 como formato de saída na geração de código portável (dois exemplos notáveis
 são os compiladores GHC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

 e o SmartEiffel 
\begin_inset LatexCommand \cite{collin-eiffel}

\end_inset 

, que geram C a partir de Haskell e Eiffel, respectivamente).
 Isto faz com que a API para C seja um formato conveniente para uma FLI.
\layout Standard


\emph on 
\color red
[TODO: descrições de interfaces em linguagens específicas podem ir para
 o cap.
 seguinte]
\layout Standard

Para permitir invocar funções C, a FLI deve fornecer uma forma de registrar
 estas funções no ambiente de execução, idealmente permitindo ao programa
 chamá-las de forma igual a funções nativas.
 A linguagem Java, por exemplo, possui uma palavra reservada,
\family typewriter 
 native
\family default 
, para indicar funções não implementadas em Java.
 Assim, ao contrário do que o nome pode dar a entender, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 Em linguagens dinâmicas, declarações de funções podem ser realizadas em
 tempo de execução, usando funções como 
\family typewriter 
lua_register
\family default 
 em Lua ou 
\family typewriter 
rb_define_method
\family default 
 em Ruby 
\begin_inset LatexCommand \cite{thomas-ruby}

\end_inset 

.
\layout Standard

Na grande maioria dos casos, a representação interna de código produzida
 por compiladores de outras linguagens não é compatível com C, seja por
 diferenças em convenções de chamadas ou de nomes, ou por produzirem código
 para execução em máquinas virtuais.
 Desta forma, para permitir a um programa em C acessar este código, cabe
 à linguagem expor uma biblioteca de funções C que realizem a tradução necessári
a.
 Em ambientes de máquina virtual, esta biblioteca de funções normalmente
 é genérica, oferecendo facilidades para comunicação com a própria máquina
 virtual.
 Para linguagens estáticas, normalmente é necessário criar uma biblioteca
 específica que realize a conversão das chamadas, como ocorre em interfaces
 C para APIs C++.
\layout Standard

Para linguagens não imperativas, há ainda o problema de código C potencialmente
 gerar efeitos colaterais.
 Algum recurso para isolamento das chamadas deve ser oferecido.
 No GHC, a construção para chamadas em C, 
\family typewriter 
_ccall_
\family default 
, é definida na mônada de IO; no adendo do padrão Haskell 98, a diretiva
 
\family typewriter 
ccall
\family default 
 foi integrada, mas o uso da mônada é opcional, cabendo ao programador garantir
 que funções que não a utilizem sejam puras
\begin_inset Foot
collapsed false

\layout Standard

Diversas convenções de chamada são definidas (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
) mas 
\family typewriter 
ccall
\family default 
 é a única declarada como obrigatória pelo documento.
\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{sub:Sistemas-de-tipos}

\end_inset 

Sistemas de Tipos
\layout Standard

O principal complicador na interação entre linguagens de programação não
 é a diferença de sintaxe ou semântica das construções de fluxo de controle,
 mas a representação dos dados.
 Na comunicação entre código escrito em duas linguagens diferentes, dados
 trafegam de várias formas: como parâmetros, atributos de objetos, elementos
 de estruturas de dados, etc.
\layout Standard

Freqüentemente, o formato como estes dados são representados difere.
 Em casos como este, há três possibilidades.
 A mais simples é expor o dado à linguagem de destino como uma entidade
 opaca.
 A linguagem de destino recebe apenas algum tipo de 
\emph on 
handle
\emph default 
 que permite identificar unicamente o dado em operações requisitadas posteriorme
nte.
 Esta abordagem é útil, por exemplo, se uma linguagem está apenas armazenando
 os dados para a outra, a fim de aproveitar estruturas de dados de mais
 alto nível que esta ofereça.
 
\layout Standard

Outra abordagem envolve realizar algum tipo de conversão dos dados do sistema
 de tipos de uma linguagem para o da outra.
 A duplicação que ocorre na conversão limita a aplicabilidade deste método,
 restringindo o seu uso tipicamente para tipos com volume pequeno de dados,
 como tipos numéricos e, em menor grau, strings.
 Finalmente, a linguagem de origem pode explicitamente oferecer facilidades
 na linguagem de destino para a manipulação destes dados, ou seja, uma linguagem
 oferecer uma API para a outra.
\layout Standard

C, por ser orientada à manipulação de ponteiros e estruturas, possui um
 conjunto pequeno de tipos básicos.
 Além disso, C é bastante liberal em relação à representação interna dos
 tipos estruturados, cabendo às diferentes plataformas definirem interfaces
 binárias (
\emph on 
application binary interfaces
\emph default 
, ABIs).
 Assim, mesmo em casos onde é possível li\SpecialChar \-
gar a código C diretamente utilizando
 tipos básicos compatíveis e convenções de chamada apropriadas (como em
 Free Pascal ou em diversos compiladores Fortran), uma biblioteca de 
\emph on 
bindings
\emph default 
 é usualmente necessária para tornar mais conveniente a manipulação de tipos
 mais complexos.
\layout Standard

Até nos tipos numéricos fundamentais, há vários cuidados que devem ser tomados.
 Algumas linguagens, como Smalltalk e Ruby, realizam conversão automática
 de inteiros para 
\begin_inset Quotes eld
\end_inset 

inteiros grandes
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 Em Ruby, particularmente, os inteiros primitivos têm 1 bit a menos de precisão
 do que o tamanho de palavra da máquina.
 Máquinas virtuais com representação de 
\emph on 
bytecodes
\emph default 
 independentes de arquitetura, como Java, precisam ainda lidar com conversão
 de 
\emph on 
endianness
\emph default 
 e formato de números de ponto flutuante.
\layout Standard

Tipos que envolvem uma quantidade maior de dados, como strings, trazem ainda
 preocupações com desempenho.
 Em diversos casos a representação interna usada para strings é a mesma
 que a usada em C, então uma opção é simplesmente passar ao código C um
 ponteiro para o endereço onde a string está armazenada, o que evita a cópia
 de dados, sob risco de permitir ao programa C modificar o conteúdo da string.
 Isto é uma possível fonte de erros, especialmente em linguagens como Lua,
 onde strings de conteúdo igual compartilham o mesmo espaço de memória.
 Expor ao código C ponteiros para endereços de memória dentro do ambiente
 de execução da outra linguagem pode trazer ainda problemas de concorrência,
 caso o ambiente em questão utilize múltiplas 
\emph on 
threads
\emph default 
.
\layout Standard

Ao expor ao código C dados de tipos estruturados, a conversão para um tipo
 de dado nativo de C, em muitos casos, não é uma opção.
 Além da questão da quantidade de dados, tipos estruturados em C são definidos
 estaticamente, não servindo assim para representar convenientemente dados
 de estrutura dinâmica, como objetos que podem ganhar ou perder atributos
 e até mesmo mudar de classe em tempo de execução.
 Mesmo em linguagens com tipos estáticos, como Java, a cópia de objetos
 não costuma ser uma opção interessante em função do volume de dados.
 A cópia de objetos estruturados costuma se restringir a operações específicas
 como manipulação de arrays de elementos primitivos.
\layout Standard

A alternativa para permitir que código C opere sobre dados estruturados,
 então, é fornecer uma a ele uma API que exponha, em forma de funções, as
 operações definidas sobre os tipos em questão.
 Isto evita também a necessidade de controlar a consistência entre duas
 cópias de uma mesma estrutura.
 Problemas de consistência, entretanto, podem ocorrer caso a API permita
 ao código C armazenar ponteiros para objetos da linguagem---isto torna
 necessário ao programador gerenciar explicitamente a sincronia entre os
 ponteiros e o ciclo de vida dos objetos, que podem estar sujeitos a coleta
 de lixo.
 A Seção 
\begin_inset LatexCommand \ref{sub:Coletores-de-lixo}

\end_inset 

 discute esta questão em mais detalhe.
\layout Standard


\color red
As abordagens empregadas em diferentes FLIs para expor estruturas C às suas
 linguagens de origem possuem diversas variações.
 A declaração de classes Ruby a partir de C se dá através de uma série de
 chamadas da API.
 
\layout Standard


\color red
Lua define tipos primitivos 
\emph on 
function
\emph default 
, 
\emph on 
userdata
\emph default 
 e 
\emph on 
lightuserdata
\emph default 
 que permitem armazenar ponteiros para funções e estruturas C.
 Um objeto 
\emph on 
lightuserdata
\emph default 
 corresponde a um ponteiro C simples; um objeto 
\emph on 
userdata
\emph default 
 pode ter associado a si uma 
\emph on 
metatable
\emph default 
: uma tabela contendo uma série de funções a serem usadas pelo ambiente
 de execução, de forma similar à estrutura 
\family typewriter 
PyTypeObject
\family default 

\begin_inset Foot
collapsed true

\layout Standard


\color red
Estas funções são usadas, por exemplo, para permitir ao programador liberar
 recursos quando o objeto é coletado (função 
\family typewriter 
__gc
\family default 
 na 
\emph on 
metatable
\emph default 
 Lua, 
\family typewriter 
dealloc
\family default 
 na estrutura 
\family typewriter 
PyTypeObject
\family default 
).
 
\end_inset 

.
 Um objeto é então construindo armazenando instâncias destes tipos em uma
 tabela Lua através de chamadas de API, de forma similar a Ruby.
\layout Section


\begin_inset LatexCommand \label{sub:Coletores-de-lixo}

\end_inset 

Coletores de Lixo
\layout Standard

A partir do momento em que código C ganha acesso a referências a dados armazenad
os no espaço de armazenamento de outra linguagem, sejam ponteiros ou identificad
ores, o programador deve levar em consideração as diferenças entre os modelos
 de gerência de memória envolvidos, já que código executado na outra linguagem
 pode liberar o dado (destruir o objeto, remover um elemento de uma estrutura).
 Em princípio, isto não é diferente da gerência de memória realizada normalmente
 pelo programador em C.
 Entretanto, a interação com algumas linguagens adiciona um complicador:
 mecanismos de coleta de lixo realizam liberação de dados da memória de
 forma implícita.
 O princípio fundamental da coleta de lixo dita que um objeto não é coletado
 caso haja algum elemento (variável, estrutura de dados) apontando para
 ele.
 Todavia, o mesmo não vale para o ambiente C: a presença de um ponteiro
 apontando para um objeto não garante que ele não será coletado, uma vez
 que o coletor de lixo não gerencia os ponteiros do código C.
\layout Standard

É preciso, então, indicar a partir do código C que os dados que continuam
 acessíveis por ele não devem ser coletados.
 De forma complementar, ao transferir o controle de objetos C para o domínio
 da outra linguagem---por exemplo, para armazená-los em uma estrutura de
 dados desta---é necessário indicar à linguagem como desalocar a memória
 da estrutura quando o coletor de lixo detectar que ela não está mais em
 uso.
 A forma como a FLI irá fornecer estas funcionalidades depende não só do
 projeto da API para C, mas também do modelo de coleta de lixo empregado
 pela implementação da linguagem.
\layout Standard


\color red
A API de Python retorna ao código C ponteiros para os objetos alocados pela
 máquina virtual.
 Como esta utiliza um coletor de lixo baseado em contagem de referências,
 o programador é obrigado então a controlar o número de referências dos
 ponteiros do tipo 
\family typewriter 
PyObject*
\family default 
 com macros 
\family typewriter 
Py_INCREF
\family default 
 e 
\family typewriter 
Py_DECREF
\family default 
.
 Além disso, tipos definidos pelo usuário através da API C devem implementar
 funções adicionais na sua estrutura 
\family typewriter 
PyTypeObject
\family default 
, para evitar ciclos na contagem de referência.
 Ruby, que utiliza um coletor 
\emph on 
mark-and-sweep
\emph default 
 
\begin_inset LatexCommand \cite{wilson-gc}

\end_inset 

, requer que classes definidas em C que armazenem outros objetos Ruby declarem
 uma função 
\family typewriter 
mark
\family default 
, que propague chamadas a 
\family typewriter 
rb_gc_mark
\family default 
 aos objetos internos da instância.
\layout Standard


\color red
Para reduzir a necessidade de controle explícito de referências, Java faz
 uma distinção entre referências globais e locais.
 Referências globais são explicitamente criadas com 
\family typewriter 
NewGlobalRef
\family default 
 e que permanecem válidas até serem explicitamente liberadas com 
\family typewriter 
DeleteGlobalRef
\family default 
.
 Referências locais, passadas ao código C pelas demais funções da API, não
 precisam ser explicitamente liberadas, mas assume-se que perdem a validade
 ao final da função C invocada via JNI.
 É relevante notar que a simplificação trazida por esta abordagem deve-se
 ao fato da máquina virtual Java estar controlando as invocações de código
 C.
 No caso oposto, quando a máquina Java é embutida em uma aplicação C, referência
s locais permanecem válidas até o encerramento da thread, fazendo com que
 na prática seja recomendável o programador liberar as referências explicitament
e com 
\family typewriter 
DeleteLocalRef
\family default 
.
\layout Standard


\color red
A abordagem adotada por Lua evita o problema de gerência de referências
 ao não expor ponteiros para os seus objetos ao código C e adotar uma API
 de pilha.
 O armazenamento de objetos Lua em estruturas de dados em C ainda é possível,
 utilizando índices de uma tabela global como referências e funções explícitas
 
\family typewriter 
luaL_ref
\family default 
 e 
\family typewriter 
luaL_unref
\family default 
, de forma análoga às referências globais em Java.
\layout Section

Modelos de Concorrência
\layout Standard

Outra possível fonte de incompatibilidade entre linguagens que deve ser
 tratada quando estas interagem é a diferença entre modelos de concorrência.
 C, em particular, não define construções de concorrência, sendo estas implement
adas através de bibliotecas.
 Ao mesmo tempo que isto traz grande flexibilidade à linguagem, implica
 também em problemas de portabilidade para linguagens que dependam da disponibil
idade de mecanismos de concorrência em C compatíveis com os modelos que
 elas utilizam.
\layout Standard

Por exemplo, APIs entre C e Java devem levar em conta o modelo de 
\emph on 
multithreading
\emph default 
 preemptivo adotado por Java.
 A JNI (
\emph on 
Java Native Interface
\emph default 
) 
\begin_inset LatexCommand \cite{liang-jni}

\end_inset 

 define funções para controlar exclusão mútua entre dados compartilhados
 entre C e Java.
 O programador deve tomar o cuidado de buscar o equilíbrio entre o tempo
 gasto bloqueando a máquina virtual acessando dados compartilhados e o tempo
 gasto realizando cópia de dados entre os ambientes para reduzir o compartilhame
nto.
\layout Standard

Outra situação em que o modelo de concorrência da linguagem demanda cuidados
 por parte do programador na integração com C ocorre no uso de co-rotinas
 em Lua.
 A combinação de dois recursos de Lua, multitarefa cooperativa com múltiplas
 pilhas de execução e a capacidade de alternar entre chamadas a funções
 Lua e C em uma pilha, traz consigo uma limitação: uma co-rotina não pode
 executar a operação de 
\emph on 
yield
\emph default 
 caso haja uma função C na sua pilha, uma vez que não há uma forma portável
 de alternar entre múltiplas pilhas em C 
\begin_inset LatexCommand \cite{moura-colua}

\end_inset 

.
 
\layout Section

Módulos Externos
\layout Standard

Uma das motivações mais freqüentes para integração com código C é o uso
 de bibliotecas externas.
 Expor uma biblioteca C através da FLI para acesso em uma linguagem pode
 incorrer no registro de centenas de funções.
 É comum definir também tipos de dados que dêem às estruturas definidas
 pela biblioteca uma aparência mais nativa, como por exemplo converter funções
 C que registram 
\emph on 
callbacks
\emph default 
 em métodos Ruby que aceitam blocos de código como parâmetro.
 Essas inicializações e adaptações são usualmente definidas em uma biblioteca
 de 
\emph on 
bindings
\emph default 
, que serve de ponte entre a linguagem e a biblioteca C encapsulando a interação
 com a FLI.
\layout Standard

Os padrões que ocorrem na produção de bindings são tão comuns que deram
 origem a programas visam automatizar o processo.
 Estes geradores de 
\emph on 
bindings
\emph default 
 costumam trabalhar a partir de alguma representação preparada para o seu
 uso, já que analisar os cabeçalhos C pode-se mostrar insuficiente: por
 exemplo, o programa muitas vezes não seria capaz de interpretar a intenção
 de uma construção como 
\family typewriter 
int**
\family default 
.
 SWIG 
\begin_inset LatexCommand \cite{beazley-swig}

\end_inset 

 é uma popular ferramenta multi-linguagem para geração de 
\emph on 
bindings
\emph default 
 de bibliotecas C e C++ que utiliza um formato próprio para descrição de
 interfaces.
 FLIs podem ainda utilizar geradores de 
\emph on 
stubs
\emph default 
 para poupar o programador de escrever código C repetitivo ou não portável.
 Java possui um gerador de cabeçalhos C contendo os protótipos dos métodos
 nativos a serem implementados.
 Pyrex 
\begin_inset LatexCommand \cite{ewing-pyrex}

\end_inset 

 é um gerador de módulos C para Python a partir de uma sintaxe baseada na
 própria linguagem Python.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

APIs de Máquinas Virtuais
\layout Standard


\emph on 
\color red
[TODO: OBJETIVO DESTE CAPÍTULO -> (texto a seguir do Plano de Trabalho da
 proposta) A partir dos requisitos levantados no capítulo anterior, pretende-se
 então classificar as facilidades oferecidas pelas APIs---suas funções,
 macros, estruturas---em função destes problemas.
 Ao cruzar estes dados, será possivel ter uma melhor compreensão de como
 estão distribuídos o tamanho e complexidade das APIs.
 Deseja-se saber o quão completas elas são em relação às funcionalidades
 que as linguagens oferecem, ou seja, o que é possível fazer via código
 nativo que não é possível ou não é prático via API.
 Com base nesta classificação, o passo seguinte será identificar, para cada
 problema, as abordagens gerais empregadas por cada API e assim expor com
 mais clareza as semelhanças e diferenças das APIs de diferentes linguagens.
 O objetivo é catalogar as técnicas empregadas de forma independente das
 implementações específicas, bem como o impacto que a escolha de uma determinada
 técnica na solução de um problema tem no espaço de alternativas para a
 solução dos demais.
 Espera-se que o fruto deste trabalho seja, através da documentação das
 práticas em uso corrente, proporcionar um base comum que facilite a avaliação
 e o desenvolvimento de interfaces entre linguagens de programação.]
\layout Standard

FLIs providas por máquinas virtuais são usualmente compreendidas como 
\begin_inset Quotes eld
\end_inset 

APIs de extensão
\begin_inset Quotes erd
\end_inset 

: elas servem ou para estender a máquina virtual com recursos não oferecidos
 por esta, ou para estender uma aplicação externa com os recursos oferecidos
 pela máquina virtual, embarcando-a nesta aplicação.
 O primeiro cenário é o utilizado no modelo de programação onde a coordenação
 de alto nível é realizada em uma linguagem interpretada e módulos compilados
 em linguagens como C e C++ são usados para acesso a bibliotecas externas
 ou implementação de partes onde o desempenho é crítico.
 O segundo cenário, via de regra, irá englobar também o primeiro, ao expor
 à máquina virtual embarcada extensões que a permitam comunicar-se com a
 aplicação hospedeira.
\layout Section

Transferência de dados
\layout Subsection

Python
\layout Standard

Para a conversão de dados de C para Python, a linguagem oferece uma série
 de funções que recebem variáveis de tipos primitivos de C como parâmetro,
 como 
\family typewriter 
PyString_FromStringAndSize
\family default 
 e 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Cada uma destas funções retorna ao código C um ponteiro para um novo objeto
 
\family typewriter 
PyObject
\family default 
.
 Dados passados para estas funções, como por exemplo strings, são copiados
 por Python.
 
\layout Standard

Para o retorno de dados de Python para C, um conjunto complementar de funções
 é oferecido, mapeando os tipos básicos de Python de volta a tipos de C.
 Alguns exemplos destas funções que recebem um ponteiro para um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam o dado correspondente em C são 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
, 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLongLong
\family default 
, 
\family typewriter 
PyComplex_\SpecialChar \-
RealAsDouble
\family default 
 e 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Diferentemente das funções de entrada, nas fun\SpecialChar \-
ções de saída as strings
 retornadas são ponteiros para a área armazenada internamente por Python.
 A documentação recomenda não modificar o conteúdo da string exceto no caso
 de esta área de memória haver sido recém alocada por uma chamada a 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
tamanho
\family typewriter 
\emph default 
)
\family default 
.
 Desta forma, é possível alocar uma string para armazenamento em Python
 e preenchê-la posteriormente através de código C, possivelmente através
 de uma seqüência de comandos.
 
\layout Standard

Para alguns de seus tipos básicos que não possuem correspondente direto
 em ANSI C 89, Python define tipos em C equivalentes: 
\family typewriter 
Py_UNICODE
\family default 
 e 
\family typewriter 
Py_complex
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Um tipo de dado para 
\begin_inset Quotes eld
\end_inset 

wide strings
\begin_inset Quotes erd
\end_inset 

, wchar_t, foi introduzido pela emenda de 1995 de ANSI C, e um tipo para
 números complexos, complex, no padrão ISO C 99.
\end_inset 

.
 Estes tipos foram adicionados com o objetivo de aumentar o desempenho de
 módulos Python para manipulação numérica ou de texto Unicode implementados
 em C, evitando conversões freqüentes de e para 
\family typewriter 
PyObject
\family default 
.
\layout Standard

Python oferece ainda algumas versões de funções de conversão para C implementada
s como macros sem a verificação de tipo, assumindo que o 
\family typewriter 
PyObject
\family default 
 passado será compatível.
 Estas funções podem ser identificadas pelos nomes em maiúsculas.
 As únicas macros de conversão oferecidas são 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
, 
\family typewriter 
PyFloat_\SpecialChar \-
AS_DOUBLE
\family default 
, 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
 e 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_DATA
\family default 
, além de macros especiais para obter valores dos campos de objetos 
\family typewriter 
PyDateTime_DateTime
\family default 
 e 
\family typewriter 
PyDateTime_Time
\family default 
.
\layout Standard

Além de funções para conversão de tipos entre Python e C, a API de Python
 oferece ainda algumas funções de conversão entre tipos de Python.
 Estas funções recebem um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam um novo 
\family typewriter 
PyObject
\family default 
 com o resultado da conversão, e são equivalentes a funções Python que realizam
 estas conversões (na verdade chamadas a tipos 
\family typewriter 
PyTypeObject
\family default 
 que respondem ao método 
\family typewriter 
__call__
\family default 
).
 A Figura 
\begin_inset LatexCommand \ref{cap:PyObject_Str}

\end_inset 

 demonstra a equivalência entre 
\family typewriter 
PyObject_Str
\family default 
 e 
\family typewriter 
str
\family default 
.
\layout Standard


\begin_inset Float figure
wide false
collapsed true

\layout LyX-Code


\size footnotesize 
#include <Python.h>
\layout LyX-Code


\size footnotesize 
PyObject *str;
\layout LyX-Code


\size footnotesize 
PyObject* my_PyObject_Str(PyObject* o) {
\layout LyX-Code


\size footnotesize 
   return PyObject_CallFunctionObjArgs(str, o, NULL);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
int main() {
\layout LyX-Code


\size footnotesize 
   PyObject *builtins_module, *builtins, *an_int, *a_str;
\layout LyX-Code


\size footnotesize 
   char *result; 
\layout LyX-Code


\size footnotesize 
   Py_Initialize();
\layout LyX-Code


\size footnotesize 
   builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
   builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
   str = PyDict_GetItemString(builtins, "str");
\layout LyX-Code


\size footnotesize 
   an_int = PyInt_FromLong(5556);
\layout LyX-Code


\size footnotesize 
   a_str = my_PyObject_Str(an_int);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(an_int);
\layout LyX-Code


\size footnotesize 
   result = PyString_AsString(a_str);
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", result);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(a_str);
\layout LyX-Code


\size footnotesize 
   Py_Finalize();
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:PyObject_Str}

\end_inset 

A implementação de uma função equivalente a PyObject_Str
\end_inset 


\layout Standard

Para referenciar-se a objetos Python a partir de código C, é preciso obter
 uma referência a um objeto onde ele esteja contido.
 Variáveis são armazenadas em um 
\emph on 
ambiente
\emph default 
, representado como um dicionário.
 Funções como 
\family typewriter 
PyRun_File
\family default 
 recebem, entre seus parâmetros, um dicionário de variáveis globais e outro
 de variáveis locais.
 O ambiente 
\emph on 
top-level
\emph default 
 é identificado através do módulo 
\family typewriter 
__main__
\family default 
.
 Objetos 
\emph on 
built-in
\emph default 
 são acessíveis através do módulo 
\family typewriter 
__builtin__
\family default 
, como pode também ser observado na Figura 
\begin_inset LatexCommand \ref{cap:PyObject_Str}

\end_inset 

 ao obter-se uma referência para 
\family typewriter 
str
\family default 
.
 Funções C chamadas a partir de Python não recebem referências ao ambiente
 além dos parâmetros da chamada da função (que podem incluir o objeto 
\family typewriter 
self
\family default 
).
 Para evitar a busca dos dicionários de globais e 
\emph on 
built-ins
\emph default 
, o programador deve tipicamente recorrer a armazená-los em ponteiros globais
 em C.
 
\layout Standard

O armazenamento de dados de C no espaço de objetos de Python pode ser feito
 de duas formas.
 Uma maneira consiste em criar um objeto do tipo 
\family typewriter 
CObject
\family default 
 a partir de um ponteiro C qualquer, construindo assim um valor opaco para
 Python.
 As funções de construção deste tipo, 
\family typewriter 
PyCObject_\SpecialChar \-
FromVoidPtr
\family default 
 e 
\family typewriter 
PyCObject_\SpecialChar \-
FromVoidPtrAndDesc
\family default 
, permitem associar ao dado uma função C a ser chamada quando o 
\family typewriter 
CObject
\family default 
 for desalocado.
 Segundo a documentação de Python, 
\family typewriter 
CObject
\family default 
s têm como objetivo principal permitir a passagem de dados em C de um módulo
 de extensão para outro 
\begin_inset LatexCommand \cite{pyvhll_cobjects}

\end_inset 

.
\layout Standard

A outra forma consiste em declarar novos tipos Python através de estruturas
 em C.
 Para isto, deve-se definir uma 
\emph on 
struct
\emph default 
 C com um cabeçalho definido pela macro 
\family typewriter 
PyObject_HEAD
\family default 
, seguido de atributos definidos pelo usuário 
\begin_inset LatexCommand \cite{vanrossum-extpy}

\end_inset 

, que será usada para alocar instâncias do novo tipo.
 Em seguida, define-se uma instância de 
\family typewriter 
PyTypeObject
\family default 
, onde podem-se passar ponteiros para as funções C a serem usadas pelo ambiente
 de execução Python como metamétodos, para operações como 
\family typewriter 
__call__
\family default 
 e 
\family typewriter 
__getattr__
\family default 
.
 Funções C podem ser associadas ao novo tipo como métodos, declarando-os
 em estruturas 
\family typewriter 
PyMethodDef
\family default 
 e realizando chamadas a 
\family typewriter 
PyDescr_NewMethod
\family default 
.
 
\layout Subsection

Java
\layout Standard

A JNI define no cabeçalho 
\family typewriter 
jni.h
\family default 
 tipos em C equivalentes a cada um dos tipos primitivos de Java (
\family typewriter 
jint
\family default 
 para 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 para 
\family typewriter 
float
\family default 
, e assim por diante).
 Os 
\begin_inset Quotes eld
\end_inset 

tipos de referências
\begin_inset Quotes erd
\end_inset 

, como classes e objetos, são expostos a C como referências opacas, instâncias
 de 
\family typewriter 
jobject
\family default 
.
 Strings e arrays também são objetos em Java e são portanto também expostos
 como instâncias de
\family typewriter 
 jobject
\family default 
.
 Entretanto, a JNI define como conveniência alguns tipos em C que agem como
 
\begin_inset Quotes eld
\end_inset 

subtipos
\begin_inset Quotes erd
\end_inset 

 de 
\family typewriter 
jobject
\family default 
: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, além de um tipo array para cada tipo primitivo (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
\layout Standard

Diferentes métodos são utilizados para a leitura de tipos prmitivos, strings,
 arrays e outros objetos.
 A leitura do conteúdo de uma 
\family typewriter 
jstring
\family default 
 em C requer a conversão do formato interno usado por Java, UTF-16.
 A API oferece uma função utilitária que aloca uma string contendo a representaç
ão do texto em UTF-8 (formato compatível com ASCII), 
\family typewriter 
GetStringUTFChars
\family default 
.
 Esta string deve ser posteriormente desalocada com 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
 A função 
\family typewriter 
GetStringChars
\family default 
 permite acesso direto à string em formato UTF-16; ela possui um parâmetro
 adicional que 
\emph on 
retorna
\emph default 
 se a string retornada é o 
\emph on 
buffer
\emph default 
 interno da JVM ou uma cópia.
 Ao mesmo tempo que isto permite ao código C evitar duplicação da string
 nos casos onde deseja-se modificá-la e a JVM tenha optado por retornar
 uma cópia, tal parâmetro expõe na API questões de baixo nível da gerência
 de strings na JVM.
 Alternativamente, as funções 
\family typewriter 
GetStringRegion
\family default 
 e 
\family typewriter 
GetStringUTFRegion
\family default 
 realizam a cópia da string para um buffer pré-alocado pelo programador.
 
\family typewriter 
GetStringCritical
\family default 
 permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
 cuidados especiais em relação à coleta de lixo, discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays de elementos primitivos são tratados diferentemente de arrays de
 objetos
\begin_inset Foot
collapsed true

\layout Standard

Arrays multi-dimensionais são considerados 
\begin_inset Quotes eld
\end_inset 

arrays de arrays
\begin_inset Quotes erd
\end_inset 

 e, portanto, são, exceto na última dimensão, também arrays de objetos.
\end_inset 

.
 Arrays de elementos primitivos são tratados de forma similar a strings.
 Há funções para realizar a cópia de arrays (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayRegion
\family default 
), funções que retornam ponteiros para o array podendo ou não realizar cópias,
 de forma similar a 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) e que podem acessar o buffer interno da JVM diretamente, como em 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
).
 Para arrays de objetos, é possível apenas obter elementos do array, sob
 forma de referências 
\family typewriter 
jobject
\family default 
, um a um, com 
\family typewriter 
GetObjectArrayElement
\family default 
.
\layout Standard

A obtenção de valores de atributos se dá através de métodos como 
\family typewriter 
GetObjectField
\family default 
 e 
\family typewriter 
GetStaticField
\family default 
, que retornam referências do tipo 
\family typewriter 
jobject
\family default 
.
 Para cada um dos tipos primitivos existe uma chamada equivalente, como
 
\family typewriter 
GetIntField
\family default 
 e 
\family typewriter 
GetStaticIntField
\family default 
.
 Todas estas funções recebem como parâmetro um 
\emph on 
identificador de campo
\emph default 
.
 Apesar de a linguagem Java definir uma classe 
\family typewriter 
java.lang.reflect.Field
\family default 
, os identificadores de campo são valores C do tipo 
\family typewriter 
jfieldID
\family default 
.
 Estes valores são obtidos com uma chamada a 
\family typewriter 
GetFieldID
\family default 
, que recebe entre seus parâmetros uma string chamada de 
\begin_inset Quotes eld
\end_inset 

descritor de campo JNI
\begin_inset Quotes erd
\end_inset 

 com uma sintaxe especial.
 Por exemplo, o tipo 
\family typewriter 
int[][]
\family default 
 é descrito com 
\family typewriter 
"[[I"
\family default 
 e o tipo java.lang.String como 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este é outro ponto onde detalhes da implementação transparecem na API.
 Não por coincidência, esta sintaxe é a mesma usada na representação interna
 de tipos em 
\emph on 
bytecodes
\emph default 
 da JVM.
\end_inset 

.
 A Figura 
\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

 demonstra o acesso de um atributo Java a partir de C.
 É possível ainda obter um jfieldID a partir de um objeto Field usando a
 função 
\family typewriter 
FromReflectedField
\family default 
.
\layout Standard


\begin_inset Float figure
wide false
collapsed true

\layout LyX-Code


\size footnotesize 
public class ExemploJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elementos = { "Terra", "Ar", "Fogo", "Agua" };
\layout LyX-Code


\size footnotesize 
   private native void segundoElemento();
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
      new ExemploJNI().segundoElemento();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExemploJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code
\align center 

\family roman 
\size footnotesize 
(a) ExemploJNI.java
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExemploJNI.h"
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExemploJNI_segundoElemento(JNIEnv *J, jobject this) {
\layout LyX-Code


\size footnotesize 
   jclass classe = (*J)->GetObjectClass(env, this);
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(env, classe,
\layout LyX-Code


\size footnotesize 
      "elementos", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(env, this, elemsID);
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(env, elems, 1);
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(env, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(env, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code
\align center 

\family roman 
\size footnotesize 
(b) ExemploJNI.c
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

Acesso a atributos Java em C via JNI
\end_inset 


\layout Standard

A manipulação de objetos do tipo 
\family typewriter 
Class
\family default 
 também é feita através de funções específicas.
 É possível criar uma nova classe Java em tempo de execução a partir da
 API C usando a função 
\family typewriter 
DefineClass
\family default 
, que recebe um buffer contendo a representação de uma classe Java pré-compilada.
 Referências do tipo 
\family typewriter 
jclass
\family default 
 podem ser obtidas através do nome da classe usando 
\family typewriter 
FindClass
\family default 
, que utiliza uma sintaxe de descritores de classe similar à de descritor
 de campos usada por 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Tanto em descritores de classe como de campo, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 representam 
\family typewriter 
String[]
\family default 
.
 Para o tipo 
\family typewriter 
String
\family default 
, entretanto, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 é o descritor de campo e 
\family typewriter 
"java/lang/String"
\family default 
 o de classe.
\end_inset 

.
\layout Standard

Para o armazenamento de valores de C que podem ser convertidos para tipos
 primitivos de Java, a JNI possui funções como 
\family typewriter 
SetIntField
\family default 
 e 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 Para os demais tipos, não há uma provisão específica para o armazenamento
 de dados de C no espaço de objetos de Java.
 Nestes casos, a documentação recomenda o armazenamento de ponteiros em
 tipos numéricos, apesar dos problemas de portabilidade em que tal abordagem
 incorre.
\layout Subsection

Ruby
\layout Standard

Para a comunicação de dados entre Ruby e C, a API de Ruby define um tipo
 de dados em C chamado 
\family typewriter 
VALUE
\family default 
, que referencia um objeto Ruby.
 
\family typewriter 
VALUE
\family default 
 pode representar tanto uma referência para um objeto (isto é, um ponteiro
 para a 
\emph on 
heap
\emph default 
 de Ruby) como um valor imediato.
 Em particular, as constantes 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 e 
\family typewriter 
Qnil
\family default 
 são definidas como valores imediatos, permitindo a comparação destas usando
 
\family typewriter 
==
\family default 
.
 Para os tipos numéricos, a conversão entre C e Ruby é feita através de
 macros como 
\family typewriter 
INT2NUM
\family default 
 e de funções como 
\family typewriter 
rb_float_new
\family default 
, que recebem ou retornam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

Para a passagem de strings para Ruby a partir de C, são oferecidas as funções
 
\family typewriter 
rb_str_new
\family default 
, que recebe um ponteiro e um argumento numérico de tamanho, de modo a permitir
 a passagem de strings contendo caracteres nulos, e 
\family typewriter 
rb_str_new2
\family default 
, que assume uma string padrão de C, com o caracter nulo como terminador.
 
\family typewriter 
VALUE
\family default 
s que apontam para strings de Ruby permitem acessar o seu conteúdo através
 do 
\emph on 
cast
\emph default 
 
\family typewriter 
RSTRING(uma_string)->ptr
\family default 
.
 Todavia, a API recomenda o uso da macro 
\family typewriter 
StringValue
\family default 
, que retorna o próprio 
\family typewriter 
VALUE
\family default 
 passado caso este seja uma string, ou um novo 
\family typewriter 
VALUE
\family default 
 da classe String produzido através do método de conversão 
\family typewriter 
to_s
\family default 
 aplicado ao objeto passado (ou ainda causar uma exceção 
\family typewriter 
TypeError
\family default 
 caso a conversão não seja possível).
 Sob a justificativa de aumentar o desempenho no acesso, alguns outros tipos
 de Ruby como 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 e 
\family typewriter 
File
\family default 
 permitem este tipo de acesso de baixo nível aos membros das estruturas
 utilizadas na implementação dos objetos.
 Por exemplo, 
\family typewriter 
RARRAY(um_array)->len
\family default 
 permite ler o tamanho de um array diretamente.
 A recomendação da API é utilizar este tipo de acesso somente para leitura,
 já que a alteração destes valores pode facilmente tornar o estado interno
 dos objetos inconsistente.
\layout Standard

A API permite criar classes a partir de C através da função 
\family typewriter 
rb_define_class
\family default 
.
 Esta função recebe uma string C com o nome da nova classe e um 
\family typewriter 
VALUE
\family default 
 a ser usado como superclasse (como por exemplo a constante C 
\family typewriter 
rb_cObject
\family default 
, que representa a classe Ruby 
\family typewriter 
Object
\family default 
) e retorna um novo 
\family typewriter 
VALUE
\family default 
 representando a nova classe.
 Esta nova referência pode então ser usada como parâmetro em chamadas de
 de 
\family typewriter 
rb_define_method
\family default 
, que adiciona um método à classe recebendo um ponteiro para função C como
 parâmetro, e 
\family typewriter 
rb_class_new_instance
\family default 
, que produz novos objetos Ruby que são instâncias da classe.
 Como em código Ruby, a declaração de atributos de objetos é feita no método
 
\family typewriter 
initialize
\family default 
, que pode ser implementado em C.
\layout Standard

O acesso a objetos Ruby se dá através da família de funções 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
, que retornam 
\family typewriter 
VALUE
\family default 
s.
 As funções 
\family typewriter 
rb_iv_get
\family default 
 e 
\family typewriter 
rb_ivar_get
\family default 
 obtêm atributos de objetos (
\emph on 
instance variables
\emph default 
), A primeira forma usa strings C como nomes, a segunda usa 
\family typewriter 
ID
\family default 
s, identificadores que substituem strings internalizadas na tabela de símbolos
 de Ruby, que podem ser obtidos usando a função 
\family typewriter 
rb_intern
\family default 
.
 Diferentemente de 
\family typewriter 
jfieldID
\family default 
s de Java, que contêm informação de tipo, 
\family typewriter 
ID
\family default 
s de Ruby meramente correspondem a uma string: um mesmo 
\family typewriter 
ID
\family default 
 pode ser usado para referenciar-se a atributos de objetos de classes diferentes
 que tenham o mesmo nome.
 Há ainda as funções 
\family typewriter 
rb_cv_get
\family default 
 e 
\family typewriter 
rb_cvar_get
\family default 
 para atributos de classes, 
\family typewriter 
rb_gv_get
\family default 
 para variáveis globais e 
\family typewriter 
rb_const_get
\family default 
 para constantes.
 Para cada uma destas, há uma função 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 análoga.
\layout Standard

Para o armazenamento de dados de C no espaço de objetos de Ruby, a API oferece
 uma macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, que recebe um ponteiro C e cria um objeto Ruby que armazena este ponteiro.
 O ponteiro pode ser acessado a partir de código C usando 
\family typewriter 
Data_Get_Struct
\family default 
, mas não a partir de Ruby.
 Para classes cujas instâncias irão conter dados de C, é possível associar
 a uma classe uma função C responsável por realizar a alocação de memória
 das instâncias usando a função 
\family typewriter 
rb_define_alloc_func
\family default 
.
 Definindo uma função de alocação desta forma e implementando um método
 
\family typewriter 
initialize_copy
\family default 
, torna-se possível implementar classes Ruby em C compatíveis com as rotinas
 de cópia de objetos 
\family typewriter 
dup
\family default 
 e 
\family typewriter 
clone
\family default 
.
\layout Subsection

Lua
\layout Standard

A API de Lua define uma abordagem diferente para a manipulação de dados
 em C: não são expostos ao código C ponteiros ou 
\emph on 
handles
\emph default 
 para objetos Lua.
 As operações são definidas em termos de índices de uma pilha virtual.
 Assim, a transferência de dados de C para Lua se dá através de funções
 que recebem tipos de C, os convertem para valores Lua e os empilham, como
 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 e 
\family typewriter 
lua_pushlstring
\family default 
.
 Diversas operações da API operam sobre o valor no topo da pilha, como por
 exemplo 
\family typewriter 
lua_setglobal
\family default 
.
 A maioria das funções de consulta, entretanto, permitem especificar um
 índice qualquer da pilha (com valores positivos para indexação a partir
 da base e negativos para índices a partir do topo).
\layout Standard

A conversão de dados de Lua para C é feita através de funções como lua_tonumber
 e lua_tolstring, que recebem um índice da pilha, convertem o valor no índice
 para o tipo Lua especificado, e retornam o valor no tipo C equivalente.
 Números têm o tipo C 
\family typewriter 
lua_Number
\family default 
, que corresponde a 
\family typewriter 
double
\family default 
 por padrão mas é um parâmetro na compilação de Lua.
 Strings, em particular, são objetos imutáveis e têm sua representação internali
zada: duas strings de conteúdo idêntico compartilham a mesma representação
 interna.
 Para tornar mais eficiente a construção de strings Lua a partir de C, a
 biblioteca auxiliar define um tipo C 
\family typewriter 
luaL_Buffer
\family default 
 e funções como 
\family typewriter 
luaL_addstring
\family default 
 e 
\family typewriter 
luaL_addvalue
\family default 
, que permitem a construção de uma string em etapas até que ela possa ser
 finalmente convertida para uma string Lua com 
\family typewriter 
luaL_pushresult
\family default 
.
\layout Standard

Lua define dois tipos de dados específicos para o armazenamento de dados
 para C, 
\emph on 
full userdata
\emph default 
 e 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 descrevem blocos de memória gerenciados por Lua e utilizados por código
 C.
 Eles existem em Lua como objetos opacos, e são criados por 
\family typewriter 
lua_newuserdata
\family default 
, que insere o novo objeto na pilha de Lua e retorna a C um ponteiro com
 a área de memória do tamanho requisitado.
 Objetos do tipo 
\emph on 
light userdata
\emph default 
, criados através de 
\family typewriter 
lua_pushlightuserdata
\family default 
, permitem armazenar ponteiros de C em Lua; a alocação e gerência do bloco
 de memória ficam a cargo do código C.
 
\layout Standard

A área de armazenamento da pilha não se ajusta dinamicamente e as funções
 da API não realizam controle de 
\emph on 
overflow
\emph default 
.
 Assim, o programador é responsável por controlar o tamanho da pilha, através
 da função 
\family typewriter 
lua_checkstack
\family default 
.
 Na prática, o tamanho da pilha só irá crescer na ocorrência de laços empilhando
 elementos, já que seqüências típicas de operações tendem a empilhar valores
 e desempilhá-los em seguida.
\layout Standard

Tabelas são o único tipo para construção de estruturas de dados em Lua.
 Lua oferece uma API completa para manipulação de tabelas a partir de C.
 Tabelas podem ser criadas com 
\family typewriter 
lua_newtable
\family default 
 ou 
\family typewriter 
lua_createtable
\family default 
; a segunda forma permite pré-alocar memória para os elementos da tabela.
 As funções 
\family typewriter 
lua_gettable
\family default 
 e 
\family typewriter 
lua_settable
\family default 
 implementam a semântica de leitura e atribuição de campos em uma tabela
 em Lua, incluindo a possível chamada a metamétodos; para chamadas sem a
 invocação de metamétodos existem as funções 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, equivalentes a 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 em Lua (além das variantes 
\family typewriter 
lua_rawgeti
\family default 
 e 
\family typewriter 
lua_rawseti
\family default 
 para conveniência).
 Há ainda a função 
\family typewriter 
lua_next
\family default 
, equivalente à função Lua 
\family typewriter 
next
\family default 
, que permite percorrer os elementos de uma tabela.
\layout Standard

Diversos conceitos de Lua são representados através de tabelas -- ambiente
 global, metatabelas, 
\emph on 
registry
\emph default 
 -- e são assim manipulados usando as funções da API para gerência de tabelas.
 A tabela do ambiente global da 
\emph on 
thread
\emph default 
 em execução pode ser acessada através de um índice especial da pilha virtual,
 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 Pode-se ainda definir uma tabela de ambiente da função, indexada em 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, para isolar dados a serem compartilhados internamente em funções de módulos
 escritos em C.
 
\layout Standard

Embora referências explícitas para objetos não sejam manipuladas na API,
 algumas funções retornam ponteiros para estruturas gerenciadas por Lua:
 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_push
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_touserdata
\family default 
 e 
\family typewriter 
lua_topointer
\family default 
.
 Esta última função permite obter ponteiros para alguns tipos de objetos
 (
\emph on 
userdata
\emph default 
, tabelas, 
\emph on 
threads
\emph default 
 e funções), mas somente com o objetivo de obter informação para depuração,
 já que não é possível converter o ponteiro de volta para um valor Lua.
 A validade dos ponteiros retornados por estas funções é dependente do tempo
 de vida do objeto correspondente a eles; para strings em particular, o
 ponteiro retornado só é garantidamente válido enquanto o dado estiver na
 pilha.
\layout Subsection

Perl
\layout Standard

como transferir dados de C para L
\layout Standard

como transferir dados de L para C
\layout Standard

conversões em L
\layout Standard

como encontrar dados (resolver nomes)
\layout Standard

como guardar dados de C em L
\layout Section

Coleta de lixo
\layout Subsection

Python
\layout Standard

que dados sobrevivem durante uma função
\layout Standard

* borrowed references
\layout Standard

como salvar dados de L em estruturas C
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

que dados sobrevivem durante uma função
\layout Standard

* Get/ReleaseStringCritical ( http://java.sun.com/docs/books/jni/html/objtypes.html
#30934 )
\layout Standard

* DeleteLocalRef em loops, Push/PopLocalFrame, comparar com Lua 2/3.x?
\layout Standard

como salvar dados de L em estruturas C
\layout Subsection

Ruby
\layout Standard

* Segredo da mágica de VALUEs locais em Ruby (ruby-core 7983), incluindo
 setjmp pra forçar flush de registradores.
\layout Standard

* 
\family typewriter 
Data_Wrap_Struct
\family default 
,recebe como parâmetros ponteiros para duas funções C a serem chamadas pelo
 coletor de lixo 
\layout Standard

* Ruby oferece ainda wrappers para a função 
\family typewriter 
malloc
\family default 
 que interagem com o coletor de lixo.
\layout Standard

que dados sobrevivem durante uma função
\layout Standard

como salvar dados de L em estruturas C
\layout Subsection

Lua
\layout Standard

que dados sobrevivem durante uma função
\layout Standard

como salvar dados de L em estruturas C
\layout Standard

* permite especificar um alocador
\layout Standard

* gc de full x light userdata
\layout Subsection

Perl
\layout Standard

que dados sobrevivem durante uma função
\layout Standard

como salvar dados de L em estruturas C
\layout Section

Chamada de funções
\layout Subsection

Python
\layout Standard

como chamar uma função L em C
\layout Standard

como chamar uma função C em L
\layout Subsection

Java
\layout Standard

* Apesar de métodos em Java poderem ser representados como objetos da classe
 java.lang.Method, para fins de realização de chamadas, métodos não são expostos
 na JNI como jobjects, mas como 
\begin_inset Quotes eld
\end_inset 

IDs
\begin_inset Quotes erd
\end_inset 

, do tipo jmethodID.
 
\layout Standard

* Caching de IDs pode ser necessário para assegurar-se que o método correto
 é chamado.
\layout Standard

como chamar uma função L em C
\layout Standard

como chamar uma função C em L
\layout Subsection

Ruby
\layout Standard

como chamar uma função L em C
\layout Standard

como chamar uma função C em L
\layout Subsection

Perl
\layout Standard

como chamar uma função L em C
\layout Standard

como chamar uma função C em L
\layout Subsection

Lua
\layout Standard

como chamar uma função L em C
\layout Standard

como chamar uma função C em L
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de Caso: LibScript
\layout Standard


\emph on 
\color red
[TODO: Explicar a intenção do estudo de caso]
\layout Standard

LibScript é uma biblioteca projetada para permitir a adição de extensibilidade
 a aplicações através de 
\emph on 
scripting
\emph default 
 de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo que desacopla a aplicação em si das máquinas virtuais providas
 pelas diversas linguagens.
 A biblioteca principal, 
\family typewriter 
libscript
\family default 
, é uma fina camada que provê uma API para 
\emph on 
scripting
\emph default 
 independente de linguagem, permitindo à aplicação registrar as suas funções
 e invocar código a ser executado.
 Esta biblioteca, então invoca o 
\emph on 
plugin
\emph default 
 apropriado (
\family typewriter 
libscript-python
\family default 
, 
\family typewriter 
libscript-ruby
\family default 
, 
\family typewriter 
libscript-lua
\family default 
, etc.) para rodar o código.
 Desta forma, a aplicação permite ao usuário utilizar qualquer uma destas
 linguagens para scripting sem adicionar todas elas como suas dependências.
\layout Standard


\emph on 
\color red
[TODO: juntar o parágrafo acima ao texto abaixo para obter uma introdução
 para o capítulo de LibScript.]
\layout Standard

Uma FLI age como uma ponte de dois sentidos: ela deve expor os tipos de
 dados e permitir chamada de código de C à linguagem, e expor os tipos de
 dados e permitir chamada de código da linguagem a C.

\color red
 
\emph on 
[Serão esses os 
\begin_inset Quotes eld
\end_inset 

quatro objetivos
\begin_inset Quotes erd
\end_inset 

 principais de uma FLI? Mapear APIs das linguagens estudadas dentro desses
 2 grandes grupos (cada um com 2 sub-grupos)?]
\layout Standard


\emph on 
\color red
[TODO: deixar o texto apresentável :) ]
\color default
 
\emph default 
O objetivo geral de LibScript é tornar aplicações 
\begin_inset Quotes eld
\end_inset 

scriptable
\begin_inset Quotes erd
\end_inset 

 de modo independente de linguagem.
 Os objetivos específicos são: (a) expor os dados e permitir chamada de
 código de C de uma aplicação aos scripts; (b) construir um espaço de nomes
 que possa ser acessado de forma comum entre as diferentes máquinas virtuais,
 para que scripts escritos em diferentes linguagens possam interagir.
\layout Standard

Para que o segundo objetivo seja atingido, é necessário que mudanças no
 espaço de nomes ocorridas externamente a uma VM, seja pelo código C ou
 por outra máquina virtual, sejam refletidas transparentemente na representação
 local do espaço de nomes desta VM.
 Para que isto ocorra, deve ser possível realizar um certo grau de metaprogramaç
ão através da FLI.
 Em particular, deve ser possível capturar chamadas a funções não definidas
 e resolver estas chamadas através de código C.
 
\layout Standard

O primeiro objetivo implementa um dos sentidos da comunicação realizada
 por uma FLI.
 O segundo objetivo é similar ao sentido inverso no que permite a chamada
 de código da linguagem, mas não contempla a exposição dos tipos de dados:
 estruturas de dados não oferecidas por C podem ser manipulados apenas como
 tipos opacos, já que os conjuntos de funcionalidades a ser exposta ao mapear
 os tipos de dados específicos de cada linguagem variam muito entre si.
 
\layout Standard


\emph on 
\color red
[Um aspecto ainda um tanto nebuloso nessa classificação é a 
\begin_inset Quotes eld
\end_inset 

definição de novos tipos para a linguagem a partir de C
\begin_inset Quotes erd
\end_inset 

.
 Python e Ruby permitem criar em C classes que por sua vez produzem instâncias
 na VM.
 Lua permite criar tabelas, mas estas 
\emph default 
são
\emph on 
 instâncias na VM.
 Mesmo uma FLI simplista do tipo 'tudo via string' permite criar tipos complexos
 (
\begin_inset Quotes eld
\end_inset 

x = { foo=4, bar=2 }
\begin_inset Quotes erd
\end_inset 

), mas possivelmente não obtê-los, a não ser que ganhem uma representação
 como 
\emph default 
handle
\emph on 
 (registro de Lua como exemplo de manipulação de objetos da VM via 
\emph default 
handles
\emph on 
).]
\layout Section

A Camada Independente de Linguagem
\layout Standard


\emph on 
\color red
[TODO: reler esta seção, contextualizá-la]
\layout Standard

A API oferecida pela biblioteca deve ser independente de linguagem e isolar
 a aplicação das diferentes APIs oferecidas pelas linguagens de scripting.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas.
 Isto seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Uma abordagem mais interessante é, ao invés de expor a API da linguagem
 à aplicação, expor apenas uma API de funções da aplicação para a linguagem
 e manter as estruturas de dados e recursos desta restrito ao domínio que
 será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em 
\begin_inset LatexCommand \cite{ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{pyvhll_ext,pyvhll_ref}

\end_inset 

.
\layout Standard

Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python 
\begin_inset LatexCommand \cite{pyvhll_ref}

\end_inset 

, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby 
\begin_inset LatexCommand \cite{ext_ruby}

\end_inset 

, 
\family typewriter 
perl_eval_sv
\family default 
 em Perl 
\begin_inset LatexCommand \cite{perlembed}

\end_inset 

 , 
\family typewriter 
TclEval
\family default 
 em Tcl 
\begin_inset LatexCommand \cite{tcl}

\end_inset 

.
 No caso de Java, uma vez que o compilador e a máquina virtual não são combinado
s, não há uma primitiva deste tipo, embora seja possível carregar dinamicamente
 arquivos pré-compilados para execução através da classe 
\family typewriter 
ClassLoader
\family default 
.
 Alternativamente, scripting em Java pode ser oferecido adicionando-se um
 compilador Java 
\emph on 
embedded
\emph default 
 como o Janino 
\begin_inset LatexCommand \cite{janino}

\end_inset 

.
\layout Section

API de LibScript
\layout Standard


\emph on 
\color red
[TODO: reorganizar o texto dessa seção pra ser menos bullet-centric, incluindo
 parágrafos sobre o design geral de cada parte.
 Jogar esse 
\begin_inset Quotes eld
\end_inset 

reference guide
\begin_inset Quotes erd
\end_inset 

 para um Apêndice?]
\layout Subsection

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ambiente.
 Um ambiente define um espaço de funções a serem expostas à biblioteca e
 de 
\begin_inset Quotes eld
\end_inset 

estados
\begin_inset Quotes erd
\end_inset 

 de plugins carregados.
 Assim, várias máquinas virtuais podem estar carregadas em um ambiente.
 O parâmetro 
\family typewriter 
namespace
\family default 
 refere-se ao identificador a ser inicializado no espaço de nomes da máquina
 virtual para armazenar as funções expostas.
 
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente.
\layout Subsection

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo de funções a serem registradas no ambiente.
 Tipicamente será uma função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente.
\layout Itemize


\family typewriter 
double script_in_double(script_env* env)
\newline 
int script_in_int(script_env* env)
\newline 
const char* script_in_string(script_env* env)
\family default 

\newline 
Obtêm parâmetros do ambiente.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada, em ordem.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_in_string
\family default 
, é retornada uma referência que pertence ao ambiente.
 O código deve realizar uma cópia caso queira modificar a string.
\layout Itemize


\family typewriter 
script_type script_in_type(script_env* env)
\newline 
int script_param_count(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_in_type
\family default 
 obtém o tipo do próximo parâmetro a ser obtido com a função 
\family typewriter 
script_in_*
\family default 
 e 
\family typewriter 
script_param_count
\family default 
 retorna o número de parâmetros disponíveis para consumo.
\layout Itemize


\family typewriter 
void script_out_double(script_env* env, double value)
\newline 
void script_out_int(script_env* env, int value)
\newline 
void script_out_string(script_env* env, const char* value)
\newline 

\family default 
Inserem parâmetros no ambiente.
 Estas funções permitem retornar os valores de saída.
 Ao final de uma função 
\emph on 
wrapper
\emph default 
, os valores de retorno da função devem ser passados com chamadas a estas
 funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Standard

As funções 
\family typewriter 
script_{in,out}_*
\family default 
 também devem são utilizadas na implementação dos plugins, de maneira inversa:
 antes de chamar o 
\emph on 
wrapper
\emph default 
, o plugin registra no ambiente os valores de entrada (devidamente convertidos
 para C) usando as funções 
\family typewriter 
out
\family default 
, e após a chamada, repassa o retorno para a máquina virtual obtendo os
 valores usando as funções 
\family typewriter 
in
\family default 
.
\layout Subsection

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_out_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_in_*
\family default 
.
 
\emph on 
\color red
[Na implementação atual,]
\emph default 
\color default
 Inicialmente, a tabela de funções C é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas no namespace definido para a LibScript na máquina
 virtual da linguagem (isto é, no nome criado com 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\family default 

\newline 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
\layout Subsection

Funções para Implementação de Plugins
\layout Itemize


\family typewriter 
script_fn script_get_function(script_env* env, const char* name)
\family default 

\newline 
Localiza uma função no ambiente.
 Na implementação atual, todos os plugins estão fazendo o registro de funções
 na máquina virtual sob demanda: na inicialização, um objeto é criado com
 o nome do 
\emph on 
namespace
\emph default 
 do ambiente (uma tabela em Lua, um módulo em Python e Ruby) e acessos a
 funções deste objeto são resolvidas chamando esta função.
\layout Itemize


\family typewriter 
void script_set_error_message(script_env* env, const char* message)
\family default 

\newline 
Define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
void script_start_params(script_env* env)
\family default 

\newline 
Usada para zerar a lista interna de parâmetros de entrada e saída.
 Deve ser usada na implementação da chamada de funções para garantir que
 parâmetros que não tenham sido consumidos sejam removidos.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Standard

Para linguagens que precisem carregar todas as funções na máquina virtual
 durante a inicialização do plugin, será necessário adicionar alguma funcionalid
ade que permita iterar sobre a lista de funções registradas.
\layout Subsection

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\emph on 
lang
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente deve ser exposto
 à máquina virtual de alguma forma apropriada para a linguagem (como uma
 tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\emph on 
lang
\emph default 
(script_plugin_state state, char* programtext)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\emph on 
lang
\emph default 
(script_plugin_state state, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_in_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_out_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\emph on 
lang
\emph default 
(script_plugin_state state)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\layout Section

Múltiplos estados independentes
\layout Standard


\emph on 
\color red
[TODO: Estas questões gerais (estados independentes, valores de retorno,
 etc.) que aparecem nas seções seguintes devem ser apresentadas nos capítulos
 anteriores, com o texto aqui se concentrando em como estas situações aparecem
 nos plugins de LibScript.]
\layout Standard

O 
\emph on 
design
\emph default 
 atual da API oferece suporte a múltiplos estados independentes, ao permitir
 a manipulação de diversos ambientes, cada um possivelmente contendo um
 estado diferente de um dado plugin.
 Isto pode trazer problemas para linguagens que não dão suporte a múltiplos
 estados.
 Lua, Perl e Tcl são linguagens que permitem múltiplos estados de forma
 simples, uma vez que as chamadas à API incluem um identificador de estado
\begin_inset Foot
collapsed true

\layout Standard

Perl precisa ser compilado com -DMULTIPLICITY para permitir múltiplos estados.
\end_inset 

.
 Já linguagens que mantêm estado da máquina virtual de forma estática, como
 Python, não permitem trabalhar com múltiplos estados facilmente.
 O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter()
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados 
\emph on 
\color red
[a documentação diz 
\begin_inset Quotes eld
\end_inset 

This is a hard-to-fix bug that will be addressed in a future release
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{py-hardtofix}

\end_inset 

]
\emph default 
\color default
.
\layout Standard


\emph on 
\color red
[ Há ainda a questão da 
\emph default 
thread-safety
\emph on 
 da API resultante, que é dependente da 
\emph default 
thread-safety
\emph on 
 dos plugins e, por extensão, das máquinas virtuais.
 É uma questão prática importante, mas pode estar saindo de escopo.
 Abordar isto? ]
\layout Section

Múltiplos valores de retorno
\layout Standard

A API para implementação de funções em C a serem expostas às máquinas virtuais
 permite declarar funções com múltiplos valores de retorno.
 Muitas linguagens não possuem este recurso, mas é possível, ao detectar
 no plugin que mais de um valor foi retornado, construir um tipo de dado
 agregado (tupla em Python, array em Ruby, etc.) e armazenar nele os valores,
 retornando à máquina virtual um valor de retorno único.
\layout Section

Resolução de funções sob demanda
\layout Standard

Uma técnica que vem sendo implementada nos plugins de LibScript, quando
 permitido pela linguagem, consiste em realizar o binding entre a função
 C declarada e uma função 
\emph on 
stub
\emph default 
 nativa somente no momento em que ela é chamada.
 
\layout Standard

O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória da máquina virtual (ao evitar a criação de 
\emph on 
stubs
\emph default 
 que não serão utilizados), é permitir a localização de funções declaradas
 após a inicialização do ambiente -- possivelmente funções implementadas
 em outras linguagens, declaradas em outros plugins.
 Ao comparar as abordagens empregadas em cada plugin, isto nos permitirá
 avaliar os recursos de introspecção oferecidos por cada API.
\layout Subsection

Lua
\layout Standard


\emph on 
\color red
[Parágrafo carregado de jargão Lua...]
\color default
 
\emph default 
Durante a inicialização do plugin, é criada uma tabela armazenada em uma
 variável global, com o nome do 
\emph on 
namespace
\emph default 
 declarado.
 Esta tabela tem associada a si uma 
\emph on 
metatable
\emph default 
 cujo índice 
\family typewriter 
__index
\family default 
 aponta para uma função C interna ao plugin, 
\family typewriter 
script_lua_find_function
\family default 
, que localiza a função 
\begin_inset Formula $f$
\end_inset 

 solicitada na lista de funções registradas no ambiente.
 Após localizar a função, 
\family typewriter 
script_lua_find_function
\family default 
 associa à entrada da tabela do namespace outra função C interna, 
\family typewriter 
script_lua_call
\family default 
, criando uma 
\emph on 
C closure
\emph default 
 e associando a ela o endereço de 
\begin_inset Formula $f$
\end_inset 

 como um 
\emph on 
upvalue
\emph default 
.
 Ao ser invocada, a função 
\family typewriter 
script_lua_call
\family default 
 lê os valores da pilha de Lua (parâmetros de entrada) e os registra no
 ambiente LibScript, invoca a função C armazenada no 
\emph on 
upvalue
\emph default 
 e obtém os valores de retorno.
\layout Subsection

Python
\layout Standard

Na inicialização em Python, o 
\emph on 
namespace
\emph default 
 é declarado como um módulo.
 É declarado também um tipo de dado, 
\family typewriter 
script_py_object
\family default 
, definido como um objeto Python contendo um ponteiro de função C e com
 um callback 
\family typewriter 
__call
\family default 
 definido 
\family typewriter 
script_py_object_call
\family default 
, uma função equivalente a 
\family typewriter 
script_lua_call
\family default 
.
 Assim, objetos deste tipo correspondem à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
 O módulo é automaticamente importado na inicialização do plugin, executando
 uma string de código Python 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

import 
\emph on 
namespace
\emph default 

\begin_inset Quotes erd
\end_inset 


\family default 
.
 
\emph on 
\color red
[Parece não ser possível importar um módulo de outra forma pela API Python/C;
 o opcode responsável na máquina virtual carrega as funções iterando o dicionári
o do módulo.
 Preciso conferir isso na lista de Python.]
\layout Standard

Ao chamar 
\family typewriter 
\emph on 
namespace
\emph default 
.f()
\family default 
, o callback 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_py_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 obtém o endereço de 
\begin_inset Formula $f$
\end_inset 

 da lista de funções do ambiente.
 É declarado então um objeto 
\family typewriter 
script_py_object
\family default 
 contendo o atributo 
\begin_inset Formula $f$
\end_inset 

, que é em seguida armazenado em 
\family typewriter 
\emph on 
namespace
\emph default 
.f
\family default 
.
 A função callback do módulo retorna e o rotina 
\family typewriter 
__call
\family default 
 do objeto é invocada em seguida, executando 
\family typewriter 
script_py_object_call
\family default 
, que registra os parâmetros de entrada no ambiente LibScript, invoca a
 função C armazenada no atributo interno do objeto e retorna a Python os
 valores de saída da função.
\layout Subsection

Ruby
\layout Standard


\emph on 
\color red
[TODO: reescrever esta parte toda.
 A implementação Ruby já resolve funções transparentemente.]
\layout Standard

A implementação atual em Ruby ainda não está realizando a resolução de funções
 de forma transparente, mas ela já o faz de forma dinâmica.
 A inicialização do plugin em Ruby define uma classe com o nome do namespace,
 contendo dois métodos, 
\family typewriter 
get
\family default 
 e 
\family typewriter 
call
\family default 
.
 O método get opera de modo similar a 
\family typewriter 
script_lua_find_function
\family default 
 e 
\family typewriter 
script_py_get
\family default 
, mas não é chamado automaticamente quando um método inexistente é chamado;
 ele precisa ser invocado explicitamente.
 Após uma chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.get(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
, o método 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
 passa a estar disponível na classe.
\layout Standard

O método 
\family typewriter 
get
\family default 
 declara uma função wrapper Ruby que invoca 
\family typewriter 
\emph on 
Namespace
\emph default 
.call
\family default 
 passando como parâmetros o endereço da função C 
\begin_inset Formula $f$
\end_inset 

 (convertido para tipo numérico) e os parâmetros passados na chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
.
 Para fixar esse valor de 
\begin_inset Formula $f$
\end_inset 

 na função declarada, esta declaração é feita gerando uma string de código
 Ruby.
 Uma vez declarada a função, o método padrão 
\family typewriter 
\emph on 
Namespace
\emph default 
.method(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
 é chamado de modo a obter uma referência para o método recém-criado, para
 que ele seja retornado por 
\family typewriter 
get
\family default 
.
 O método 
\family typewriter 
call
\family default 
, por sua vez, equivale a 
\family typewriter 
script_lua_call
\family default 
 e 
\family typewriter 
script_py_object_call
\family default 
., realizando a conversão dos parâmetros e chamada da função 
\begin_inset Formula $f$
\end_inset 

.
\layout Section

Manipulação do estado de nomes
\layout Standard

Para que o ambiente descreva um espaço de nomes consistente entre todos
 os plugins, é necessário contemplar o caso onde os plugins adicionam funções
 a ele, possivelmente sobrescrevendo funções previamente definidas.
\layout Standard


\emph on 
\color red
[Atualmente, os plugins armazenam funções registradas em uma cache (Lua
 e Python no primeiro acesso, Ruby com a função explícita 
\family typewriter 
get
\family default 
).
 Como manter a consistência entre os espaços de nomes das máquinas virtuais?
 Deixar de usar a cache e cada chamada então deve consultar a lista de funções
 em libscript? Ou o registro de uma nova função deve notificar os plugins?
 Pode ser necessário utilizar soluções diferentes em cada plugin.
 Lua, por exemplo, não chama o metamétodo 
\family typewriter 
__newindex
\family default 
 uma vez que o primeiro valor já foi armazenado.
 Em Ruby, ao chamar um método inexistente, é chamado o callback method_missing,
 mas chamada a Classe.method(
\begin_inset Quotes eld
\end_inset 

inexistente
\begin_inset Quotes erd
\end_inset 

) não ativa o callback.]
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Considerações Finais
\layout Standard


\emph on 
\color red
[TODO: Concluir alguma coisa :-) ]
\layout Bibliography
\bibitem {finne-fli}

FINNE, S.; LEIJEN, D.; MEIJER, E.; PEYTON JONES, S.
 
\series bold 
H/Direct: a Binary Foreign Language Interface for Haskell
\series default 
, Em: THIRD ACM SIGPLAN INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING,
 PROCEEDINGS, p.
 153--162, Baltimore, EUA, 1998.
 ACM Press, New York, EUA.
 ISBN: 1581130244
\layout Bibliography
\bibitem {ada95}

ANSI/ISO/IEC-8652:1995; 
\series bold 
Ada 95 Reference Manual
\series default 
.
 volume 1246 de 
\series bold 
Lecture Notes in Computer Science
\series default 
, 1995.
 Springer-Verlag.
\layout Bibliography
\bibitem {tarditi92no}

TARDITI, D.; LEE, P.; ACHARYA, A.
 
\series bold 
No Assembly Required: Compiling Standard ML to C
\series default 
.
 Em: ACM LETTERS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 1, número
 2, p.
 161--177, junho 1992.
 ACM Press.
\layout Bibliography
\bibitem {tolmach-from}

TOLMACH, A.; OLIVA, D.
 
\series bold 
From ML to Ada: Strongly-typed Language Interoperability via Source Translation
\series default 
.
 Em: JOURNAL OF FUNCTIONAL PROGRAMMING, volume 8, número 4, p.
 367--412, 1998.
\layout Bibliography
\bibitem {jones93glasgow}

PEYTON JONES, S.; HALL, C.; HAMMOND, K.; PARTAIN, W.; WADLER, P.
 
\series bold 
The Glasgow Haskell compiler: a technical overview
\series default 
.
 Em: UK JOINT FRAMEWORK FOR INFORMATION TECHNOLOGY (JFIT) TECHNICAL CONFERENCE,
 PROCEEDINGS, 1993.
\layout Bibliography
\bibitem {gosling-java}

GOSLING, J.; JOY, B.; STEELE, G.
 
\series bold 
The Java Language Specification
\series default 
.
 Addison-Wesley Professional, Reading, EUA, 3a.
 Edição, junho 2005.
 ISBN: 0321246780
\layout Bibliography
\bibitem {hugunin-jython}

HUGUNIN, J.
 
\series bold 
Java and Python: the Best of Both Worlds
\series default 
.
 Em: 6TH INTERNATIONAL PYTHON CONFERENCE.
 San Jose, EUA, 1997.
\layout Bibliography
\bibitem {lutz-python}

LUTZ, M.
 
\series bold 
Programming Python
\series default 
.
 O'Reilly Media Inc.
 2a.
 Edição, março 2001.
 ISBN: 0596000855
\layout Bibliography
\bibitem {luajava}

Kepler Project.

\series bold 
 LuaJava
\series default 
.
 
\begin_inset LatexCommand \url{http://www.keplerproject.org/luajava/}

\end_inset 


\layout Bibliography
\bibitem {lua}

IERUSALIMSCHY, R.; FIGUEIREDO, L.H.; CELES, W.; 
\series bold 
Lua -- an Extensible Extension Language
\series default 
.
 Em: Software--Practice and Experience, volume 26, número 6, p.
 635--652, 1996.
\layout Bibliography
\bibitem {benton99interlanguage}

BENTON, N.; KENNEDY, A.
 
\series bold 
Interlanguage Working Without Tears: Blending SML with Java
\series default 
.
 Em: INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING, PROCEEDINGS, p.
 126--137, 1999.
 
\layout Bibliography
\bibitem {box-net}

BOX, D.; SELLS, C.
 
\series bold 
Essential .NET, Volume I: The Common Language Runtime
\series default 
.
 Addison-Wesley Professional, 1a.
 Edição, novembro 2002.
 ISBN: 0201734117
\layout Bibliography
\bibitem {hejlsberg-csharp}

HEJLSBERG, A.; WILTAMUTH, S.
 
\series bold 
C# Language Specification
\series default 
.
 Microsoft Corporation, 2000.
\layout Bibliography
\bibitem {managedcpp}

Microsoft Corporation.
 
\series bold 
Managed Extensions for C++ Specification
\series default 
.
 
\begin_inset LatexCommand \url{http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmxspec/html/vcmanagedextensionsspec_start.asp}

\end_inset 

 
\layout Bibliography
\bibitem {syme-fsharp}

SYME, D.; MARGETSON, J.; MARLOW, S.

\series bold 
 F#.

\series default 
 Microsoft Corporation.
 
\begin_inset LatexCommand \url{http://research.microsoft.com/projects/ilx/fsharp.aspx}

\end_inset 

 
\layout Bibliography
\bibitem {randal-perl6}

RANDAL, A.; SUGALSKI, D.; TOETSCH, L.
 
\series bold 
Perl 6 and Parrot Essentials
\series default 
.
 O'Reilly Media, Inc.
 2a.
 Edição, junho 2004.
 ISBN: 059600737X
\layout Bibliography
\bibitem {conway-uncol}

CONWAY, M.
 
\series bold 
Proposal for an UNCOL
\series default 
.
 Em: COMMUNICATIONS OF THE ACM, volume 1, número 10.
 p.
 5--8, ACM Press, New York, NY, EUA.
 ISSN: 0001-0782
\layout Bibliography
\bibitem {metzner-xl}

METZNER, J.
 
\series bold 
A Graded Bibliography on Macro Systems and Extensible Languages
\series default 
.
 Em: ACM SIGPLAN NOTICES, volume 14, número 1, p.
 57--64, 1979.
 ACM Press.
 New York, NY, EUA.
 ISSN: 0362-1340
\layout Bibliography
\bibitem {peterson-fpy}

PETERSON, P.; MARTINS, J.R.R.A; ALONSO, J.J.; 
\series bold 
Fortran to Python Interface Generator with an Application to Aerospace Engineeri
ng
\series default 
.
 Em: 9TH INTERNATIONAL PYTHON CONFERENCE, PROCEEDINGS, Long Beach, EUA,
 março 2001.
\layout Bibliography
\bibitem {lunatic-python}

NIEMEYER, G.
 
\series bold 
Lunatic Python
\series default 
.
 
\begin_inset LatexCommand \url{http://labix.org/lunatic-python}

\end_inset 

 
\layout Bibliography
\bibitem {jones99portable}

PEYTON JONES, S.; RAMSEY, N.; REIG, F.
 
\series bold 
C--: a Portable Assembly Language that Supports Garbage Collection
\series default 
, Em: INTERNATIONAL CONFERENCE ON PRINCIPLES AND PRACTICE OF DECLARATIVE
 PROGRAMMING, PROCEEDINGS.
 1999.
\layout Bibliography
\bibitem {dvorak05gcc}

DVORAK, Z.
 
\series bold 
Gimplification Improvements.
 
\series default 
Em: GCC DEVELOPERS' SUMMIT, PROCEEDINGS.
 p.
 47--56.
 Ottawa, Canada.
 junho 2005.
\layout Bibliography
\bibitem {omg-corba}

Object Management Group, Inc.
 
\series bold 
The Common Object Request Broker: Architecture and Specification
\series default 
, Versão 3.0, Framingham, MA, EUA, julho 2002.
\layout Bibliography
\bibitem {gelernter-linda}

GELERNTER, D.
 
\series bold 
Generative communication in Linda
\series default 
.
 Em: ACM TRANSACTIONS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 7, número
 1, p.
 80--112.
 New York, NY, EUA.
 ACM Press.
 ISSN: 0164-0925
\layout Bibliography
\bibitem {chapman-opus}

CHAPMAN, B.; HAINES, M.; MEHROTRA, P.; ZIMA, H.; VAN ROSENDALE, J.
 
\series bold 
Opus: A Coordination Language for Multidisciplinary Applications
\series default 
.
 Em: SCIENTIFIC PROGRAMMING, volume 6, número 4.
 p 345--362.
 1997.
\layout Bibliography
\bibitem {collin-eiffel}

COLLIN, S.; COLNET, D.; ZENDRA, O.
 
\series bold 
Type Inference for Late Binding
\series default 
.
 The SmallEiffel Compiler.
 Em: JOINT MODULAR LANGUAGES CONFERENCE, (JMLC'97), 1997, volume 1204 de
 
\series bold 
Lecture Notes in Computer Science
\series default 
, p.
 67--81.
 IEEE, Springer-Verlag.
\layout Bibliography
\bibitem {thomas-ruby}

THOMAS, D.; FOWLER, C.; HUNT, A.
 
\series bold 
Programming Ruby: The Pragmatic Programmer's Guide
\series default 
.
 2a.
 Edição.
 Pragmatic Bookshelf, outubro 2004.
\layout Bibliography
\bibitem {vanrossum-extpy}

VAN ROSSUM, G.
 
\series bold 
Extending and Embedding the Python Interpreter
\series default 
.
 Versão 2.4.2.
 Python Software Foundation, setembro 2005.
\layout Bibliography
\bibitem {wilson-gc}

WILSON, P.
 
\series bold 
Uniprocessor Garbage Collection Techniques
\series default 
.
 Em: INTERNATIONAL WORKSHOP ON MEMORY MANAGEMENT, PROCEEDINGS, p.
 637.
 Saint-Malo, França, 1992.
 Springer-Verlag.
\layout Bibliography
\bibitem {liang-jni}

LIANG, S.
 
\series bold 
Java Native Interface: Programmer's Guide and Specification
\series default 
.
 Addison-Wesley Professional, junho 1999.
 ISBN: 0201325772
\layout Bibliography
\bibitem {moura-colua}

MOURA, A.L.; RODRIGUEZ, N.; IERUSALIMSCHY, R.
 
\series bold 
Coroutines in Lua
\series default 
.
 Em: JOURNAL OF UNIVERSAL COMPUTER SCIENCE, volume 10, número 7, p.
 910--925, julho 2004.
 
\layout Bibliography
\bibitem {beazley-swig}

BEAZLEY, D.; 
\series bold 
SWIG and Automated C/C++ Scripting Extensions
\series default 
.
 Em: DR.
 DOBB'S JOURNAL, fevereiro 1998.
\layout Bibliography
\bibitem {ewing-pyrex}

EWING, G.; 
\series bold 
Pyrex - a Language for Writing Python Extension Modules
\series default 
.
 
\begin_inset LatexCommand \url{http://nz.cosc.canterbury.ac.nz/~greg/python/Pyrex/}

\end_inset 


\layout Bibliography
\bibitem {ltn004}


\color red
[TODO - Pegar as referências de verdade; essas aqui são só para o meu controle
 interno.]
\color default
 http://www.lua.org/notes/ltn004.html
\layout Bibliography
\bibitem {pyvhll_ext}

http://www.python.org/doc/ext/high-level-embedding.html
\layout Bibliography
\bibitem {pyvhll_cobjects}

http://www.python.org/doc/ext/using-cobjects.html
\layout Bibliography
\bibitem {pyvhll_ref}

http://www.python.org/doc/api/veryhigh.html
\layout Bibliography
\bibitem {ext_ruby}

http://www.rubycentral.com/book/ext_ruby.html
\layout Bibliography
\bibitem {perlembed}

http://www.perl.com/doc/manual/html/pod/perlembed.html
\layout Bibliography
\bibitem {tcl}

http://wiki.tcl.tk/2074
\layout Bibliography
\bibitem {janino}

http://www.janino.net
\layout Bibliography
\bibitem {py-hardtofix}

http://www.python.org/doc/api/initialization.html
\the_end
