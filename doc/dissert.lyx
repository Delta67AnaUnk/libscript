#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{a4wide}
\usepackage{indentfirst}
\end_preamble
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Standard


\backslash 
autor{Hisham H.
 Muhammad}
\layout Standard


\backslash 
autorR{Muhammad, Hisham H.}
\layout Standard


\backslash 
orientador{Roberto Ierusalimschy}
\layout Standard


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Standard


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Standard


\backslash 
cidade{Rio de Janeiro}
\layout Standard


\backslash 
departamento{Informática}
\layout Standard


\backslash 
programa{Informática}
\layout Standard


\backslash 
centro{Centro Técnico Científico} 
\end_inset 


\layout Title

Estudo sobre APIs de linguagens de script
\layout Author
\added_space_bottom bigskip 
Hisham H.
 Muhammad
\newline 

\newline 

\newline 

\size normal 
Orientador: Roberto Ierusalimschy
\newline 

\newline 

\newline 

\newline 
Pontifícia Universidade Católica do Rio de Janeiro
\newline 
Centro Técnico Científico
\newline 
Departamento de Informática
\layout Standard
\pagebreak_top 
\SpecialChar ~

\begin_inset ERT
status Open

\layout Standard

\backslash 
thispagestyle{empty}
\end_inset 


\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 
Resumo
\layout Standard

Um cenário comum atualmente é o de aplicações desenvolvidas usando duas
 linguagens de programação a fim de otimizar partes onde o desempenho é
 crítico e permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
 Há várias formas de se obter esse tipo de interoperabilidade; idealmente,
 entretanto, uma linguagem deve prover uma interface de acesso externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem.
 
\layout Standard

Este trabalho discute as principais questões envolvendo o projeto de APIs
 para integração de ambientes de execução de linguagens em aplicações\SpecialChar ~
C.
 Apresentamos os principais problemas enfrentados na interação entre código
 executando em um ambiente com características inerentemente dinâmicas como
 o de uma linguagem de script com código\SpecialChar ~
C.
 Comparamos aqui as abordagens empregadas por cinco linguagens no tratamento
 da comunicação entre os espaços de dados de\SpecialChar ~
C e do ambiente de execução
 embutido e as conseqüências destas abordagens no gerenciamento de memória,
 bem como no compartilhamento de código entre a aplicação\SpecialChar ~
C e o da linguagem
 de script.
 
\layout Standard

Ilustramos as diferenças das APIs destas linguagens e o impacto destas no
 código resultante de uma aplicação\SpecialChar ~
C através de um estudo de caso.
 Diferentes linguagens de script são embutidas como plugins de uma mesma
 biblioteca, que por sua vez expõe a aplicações clientes uma API genérica
 de scripting.
 Assim, o código de cada plugin permite observar de forma clara e isolada
 os procedimentos adotados em cada linguagem para chamada de funções, registro
 de funções\SpecialChar ~
C e conversão de dados entre os ambientes.
\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 

\lang english
Abstract
\layout Standard


\lang english
Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard


\lang english
This work discusses the main issues involving the design of APIs for the
 integration of language environments within C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C\SpecialChar ~
code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C\SpecialChar ~
application and that from the scripting language.
\layout Standard


\lang english
We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C\SpecialChar ~
application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C\SpecialChar ~
functions and conversion of data between the environments.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introdução
\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\end_inset 


\layout Standard

Existem muitas situações onde é necessário ou interessante que haja interação
 entre programas escritos em diferentes linguagens.
 Um caso típico é o emprego de bibliotecas externas, como 
\emph on 
toolkits
\emph default 
 gráficos, APIs de acesso a banco de dados, ou até mesmo chamadas ao sistema
 operacional.
 Outro cenário ainda envolve aplicações desenvolvidas usando mais de uma
 linguagem de programação a fim de otimizar partes onde o desempenho é crítico
 ou permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
\layout Standard

Independentemente da finalidade, a comunicação entre programas escritos
 em linguagens diferentes traz consigo uma série de questões de projeto,
 não apenas no desenvolvimento das aplicações, mas das linguagens em si.
 Há várias formas de se obter esse tipo de interoperabilidade, desde tradução
 de código de uma linguagem para outra até o uso de uma máquina virtual
 comum.
 Idealmente, entretanto, uma linguagem deve prover uma interface de acesso
 externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem\SpecialChar ~

\begin_inset LatexCommand \cite{finne98haskellfli}

\end_inset 

.
 Entre os fatores que devem ser levados em consideração no desenvolvimento
 de tal interface estão as diferenças entre os sistemas de tipos, problemas
 de gerência de memória (como coleta de lixo e acesso direto a ponteiros)
 e modelos de concorrência.
 Além de lidar com diferenças semânticas, o projeto de uma interface entre
 linguagens envolve questões pragmáticas como o equilíbrio entre o isolamento
 seguro dos ambientes de execução, o desempenho e a simplicidade da API
 resultante.
\layout Standard

Pode-se observar nas implementações existentes de FLIs um número de abordagens
 para estes problemas.
 De fato, FLIs de diferentes linguagens (ou mesmo de diferentes revisões
 de uma mesma linguagem) tendem a ser bastante distintas entre si.
 Ainda assim é possível traçar paralelos entre as técnicas utilizadas, uma
 vez que os problemas fundamentais que elas atacam são os mesmos.
\layout Standard

Em função da popularidade da linguagem C e do suporte oferecido a ela pelos
 sistemas operacionais mais utilizados, grande parte das implementações
 de interfaces de acesso externo são, na prática, APIs para C.
 Além disso, um modelo de interação entre linguagens que tem se mostrado
 especialmente relevante na atualidade é o que se dá entre linguagens compiladas
 tipadas estaticamente, como C, e linguagens interpretadas tipadas dinamicamente
, tipicamente chamadas de linguagens de script, como defendido por Ousterhout\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

.
 Estas duas categorias de linguagens possuem objetivos fundamentalmente
 diferentes.
 Linguagens estaticamente tipadas são usualmente implementadas visando alto
 desempenho e possuem um enfoque de mais baixo nível.
 Em contraste, linguagens de script tendem a ser implementadas como interpretado
res ou máquinas virtuais e fazem uso extensivo de construções de alto nível,
 tais como listas e hashes, como sendo tipos básicos.
 Estas características complementares têm tornado popular o modelo de programaçã
o baseado em duas linguagens, onde uma linguagem de mais baixo nível é usada
 para o desenvolvimento de componentes que são conectados através de uma
 linguagem de mais alto nível.
\layout Section

Objetivo
\layout Standard

Este trabalho discute as principais questões envolvendo o projeto de APIs
 para integração de ambientes de execução de linguagens de script em aplicações
 C.
 Apresentamos os principais problemas enfrentados na interação entre código
 executando em um ambiente com características inerentemente dinâmicas como
 o de uma linguagem de script com código C.
 Além de se tratar da classe de linguagens mais popular atualmente para
 desenvolvimento multi-linguagem, características típicas de linguagens
 de script como coleta de lixo e tipagem dinâmica, por não estarem presentes
 em C, ilustram bem os problemas envolvendo a comunicação de dados entre
 diferentes ambientes de programação.
 Linguagens com tipagem estática podem apresentar necessidades de conversão
 de tipos semelhantes, mas o problema tende a ser simplificado pela definição
 de tipos equivalentes na API e inferência em tempo de compilação (vide
 exemplos nas API de Ada e Fortran com C).
 Linguagens funcionais possuem preocupações adicionais com efeitos colaterais
 no código C, mas isto é equivalente ao problema de quebra do paradigma
 causada pelo tratamento de entrada e saída que todas elas enfrentam.
\layout Standard

Este estudo consiste de duas partes.
 Na primeira, realizamos a análise em profundidade de um conjunto de APIs
 para C providas por quatro linguagens de script -- especificamente, Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06ref}

\end_inset 

, Perl\SpecialChar ~

\begin_inset LatexCommand \cite{wall00perl}

\end_inset 

, Ruby\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

, Lua\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 -- além da provida pela linguagem Java\SpecialChar ~

\begin_inset LatexCommand \cite{gosling00java}

\end_inset 

.
 Diferentemente das demais, Java possui tipagem estática, mas assim como
 elas é baseada em um modelo de máquina virtual, possui gerência automática
 de memória e permite carga dinâmica de código.
 Isto nos permite observar também como a tipagem afeta o projeto da API.
\layout Standard

Na segunda parte, ilustramos as diferenças das APIs destas linguagens e
 o impacto destas no código resultante de uma aplicação C através de um
 estudo de caso.
 Realizamos uma comparação entre as APIs das linguagens de script através
 de um exemplo concreto, de modo a colocar implementações em cada uma das
 linguagens lado a lado.
 O exemplo consiste de uma biblioteca genérica para scripting, chamada LibScript
, e uma série de plugins que realizam a interface com as diferentes linguagens.
 Assim, o código de cada plugin permite observar de forma clara e isolada
 os procedimentos adotados em cada linguagem para chamada de funções, registro
 de funções C e conversão de dados entre os ambientes.
\layout Section

Estrutura do texto
\layout Standard

O trabalho está organizado da seguinte forma.
 No Capítulo\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, são discutidas as várias abordagens para interação entre código escrito
 em diferentes linguagens de programação.
 Partindo de uma visão geral, o foco se concentrará no método de interface
 externa mais comum nas linguagens da atualidade: interfaces com a linguagem
 C.
 Discutiremos os problemas comumente envolvidos na comunicação com código
 C e os modelos de programação que surgiram com a popularização da sua integraçã
o com linguagens de script.
 No Capítulo\SpecialChar ~

\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

 são apresentadas em detalhe APIs para C de um conjunto de linguagens de
 script.
 Ao discutir estas interfaces, as diferentes soluções empregadas para os
 principais problemas envolvendo interação entre C e ambientes dinâmicos
 são levantadas.
 O Capítulo\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercita estas diferentes APIs através de um estudo de caso: uma biblioteca
 baseada em plugins que oferece uma interface uniforme simplificada para
 linguagens de script.
 Ao examinar a implementação de cada plugin, podemos comparar as APIs de
 cada linguagem realizando operações equivalentes.
 Finalmente, no Capítulo\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

 são apresentadas as conclusões do trabalho, bem como apontados caminhos
 para trabalhos futuros.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interação entre linguagens de programação
\layout Standard

As abordagens aplicadas na interação entre diferentes linguagens de programação
 variam bastante entre si, mas é possível identificar algumas técnicas tipicamen
te utilizadas: tradução de linguagens, seja de uma para outra ou de ambas
 para uma terceira; comunicação através de protocolo ou linguagem intermediária;
 compartilhamento de um ambiente de execução comum, seja de máquina virtual
 ou através de convenção de chamadas; e interfaces de acesso externo.
\layout Section

Tradução de código
\layout Standard

Permitir o uso de duas linguagens diferentes em um programa traduzindo o
 código de uma delas para a outra minimiza o problema de comunicação entre
 as partes do programa escritas em linguagens diferentes, uma vez que o
 programa final utilizará um espaço único de dados.
 Em contrapartida, ao ter de se descrever uma linguagem em termos de outra,
 a diferença de semântica das construções pode se tornar um problema.
 Se a linguagem de destino não possui construções oferecidas pela linguagem
 de origem, simulá-las pode ser custoso.
\layout Standard

Um exemplo típico de problema enfrentado em ferramentas de tradução de código
 é a complexidade adicionada pela simulação de funções de alta ordem e recursão
 final ao traduzir-se o código de linguagens funcionais para outra que não
 possui estes recursos.
 Tarditi et al.\SpecialChar ~

\begin_inset LatexCommand \cite{tarditi92mlc}

\end_inset 

 descrevem o desenvolvimento de um tradutor de Standard ML para ANSI C.
 Medições evidenciaram o custo de adaptação destes recursos de ML para C,
 resultando em código em média 2 vezes mais lento que o gerado pelo compilador
 ML nativo.
 Em\SpecialChar ~

\begin_inset LatexCommand \cite{tolmach98mlada}

\end_inset 

, são discutidos desafios similares na tradução de ML para Ada: na solução
 adotada, o processo possui um passo intermediário onde as construções de
 alta ordem são 
\begin_inset Quotes eld
\end_inset 

aplainadas
\begin_inset Quotes erd
\end_inset 

 para construções de primeira ordem envolvendo registros, para que pudessem
 assim ser representados em Ada.
\layout Standard

Além de problemas como este, diferenças na representação dos dados ainda
 é algo a ser tratado no processo de tradução de uma linguagem para outra.
 No caso particular de\SpecialChar ~
C, as facilidades de baixo nível para manipulação
 de memória permitem a descrição de estruturas de dados de linguagens de
 mais alto nível sem maiores problemas.
 Isto faz de\SpecialChar ~
C uma candidata freqüente para uso como representação de baixo
 nível portável.
 O compilador de Haskell GHC oferece, como alternativa à geração de código
 nativo, geração de código C para uso com o GCC\SpecialChar ~

\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 Uma das vantagens deste recurso é permitir o 
\emph on 
bootstrapping
\emph default 
 do compilador em novas arquiteturas, dado que o próprio GHC é escrito em
 Haskell.
 De fato, a ubiqüitude dos compiladores C faz com que a linguagem seja utilizada
 também como 
\emph on 
lingua franca
\emph default 
 entre diferentes linguagens, como será visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Compartilhamento de máquinas virtuais
\layout Standard

Outra abordagem para a interação entre linguagens envolve o uso de um ambiente
 de execução comum, como uma máquina virtual.
 O código das diferentes linguagens é compilado de modo a produzir representaçõe
s compatíveis entre si, de acordo com os tipos de dados oferecidos pelo
 ambiente de execução.
 Diversas implementações utilizam a Java Virtual Machine\SpecialChar ~

\begin_inset LatexCommand \cite{lindholm99jvm}

\end_inset 

 com essa finalidade.
 Jython\SpecialChar ~

\begin_inset LatexCommand \cite{hugunin97python}

\end_inset 

 é uma implementação da linguagem Python que produz bytecodes Java.
 SMLj\SpecialChar ~

\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 é um compilador Standard ML que gera bytecodes Java e permite acesso de
 classes e métodos Java a estruturas e funções ML e vice-versa.
 O fato da Java Virtual Machine não ter sido projetada para comportar diferentes
 linguagens de programação, entretanto, transparece nas limitações apresentadas
 por estes projetos.
 SMLj define extensões à linguagem ML para permitir acesso a construções
 específicas de Java; Jython possui limitações ao realizar a interface de
 Python com a API de reflexão e carga dinâmica de classes de Java.
 Além disso, o conjunto de instruções da máquina virtual privilegia operações
 que condizem com a semântica de Java, tornando, por exemplo, implementações
 de 
\emph on 
arrays
\emph default 
 com semântica diferente menos eficientes.
\layout Standard

O .NET Framework\SpecialChar ~

\begin_inset LatexCommand \cite{box02net}

\end_inset 

 é um ambiente de execução baseado em máquina virtual que vem sendo indicado
 pela Microsoft como plataforma de programação preferencial em sistemas
 Windows.
 Apesar de com ele ter sido introduzida a linguagem C#\SpecialChar ~

\begin_inset LatexCommand \cite{csharp06spec}

\end_inset 

, o ambiente tem como um de seus objetivos oferecer suporte a múltiplas
 linguagens -- evidenciado pelo próprio nome Common Language Runtime (CLR)
 -- em contraste com as limitações que o ambiente de Java impõe àqueles
 que tentam utilizá-lo com outras linguagens.
 Todavia, adaptações às linguagens continuam necessárias com o ambiente
 .NET: A versão .NET de Visual Basic inclui alterações na linguagem de modo
 a tornar a sua semântica mais similar à de C#; um novo dialeto de C++,
 C++/CLI, foi introduzido adaptando o modelo de gerenciamento de memória
 ao do CLR\SpecialChar ~

\begin_inset LatexCommand \cite{cppcli05spec}

\end_inset 

; de forma análoga, foi desenvolvido um novo dialeto de ML chamado F#, para,
 entre outros motivos, proporcionar melhor integração com componentes .NET
 desenvolvidos em outras linguagens\SpecialChar ~

\begin_inset LatexCommand \cite{syme06fsharp}

\end_inset 

.
\layout Standard

Outra implementação de uma máquina virtual para múltiplas linguagens vem
 sendo feita pelo projeto Parrot\SpecialChar ~

\begin_inset LatexCommand \cite{randal04perl6}

\end_inset 

.
 O escopo deste projeto é mais restrito, visando ser um 
\emph on 
back-end
\emph default 
 comum para linguagens dinâmicas como Perl e Python.
 O foco do projeto, entretanto, está atualmente na implementação de Perl
 6.
\layout Standard

Um tipo de comunicação que pode ser considerado também uma forma de ambiente
 de execução comum é a comunicação entre executáveis e bibliotecas nativas
 através de convenções de chamada: regras para a passagem de parâmetros
 na pilha de execução, uso de registradores e 
\emph on 
mangling
\emph default 
 de nomes.
 Este pode ser considerado o método de interação entre código em diferentes
 linguagens de mais baixo nível.
 Convenções de chamada, entretanto, são um recurso limitado de comunicação,
 já que assumem tipos de dados com representação em memória idêntica nas
 duas linguagens.
 Tal compatibilidade dificilmente ocorre a não ser que uma das linguagens
 explicitamente considere este tipo de interação na sua definição: o padrão
 de Ada, por exemplo, requer que as suas implementações sejam compatíveis
 com as convenções de C, COBOL e Fortran\SpecialChar ~

\begin_inset LatexCommand \cite{ada95manual}

\end_inset 

.
 De forma similar, C++ permite especificar funções com linkagem compatível
 com C, através da diretiva 
\family typewriter 
extern "C"
\family default 
.
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Modelos de objetos independentes de linguagem
\layout Standard

Adotar um modelo de tipos independente de linguagem é uma outra forma de
 tratar as questões de interoperabilidade de dados entre linguagens.
 Assim, na definição dos dados de uma aplicação, as suas interfaces são
 definidas de forma neutra, tipicamente utilizando alguma linguagem projetada
 especificamente para este fim (uma IDL, 
\emph on 
interface description language
\emph default 
) enquanto as implementações são feitas nas linguagens específicas.
 A arquitetura CORBA (
\emph on 
Common Object Request Broker Architecture
\emph default 
)\SpecialChar ~

\begin_inset LatexCommand \cite{omg02corba}

\end_inset 

 é uma das principais representantes deste modelo.
 A motivação principal para o desenvolvimento de CORBA foi permitir o desenvolvi
mento de aplicações distribuídas em ambientes heterogêneos; a heterogeneidade
 de linguagens foi um dos aspectos levados em consideração.
\layout Standard

Os desafios existentes ao projetar um modelo de dados ou objetos 
\begin_inset Quotes eld
\end_inset 

independente de linguagens
\begin_inset Quotes erd
\end_inset 

, entretanto, são parecidos com os de uma interface entre duas linguagens
 quaisquer, já que esse modelo, por sua vez, descreve também um sistema
 de tipos.
 Ao implementar 
\emph on 
bindings
\emph default 
 para algum destes modelos de objetos é necessário definir uma correspondência
 entre os tipos definidos pelo modelo e os oferecidos pela linguagem destino
 e prover a esta uma API para interação com o ambiente de execução -- no
 caso de CORBA, com o ORB (
\emph on 
Object Request Broker
\emph default 
).
 
\layout Standard

Se por um lado a tarefa pode ser facilitada pelo fato de o modelo ter sido
 projetado visando interação com outras linguagens (diferentemente, por
 exemplo, do sistema de tipos de C), por outro espera-se usualmente um grau
 de transparência maior na representação dos dados.
 Por exemplo, enquanto em uma aplicação integrando C++ e Python a distinção
 entre objetos C++ e objetos Python é clara e a API Python define o limite
 entre os dois universos, em uma aplicação desenvolvida utilizando CORBA
 espera-se que, tanto em uma linguagem como em outra, a manipulação dos
 objetos seja igual, sejam eles implementados em C++ ou Python.
 Para isso, a solução adotada é o uso de 
\emph on 
stubs
\emph default 
, objetos que dão uma aparência nativa uniforme aos dados, indepentemente
 da linguagem em que foram implementados e, no caso de modelos distribuídos
 como CORBA, da localização dos mesmos na rede.
 A correspondência entre os ciclos de vida dos 
\emph on 
stubs
\emph default 
 e dos objetos que eles representam é outro fator que deve ser levado em
 consideração.
 Nos 
\emph on 
bindings
\emph default 
 Java, por exemplo, isto é realizado com o auxílio do coletor de lixo da
 própria linguagem.
 Já em linguagens como C++ o controle das referências é explícito.
\layout Standard

Outras abordagens de mais alto nível têm sido propostas para a integração
 de aplicações desenvolvidas em múltiplas linguagens.
 Linguagens de coordenação como Linda\SpecialChar ~

\begin_inset LatexCommand \cite{gelernter85linda}

\end_inset 

 e Opus\SpecialChar ~

\begin_inset LatexCommand \cite{chapman97opus}

\end_inset 

 definem mecanismos para troca de mensagens e um conjunto restrito de construçõe
s para indicar o fluxo destas entre agentes implementados em outras linguagens.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C como linguagem intermediária
\layout Standard

O desejo de uma linguagem intermediária universal é antigo no mundo da computaçã
o.
 Diversas propostas surgiram ao longo dos anos, desde o projeto UNCOL\SpecialChar ~

\begin_inset LatexCommand \cite{conway58uncol}

\end_inset 

 às linguagens de sintaxe extensível da década de 70\SpecialChar ~

\begin_inset LatexCommand \cite{metzner79extensible}

\end_inset 

 até os mais recentes ambientes de máquina virtual como .NET.
 Na prática, as necessidades que estes projetos visavam atender vêm sendo
 supridas ao longo dos anos de forma mais pragmática, ainda que menos ideal,
 usando C.
 Dois motivos fazem de C uma escolha comum como linguagem intermediária.
 Primeiro, a sua característica de linguagem de 
\begin_inset Quotes eld
\end_inset 

médio nível
\begin_inset Quotes erd
\end_inset 

, ao permitir ao mesmo tempo independência de hardware e manipulação direta
 de memória.
 Segundo, a grande disponibilidade de compiladores C, alavancada pela proliferaç
ão dos sistemas Unix nas mais diferentes arquiteturas.
 Assim, com o passar do tempo, oferecer uma interface para interoperabilidade
 com outras linguagens passou a significar oferecer uma interface para comunicaç
ão com código C.
 Isto é especialmente verdadeiro para linguagens dinâmicas que oferecem
 recursos para extensibilidade de aplicações.
 Não por acaso, estas são tipicamente implementadas em C.
\layout Standard

A disponibilidade de APIs para C oferecidas pelas diferentes linguagens
 faz com que C seja bastante usada também como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

.
 A integração entre Python e Fortran se dá através de um módulo Python escrito
 em C que acessa uma biblioteca Fortran, que por sua vez expõe funções com
 convenção de chamada compatível com C\SpecialChar ~

\begin_inset LatexCommand \cite{peterson01fortranpy}

\end_inset 

.
 LunaticPython\SpecialChar ~

\begin_inset LatexCommand \cite{niemeyer06lunaticpython}

\end_inset 

 oferece pontes de Lua para Python e de Python para Lua, implementadas através
 de um par de módulos de extensão para cada linguagem de origem escritos
 em C.
\layout Standard

Todavia, linguagens intermediárias genéricas continuam a ser propostas como
 alternativas a C.
 C-
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1pt}
\end_inset 

-\SpecialChar ~

\begin_inset LatexCommand \cite{jones99cminusminus}

\end_inset 

 é um projeto que tenta superar as limitações de C enquanto linguagem intermediá
ria tornando mais explícita a representação em memória dos tipos de dados
 e adicionando suporte a construções não facilmente representáveis em C,
 como recursão final.
 Versões recentes da suíte de compiladores GCC padronizaram uma linguagem
 intermediária para comunicação entre os seus diversos 
\emph on 
back-ends
\emph default 
 e 
\emph on 
front-ends
\emph default 
\SpecialChar ~

\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces com C
\layout Standard

A linguagem C tem, na atualidade, um papel especial no mundo das linguagens
 de programação.
 Além de ser bastante utilizada na implementação de compiladores, interpretadore
s e máquinas virtuais (as principais implementações de Perl, Python, Ruby,
 e Lua são apenas alguns exemplos), é também usada em compiladores como
 formato de saída na geração de código portável (dois exemplos notáveis
 são os compiladores GHC e SmartEiffel\SpecialChar ~

\begin_inset LatexCommand \cite{collin97smalleiffel}

\end_inset 

, que geram C a partir de Haskell e Eiffel, respectivamente).
 Isto faz com que a API para C seja um formato conveniente para uma interface
 de acesso externo.
\layout Standard

Na grande maioria dos casos, a representação interna de código produzida
 por compiladores de outras linguagens não é compatível com C, seja por
 diferenças em convenções de chamadas ou de nomes, ou por produzirem código
 para execução em máquinas virtuais.
 Desta forma, para permitir a um programa em C acessar este código, cabe
 à linguagem expor uma biblioteca de funções C que realizem a tradução necessári
a.
 Em ambientes de máquina virtual, esta biblioteca de funções normalmente
 é genérica, oferecendo facilidades para comunicação com a própria máquina
 virtual.
 Para linguagens estáticas, usualmente é necessário criar uma biblioteca
 específica que realize a conversão das chamadas, como ocorre em interfaces
 que expõem bibliotecas C++ para C.
 Um exemplo disto é QtC\SpecialChar ~

\begin_inset LatexCommand \cite{kdebindings}

\end_inset 

, uma biblioteca de bindings C para o toolkit gráfico Qt, que é implementado
 em C++.
\layout Standard

Para linguagens não imperativas, há ainda o problema de código C potencialmente
 gerar efeitos colaterais.
 Algum recurso para isolamento das chamadas deve ser oferecido.
 No GHC, a construção para chamadas em C, 
\family typewriter 
_ccall_
\family default 
, é definida na mônada de IO; no adendo do padrão Haskell 98, a diretiva
 
\family typewriter 
ccall
\family default 
 foi integrada, mas o uso da mônada é opcional, cabendo ao programador garantir
 que funções que não a utilizem sejam puras
\begin_inset Foot
collapsed true

\layout Standard

Diversas convenções de chamada são definidas (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
) mas 
\family typewriter 
ccall
\family default 
 é a única declarada como obrigatória pelo documento.
\end_inset 

.
\layout Standard

Outra possível fonte de incompatibilidade entre linguagens que deve ser
 tratada quando estas interagem é a diferença entre modelos de concorrência.
 C, em particular, não define construções de concorrência, sendo estas implement
adas através de bibliotecas.
 Ao mesmo tempo que isto traz grande flexibilidade à linguagem, implica
 também em problemas de portabilidade para linguagens que dependam da disponibil
idade de mecanismos de concorrência em C compatíveis com os modelos que
 elas utilizam.
\layout Standard

Por exemplo, APIs entre C e Java devem levar em conta o modelo de 
\emph on 
multithreading
\emph default 
 preemptivo adotado por Java.
 A JNI (
\emph on 
Java Native Interface
\emph default 
)\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

 define funções para controlar exclusão mútua entre dados compartilhados
 entre as duas linguagens.
 O programador deve tomar o cuidado de buscar o equilíbrio entre o tempo
 gasto bloqueando a máquina virtual acessando dados compartilhados e o tempo
 gasto realizando cópia de dados entre os ambientes para reduzir o compartilhame
nto.
 Outra situação em que o modelo de concorrência da linguagem demanda cuidados
 por parte do programador na integração com C ocorre no uso de co-rotinas
 em Lua.
 A combinação de dois recursos de Lua, multitarefa cooperativa com múltiplas
 pilhas de execução e a capacidade de alternar entre chamadas a funções
 Lua e C em uma pilha, traz consigo uma limitação: uma co-rotina não pode
 executar a operação de 
\emph on 
yield
\emph default 
 caso haja uma função C na sua pilha, uma vez que não há uma forma portável
 de alternar entre múltiplas pilhas em C\SpecialChar ~

\begin_inset LatexCommand \cite{moura04colua}

\end_inset 

.
\layout Standard

Uma das motivações mais freqüentes para integração com código C é o uso
 de bibliotecas externas.
 Expor uma biblioteca C através da FLI para acesso em uma linguagem pode
 incorrer no registro de centenas de funções.
 É comum definir também tipos de dados que dêem às estruturas definidas
 pela biblioteca uma aparência mais nativa, como por exemplo converter funções
 C que registram 
\emph on 
callbacks
\emph default 
 em métodos Ruby que aceitam blocos de código como parâmetro.
 Essas inicializações e adaptações são usualmente definidas em uma biblioteca
 de 
\emph on 
bindings
\emph default 
, que serve de ponte entre a linguagem e a biblioteca C encapsulando a interação
 com a FLI.
\layout Standard

Os padrões que ocorrem na produção de bindings são tão comuns que deram
 origem a programas que visam automatizar o processo.
 Estes geradores de bindings costumam trabalhar a partir de alguma representação
 preparada para o seu uso, já que analisar os cabeçalhos C pode-se mostrar
 insuficiente: por exemplo, o programa muitas vezes não seria capaz de interpret
ar a intenção de uma construção como 
\family typewriter 
int**
\family default 
.
 SWIG\SpecialChar ~

\begin_inset LatexCommand \cite{beazley96swig}

\end_inset 

 é uma ferramenta multi-linguagem para geração de bindings de bibliotecas
 C e C++ popular que utiliza um formato próprio para descrição de interfaces.
 FLIs podem ainda utilizar geradores de 
\emph on 
stubs
\emph default 
 para poupar o programador de escrever código C repetitivo ou não portável.
 Java possui um gerador de cabeçalhos C contendo os protótipos dos métodos
 nativos a serem implementados.
 Pyrex\SpecialChar ~

\begin_inset LatexCommand \cite{ewing06pyrex}

\end_inset 

 é um gerador de módulos C para Python a partir de uma sintaxe baseada na
 própria linguagem Python.
 Outro exemplo é toLua++\SpecialChar ~

\begin_inset LatexCommand \cite{manzur06tolua}

\end_inset 

, uma ferramenta para integrar código C e C++ a Lua, que gera stubs a partir
 de arquivos de cabeçalhos C preparados para uso pelo programa, podendo
 conter anotações que auxiliem o processo de conversão.
\layout Section

Linguagens de script
\layout Standard

Um modelo de interação entre linguagens que tem se mostrado especialmente
 relevante na atualidade é o que se dá entre linguagens compiladas tipadas
 estaticamente, como C e C++, e linguagens interpretadas tipadas dinamicamente,
 como Perl e Python.
 Em\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

, Ousterhout categoriza estes dois grupos como 
\emph on 
linguagens de programação de sistemas
\emph default 
 e 
\emph on 
linguagens de script
\emph default 
.
\layout Standard

Estas duas categorias de linguagens possuem objetivos fundamentalmente diferente
s.
 Linguagens de programação de sistemas surgiram como alternativa ao assembly
 no desenvolvimento de aplicações, tendo como principais características
 a tipagem estática, o que facilita a compreensão das estruturas de dados
 de sistemas grandes, e a implementação através de compiladores, devido
 a preocupações com o desempenho.
 Em contraste, linguagens de script são tipadas dinamicamente e implementadas
 como interpretadores ou máquinas virtuais.
 A tipagem dinâmica e o uso extensivo de construções de alto nível como
 tipos básicos, como listas e hashes, traz maior flexibilidade na interação
 entre componentes; em linguagens estáticas, o sistema de tipos impõe restrições
 a estas interações, muitas vezes exigindo que o programador escreva interfaces
 de adaptação, o que torna o reuso de componentes mais difícil.
\layout Standard

Ousterhout aponta que, num modelo integrando estes dois tipos de linguagens,
 a tendência é que linguagens de programação de sistemas não sejam mais
 usadas para escrever aplicações inteiras, mas passem a ser usadas para
 a implementação de componentes, que por sua vez são conectados através
 de código escrito com linguagens de script.
 A conveniência oferecida por linguagens interpretadas de alto nível permite
 prototipagem rápida e encoraja o reuso de componentes.
\layout Standard

A integração de programas desenvolvidos em linguagens de programação de
 sistemas coordenados através de linguagens de script é prática comum há
 bastante tempo.
 Shell scripting em sistemas Unix é provavelmente o exemplo mais célebre,
 onde construções como pipes (que conectam a saída de um processo à entrada
 de outro) permitem realizar tarefas combinando uma série de programas implement
ados em outras linguagens, ou mesmo outros scripts.
 Com o surgimento de Tcl\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout94tcl}

\end_inset 

, este tipo de coordenação de componentes através de linguagens de script
 passou a ocorrer com maior freqüência 
\emph on 
dentro
\emph default 
 de aplicações.
 Neste modelo, a linguagem de script é implementada como uma biblioteca
 e é embutida em uma aplicação escrita em uma linguagem de mais baixo nível,
 como C.
 Estruturas de dados da aplicação são expostas ao ambiente de script como
 objetos manipuláveis; em contrapartida, a aplicação pode disparar funções
 na linguagem de script e acessar os seus dados.
 Aplicações programáveis já existiam bem antes disso, tipicamente usando
 pequenas linguagens criadas especificamente para a aplicação, mas o conceito
 introduzido por Tcl de implementar linguagens de script como bibliotecas
 para C impulsionou fortemente o desenvolvimento de aplicações extensíveis.
\layout Standard

O modelo de desenvolvimento baseado em duas linguagens não se limita a aplicaçõe
s que permitem customizações através de scripts escritos pelo usuário.
 Em muitos cenários, existe claramente uma distinção entre uma camada de
 mais baixo nível onde desempenho é um fator crítico e outra de alto nível
 que se caracteriza por operações de coordenação de elementos da camada
 inferior.
 Exemplos típicos são aplicações gráficas onde a interface é descrita por
 linguagens de script controlando componentes implementados em C e jogos
 onde a lógica é descrita em scripts e a 
\emph on 
engine
\emph default 
 de execução é implementada em linguagens de mais baixo nível.
 Este aumento da importância das linguagens de script, onde elas deixam
 de ser apenas um mecanismo de extensão de aplicações e passam a ter um
 papel mais central na coordenação da execução do programa, promoveu também
 um modelo inverso de interação entre linguagens, no qual a aplicação em
 si é escrita usando linguagem de script e bibliotecas escritas em linguagens
 de mais baixo nível são carregadas por este como módulos de extensão.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

APIs de linguagens de script
\layout Standard

Interfaces providas por linguagens de script são usualmente compreendidas
 como 
\begin_inset Quotes eld
\end_inset 

APIs de extensão
\begin_inset Quotes erd
\end_inset 

: elas servem para estender a máquina virtual com recursos não oferecidos
 por esta, ou ainda para estender uma aplicação externa com os recursos
 oferecidos pelo ambiente de execução da linguagem, embutindo-o nesta aplicação.
 O primeiro cenário é o utilizado no modelo de programação onde a coordenação
 de alto nível é realizada em uma linguagem interpretada e módulos compilados
 em linguagens como C e C++ são usados para acesso a bibliotecas externas
 ou implementação de partes onde o desempenho é crítico.
 O segundo cenário, via de regra, irá englobar também o primeiro, ao expor
 à máquina virtual embutida extensões que a permitam comunicar-se com a
 aplicação hospedeira.
\layout Standard

Ambos os cenários envolvem os mesmos problemas gerais: transferência de
 dados entre uma linguagem e outra, incluindo como permitir à linguagem
 de script manipular estruturas declaradas em C e vice-versa; tratar a diferença
 entre os modelos de gerência de memória, mais especificamente a interação
 entre a coleta de lixo na máquina virtual e a desalocação explícita em
 C; a chamada de funções declaradas pela linguagem de script a partir de
 C; e o registro de funções C para que possam ser invocadas a partir de
 scripts.
 As seções seguintes discutem as principais questões envolvidas na comunicação
 entre código C e de linguagens de script, e apresentam as abordagens empregadas
 pelas APIs de Python, Ruby, Java, Lua e Perl no tratamento destas questões.
 Cada seção conclui com uma comparação onde as diferentes características
 apresentadas na exposição de cada linguagem são revistas lado a lado e
 assim postas em perspectiva.
\layout Section

Transferência de dados
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

O principal complicador na interação entre linguagens de programação não
 é a diferença de sintaxe ou semântica das construções de fluxo de controle,
 mas a representação dos dados.
 Na comunicação entre código escrito em duas linguagens diferentes, dados
 trafegam de várias formas: como parâmetros, atributos de objetos, elementos
 de estruturas de dados, etc.
\layout Standard

Freqüentemente, o formato como estes dados são representados difere.
 Nestes casos, há três alternativas para realizar a transferência de dados
 entre as duas linguagens.
 A mais simples é expor o dado à linguagem de destino como uma entidade
 opaca.
 A linguagem de destino recebe apenas algum tipo de 
\emph on 
handle
\emph default 
 que permite identificar unicamente o dado em operações requisitadas posteriorme
nte.
 Esta abordagem é útil, por exemplo, se uma linguagem está apenas armazenando
 os dados para a outra, a fim de aproveitar estruturas de dados de mais
 alto nível que a linguagem ofereça.
 
\layout Standard

Outra abordagem envolve realizar algum tipo de conversão dos dados do sistema
 de tipos de uma linguagem para o da outra.
 A duplicação que ocorre na conversão limita a aplicabilidade deste método,
 restringindo o seu uso tipicamente para tipos numéricos e, em menor grau,
 strings.
 Finalmente, a linguagem de origem pode explicitamente oferecer facilidades
 na linguagem de destino para a manipulação destes dados, ou seja, uma linguagem
 oferecer uma API para a outra.
 A diferença entre esta abordagem e a primeira é que, enquanto naquela o
 conteúdo do dado se mantém opaco, nesta a própria API define uma forma
 de manipular o seu conteúdo.
\layout Standard

C, por ser orientada à manipulação de ponteiros e estruturas, possui um
 conjunto pequeno de tipos básicos.
 Além disso, C é bastante liberal em relação à representação interna dos
 tipos estruturados, cabendo às diferentes plataformas definirem interfaces
 binárias (
\emph on 
application binary interfaces
\emph default 
, ABIs).
 Assim, mesmo em casos onde é possível li\SpecialChar \-
gar código C diretamente utilizando
 tipos básicos compatíveis e convenções de chamada apropriadas (como em
 Free Pascal ou em diversos compiladores Fortran), uma biblioteca de 
\emph on 
bindings
\emph default 
 é usualmente necessária para tornar mais conveniente a manipulação de tipos
 mais complexos.
\layout Standard

Até nos tipos numéricos fundamentais, há vários cuidados que devem ser tomados.
 Algumas linguagens, como Smalltalk e Ruby, realizam conversão automática
 de inteiros para 
\begin_inset Quotes eld
\end_inset 

inteiros grandes
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 Em Ruby, particularmente, os inteiros primitivos têm 1 bit a menos de precisão
 do que o tamanho de palavra da máquina.
 Pode haver ainda a necessidade de conversão de 
\emph on 
endianness
\emph default 
 e formato de números de ponto flutuante.
\layout Standard

Para tipos como strings, o tamanho dos valores traz ainda preocupações com
 desempenho.
 Em diversos casos a representação interna usada para strings é a mesma
 que a usada em C, então uma opção é simplesmente passar ao código C um
 ponteiro para o endereço onde a string está armazenada, o que evita a cópia
 de dados, sob risco de permitir ao programa C modificar o conteúdo da string.
 Expor ao código C ponteiros para endereços de memória dentro do ambiente
 de execução da outra linguagem pode trazer ainda problemas de concorrência,
 caso o ambiente em questão utilize múltiplas 
\emph on 
threads
\emph default 
.
\layout Standard

Ao expor ao código C dados de tipos estruturados, a conversão para um tipo
 de dado nativo de C, em muitos casos, não é uma opção.
 Além da questão da quantidade de dados, tipos estruturados em C são definidos
 estaticamente, não servindo assim para representar convenientemente dados
 de estruturas dinâmicas, como objetos que podem ganhar ou perder atributos
 e até mesmo mudar de classe em tempo de execução.
 Mesmo em linguagens com tipos estáticos, como Java, a cópia de objetos
 não costuma ser uma opção interessante em função do volume de dados.
 A cópia de objetos estruturados costuma se restringir a operações específicas
 como manipulação de arrays de elementos primitivos.
\layout Standard

A alternativa para permitir que código C opere sobre dados estruturados,
 então, é fornecer a ele uma API que exponha, em forma de funções, as operações
 definidas sobre os tipos em questão.
 Isto evita também a necessidade de controlar a consistência entre duas
 cópias de uma mesma estrutura.
 Problemas de consistência, entretanto, podem ocorrer caso a API permita
 ao código C armazenar ponteiros para objetos da linguagem -- isto torna
 necessário ao programador gerenciar explicitamente a sincronia entre os
 ponteiros e o ciclo de vida dos objetos, que podem estar sujeitos a coleta
 de lixo.
 A Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discute esta questão em mais detalhe.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

Todos os valores na máquina virtual de Python são representados como objetos,
 mapeados para a API de C como a estrutura 
\family typewriter 
PyObject
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Tipos mais específicos como 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 e 
\family typewriter 
PyListObject
\family default 
 são 
\family typewriter 
PyObject
\family default 
s por equivalência estrutural, isto é, podem ser convertidos através de
 um 
\emph on 
cast
\emph default 
 C.
 Refletindo o modelo de tipagem dinâmica de Python, as funções da API usam
 
\family typewriter 
PyObject*
\family default 
 como tipo sempre que se referem a objetos Python, mesmo quando são projetadas
 para atuar sobre valores Python de tipos mais específicos, como por exemplo
 a função 
\family typewriter 
PyString_Size
\family default 
, que retorna o tamanho de uma string.
 Cada tipo específico possui uma função de verificação na API, como 
\family typewriter 
PyNumber_Check
\family default 
 e 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python é uma linguagem fortemente tipada: cada objeto é amarrado a um tipo.
 Tipos são representados por estruturas 
\family typewriter 
PyTypeObject
\family default 
, que também são estruturalmente equivalentes a 
\family typewriter 
PyObject
\family default 
.
 Cada tipo Python possui um 
\family typewriter 
PyTypeObject
\family default 
 pré-definido na API, como 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 e 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compara o tipo de um 
\family typewriter 
PyObject
\family default 
 a um 
\family typewriter 
PyTypeObject
\family default 
 passado como parâmetro.
\layout Standard

Para a conversão de dados de C para Python, a linguagem oferece uma série
 de funções que recebem valores de tipos primitivos de C como parâmetro,
 como 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 e 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Cada uma destas funções retorna ao código C um ponteiro para um novo objeto
 
\family typewriter 
PyObject
\family default 
.
 Strings passadas são copiadas por Python.
 O exemplo a seguir ilustra a criação um objeto Python através da conversão
 de um valor C:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os dois exemplos abaixo, equivalentes, ilustram a verificação de tipo através
 da API, primeiro através de uma função de conveniência, e depois explicitamente
, comparando o tipo da string Python com 
\family typewriter 
PyString_Type
\family default 
:
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Sim.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Sim.
\backslash 
n");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para o retorno de dados de Python para C, um conjunto complementar de funções
 é oferecido, mapeando os tipos básicos de Python de volta a tipos de C.
 Alguns exemplos destas funções que recebem um ponteiro para um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam o dado correspondente em C são 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 e 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Diferentemente das funções de entrada, nas fun\SpecialChar \-
ções de saída não há cópia
 de strings: as strings retornadas são ponteiros para a área armazenada
 internamente por Python.
 A documentação recomenda não modificar o conteúdo da string exceto no caso
 de esta área de memória haver sido retornada por uma chamada a 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
tamanho
\family typewriter 
\emph default 
)
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
 Desta forma, é possível alocar uma string para armazenamento em Python
 e preenchê-la posteriormente através de código C, como no exemplo a seguir:
\layout LyX-Code


\size footnotesize 
\emph on 
/* alocando uma string não-inicializada em Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtendo o ponteiro para a área de memória da string */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Agora, podemos preencher a string em C.
 Um exemplo qualquer: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para alguns de seus tipos básicos que não possuem correspondente direto
 em ANSI C 89, Python define tipos em C equivalentes: 
\family typewriter 
Py_UNICODE
\family default 
 e 
\family typewriter 
Py_complex
\family default 
.
 Estes tipos foram adicionados com o objetivo de expor a representação interna
 dos dados usada por Python aos módulos para manipulação numérica ou de
 texto Unicode implementados em C, evitando conversões freqüentes de e para
 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python oferece ainda algumas versões de funções de conversão para C implementada
s como macros sem a verificação de tipo, assumindo que o 
\family typewriter 
PyObject
\family default 
 passado será compatível, oferecendo melhor desempenho às custas de segurança.
 Estas funções podem ser identificadas pelos nomes em maiúsculas.
 Entre as macros de conversão oferecidas estão 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 e 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Além de funções para conversão de tipos entre Python e C, a API de Python
 oferece ainda algumas funções de conversão entre tipos de Python.
 Estas funções recebem um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam um novo 
\family typewriter 
PyObject
\family default 
 com o resultado da conversão, e são equivalentes a funções Python que realizam
 estas conversões (na verdade chamadas a tipos 
\family typewriter 
PyTypeObject
\family default 
 que respondem ao método 
\family typewriter 
__call__
\family default 
).
 Por exemplo, a função 
\family typewriter 
PyObject_Str
\family default 
 é equivalente à função Python 
\family typewriter 
str
\family default 
.
 
\layout Standard

Em Python, objetos são armazenados em módulos, que são espaços de nomes
 declarados globalmente, ou como atributos de objetos.
 Variáveis são armazenadas em um 
\emph on 
ambiente
\emph default 
, representado como um dicionário.
 Funções como 
\family typewriter 
PyRun_File
\family default 
 recebem, entre seus parâmetros, um dicionário de variáveis globais e outro
 de variáveis locais.
 O conjunto de variáveis e funções globais é representado como o dicionário
 do módulo 
\family typewriter 
__main__
\family default 
.
 Objetos 
\emph on 
built-in
\emph default 
 são acessíveis através do módulo 
\family typewriter 
__builtin__
\family default 
.
 Por exemplo, para obter o objeto 
\family typewriter 
str
\family default 
, obtemos inicialmente uma referência ao módulo 
\family typewriter 
__builtin__
\family default 
 com a função 
\family typewriter 
PyImport_AddModule
\family default 
 e em seguida o dicionário do módulo com a função 
\family typewriter 
PyModule_GetDict
\family default 
.
 
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Python, 
\family typewriter 
str
\family default 
 é um objeto chamável, que atua como a função de conversão para strings.
 Assim, uma vez que obtivemos uma referência para o 
\family typewriter 
PyObject
\family default 
 correspondente a 
\family typewriter 
str
\family default 
, a chamada seguinte equivale a chamar 
\family typewriter 
PyObject_Str
\family default 
 sobre um objeto Python qualquer 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Esta é uma função vararg que recebe como argumentos adicionais uma lista
\layout LyX-Code


\size footnotesize 
\emph on 
   terminada em NULL de PyObjects a serem passados à função Python indicada
\layout LyX-Code


\size footnotesize 
\emph on 
   no primeiro argumento.
 */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O armazenamento de dados de C no espaço de objetos de Python pode ser feito
 de duas formas.
 Uma maneira é criar um objeto do tipo 
\family typewriter 
CObject
\family default 
 encapsulando um ponteiro C qualquer, construindo assim um valor opaco para
 Python.
 As funções de construção deste objetos deste tipo permitem associar ao
 dado uma função C a ser chamada quando o 
\family typewriter 
CObject
\family default 
 for desalocado.
 Segundo a documentação de Python, 
\family typewriter 
CObject
\family default 
s têm como objetivo principal permitir a passagem de dados em C de um módulo
 de extensão para outro\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
\layout Standard

A outra forma é declarar novos tipos Python através de estruturas em C.
 Em\SpecialChar ~
C, um tipo Python é descrito em duas partes: um tipo 
\emph on 
struct,
\emph default 
 a partir do qual instâncias do tipo serão produzidas, e uma instância da
 struct 
\family typewriter 
PyTypeObject
\family default 
, que descreverá o tipo para Python.
 O exemplo a seguir ilustra a criação de um novo tipo Python em C.
 Inicialmente, temos 
\family typewriter 
point
\family default 
, que será o tipo\SpecialChar ~
C das instâncias dos objetos:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A macro 
\family typewriter 
PyObject_HEAD
\family default 
 garante equivalência estrutural com 
\family typewriter 
PyObject
\family default 
.
 Quando funções retornarem o objeto ao código C como um 
\family typewriter 
PyObject*
\family default 
, este pode ser convertido de volta para 
\family typewriter 
point
\family default 
 via cast, dando assim acesso aos atributos 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
.
 Definiremos também uma função que opera sobre objetos deste tipo:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(p->x*p->x + p->y*p->y) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função é definida com tipo de retorno 
\family typewriter 
PyObject
\family default 
* para que possa ser registrada na máquina virtual de Python.
 Para associar a função ao tipo Python, iremos inicialmente armazená-la
 em um array de estruturas 
\family typewriter 
PyMethodDef
\family default 
, que listará os métodos do tipo:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para que os atributos do tipo sejam visíveis a partir de Python, precisamos
 implementar uma rotina de acesso, que recebe o objeto e o nome do atributo
 acessado.
 A sua implementação é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Uma vez registrada na descrição do tipo, esta função será responsável por
 retornar os seus atributos e métodos.
 Assim, podemos expor ao ambiente Python atributos armazenados na struct
 C.
 A função 
\family typewriter 
Py_FindMethod
\family default 
 localiza uma função no array passado como parâmetro e a retorna como um
 método
\begin_inset Foot
collapsed false

\layout Standard

O registro de funções Python será discutido em detalhe na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

Finalmente, definiremos 
\family typewriter 
point_type
\family default 
, que será o 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo Python relativo a eles
\begin_inset Foot
collapsed false

\layout Standard

Para maior brevidade, apresentamos o exemplo usando a sintaxe para descrição
 de structs de C99, evitando-nos de listar os elementos a serem inicializados
 com 
\family typewriter 
NULL
\family default 
, já que a struct 
\family typewriter 
PyTypeObject
\family default 
 possui 54 campos ao todo.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",             
\emph on 
/* O nome da classe */
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  
\emph on 
/* O tamanho da área de memória a ser alocada */
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    
\emph on 
/* A função de acesso a atributos */
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT  
\emph on 
/* Classe não requer tratamentos especiais */
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Novamente, uma macro foi usada no início da definição do tipo para garantir
 equivalência estrutural.
 
\family typewriter 
PyTypeObject
\family default 
 possui vários outros campos, mas os manteremos como 
\family typewriter 
NULL
\family default 
 de modo que sejam preenchidos com valores default quando da construção
 do tipo em tempo de execução.
 O tipo 
\family typewriter 
PyTypeObject
\family default 
 contém uma série de campos que permitem descrever o comportamento do tipo
 declarado.
 No campo 
\family typewriter 
tp_getattr
\family default 
 de 
\family typewriter 
point_type
\family default 
, especificamos que a função C a ser usada para tratar acesso a atributos
 será 
\family typewriter 
point_getattr
\family default 
.
 Especificamos 
\family typewriter 
Py_TPFLAGS_DEFAULT
\family default 
 no campo de flags para indicar uma classe de comportamento padrão, sem
 a necessidade de tratamentos especiais como verificação de ciclos na coleta
 de lixo.
\layout Standard

Embora a representação em memória de objetos Python do tipo definido pelo
 usuário sejam instâncias de 
\family typewriter 
point
\family default 
, para criar um novo objeto não basta alocar uma instância da struct 
\family typewriter 
point
\family default 
 e usá-la como 
\family typewriter 
PyObject
\family default 
 via cast.
 É preciso inicializar o objeto para que este seja registrado no mecanismo
 de coleta de lixo e tenha os campos de seu cabeçalho 
\family typewriter 
PyObject
\family default 
 devidamente inicializados.
 A alocação em C de novos objetos de um tipo definido pelo usuário deve
 ser feita através da macro 
\family typewriter 
PyObject_New
\family default 
, que recebe como parâmetros o tipo da struct a ser alocada e o 
\family typewriter 
PyTypeObject
\family default 
 correspondente ao tipo.
 Antes de alocar objetos do tipo em C, deve-se completar a inicialização
 de 
\family typewriter 
point_type
\family default 
 em tempo de execução.
 A documentação recomenda inicializar em tempo de execução a função padrão
 de construção de objetos, 
\family typewriter 
PyType_GenericNew
\family default 
, por razões de portabilidade\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Finalmente, o preenchimento dos campos não definidos na declaração da struct
 é feita pela função 
\family typewriter 
PyType_Ready
\family default 
.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

A partir daí, instâncias podem ser criadas com 
\family typewriter 
PyObject_New
\family default 
, como no exemplo abaixo:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria uma instância */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena a instância na global Python 
\emph default 
P
\emph on 
,
\layout LyX-Code


\size footnotesize 
\emph on 
   assume que o dicionário de globais já foi armazenado em 
\emph default 
globals
\emph on 
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Uma vez declarado em C, este valor pode ser usado em Python:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A API de Python possui um grande número de funções para manipulação de tipos
 pré-definidos da linguagem.
 
\emph on 
Tuplas
\emph default 
 merecem menção especial no que tange à transferência de dados entre Python
 e C, pois são usadas em diversos contextos: na passagem de parâmetros em
 chamadas a funções Python a partir de C, no recebimento dos parâmetros
 de entrada em funções C e também na passagem e recebimento de múltiplos
 valores de retorno, como será visto nas Seções\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 e\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

Como tuplas são usadas com freqüência como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 entre Python e C, a API possui uma função de conveniência, 
\family typewriter 
PyArg_ParseTuple
\family default 
, que evita que o acesso aos elementos da tupla e a verificação dos seus
 tipos seja feita item a item pelo programador.
 Trata-se de uma função C 
\emph on 
vararg
\emph default 
 que recebe como parâmetros a tupla, uma string indicando os tipos dos parâmetro
s esperados e os endereços onde os valores, convertidos para tipos C, devem
 ser armazenados.
 A função define uma sintaxe para os indicadores de tipo especificados na
 string passada e os tipos C correspondentes.
 Por exemplo: 
\family typewriter 
"s#"
\family default 
 indica que a tupla deve conter um objeto Python de tipo 
\family typewriter 
string
\family default 
 ou 
\family typewriter 
Unicode
\family default 
 e que dois parâmetros devem ser passados à função C, de tipos 
\family typewriter 
const char**
\family default 
 e 
\family typewriter 
int*
\family default 
, que irão retornar o ponteiro para a string e o seu tamanho.
 Em um exemplo mais elaborado, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indica que a função espera dois endereços de inteiros\SpecialChar ~
(
\family typewriter 
"ii"
\family default 
), seguido do endereço de um ponteiro 
\family typewriter 
PyObject\SpecialChar ~

\family default 
(
\family typewriter 
"O"
\family default 
) e de um objeto 
\family typewriter 
PyTypeObject
\family default 
 a ser usado na verificação do tipo do objeto recebido\SpecialChar ~
(
\family typewriter 
"!"
\family default 
) e opcionalmente\SpecialChar ~
(
\family typewriter 
"|"
\family default 
), dois endereços de valores 
\family typewriter 
double
\family default 
 passados via Python através de uma outra tupla\SpecialChar ~
(
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

De forma similar, a API de Python possui a função 
\family typewriter 
Py_BuildValue
\family default 
, que permite a construção de objetos estruturados, como tuplas, listas
 e dicionários, em uma só chamada.
 Esta função é freqüentemente usada tanto para a construção da tupla de
 parâmetros ao chamar funções como para valores de retorno.
 A sintaxe da string de parâmetros é similar à de 
\family typewriter 
PyArg_ParseTuple
\family default 
, mas possui um conjunto diferente de indicadores de tipo, além de permitir
 descrever listas e dicionários.
 Por exemplo, a seguinte chamada cria uma lista contendo um inteiro, um
 número de ponto flutuante e um dicionário contendo um elemento de chave
 string e valor inteiro:
\layout LyX-Code


\size footnotesize 
PyObject* lista = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

Isto equivale à seguinte construção em Python:
\layout LyX-Code


\size footnotesize 
lista = [123, 12.30, {"foo": 1234}]
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-dados}

\end_inset 


\layout Standard

Para a comunicação de dados entre Ruby e C, a API de Ruby define um tipo
 de dados em C chamado 
\family typewriter 
VALUE
\family default 
, que representa um objeto Ruby.
 
\family typewriter 
VALUE
\family default 
 pode representar tanto uma referência para um objeto (isto é, um ponteiro
 para a 
\emph on 
heap
\emph default 
 de Ruby) como um valor imediato.
 Em particular, as constantes 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 e 
\family typewriter 
Qnil
\family default 
 são definidas como valores imediatos, permitindo a comparação destas em
 C usando o operador 
\family typewriter 
==
\family default 
.
\layout Standard

Para a verificação de tipos, Ruby disponibiliza as macros 
\family typewriter 
Check_Type
\family default 
 e 
\family typewriter 
TYPE
\family default 
.
 
\family typewriter 
Check_Type
\family default 
 permite comparar o tipo de valores a constantes que descrevem os tipos
 básicos de Ruby como 
\family typewriter 
T_OBJECT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 retorna a constante relativa ao tipo de um valor passado.
 Para a verificação da classe de um objeto, devemos usar 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

Para a transferência de valores numéricos, a conversão entre C e Ruby é
 feita através de macros como 
\family typewriter 
INT2NUM
\family default 
 e de funções como 
\family typewriter 
rb_float_new
\family default 
, que recebem ou retornam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

Para a passagem de strings para Ruby a partir de C, são oferecidas as funções
 
\family typewriter 
rb_str_new
\family default 
, que recebe um ponteiro e um argumento numérico de tamanho, de modo a permitir
 a passagem de strings contendo caracteres nulos, e 
\family typewriter 
rb_str_new2
\family default 
, que assume uma string padrão de C, com o caracter nulo como terminador.
 Estas funções fazem uma cópia da string C para o espaço de Ruby.

\family typewriter 
 VALUE
\family default 
s que apontam para strings de Ruby permitem acessar e alterar o seu conteúdo
 através do 
\emph on 
cast
\emph default 
 
\family typewriter 
RSTRING(uma_string)->ptr
\family default 
.
 Todavia, a API recomenda o uso da macro 
\family typewriter 
StringValue
\family default 
, que retorna o próprio 
\family typewriter 
VALUE
\family default 
 passado caso este seja uma string, ou um novo 
\family typewriter 
VALUE
\family default 
 da classe 
\family typewriter 
String
\family default 
 produzido através do método de conversão 
\family typewriter 
to_s
\family default 
 aplicado ao objeto passado (ou ainda causa uma exceção 
\family typewriter 
TypeError
\family default 
 caso a conversão não seja possível).
\layout LyX-Code


\size footnotesize 
void mostra_valor(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Faria um acesso ilegal se TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Funciona para qualquer tipo que aceite obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         dispara uma exceção em caso contrário */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Valor: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Sob a justificativa de aumentar o desempenho no acesso, alguns outros tipos
 de Ruby como 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 e 
\family typewriter 
File
\family default 
 permitem acesso de baixo nível aos membros das estruturas utilizadas na
 implementação dos objetos.
 Por exemplo, 
\family typewriter 
RARRAY(um_array)->len
\family default 
 permite ler o tamanho de um array diretamente.
 A recomendação da API é utilizar este tipo de acesso somente para leitura,
 já que a alteração destes valores pode facilmente tornar o estado interno
 dos objetos inconsistente.
\layout Standard

Para o armazenamento de dados de C no espaço de objetos de Ruby, a API oferece
 uma macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, que recebe um ponteiro C e cria um objeto Ruby que encapsula este ponteiro.
 O ponteiro pode ser acessado a partir de código C usando 
\family typewriter 
Data_Get_Struct
\family default 
, mas não a partir de Ruby.
 Em 
\family typewriter 
Data_Wrap_Struct
\family default 
 é passada também uma função C a ser executada quando o objeto for coletado.
 Por exemplo, criemos uma classe 
\family typewriter 
Point
\family default 
, similar ao tipo definido em Python na seção anterior.
 Inicialmente definiremos um tipo\SpecialChar ~
C:
\layout LyX-Code


\begin_inset LatexCommand \label{struct-point}

\end_inset 


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Funções de alocação (
\family typewriter 
point_alloc
\family default 
) e desalocação (
\family typewriter 
point_free
\family default 
) para a classe 
\family typewriter 
Point
\family default 
 são dadas a seguir:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

 
\newline 

\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O segundo argumento é a função de marcação para coleta de lixo
\layout LyX-Code


\size footnotesize 
\emph on 
      (NULL aqui pois o tipo não armazena VALUEs), cf.
 Seção 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

 */
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, NULL, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que 
\family typewriter 
Data_Wrap_Struct
\family default 
 faz uso de um 
\family typewriter 
VALUE
\family default 
 que representa a classe 
\family typewriter 
Point
\family default 
 em Ruby.
 Classes são criadas em C com a função 
\family typewriter 
rb_define_class
\family default 
.
 Esta função recebe uma string C com o nome da nova classe e um 
\family typewriter 
VALUE
\family default 
 a ser usado como superclasse (como por exemplo a constante 
\family typewriter 
rb_cObject
\family default 
, que representa a classe Ruby 
\family typewriter 
Object
\family default 
) e retorna um 
\family typewriter 
VALUE
\family default 
 representando a nova classe.
 Para classes como 
\family typewriter 
Point
\family default 
, cujas instâncias irão conter dados de C, é possível registrar uma função
 C responsável por realizar a alocação de memória das instâncias usando
 a função 
\family typewriter 
rb_define_alloc_func
\family default 
.
 A criação da classe e o registro da função de alocação, então, se dão da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como em código Ruby, a declaração de atributos de objetos é feita no método
 
\family typewriter 
initialize
\family default 
, que pode ser implementado em C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O método é registrado na classe em tempo de execução com a função 
\family typewriter 
rb_define_method
\family default 
 (o registro de funções C em Ruby será discutido em detalhe na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para que a cópia de objetos através dos métodos Ruby 
\family typewriter 
dup
\family default 
 e 
\family typewriter 
clone
\family default 
 trate corretamente os dados armazenados via C, é preciso ainda registrar
 o método 
\family typewriter 
initialize_copy
\family default 
.
 Uma possível implementação em C é dada abaixo:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby pode chamar esta função com o mesmo objeto nos dois parâmetros;
\layout LyX-Code


\size footnotesize 
\emph on 
      nesse caso, ignore a chamada e retorne o objeto */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter os ponteiros armazenados nos objetos */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cópia da 
\begin_inset Quotes eld
\end_inset 

parte C
\begin_inset Quotes erd
\end_inset 

 do objeto */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna a cópia */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Completemos o exemplo com uma função C implementando o método 
\family typewriter 
distance
\family default 
 como feito na seção anterior para Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(p->x*p->x + p->y*p->y)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Estas funções também são registradas como métodos de 
\family typewriter 
Point
\family default 
:
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
rb_class_new_instance
\family default 
 produz novos objetos Ruby que são instâncias da classe, recebendo um array
 C de 
\family typewriter 
VALUE
\family default 
s a ser passados na inicialização e o 
\family typewriter 
VALUE
\family default 
 da classe.
 
\layout Standard

O acesso a variáveis Ruby se dá através da família de funções 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
, que retornam os 
\family typewriter 
VALUE
\family default 
s relativos a atributos de objetos ou classes, variáveis globais e constantes.
 Para cada uma destas há uma função 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 análoga
\begin_inset Foot
collapsed true

\layout Standard

Constantes podem ser criadas com o valor 
\family typewriter 
Qundef
\family default 
 e terem o seu valor definido posteriormente com 
\family typewriter 
rb_const_set
\family default 
, porém uma única vez.
\end_inset 

.
 As funções 
\family typewriter 
rb_iv_get
\family default 
 e 
\family typewriter 
rb_ivar_get
\family default 
, por exemplo, obtêm atributos de objetos (
\emph on 
instance variables
\emph default 
).
 A primeira forma usa strings C como nomes, a segunda usa 
\family typewriter 
ID
\family default 
s, identificadores que substituem strings internalizadas na tabela de símbolos
 de Ruby, que podem ser obtidos usando a função 
\family typewriter 
rb_intern
\family default 
.
 De fato, 
\family typewriter 
ID
\family default 
s correspondem ao tipo 
\emph on 
símbolo
\emph default 
 de Ruby, que na prática são strings imutáveis.
 O seguinte exemplo obtém o valor de uma variável global 
\family typewriter 
g
\family default 
 e a atribui ao campo 
\family typewriter 
c
\family default 
 de um objeto, e depois altera o valor da variável global para zero:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém variável global */
\layout LyX-Code


\size footnotesize 
VALUE g = rb_gv_get("g");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui ao campo c do objeto obj */
\layout LyX-Code


\size footnotesize 
VALUE obj = rb_gv_get("obj");
\layout LyX-Code


\size footnotesize 
rb_iv_set(obj, "c", g);
\emph on 
 /* Equivale a: rb_ivar_set(obj, rb_intern("c"), g); */
\layout LyX-Code


\size footnotesize 
\emph on 
/* Zera a variável global */
\layout LyX-Code


\size footnotesize 
rb_gv_set("g", INT2NUM(0));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard


\family typewriter 
ID
\family default 
s nunca são coletados: observamos que a tabela de símbolos não é zerada
 mesmo com 
\family typewriter 
ruby_finalize
\family default 
.
 Assim, uma aplicação C que oferece uma interface para scripting criando
 ambientes supostamente isolados, com 
\family typewriter 
ruby_init
\family default 
 e 
\family typewriter 
ruby_finalize
\family default 
 cercando cada execução de script, pode ter o seu consumo de memória aumentado
 indefinidamente à medida que os scripts criam símbolos.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

A JNI define no cabeçalho 
\family typewriter 
jni.h
\family default 
 tipos em C equivalentes a cada um dos tipos primitivos de Java (
\family typewriter 
jint
\family default 
 para 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 para 
\family typewriter 
float
\family default 
, e assim por diante).
 Os 
\begin_inset Quotes eld
\end_inset 

tipos de referências
\begin_inset Quotes erd
\end_inset 

, como classes e objetos, são expostos a C como referências opacas, instâncias
 de 
\family typewriter 
jobject
\family default 
.
 Strings e arrays também são objetos em Java e são portanto expostos como
 instâncias de
\family typewriter 
 jobject
\family default 
.
 Entretanto, a JNI define como conveniência alguns tipos em C que agem como
 
\begin_inset Quotes eld
\end_inset 

subtipos
\begin_inset Quotes erd
\end_inset 

 de 
\family typewriter 
jobject
\family default 
: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, além de um tipo array para cada tipo primitivo (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 O tipo 
\family typewriter 
jvalue
\family default 
 é uma 
\emph on 
union
\emph default 
 dos tipos primitivos e de referências.
 O valor C 
\family typewriter 
NULL
\family default 
 equivale a 
\family typewriter 
null
\family default 
 em Java.
\layout Standard

Diferentes métodos são utilizados para a leitura de tipos primitivos, strings,
 arrays e outros objetos.
 A leitura do conteúdo de uma 
\family typewriter 
jstring
\family default 
 em C requer a conversão do formato interno usado por Java, UTF-16.
 A API oferece uma função utilitária que aloca uma string contendo a representaç
ão do texto em UTF-8 (formato compatível com ASCII), 
\family typewriter 
GetStringUTFChars
\family default 
.
 Esta string deve ser posteriormente desalocada com 
\family typewriter 
ReleaseString\SpecialChar \-
UTFChars
\family default 
.
 A função 
\family typewriter 
GetStringChars
\family default 
 permite acesso direto à string em formato UTF-16; ela possui um parâmetro
 de saída que indica se a string retornada é o 
\emph on 
buffer
\emph default 
 interno da JVM ou uma cópia.
 Ao mesmo tempo que isto permite ao código C evitar duplicação da string
 nos casos onde deseja-se modificá-la e a JVM tenha optado por retornar
 uma cópia, tal parâmetro expõe na API questões de baixo nível da gerência
 de strings na JVM.
 Alternativamente, as funções 
\family typewriter 
GetStringRegion
\family default 
 e 
\family typewriter 
GetStringUTFRegion
\family default 
 realizam a cópia da string para um buffer pré-alocado pelo programador.
 
\family typewriter 
GetStringCritical
\family default 
 permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
 cuidados especiais em relação à coleta de lixo, discutidos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays de elementos primitivos são tratados de forma similar a strings,
 diferentemente de arrays de objetos
\begin_inset Foot
collapsed true

\layout Standard

Arrays multi-dimensionais são considerados 
\begin_inset Quotes eld
\end_inset 

arrays de arrays
\begin_inset Quotes erd
\end_inset 

 e, portanto, são também arrays de objetos.
\end_inset 

.
 Há funções para realizar a cópia de arrays (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), funções que retornam ponteiros para o array podendo ou não realizar cópias,
 de forma análoga a 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) e que podem acessar o buffer interno da JVM diretamente, como em 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 Para arrays de objetos, não é possível obter um ponteiro para o buffer
 interno do array, mas somente acessar e modificar os seus elementos um
 a um, sob forma de referências 
\family typewriter 
jobject
\family default 
, com 
\family typewriter 
Get
\family default 
/
\family typewriter 
SetObjectArrayElement
\family default 
.
\layout Standard

A obtenção de valores de atributos se dá através de funções como 
\family typewriter 
GetObjectField
\family default 
 e 
\family typewriter 
GetStaticField
\family default 
, que retornam referências do tipo 
\family typewriter 
jobject
\family default 
.
 Para cada um dos tipos primitivos existe uma chamada equivalente, como
 
\family typewriter 
GetIntField
\family default 
 e 
\family typewriter 
GetStaticIntField
\family default 
.
 Assim como Ruby, a API de Java define um tipo\SpecialChar ~
C específico para evitar o
 uso freqüente de strings C na descrição de campos.
 Todavia, enquanto Ruby utiliza 
\family typewriter 
ID
\family default 
s que são simplesmente strings internalizadas, em Java os identificadores
 de campo, do tipo 
\family typewriter 
jfieldID
\family default 
, contêm informação de tipo e são específicos para o campo de uma determinada
 classe.
 Estes valores são obtidos com uma chamada a 
\family typewriter 
GetFieldID
\family default 
, que recebe entre seus parâmetros uma string chamada de 
\begin_inset Quotes eld
\end_inset 

descritor de campo JNI
\begin_inset Quotes erd
\end_inset 

 com uma sintaxe especial.
 Por exemplo, o tipo Java 
\family typewriter 
int[][]
\family default 
 é descrito com 
\family typewriter 
"[[I"
\family default 
 e o tipo 
\family typewriter 
java.lang.String
\family default 
 como 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este é outro ponto onde detalhes da implementação transparecem na API.
 Não por coincidência, esta sintaxe é a mesma usada na representação interna
 de tipos em 
\emph on 
bytecodes
\emph default 
 da JVM.
\end_inset 

.
 É possível ainda obter um 
\family typewriter 
jfieldID
\family default 
 a partir de um objeto 
\family typewriter 
java.lang.reflect.Field
\family default 
 usando a função 
\family typewriter 
FromReflectedField
\family default 
.
\layout Standard

As chamadas à JNI têm o formato 
\family typewriter 
(*J)->
\family default 
\emph on 
função
\family typewriter 
\emph default 
(J,
\family default 
 ...
\family typewriter 
)
\family default 
: funções da JNI são acessadas através de ponteiros para função armazenados
 em uma tabela apontada pela estrutura 
\family typewriter 
JNIEnv
\family default 
, que por sua vez é propagada nas chamadas.
 O objetivo destes dois níveis de indireção é desacoplar a ligação das chamadas
 no código C e a biblioteca que implementa a JNI, permitindo ligar o código
 em tempo de execução a diferentes implementações da JVM\SpecialChar ~

\begin_inset LatexCommand \cite{stepanian05inliningjava}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExemploJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elementos = { "Terra", "Ar", "Fogo", "Agua" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaração do método implementado externamente */
\layout LyX-Code


\size footnotesize 
   private native void segundoElemento();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Cria uma instância e invoca o método nativo */
\layout LyX-Code


\size footnotesize 
      new ExemploJNI().segundoElemento();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Carrega o código externo na JVM que
\layout LyX-Code


\size footnotesize 
\emph on 
         implementará o método segundoElemento */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExemploJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Classe Java contendo um método implementado externamente
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExemploJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExemploJNI_segundoElemento(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter a classe de this: ExemploJNI */
\layout LyX-Code


\size footnotesize 
   jclass classe = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o campo ExemploJNI.elementos, de tipo String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, classe,
\layout LyX-Code


\size footnotesize 
      "elementos", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o conteúdo do campo ExemploJNI.elementos */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elementos[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* obter representação de elems_1 como uma string C */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* exibir a string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* liberar memória da string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

Código C implementando um método Java
\end_inset 


\layout Standard

O acesso a atributos Java em código C é ilustrado através do seguinte exemplo.
 Inicialmente, na Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, é implementada uma classe Java que possui um atributo privado, o array
 
\family typewriter 
elementos
\family default 
, e define uma função, 
\family typewriter 
segundoElemento
\family default 
, a ser implementada em C
\begin_inset Foot
collapsed true

\layout Standard

Os detalhes sobre a declaração e registro de funções implementadas em C
 serão discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

A implementação de 
\family typewriter 
segundoElemento
\family default 
 é mostrada na Fig.\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, mostrando a seqüência de chamadas até obter em C o elemento do array Java.
 Para acessar o atributo 
\family typewriter 
elementos
\family default 
, a função deve obter o identificador do campo.
 Para tal, devemos inicialmente obter uma referência da classe atual com
 
\family typewriter 
GetObjectClass
\family default 
 a partir da referência ao objeto (
\family typewriter 
this
\family default 
) passada como parâmetro à função.
 De posse da referência da classe (
\family typewriter 
classe
\family default 
), obtemos o identificador do campo com 
\family typewriter 
GetFieldID
\family default 
.
 O conteúdo do campo é então obtido com 
\family typewriter 
GetObjectField
\family default 
: uma referência para o array.
 Com este, o elemento do array é obtido com 
\family typewriter 
GetObjectArrayElement
\family default 
.
 Uma cópia do elemento, convertido para uma string C codificada em UTF-8,
 é retornada com 
\family typewriter 
GetStringUTFChars
\family default 
.
 Como discutido anteriormente, após o uso, a string deve ser liberada com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

A manipulação de objetos do tipo 
\family typewriter 
Class
\family default 
 também é feita através de funções específicas.
 Não é possível criar classes Java através da API C, mas é possível carregar
 classes em tempo de execução usando a função 
\family typewriter 
DefineClass
\family default 
, que recebe um buffer contendo a representação de uma classe Java pré-compilada.
 Referências do tipo 
\family typewriter 
jclass
\family default 
 podem ser obtidas através do nome da classe usando 
\family typewriter 
FindClass
\family default 
, que utiliza uma sintaxe de descritores de classe similar à de descritor
 de campos usada por 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Tanto em descritores de classe como de campo, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 representam 
\family typewriter 
String[]
\family default 
.
 Para o tipo 
\family typewriter 
String
\family default 
, entretanto, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 é o descritor de campo e 
\family typewriter 
"java/lang/String"
\family default 
 o de classe.
\end_inset 

.
\layout Standard

Para a atribuição de valores de C que podem ser convertidos para tipos primitivo
s de Java, a JNI possui funções como 
\family typewriter 
SetIntField
\family default 
 e 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 Para os demais tipos, não há uma provisão específica para o armazenamento
 de dados de C no espaço de objetos de Java.
 Nestes casos, a documentação sugere o armazenamento de ponteiros em tipos
 numéricos\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

, apesar dos problemas de portabilidade em que tal abordagem incorre.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

A API de Lua define uma abordagem diferente para a manipulação de dados
 em C: não são expostos ao código C ponteiros ou 
\emph on 
handles
\emph default 
 para objetos Lua.
 As operações são definidas em termos de índices de uma pilha virtual.
 Assim, a transferência de dados de C para Lua se dá através de funções
 que recebem tipos de C, os convertem para valores Lua e os empilham, como
 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 e 
\family typewriter 
lua_pushlstring
\family default 
.
 Diversas operações da API operam sobre o valor no topo da pilha, como por
 exemplo 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Funções da API que operam sobre um estado de execução Lua recebem um parâmetro
 inicial (nos exemplos, chamado de 
\family typewriter 
L
\family default 
) indicando o estado a que se referem.
 Isto será discutido mais adiante, na Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Insere o número 123 na pilha */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Atribui o número 123 na global 
\emph default 
foo
\emph on 
 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A maioria das funções de consulta, entretanto, permitem especificar um índice
 qualquer da pilha (com valores positivos para indexação a partir da base
 e negativos para índices a partir do topo).
\layout Standard

A conversão de dados de Lua para C é feita através de funções como 
\family typewriter 
lua_tonumber
\family default 
 e 
\family typewriter 
lua_tolstring
\family default 
, que recebem um índice da pilha, convertem o valor no índice para o tipo
 Lua especificado se necessário, e retornam o valor convertido para o tipo\SpecialChar ~
C
 equivalente.
 Números têm o tipo\SpecialChar ~
C 
\family typewriter 
lua_Number
\family default 
, que corresponde a 
\family typewriter 
double
\family default 
 por padrão mas é um parâmetro na compilação de Lua.
 Strings, em particular, são objetos imutáveis e têm sua representação internali
zada: duas strings de conteúdo idêntico compartilham a mesma representação
 interna.
\layout Standard

Assim, diferentemente de linguagens como Python e Ruby, não é possível modificar
 o conteúdo de uma string Lua através de C via a sua representação em memória
 como um 
\family typewriter 
char*
\family default 
.
 Para tornar mais eficiente a construção em etapas de strings Lua a partir
 de C, a biblioteca auxiliar define um tipo\SpecialChar ~
C 
\family typewriter 
luaL_Buffer
\family default 
 e funções como 
\family typewriter 
luaL_addstring
\family default 
 e 
\family typewriter 
luaL_addvalue
\family default 
, que permitem a construção de uma string em etapas até que ela possa ser
 finalmente convertida para uma string Lua com 
\family typewriter 
luaL_pushresult
\family default 
.
 Assim, evitam-se consecutivas operações de concatenação de string através
 da API de Lua.
\layout Standard

Lua define dois tipos de dados específicos para o armazenamento de dados
 para C, 
\emph on 
full userdata
\emph default 
 e 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 descrevem blocos de memória gerenciados por Lua e utilizados por código
 C.
 Eles existem em Lua como objetos opacos, e são criados por 
\family typewriter 
lua_newuserdata
\family default 
, que insere o novo objeto na pilha de Lua e retorna a C um ponteiro com
 a área de memória do tamanho requisitado.
 Objetos do tipo 
\emph on 
light userdata
\emph default 
, criados através de 
\family typewriter 
lua_pushlightuserdata
\family default 
, permitem armazenar ponteiros de C em Lua; a alocação e gerência do bloco
 de memória ficam a cargo do código C.
 O seguinte exemplo ilustra o uso de userdata, assumindo a mesma struct
 
\family typewriter 
point
\family default 
 definida na página\SpecialChar ~

\begin_inset LatexCommand \pageref{struct-point}

\end_inset 

.
 O userdata é criado da seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o full userdata e o insere na pilha e retorna
\layout LyX-Code


\size footnotesize 
\emph on 
   o ponteiro para C.
 A memória é alocada por Lua.
 */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Utilizamos então o ponteiro em C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o objeto à variável global Lua 
\emph default 
Ponto
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Ponto");
\layout Standard

A seguir, o acesso:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Empilha a global Ponto */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Ponto");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro C do userdata no topo da pilha (posição -1) */
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d)
\backslash 
n", p->x, p->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restaura a pilha à posição original, removendo o item.
\layout LyX-Code


\size footnotesize 
\emph on 
   Ele não será coletado pois está associado à variável global.
 */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumindo que a global 
\family typewriter 
Ponto
\family default 
 é a única referência para este bloco, para liberá-lo basta sobrescrevermos
 
\family typewriter 
Ponto
\family default 
, por exemplo, com 
\family typewriter 
nil
\family default 
; a memória do full userdata poderá então ser liberada pelo coletor de lixo,
 como a de qualquer valor Lua sem referências.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Ponto");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A área de armazenamento da pilha não se ajusta dinamicamente e as funções
 da API não realizam controle de 
\emph on 
overflow
\emph default 
.
 Assim, o programador é responsável por controlar o tamanho da pilha, através
 da função 
\family typewriter 
lua_checkstack
\family default 
.
 Na prática, o tamanho da pilha só irá crescer na ocorrência de laços empilhando
 elementos, já que seqüências típicas de operações tendem a empilhar valores
 e desempilhá-los em seguida.
\layout Standard

Tabelas são o único tipo para construção de estruturas de dados em Lua.
 Lua oferece uma API completa para manipulação de tabelas a partir de C.
 Tabelas podem ser criadas com 
\family typewriter 
lua_newtable
\family default 
 ou 
\family typewriter 
lua_createtable
\family default 
; a segunda forma permite pré-alocar memória para os elementos da tabela.
 As funções 
\family typewriter 
lua_gettable
\family default 
 e 
\family typewriter 
lua_settable
\family default 
 implementam a semântica de leitura e atribuição de campos em uma tabela
 em Lua, incluindo a possível chamada a metamétodos; para chamadas sem a
 invocação de metamétodos existem as funções 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, equivalentes a 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 em Lua (além das variantes 
\family typewriter 
lua_rawgeti
\family default 
 e 
\family typewriter 
lua_rawseti
\family default 
 para conveniência).
 Há ainda a função 
\family typewriter 
lua_next
\family default 
, equivalente à função Lua 
\family typewriter 
next
\family default 
, que permite percorrer os elementos de uma tabela.
 Um exemplo de manipulação de tabelas é dado a seguir:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tabela["chave"] = 12345, em C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tabela");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "chave");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable insere o item no topo da pilha
\layout LyX-Code


\size footnotesize 
\emph on 
    na tabela especificada como argumento,
\layout LyX-Code


\size footnotesize 
\emph on 
   usando como chave o elemento logo abaixo do topo: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Diversos conceitos de Lua são representados através de tabelas -- ambiente
 global, metatabelas, registro -- e são assim tratados em C usando as funções
 da API para manipulação de tabelas.
 A tabela do ambiente global da 
\emph on 
thread
\emph default 
 em execução pode ser acessada através de um índice especial da pilha virtual,
 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 Pode-se ainda definir uma tabela de ambiente da função, indexada em 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, para isolar dados a serem compartilhados internamente em funções de módulos
 escritos em C.
 Exemplificando, o ambiente global pode ser manipulado como uma tabela desta
 forma:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "Ponto");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Standard

Isto é equivalente a:
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Ponto");
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

Os processos de estender e embutir Perl são bastante distintos.
 Para extensões, Perl oferece uma linguagem para descrição de interfaces
 chamada XS.
 Ao invés de isolar o acesso às estruturas internas de Perl através de uma
 API pública, a abordagem proposta é encapsular o processo de geração de
 código 
\emph on 
wrapper
\emph default 
 para a comunicação entre funções escritas em C e as estruturas internas
 de Perl usando interfaces escritas em XS.
 Arquivos 
\family typewriter 
.xs
\family default 
 contêm código C acompanhado de anotações que simplificam o tratamento dos
 parâmetros de entrada e saída.
 Estes são alimentados ao pré-processador 
\family typewriter 
xsubpp
\family default 
, que geram então o código usando a API oferecida pela biblioteca de Perl.
 Esta biblioteca oferece acesso de baixo nível ao funcionamento do interpretador
, permitindo, por exemplo, manipular o ponteiro da sua pilha interna.
 O objetivo de XS é ocultar ao desenvolvedor de extensões estes detalhes.
\layout Standard

Para embutir o interpretador Perl em uma aplicação, a biblioteca que a implement
a oferece algumas funções que permitem disparar um interpretador.
 Na API de mais alto nível, pode-se construir um array de parâmetros a serem
 passados para o interpretador de forma equivalente às opções do interpretador
 Perl de linha de comando, inclusive usando a opção 
\family typewriter 
"-e"
\family default 
 para executar trechos de código.
\layout Standard

Os tipos de variáveis Perl são mapeados para structs em C: 
\family typewriter 
SV
\family default 
 para escalares, 
\family typewriter 
AV
\family default 
 para arrays, 
\family typewriter 
HV
\family default 
 para hashes.
 Estes valores C são melhor entendidos como 
\emph on 
containers
\emph default 
 para valores Perl: uma variável escalar em Perl tem um 
\family typewriter 
SV
\family default 
 associado a si; todavia, pode-se criar em C um 
\family typewriter 
SV
\family default 
 que não esteja associado a nenhum nome de variável Perl.
\layout Standard

Os 
\emph on 
typedefs
\emph default 
 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 e 
\family typewriter 
PV
\family default 
 representam valores C correspondentes aos tipos primitivos de Perl, e correspon
dem, respectivamente, a inteiros com e sem sinal, valores de ponto flutuante
 e strings.
 Estes valores podem ser copiados para 
\family typewriter 
SV
\family default 
s.
 Referências Perl são representadas como 
\family typewriter 
RV
\family default 
, e também são um tipo de 
\family typewriter 
SV
\family default 
.
 Há ainda o tipo 
\family typewriter 
GV
\family default 
, capaz de referenciar qualquer tipo representável em uma variável Perl.
\layout Standard

Variáveis do espaço de Perl são acessadas com 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 e 
\family typewriter 
get_hv
\family default 
.
 Estas funções recebem uma string C com o nome da variável (possivelmente
 qualificado da forma 
\family typewriter 
"pacote::variavel"
\family default 
).
 O conteúdo de valores escalares é convertido de volta para um tipo\SpecialChar ~
C com
 as macros 
\family typewriter 
Sv
\family default 
*: 
\family typewriter 
SvIV
\family default 
 retorna um inteiro, 
\family typewriter 
SvPV
\family default 
 retorna um 
\family typewriter 
char*
\family default 
 e o comprimento da string no segundo parâmetro, etc.
 O seguinte código C exibe o conteúdo da variável Perl 
\family typewriter 
$a
\family default 
, assumindo que ela contenha um valor inteiro:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A flag passada como segundo parâmetro de 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 indica se a variável deve ser criada se o nome passado não corresponder
 a uma variável existente.
 Passar um nome inexistente e usar 
\family typewriter 
TRUE
\family default 
 no segundo parâmetro é uma forma conveniente de criar uma nova variável
 acessível no espaço de C já realizando o 
\emph on 
binding
\emph default 
 desta no espaço de Perl.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria uma variável do tipo array,
\layout LyX-Code


\size footnotesize 
\emph on 
   acessível em Perl como a global @arr e em C como o AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Um 
\family typewriter 
SV
\family default 
 pode ser criado em C com as funções 
\family typewriter 
newSV
\family default 
*: 
\family typewriter 
newSViv
\family default 
 gera um novo 
\family typewriter 
SV
\family default 
 armazenando um inteiro com sinal; 
\family typewriter 
newSVpv
\family default 
 a partir de uma string, e assim por diante.
 A função 
\family typewriter 
newSV
\family default 
 permite criar um 
\family typewriter 
SV
\family default 
 com área de memória não inicializada, acessível através da função 
\family typewriter 
SvPVX
\family default 
, permitindo assim criar escalares com valores arbitrários gerenciados por
 código C.
 Usando o mesmo exemplo da struct 
\family typewriter 
point
\family default 
 das seções anteriores, podemos armazenar um objeto C em um valor Perl da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Aloca um SV não inicializado do tamanho de um 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro para a área de memória do 
\emph default 
SV
\emph on 
 */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipula o 
\emph default 
point
\emph on 
 em C.
 Quando v for retornado para Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
ele será uma variável opaca (seu conteúdo não será acessível via Perl).
 */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Valores são atribuídos a 
\family typewriter 
SV
\family default 
s usando as funções 
\family typewriter 
sv_set
\family default 
*: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 As funções para manipulação de strings possuem variantes como 
\family typewriter 
newSVpvn
\family default 
 e 
\family typewriter 
sv_setpvf
\family default 
, que permitem especificar o comprimento da string ou realizar formatação
 como em 
\family typewriter 
sprintf
\family default 
.
 Para strings, há ainda funções 
\family typewriter 
sv_cat
\family default 
*, que atuam como 
\family typewriter 
sv_set
\family default 
* mas concatenam o valor dado ao conteúdo atual da string ao invés de substituí-
lo.
 A função 
\family typewriter 
sv_setsv
\family default 
 copia o valor de um 
\family typewriter 
SV
\family default 
 para outro.
 O 
\family typewriter 
SV
\family default 
 criado no exemplo anterior pode ser atribuído para uma variável global
 da seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o SV da variável global 
\emph default 
$ponto
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* ponto = get_sv("ponto", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o valor de v para ponto */
\layout LyX-Code


\size footnotesize 
sv_setsv(ponto, v);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O tipo dos dados armazenados em 
\family typewriter 
SV
\family default 
s é verificado com as macros 
\family typewriter 
SvIOK
\family default 
 para inteiros, 
\family typewriter 
SvNOK
\family default 
 para valores de ponto flutuante e 
\family typewriter 
SvPOK
\family default 
 para strings.
 Estas funções retornam sucesso se o escalar é conversível para o tipo especific
ado -- as variantes 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verificam se o valor armazenado no 
\family typewriter 
SV
\family default 
 é realmente do tipo.
\layout Standard

Arrays e hashes são criados com 
\family typewriter 
newAV
\family default 
 e 
\family typewriter 
newHV
\family default 
.
 Arrays podem ser populados com um array C de ponteiros para 
\family typewriter 
SV
\family default 
 através de 
\family typewriter 
av_make
\family default 
.
 Operações como 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 e 
\family typewriter 
hv_exists
\family default 
 permitem operar sobre elementos das estruturas.
 Em 
\family typewriter 
av_fetch
\family default 
 e 
\family typewriter 
hv_fetch
\family default 
, o tipo de retorno é 
\family typewriter 
SV**
\family default 
, para diferenciar o retorno de um elemento existente que aponta para 
\family typewriter 
NULL
\family default 
 de um elemento não encontrado.
 No exemplo a seguir, criaremos um array Perl contendo os 10 primeiros elementos
 da série de Fibonacci:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria um novo array.
 */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena dois valores, 0 e 1, nas primeiras posições do array.
 */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviamente seria mais eficiente armazenar os valores em variáveis
\layout LyX-Code


\size footnotesize 
\emph on 
      temporárias em C, mas obtenhamos os dois últimos valores da
\layout LyX-Code


\size footnotesize 
\emph on 
      seqüência de volta do array Perl para fins de ilustração: */
\layout LyX-Code


\size footnotesize 
   SV** penultimo_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** ultimo_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém os inteiros armazenados nos SVs */
\layout LyX-Code


\size footnotesize 
   int penultimo = SvIV(*penultimo_sv);
\layout LyX-Code


\size footnotesize 
   int ultimo = SvIV(*ultimo_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um novo SV e o insere no final do array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( penultimo + ultimo ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Uma vez criado este 
\family typewriter 
AV
\family default 
, entretanto, não há uma forma de associá-lo a uma variável Perl.
 Seu conteúdo deve ser copiado item a item.
 Para que este seja acessível a partir de Perl, deveríamos tê-lo criado
 com 
\family typewriter 
get_av
\family default 
, e não 
\family typewriter 
newAV
\family default 
.
 A utilidade de 
\family typewriter 
AV
\family default 
s não associados a variáveis está na passagem de parâmetros na chamada de
 funções e como valores de retorno.
\layout Standard

Algumas funções para manipulação de hashes expõem os pares chave/valor como
 ponteiros 
\family typewriter 
HE
\family default 
.
 As macros 
\family typewriter 
HeSVKEY
\family default 
 e 
\family typewriter 
HeVAL
\family default 
 permitem extrair a chave e valor de um 
\family typewriter 
HE
\family default 
.
 A seguinte função exibe em C os elementos de uma hash Perl:
\layout LyX-Code


\size footnotesize 
void imprime_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cada HV mantém o seu controle interno de iteração */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém o próximo par chave/valor da iteração */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém a representação string dos escalares
\layout LyX-Code


\size footnotesize 
\emph on 
         representando chave e valor do item */
\layout LyX-Code


\size footnotesize 
      char* chave = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* valor = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", chave, valor);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Cuidados especiais devem ser tomados ao utilizar os valores 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em arrays e hashes, embora Perl exponha estas constantes na API de C (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 A constante 
\family typewriter 
PL_sv_undef
\family default 
 é usada internamente na implementação de 
\family typewriter 
AV
\family default 
s e 
\family typewriter 
HV
\family default 
s, e a atualização de valores em 
\family typewriter 
HV
\family default 
s ocorre 
\emph on 
in-place
\emph default 
, o que gera problemas ao atualizar elementos contendo estas constantes.
 A documentação recomenda gerar cópias destes valores ao usá-los em estruturas
 
\family typewriter 
AV
\family default 
 e 
\family typewriter 
HV
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlguts}

\end_inset 

.
\layout Standard

Referências Perl são criadas com 
\family typewriter 
newRV_inc
\family default 
 e 
\family typewriter 
newRV_noinc
\family default 
, que recebem um ponteiro para 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 como parâmetro (as duas funções diferem entre si no que tange à contagem
 de referências, que será abordada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 O valor apontado por uma referência é obtido com 
\family typewriter 
SvRV
\family default 
.
 O retorno desta macro deve ser convertido via 
\emph on 
cast
\emph default 
 para o tipo apropriado (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), que pode ser verificado com 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Diversas funções da API têm tipo de parâmetros ou retorno declarados como
 
\family typewriter 
SV
\family default 
 quando na verdade aceitam 
\family typewriter 
AV
\family default 
s ou 
\family typewriter 
HV
\family default 
s; isto é análogo ao conceito de 
\emph on 
contextos
\emph default 
 de Perl, onde um mesmo valor pode ser tratado como lista (array ou hash)
 ou escalar dependendo da expressão onde ele é inserido\SpecialChar ~

\begin_inset LatexCommand \cite{marquess06perlcall}

\end_inset 

.
 Em código Perl, o contexto em que uma função está executando pode ser verificad
o com 
\family typewriter 
wantarray
\family default 
.
 Em\SpecialChar ~
C, o contexto pode ser verificado com a macro 
\family typewriter 
GIMME_V
\family default 
, que retorna 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 ou 
\family typewriter 
G_ARRAY
\family default 
.
\layout Subsection

Comparação
\layout Standard

O conjunto básico de funções para manipulação de dados nas cinco linguagens
 discutidas é similar: todas elas possuem funções para converter valores
 da linguagem para tipos básicos de C e vice-versa.
 Todas oferecem ainda funções para a manipulação dos seus tipos estruturados
 fundamentais (tabelas em Lua, arrays em Java, arrays e hashes em Ruby e
 Perl, listas e dicionários em Python).
 Python, em particular, define uma API extensa de funções para operações
 sobre as suas classes 
\emph on 
built-in
\emph default 
; a maioria destas operações poderia ser realizada usando a API genérica
 de invocação de métodos, mas são oferecidas diretamente em C como conveniência.
\layout Standard

Lua ganha destaque por possuir, com o seu modelo de pilha, a API para manipulaçã
o de dados mais simples e ortogonal dentre as estudadas.
 Entretanto, muitas vezes o código resultante perde em legibilidade quando
 os índices da pilha são pouco óbvios.
 É comum ver código C usando a API de Lua comentado linha a linha, para
 evitar que o programador tenha que simular mentalmente o funcionamento
 da pilha ao ler o programa.
\layout Standard

Em Java, a tipagem estática reduz muito a necessidade de conversões de dados
 explícitas no código C.
 Por outro lado, o tratamento de 
\emph on 
multi-threading
\emph default 
 complica o acesso a tipos como strings e arrays.
\layout Standard

Um ponto negativo na API de Ruby é a exposição de detalhes de implementação
 dos campos da struct que descreve o seu tipo fundamental 
\family typewriter 
VALUE
\family default 
.
 Isto restringe a flexibilidade da implementação da linguagem e é uma prática
 de programação pouco segura.
 Perl também expõe grande parte de suas estruturas internas; não de forma
 tão direta quanto Ruby, mas através de macros.
 Tais macros, entretanto, assumem a aderência a protocolos tão estritos
 de uso que na prática também limitam largamente as possiblidades de alterações
 na implementação (um exemplo é a seqüência para chamada de funções, que
 será apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

).
\layout Standard

A criação de dados que contêm estruturas C armazenados pela linguagem de
 script é uma tarefa fácil em Perl, Ruby e Lua: Perl permite criar 
\family typewriter 
SV
\family default 
s contendo blocos de memória arbitrários para uso em C; Ruby disponibiliza
 a macro 
\family typewriter 
Data_Wrap_Struct
\family default 
 que gera um objeto Ruby que encapsula uma estrutura C; Lua define um tipo
 básico na linguagem especialmente para este fim.
 Já em Python, o processo é trabalhoso.
 Criar uma classe Python a partir de C envolve declarar partes dela estaticament
e e outras partes dinamicamente, sendo usualmente necessário definir três
 estruturas C diferentes.
 Em Java, não é possível criar novos tipos a partir de C, apenas carregar
 classes.
\layout Standard

Outra tarefa comum ao interagir com C é a necessidade de armazenar ponteiros
 no espaço de dados da linguagem de script.
 Python, Lua e Perl oferecem recursos para fazer isto de forma direta: criando
 um objeto 
\family typewriter 
PyCObject
\family default 
 em Python; um light userdata em Lua; ou armazenando o ponteiro na área
 de dados de um 
\family typewriter 
SV
\family default 
 em Perl.
 Em Java e Ruby, a alternativa é converter os ponteiros e armazená-los como
 números.
 De fato, isto ocorre internamente na implementação de Ruby, e as limitações
 de portabilidade desta abordagem são evidenciados pelo fato de que a compilação
 de Ruby falha se 
\family typewriter 
sizeof(void*) != sizeof(long)
\family default 
.
\layout Standard

Outro aspecto que merece nota é a preocupação em não poluir o espaço de
 nomes de\SpecialChar ~
C.
 Python, Java e Lua definem todas as suas funções e tipos C com prefixos
 que visam evitar conflitos com nomes definidos pela aplicação.
 Já Perl e Ruby definem nomes de forma desorganizada, o que ocasionalmente
 causa problemas
\begin_inset Foot
collapsed true

\layout Standard

Por exemplo, conflitos deste tipo ocorreram nos bindings Ruby do sistema
 de controle de versão Subversion em plataformas Win32 (
\begin_inset LatexCommand \url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}

\end_inset 

).
\end_inset 

.
 Perl possui opções para desabilitar uma série de macros e forçar um prefixo
 comum em suas funções, mas este recurso é incompleto e usá-lo prejudica
 a funcionalidade dos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

No estudo de caso apresentado no Capítulo 
\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

, ao utilizar a API de Perl procuramos utilizar somente as versões com prefixo
 
\family typewriter 
Perl_
\family default 
 das funções da API, mas diversas macros só estão disponíveis nas versões
 sem o prefixo.
\end_inset 

.
\layout Section

Coleta de lixo
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

A partir do momento em que código C ganha acesso a referências a dados armazenad
os no espaço de armazenamento de outra linguagem, sejam ponteiros ou identificad
ores, o programador deve levar em consideração as diferenças entre os modelos
 de gerência de memória envolvidos, já que código executado na outra linguagem
 pode liberar o dado.
 Por exemplo, o programa C pode desalocar o objeto referenciado em um dado
 da linguagem de script, ou a linguagem de script pode remover um elemento
 de uma estrutura fazendo com que ele seja coletado.
 Em princípio, esta tarefa de manter a consistência entre os dois ambientes
 não é diferente da gerência de memória realizada normalmente pelo programador
 em C.
 Entretanto, a interação com algumas linguagens adiciona um complicador:
 os mecanismos de coleta de lixo realizam liberação de dados da memória
 de forma implícita.
 O princípio fundamental da coleta de lixo dita que um objeto não é coletado
 caso haja algum elemento (variável, estrutura de dados) apontando para
 ele.
 Todavia, o mesmo não vale para o ambiente C: a presença de um ponteiro
 apontando para um objeto não garante que ele não será coletado, uma vez
 que o coletor de lixo não gerencia os ponteiros do código\SpecialChar ~
C.
\layout Standard

É preciso, então, indicar a partir do código\SpecialChar ~
C que os dados que continuam
 acessíveis por ele não devem ser coletados.
 De forma complementar, ao transferir o controle de objetos\SpecialChar ~
C para o domínio
 da outra linguagem -- por exemplo, para armazená-los em uma estrutura de
 dados desta -- é necessário indicar à linguagem como desalocar a memória
 da estrutura quando o coletor de lixo detectar que ela não está mais em
 uso.
 A forma como a API irá fornecer estas funcionalidades depende não só do
 projeto da API para C, mas também do modelo de coleta de lixo empregado
 pela implementação da linguagem.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

A máquina virtual de Python possui um coletor de lixo baseado em contagem
 de referências.
 Como a API de Python retorna ao código C ponteiros a 
\family typewriter 
PyObject
\family default 
s, o programador deve ter o cuidado de garantir que eles se mantenham válidos.
 Para isto, é necessário incrementar e decrementar o contador de referências
 do objeto apontado conforme deseja-se manter a validade dos ponteiros em
 código C.
\layout Standard

De maneira geral, uma vez que código C deseja reter um 
\family typewriter 
PyObject*
\family default 
, ele deve utilizar a macro 
\family typewriter 
Py_INCREF
\family default 
 para incrementar a sua contagem de referências e assim impedi-lo de ser
 coletado.
 Uma vez que o valor não seja mais necessário, decrementa-se a contagem
 similarmente com 
\family typewriter 
Py_DECREF
\family default 
.
 Python trabalha com o conceito de 
\emph on 

\begin_inset Quotes eld
\end_inset 

propriedade de referências
\begin_inset Quotes erd
\end_inset 


\emph default 
 para definir quando o programador deve incrementar ou decrementar o contador
 de referências retornadas pelas funções da API.
 A maior parte das funções da API que retornam ponteiros a 
\family typewriter 
PyObject
\family default 
s 
\emph on 
transferem
\emph default 
 referências para o chamador; a referência passa então a ser sua responsabilidad
e -- ele pode passá-la adiante ou terá o dever de decrementá-la com 
\family typewriter 
Py_DECREF
\family default 
 assim que não precisar mais usá-la (o código C pode guardar referências
 que sejam de sua propriedade em suas estruturas de dados; elas continuarão
 válidas mesmo após o retorno da função, até serem explicitamente decrementadas).
 Outras funções 
\emph on 
emprestam
\emph default 
 referências; o código que recebe uma referência deste tipo não precisa
 decrementá-la ao terminar de utilizá-la, mas a validade do objeto está
 atrelada à validade da referência no objeto que a retornou ao código C.
 Por exemplo, 
\family typewriter 
PyList_GetItem
\family default 
 empresta uma referência a um elemento da lista.
 O ponteiro retornado continuará válido enquanto este item continuar contido
 na lista.
 Pode-se obter a 
\begin_inset Quotes eld
\end_inset 

propriedade
\begin_inset Quotes erd
\end_inset 

 de uma referência emprestada incrementando a contagem do objeto com 
\family typewriter 
Py_INCREF
\family default 
: a validade do ponteiro passa a ser independente do objeto 
\emph on 
container
\emph default 
 que o retornou, mas o código C passa a ser responsável por decrementar
 a referência posteriormente com 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

Para referências de objetos passadas de código C de volta para Python, há
 dois casos na API em que funções 
\emph on 

\begin_inset Quotes eld
\end_inset 

roubam
\begin_inset Quotes erd
\end_inset 


\emph default 
 referências, isto é, em que a referência deixa de pertencer à função C
 chamadora: 
\family typewriter 
PyList_SetItem
\family default 
 e 
\family typewriter 
PyTuple_SetItem
\family default 
.
 A referência passada, que pertencia ao chamador, passa então a pertencer
 à lista ou tupla.
 No contexto do chamador, ele passa a ser uma referência emprestada, que
 não precisa mais ser decrementada.
 O objetivo disto é permitir chamadas de função aninhadas onde, por exemplo,
 o parâmetro de 
\family typewriter 
PyList_SetItem
\family default 
 é uma chamada que gera um novo objeto a ser armazenado na lista.
 Assim, evita-se que o programador tenha que armazenar um ponteiro para
 o objeto apenas para decrementar a sua referência posteriormente.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Acesso possivelmente inválido em 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 é garantidamente válido em 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Acesso possivelmente inválido a uma referência a um 
\family typewriter 
PyObject
\family default 
 em código C
\end_inset 


\layout Standard

A interação com o contador de referências pode ser bastante sutil.
 O exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extraído da documentação de Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

, demonstra que uma referência pode ser invalidada por código aparentemente
 não relacionado
\begin_inset Foot
collapsed false

\layout Standard

De fato, a documentação informa que versões antigas de Python continham
 variantes deste 
\emph on 
bug
\emph default 
 em alguns de seus módulos.
\end_inset 

.
 À primeira vista, a inclusão de um elemento em 
\family typewriter 
list[1]
\family default 
 parece não afetar a referência 
\family typewriter 
item
\family default 
, que corresponde a 
\family typewriter 
list[0]
\family default 
.
 Todavia, a inclusão de 
\family typewriter 
list[1]
\family default 
 pode haver removido da lista um elemento que se encontrava nesta posição.
 Caso a lista fosse a última referência válida para o elemento, este poderia
 ser coletado.
 A coleta do objeto pode invocar o seu método finalizador 
\family typewriter 
__del__
\family default 
, que pode rodar código Python arbitrário.
 Se este código remove o elemento da posição 0 de 
\family typewriter 
list
\family default 
 e isto causar a sua coleta, a referência 
\family typewriter 
item
\family default 
 passa a ser inválida, porque 
\family typewriter 
PyList_GetItem
\family default 
 retorna uma referência emprestada.
\layout Standard

Ao implementar funções em C que retornam referências a 
\family typewriter 
PyObject
\family default 
s, o mesmo cuidado de definir a política de tempo de vida da referência
 deve ser tomado.
 Para retornar uma referência nova, pode ser necessário incrementar a contagem
 do objeto.
 Isto se manifesta, por exemplo, na forma correta de uma função C retornar
 o valor 
\family typewriter 
None
\family default 
, que envolve chamar 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed false

\layout Standard

Este padrão é tão comum que a seqüência 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 foi encapsulada na macro 
\family typewriter 
Py_RETURN_NONE
\family default 
.
\end_inset 

.
 Mesmo objetos Python representando números devem ter a sua contagem de
 referências controlada pelo programador C.
 
\layout Standard

Para que o código C possa realizar operações de finalização sobre os dados
 armazenados em um tipo Python definido em C, é possível definir uma função
 de desalocação no campo 
\family typewriter 
tp_dealloc
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo.
 Esta função é normalmente responsável por liberar recursos alocados via
 código C (arquivos abertos, ponteiros para áreas de memória não acessíveis
 por Python, etc.) e decrementar referências a outros objetos Python mantidas
 pelo objeto.
\layout Standard

Ao desalocar estruturas de dados como listas pode-se provocar uma cadeia
 arbitrariamente grande de desalocações, à medida que cada elemento desencadeia
 a desalocação do próximo elemento da estrutura.
 Isto dispara a função de desalocação recursivamente e poderia facilmente
 causar estouro da pilha de C.
 Para contornar este problema, Python inclui um par de macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 e 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, que controla o número de níveis de recursão aceitos.
 A cada execução de 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 um contador interno é incrementado.
 Enquanto este contador não atingir o valor limite definido na constante
 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 (50 por padrão), a função executa normalmente.
 Quando o limite é atingido, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 armazena o objeto em uma lista interna e salta diretamente para 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, evitando desalocar o objeto e entrar em recursão novamente.
 Ao final de cada nível da recursão, a macro 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 decrementa o contador.
 Quando o contador chega a zero, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 dispara novamente 
\family typewriter 
tp_dealloc
\family default 
 sobre os elementos armazenados na lista interna, reiniciando assim a recursão
 sobre a estrutura.
 Assim, uma cadeia de 
\begin_inset Formula $n$
\end_inset 

 desalocações é quebrada em 
\begin_inset Formula $n/$
\end_inset 


\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 cadeias, nenhuma excedendo 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 níveis de recursão na pilha de C.
 As implementações dos principais tipos estruturados de Python, como listas,
 tuplas e dicionários, fazem uso deste mecanismo.
\layout Standard

O modelo de coleta de lixo utilizando contagem de referências traz consigo
 preocupações sobre referências circulares: uma cadeia de objetos que mantêm
 referências entre si mantém a contagem de cada um dos seus elementos acima
 de zero, mesmo que eles não sejam alcançáveis a partir de nenhum outro
 objeto.
 Python inclui um detector de ciclos, mas cuidados especiais devem ser tomadas
 para que tipos implementados em C se comportem corretamente caso possam
 gerar ciclos.
 Deve-se implementar uma função para percorrer referências contidas no objeto
 e uma função que decremente a contagem destas referências.
 Estas funções devem ser registradas nos campos 
\family typewriter 
tp_traverse
\family default 
 e 
\family typewriter 
tp_clear
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
.
 A função 
\family typewriter 
tp_clear
\family default 
 deve ter o cuidado de zerar o valor de seus campos 
\family typewriter 
PyObject*
\family default 
 para 
\family typewriter 
NULL
\family default 
 antes de decrementar cada referência, uma vez que a operação de decremento
 pode iniciar a desalocação do objeto e disparar uma chamada a 
\family typewriter 
tp_traverse
\family default 
 que, devido ao ciclo, retorne ao objeto anterior.
 O tipo deve ser, então, identificado com a flag 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 no campo 
\family typewriter 
tp_flags
\family default 
 de 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard

Além disso, a implementação de objetos Python que suportem coleta cíclica
 em C implica ainda em outros cuidados.
 Objetos devem ser alocados com 
\family typewriter 
PyObject_GC_New
\family default 
 ou 
\family typewriter 
PyObject_GC_NewVar
\family default 
 ao invés da funções usuais 
\family typewriter 
PyObject_New
\family default 
 e 
\family typewriter 
PyObject_NewVar
\family default 
.
 Durante a construção do objeto, após os campos a serem visitados por 
\family typewriter 
tp_traverse
\family default 
 terem sido preenchidos, é necessário ainda chamar uma função de notificação
 
\family typewriter 
PyObject_GC_Track
\family default 
 e durante a desalocação, antes de invalidar os campos do objeto, chamar
 
\family typewriter 
PyObject_GC_UnTrack
\family default 
.
 Para objetos que necessitem do mecanismo de 
\emph on 

\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 


\emph default 
 para evitar estouro de pilha, é ainda preciso tomar o cuidado de desmarcar
 o objeto com 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 antes de entrar no bloco 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\end_inset 


\layout Standard

Apesar de oferecer um mecanismo de detecção de ciclos, Python é incapaz
 de coletar ciclos cujos objetos contenham finalizadores implementados em
 Python (métodos 
\family typewriter 
__del__
\family default 
); a única forma de acessar estes objetos é então através da lista 
\family typewriter 
garbage
\family default 
 no módulo 
\family typewriter 
gc
\family default 
.
 Este módulo (acessível a partir de C através de chamadas de função Python
 via API) oferece uma interface com o coletor de lixo, incluindo funções
 como 
\family typewriter 
enable
\family default 
 e 
\family typewriter 
disable
\family default 
, para ativar e desativar o coletor de lixo; 
\family typewriter 
collect
\family default 
, para executar uma coleta; 
\family typewriter 
get_objects
\family default 
, que retorna uma lista contendo todos os objetos controlados pelo coletor
 (exceto a própria lista); 
\family typewriter 
get_referrers
\family default 
 e 
\family typewriter 
get_referents
\family default 
, que retornam a lista de objetos que referenciam ou são referenciados por
 um dado objeto -- estas listas são obtidas percorrendo objetos com a função
 
\family typewriter 
tp_traverse
\family default 
, o que pode não apontar para todos os objetos realmente alcançáveis, ou
 ainda retornar objetos em estado inválido (como objetos em ciclos ainda
 não coletados ou objetos ainda não totalmente construídos) e assim devem
 ser usadas apenas para fins de depuração.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby utiliza um coletor de lixo 
\emph on 
mark-and-sweep
\emph default 
\SpecialChar ~

\begin_inset LatexCommand \cite{wilson92gc}

\end_inset 

.
 Esta técnica evita o problema de referências cíclicas enfrentado por Python,
 bastando que os objetos válidos possam ser corretamente indicados como
 alcançáveis.
\layout Standard

Objetos alcançáveis a partir do espaço de objetos de Ruby -- atribuídos
 a uma variável global Ruby ou inseridos em alguma estrutura de dados alcançável
 em Ruby -- não estarão sujeitos à coleta de lixo.
 Além destes, temos ainda os objetos retornados por Ruby para o espaço de
 C, já que muitas funções de API retornam 
\family typewriter 
VALUE
\family default 
s.
 A documentação alerta que, para armazenar objetos Ruby em C, seja em variáveis
 globais ou estruturas de dados, é necessário notificar à máquina virtual
 que o 
\family typewriter 
VALUE
\family default 
 não deve ser coletado usando a função 
\family typewriter 
rb_global_variable
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 (Embora a documentação não informe, é possível desmarcar um valor global
 com 
\family typewriter 
rb_gc_unregister_address
\family default 
).
\layout Standard

Objetos de escopo local a uma função C, entretanto, não precisam ser notificados.
 A forma como Ruby garante a validade de 
\family typewriter 
VALUE
\family default 
s locais é bastante peculiar: ao realizar a fase de marcação, o coletor
 de lixo varre a pilha de C em busca de valores que se pareçam com endereços
 de 
\family typewriter 
VALUE
\family default 
s, isto é, seqüências numéricas que correspondam a endereços de 
\family typewriter 
VALUE
\family default 
s válidos.
 Estes endereços podem ser identificados pois objetos são sempre alocados
 dentro de 
\emph on 
heaps
\emph default 
 mantidas pelo interpretador Ruby.
 Cada 
\family typewriter 
VALUE
\family default 
 encontrado na pilha é então marcado.
 Isto garante que nenhum 
\family typewriter 
VALUE
\family default 
 localmente alcançável por código C seja invalidado, mas pode gerar 
\begin_inset Quotes eld
\end_inset 

falsos positivos
\begin_inset Quotes erd
\end_inset 

 evitando que dados que poderiam ser coletados o sejam.
\layout Standard

Apesar da conveniência para o programador, tal abordagem é extremamente
 não-portável.
 A implementação do coletor de lixo em Ruby 1.8.2 possui 
\family typewriter 
#ifdef
\family default 
s para IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC e Motorola 68000.
 Além disso, o coletor força a descarga dos registradores para a pilha usando
 
\family typewriter 
setjmp
\family default 
, para evitar que variáveis do tipo 
\family typewriter 
VALUE
\family default 
 que tenham sido otimizadas pelo compilador deixem de ser verificadas.
\layout Standard

Conforme visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-dados}

\end_inset 

, objetos Ruby criados com 
\family typewriter 
Data_Wrap_Struct
\family default 
 contêm structs C, que podem conter referências a 
\family typewriter 
VALUE
\family default 
s Ruby.
 A struct encapsulada, entretanto, é opaca para o universo Ruby.
 Então, para garantir que estes 
\family typewriter 
VALUE
\family default 
s sejam marcados como alcançáveis durante a coleta de lixo é necessário
 fazer isto via código C.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 recebe, além da struct a encapsular, dois ponteiros, um para uma função
 de marcação e outra para uma função de desalocação.
 Quando o coletor de lixo visita o objeto na fase de marcação, ele invoca
 a função registrada, que deve chamar 
\family typewriter 
rb_gc_mark
\family default 
 em cada um dos 
\family typewriter 
VALUE
\family default 
s armazenados na 
\emph on 
struct
\emph default 
 do objeto, informando assim que os objetos são alcançáveis.
 Quando um objeto encapsulado via 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 for dado como não alcançável, a função de desalocação registrada é chamada.
 Para estruturas que não armazenam outros 
\family typewriter 
VALUE
\family default 
s, pode-se definir a função de marcação como 
\family typewriter 
NULL
\family default 
 e a de desalocação como 
\family typewriter 
free
\family default 
.
\layout Standard

Ruby possui um módulo 
\family typewriter 
GC
\family default 
 que disponibiliza funções para ativar e desativar o coletor (
\family typewriter 
GC.enable
\family default 
 e 
\family typewriter 
GC.disable
\family default 
), bem como disparar uma coleta imediatamente (
\family typewriter 
GC.start
\family default 
).
 Na API em C há funções equivalentes: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 A API de C inclui ainda uma função que insere um objeto imediatamente na
 lista de objetos a serem reciclados pelo alocador de memória de Ruby, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 Esta função deve ser usada com cuidado, já que se houverem outras referências
 apontando ao objeto elas passarão a apontar para outro objeto quando a
 área de memória for reutilizada pelo alocador de Ruby.
\layout Standard

Ruby oferece ainda como conveniência para o programador C alguns 
\emph on 
wrappers
\emph default 
 para as funções 
\family typewriter 
malloc
\family default 
 e 
\family typewriter 
realloc
\family default 
 que interagem com o coletor de lixo, forçando a execução do coletor durante
 alocações grandes
\begin_inset Foot
collapsed false

\layout Standard

O limite para definir 
\begin_inset Quotes eld
\end_inset 

grande
\begin_inset Quotes erd
\end_inset 

 se ajusta de acordo com o funcionamento do coletor e com as alocações realizada
s anteriormente.
\end_inset 

 ou em situações de pouca memória disponível.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Assim como Python e Ruby, a API de Java retorna referências a objetos da
 máquina virtual que podem ser armazenados em variáveis C.
 A JNI define três tipos de referências, 
\emph on 
locais
\emph default 
, 
\emph on 
globais
\emph default 
 e 
\emph on 
globais fracas
\emph default 
, para auxiliar no controle do tempo de vida destas e a sua interação com
 o coletor de lixo.
\layout Standard

Referências locais são retornadas pela maioria das funções da JNI e são
 válidas até o retorno da função C que a obteve.
 Não é necessário desalocar explicitamente uma referência local: durante
 a execução de uma função C, a JVM mantém uma lista de referências locais
 passadas à função e libera todas elas quando o controle retorna à máquina
 virtual.
 Isto faz com que, de maneira geral, o programador não precise se preocupar
 com o coletor de lixo enquanto manipula valores retornados durante uma
 função.
 Por outro lado, em código que pode utilizar uma grande quantidade de referência
s locais é mais eficiente desalocar referências locais explicitamente, usando
 
\family typewriter 
DeleteLocalRef
\family default 
.
 A partir da versão 1.2 de Java, funções foram adicionadas para permitir
 a gerência de referências locais em blocos.
 
\family typewriter 
PushLocalFrame
\family default 
 e 
\family typewriter 
PopLocalFrame
\family default 
 permitem criar escopos aninhados de referências locais, que são desalocados
 de uma só vez.
 
\family typewriter 
PushLocalFrame
\family default 
 recebe ainda um parâmetro indicando um número de 
\emph on 
slots
\emph default 
 a serem pré-alocados, como otimização.
 Esse valor pode ser configurado também com 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Referências globais são geradas a partir de referências locais usando 
\family typewriter 
NewGlobalRef
\family default 
.
 Referências deste tipo mantêm-se válidas até serem explicitamente desalocadas
 com 
\family typewriter 
Delete\SpecialChar \-
GlobalRef
\family default 
.
 Uma referência global impede o objeto de ser coletado, podendo assim, ser
 utilizada para armazenar objetos Java no espaço de C além da duração de
 uma função, por exemplo, em variáveis globais ou estáticas.
\layout Standard

A Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 mostra um exemplo do tipo de gerência de referências necessário quando
 se tem um laço criando referências temporárias sobre um número arbitrário
 de objetos.
\layout Standard

No exemplo, a função 
\family typewriter 
Java_Exemplo_concatArray
\family default 
 (equivalente, portanto, ao método 
\family typewriter 
concatArray
\family default 
 de uma classe 
\family typewriter 
Exemplo
\family default 
) converte os elementos de um array para strings usando 
\family typewriter 
Object.toString
\family default 
 e os concatena usando 
\family typewriter 
String.concat
\family default 
.
 Note que, como o número de vezes que o laço executa depende do tamanho
 do array passado, deve-se evitar que o número de referências cresça em
 cada iteração.
 Para isso, as opções seriam ou usar 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, ou destruir as referências uma a uma com 
\family typewriter 
DeleteLocalRef
\family default 
.
 Se usássemos 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 no exemplo, teríamos que manter a string concatenada até o momento em uma
 referência global.
 Além disso, esta referência teria que ser destruída e recriada a cada iteração,
 já que strings são imutáveis em Java.
 Como o número de locais é pequeno, é mais conveniente neste caso controlá-las
 explicitamente com 
\family typewriter 
DeleteLocalRef
\family default 
 do que recorrer a referências globais.
 
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 permite, através de um parâmetro adicional, transferir uma referência local
 do conjunto que está sendo desempilhado para o escopo exterior de referências
 locais, criando assim uma nova referência.
 Para o exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, isto ainda não evitaria a necessidade de liberar referências locais explicitam
ente a cada iteração do laço, já que cada 
\family typewriter 
PopLocalFrame
\family default 
 criaria uma referência local nova.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
\emph on 
/* Fazer o caching de jmethodIDs em código C é uma técnica comum.
\layout LyX-Code


\size footnotesize 
\emph on 
   Vale lembrar que jmethodIDs não são objetos Java, e portanto
\layout LyX-Code


\size footnotesize 
\emph on 
   não estão sujeitos a coleta de lixo.
 */
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);     
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);     
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\emph on 
   /* os = o.toString() */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\emph on 
 /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Rotina para concatenar os elementos de um array representados como strings.
\end_inset 


\layout Standard

A partir da versão 1.2, a JNI inclui referências globais fracas, com o objetivo
 de oferecer uma forma simplificada das referências fracas de Java (
\family typewriter 
java.lang.ref
\family default 
) -- um objeto que esteja sendo apontado apenas por referências globais
 fracas pode ser coletado.
 Originalmente, a API incluiu a função 
\family typewriter 
IsSameObject
\family default 
 como forma de verificar a validade de uma referência fraca, mas evidentemente
 este método é insuficiente: como Java é 
\emph on 
multi-threaded
\emph default 
, o coletor de lixo pode invalidar a referência entre o teste e a instrução
 seguinte no código\SpecialChar ~
C.
 A documentação revisada avisa sobre esta limitação e recomenda o uso de
 referências globais, além de alertar sobre comportamentos indefinidos nas
 relações entre referências globais fracas em C e os tipos de referências
 fracas definidos em Java\SpecialChar ~

\begin_inset LatexCommand \cite{jni1503spec}

\end_inset 

.
\layout Standard

Além desta, outras questões surgem a partir da combinação do modelo 
\emph on 
multi-threaded
\emph default 
 de Java com a exposição de referências a objetos da máquina virtual ao
 código C.
 Para reduzir o volume de cópia de dados entre Java e C, a JNI oferece algumas
 funções que retornam e liberam ponteiros para a representação interna de
 strings e arrays de tipos pri\SpecialChar \-
mi\SpecialChar \-
ti\SpecialChar \-
vos: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 e 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 O uso destas funções, porém, possui importantes restrições.
 A API especifica que, uma vez obtido um ponteiro através destas funções,
 o código\SpecialChar ~
C não deve chamar outras funções da JNI ou realizar chamadas que
 possam bloquear a thread atual e fazer com que ela espere por outra thread
 Java, sob o risco de causar um 
\emph on 
deadlock
\emph default 
.
 Recomenda-se não manter blocos de memória bloqueados usando estas funções
 por muito tempo já que uma das técnicas possíveis para a implementação
 desta 
\begin_inset Quotes eld
\end_inset 

região crítica
\begin_inset Quotes erd
\end_inset 

 consiste em desabilitar o coletor de lixo da JVM.
 É importante notar ainda que referências locais e o ponteiro para o ambiente
 JNI passado para funções nativas são válidos apenas na thread onde foram
 criados; referências globais podem ser compartilhadas entre threads.
\layout Standard

Além do mecanismo de referências fracas fornecido pelas classes do pacote
 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
, a única forma oferecida por Java para interagir de maneira mais direta
 com o coletor de lixo é através da chamada 
\family typewriter 
System.gc()
\family default 
, que solicita à máquina virtual que dispare tão logo quanto possível a
 thread de coleta para que esta desaloque objetos não alcançáveis.
 Não há uma função C equivalente na JNI, mas este método pode ser invocado
 a partir de\SpecialChar ~
C com 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

Por não retornar referências explícitas a objetos Lua ao código C, a interação
 do código nativo com o coletor de lixo é bastante simplificada.
 Operações sobre objetos Lua são sempre especificadas através de índices
 da pilha virtual.
 Assim, a máquina virtual mantém o controle sobre quais os objetos são acessívei
s a partir de C em qualquer dado momento.
 
\layout Standard

Embora ponteiros para objetos não sejam manipulados na API, algumas funções
 retornam ponteiros para estruturas gerenciadas por Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
 e 
\family typewriter 
lua_touserdata
\family default 
.
 A validade dos ponteiros retornados por estas funções é dependente do tempo
 de vida do objeto correspondente a eles; para strings em particular, o
 ponteiro retornado só é garantidamente válido enquanto a string estiver
 na pilha.
 Lua oferece ainda a função 
\family typewriter 
lua_topointer
\family default 
, que permite obter ponteiros para alguns tipos de objetos (
\emph on 
userdata
\emph default 
, tabelas, 
\emph on 
threads
\emph default 
 e funções), mas somente com o objetivo de obter informação para depuração,
 já que não é possível converter o ponteiro de volta para um valor Lua.
 
\layout Standard

O conteúdo da pilha virtual é zerado quando a função C retorna o controle
 à máquina virtual de Lua.
 Dessa forma, não é possível reter ponteiros retornados por Lua para uso
 posterior em variáveis globais ou estruturas de C.
 Por outro lado, a API oferece um mecanismo para armazenar valores Lua em
 uma localização conhecida por código C que não pode ser alterada via código
 Lua: o 
\emph on 
registro
\emph default 
.
 O registro é uma tabela disponibilizada pela API de Lua para o armazenamento
 de valores Lua a partir de C; esta tabela não é normalmente acessível a
 partir de Lua.
 Como a tabela que implementa o registro é parte do 
\emph on 
root set
\emph default 
 do coletor de lixo, a inclusão de um objeto nesta tabela o impede de ser
 coletado, mantendo-o no registro até que seja explicitamente removido via
 código C.
\layout Standard

Usando o registro, uma forma possível de descrever dados do espaço de Lua
 em estruturas de dados em C é armazenar os dados no registro e armazenar
 os índices usados na estrutura C.
 A biblioteca auxiliar de Lua encapsula tal idioma através de duas funções,
 
\family typewriter 
luaL_ref
\family default 
 e 
\family typewriter 
luaL_unref
\family default 
.
 A função 
\family typewriter 
luaL_ref
\family default 
 associa o valor Lua passado a uma chave numérica inteira no registro, e
 retorna este número.
 Este valor então ser visto como um 
\emph on 
handle
\emph default 
 de alto nível para o objeto: o código C pode armazená-lo em variáveis ou
 estruturas e utilizá-lo para referenciar o objeto através do campo no registro.
 A função 
\family typewriter 
luaL_unref
\family default 
 remove o valor Lua do registro e libera o índice para reuso.
 Para o bom funcionamento deste mecanismo, chaves inteiras não devem ser
 utilizadas diretamente pelo programador para armazenar dados no registro.
\layout Standard

A API permite associar a objetos do tipo 
\emph on 
full userdata
\emph default 
 uma função de desalocação, 
\family typewriter 
__gc
\family default 
, na sua metatabela.
 Quando presente, esta função será tipicamente implementada em C, realizando
 a finalização de recursos.
 Por exemplo, o metamétodo 
\family typewriter 
__gc
\family default 
 de objetos retornados pela função Lua 
\family typewriter 
io.open
\family default 
 é uma função C que fecha o descritor de arquivo correspondente com a função
 C 
\family typewriter 
fclose
\family default 
.
 
\layout Standard

A princípio, o fato de que é possível obter e modificar a metatabela de
 um userdata via código Lua pode parecer problemático, já que pode-se substituir
 o seu finalizador em 
\family typewriter 
__gc
\family default 
.
 Entretanto, funções de coleta implementadas em C tipicamente validam o
 userdata recebido verificando o seu 
\begin_inset Quotes eld
\end_inset 

tipo
\begin_inset Quotes erd
\end_inset 

, identificado através da metatabela.
 Assim, mesmo que código Lua manipule a metatabela, uma função de coleta
 implementada em C que use 
\family typewriter 
luaL_checkudata
\family default 
 não será levada a operar sobre um 
\emph on 
userdata
\emph default 
 de tipo incorreto.
 Para impedir o código Lua de alterar a função de coleta de um objeto 
\emph on 
userdata
\emph default 
, pode-se atribuir um valor qualquer, como 
\family typewriter 
false
\family default 
, ao campo 
\family typewriter 
__metatable
\family default 
 da metatabela, que passa a ser retornado no lugar da metatabela, tornando
 a metatabela em si inacessível.
\layout Standard

Outro recurso relacionado à gerência de memória oferecido por Lua é a possibilid
ade de configurar, em tempo de execução, a função de alocação de memória
 a ser usada pela máquina virtual.
 Na criação de um novo estado Lua, passa-se como parâmetro uma função de
 alocação que deve oferecer funcionalidade similar às funções C 
\family typewriter 
free
\family default 
 e 
\family typewriter 
realloc
\family default 
, dependendo se o tamanho de bloco passado for igual ou maior do que zero.
 
\layout Standard

Lua oferece uma interface com o coletor de lixo através das funções 
\family typewriter 
lua_gc
\family default 
 em C e 
\family typewriter 
collectgarbage
\family default 
 em Lua.
 O coletor de Lua implementa 
\emph on 
mark-and-sweep
\emph default 
 incremental e permite ao programador configurar parâmetros relacionados
 aos intervalos de coleta, bem como ativar, desativar, disparar ciclos completos
 e executar passos do coletor.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Como Python, Perl realiza coleta de lixo baseada em contagem de referências.
 A API provê funções para o controle explícito da contagem: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 para incremento e decremento e um 
\emph on 
getter
\emph default 
, 
\family typewriter 
SvREFCNT
\family default 
.
 Outra forma de alterar a contagem de referências de um valor é atribuindo-o
 a uma referência Perl com 
\family typewriter 
newRV_inc
\family default 
.
 A contagem do valor referenciado será incrementada, fazendo com que --
 salvo tenha sua contagem alterada explicitamente -- este se mantenha válido
 enquanto for referenciado pelo 
\family typewriter 
RV
\family default 
.
 É importante notar, porém, que as funções da API que criam valores, como
 
\family typewriter 
newSViv
\family default 
, inicializam os seus contadores de referências com 1.
 Isto tem o efeito de que se um valor é criado em uma função C, armazenado
 em um 
\family typewriter 
RV
\family default 
 com 
\family typewriter 
newRV_inc
\family default 
 e esta referência é retornada a Perl, o valor nunca será coletado, pois
 o seu contador não retornará a 0 quando a referência for destruída.
 A forma correta, então, é usar 
\family typewriter 
newRV_noinc
\family default 
 para 
\family typewriter 
RV
\family default 
s contendo valores recém-criados e 
\family typewriter 
newRV_inc
\family default 
 quando um 
\family typewriter 
RV
\family default 
 deve manter válido um valor já existente.
\layout Standard

A inicialização da contagem de referências em 1 garante que valores criados
 continuarão válidos durante a execução de uma função C sem que seja necessário
 armazenar o valor no espaço de Perl.
 Estes valores podem também ser armazenados em variáveis globais e estruturas
 de dados de C e se manterão válidos até que a sua contagem de referências
 seja decrementada.
 Para valores cujo tempo de vida é restrito a uma função, a API de Perl
 define o conceito de valores 
\begin_inset Quotes eld
\end_inset 

mortais
\begin_inset Quotes erd
\end_inset 

 como uma forma de permitir desalocar todos os valores temporários de uma
 função de uma só vez.
 Um 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 pode ser criado com 
\family typewriter 
sv_newmortal
\family default 
 ou, mais comumente, convertido para mortal com 
\family typewriter 
sv_2mortal
\family default 
.
 Na prática, marcar um valor como mortal corresponde a indicar que ele deve
 ter a sua contagem de referências decrementada na chamada da macro 
\family typewriter 
FREETMPS
\family default 
 ao término da função, conforme será visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Algumas funções da API retornam valores mortais: por exemplo, 
\family typewriter 
hv_delete
\family default 
 remove um elemento de uma hash e, caso a flag 
\family typewriter 
G_DISCARD
\family default 
 não seja passada, retorna o elemento removido como um 
\family typewriter 
SV
\family default 
 mortal.
\layout Standard

A API de Perl não possui facilidades de interface com o coletor de lixo,
 mas possui algumas funções para auxílio em depuração que reportam informações
 sobre o estado da coleta de lixo.
 A função 
\family typewriter 
sv_report_used
\family default 
 exibe o conteúdo de todos os 
\family typewriter 
SV
\family default 
s do interpretador.
 O módulo 
\family typewriter 
Devel::Peek
\family default 
 permite examinar a partir de Perl o conteúdo de valores (contagem de referência
s, 
\emph on 
flags
\emph default 
, etc.) -- a partir de C, estas informações estão disponíveis diretamente
 já que as estruturas não são opacas.
\layout Subsection

Comparação
\layout Standard

Coleta de lixo tem por objetivo isolar, na medida do possível, o programador
 da gerência de memória.
 Desta forma, idealmente uma API deveria também ser tão independente quanto
 possível do algoritmo de coleta de lixo utilizado pela implementação da
 máquina virtual.
 Perl e Python realizam coleta de lixo baseada em contagem de referências,
 e isto transparece nas operações de incremento e decremento de referências
 freqüentemente necessárias durante o uso de suas APIs.
\layout Standard

Ruby utiliza um contador de referências baseado em mark-and-sweep.
 A sua API consegue abstrair bem este fato para a manipulação de objetos
 nativos Ruby, mas a implementação do coletor é evidente na criação de tipos
 Ruby em C, onde precisamos declarar uma função de marcação quando temos
 estruturas C que guardam referências para objetos Ruby.
 A API de Lua vai além ao isolar-se da implementação do coletor de lixo
 utilizado: o único ponto da API onde o emprego de um coletor de lixo incrementa
l é aparente é na rotina de interação direta com o coletor, 
\family typewriter 
lua_gc
\family default 
, onde pode-se configurar parâmetros deste.
\layout Standard

Das cinco linguagens, a única cuja API abstrai totalmente a implementação
 do coletor de lixo é Java.
 A única operação de interface com o coletor que a linguagem provê, 
\family typewriter 
System.gc()
\family default 
, não recebe parâmetros e não especifica como ou quando a coleta deve ser
 feita
\begin_inset Foot
collapsed true

\layout Standard

A documentação é propositalmente vaga, dizendo apenas que este método 
\emph on 

\begin_inset Quotes eld
\end_inset 

suggests that the Java Virtual Machine expend effort toward recycling unused
 objects
\begin_inset Quotes erd
\end_inset 


\emph default 
 .
\end_inset 

.
 De fato, as várias implementações da JVM utilizam algoritmos diferentes
 para coleta de lixo.
\layout Standard

Na manipulação de dados através da API, Lua e Ruby são as linguagens que
 menos demandam do programador preocupações com gerência de referências.
 Ruby mantém o controle das referências retornadas a funções C varrendo
 a pilha de C durante a coleta de lixo, detectando a presença de referências
 armazenadas em variáveis locais.
 Lua evita o problema como um todo, mantendo seus objetos na pilha virtual
 e não retornando referências a eles ao código C.
\layout Standard

O problema de referências armazenadas em variáveis locais de uma função
 é tratado por Perl e Java de forma semelhante, definindo dois tipos de
 referências, globais e locais (referências locais são chamadas de 
\begin_inset Quotes eld
\end_inset 

variáveis mortais
\begin_inset Quotes erd
\end_inset 

 em Perl).
 Referências locais têm gerência implícita (salvo alguns casos, como discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

).
 As funções da API de Java retornam referências locais por padrão, que podem
 ser convertidas para globais com 
\family typewriter 
NewGlobalRef
\family default 
.
 Em Perl ocorre o contrário, e as referências globais são convertidas para
 locais com 
\family typewriter 
sv_2mortal
\family default 
.
 O modelo de Java é mais interessante, pois normalmente são usadas mais
 variáveis de escopo local do que global.
 Valores armazenados globalmente têm sempre alguma forma de gerência explícita
 associada a si, mesmo em Ruby e Lua, através de 
\family typewriter 
rb_global_variable
\family default 
 e 
\family typewriter 
luaL_ref
\family default 
/
\family typewriter 
luaL_unref
\family default 
.
\layout Section

Chamada de funções a partir de C
\layout Standard

A API deve prover uma forma de invocar a partir de C funções a serem executadas
 pela linguagem de script.
 Isto envolve a passagem de dados entre estes dois 
\begin_inset Quotes eld
\end_inset 

espaços
\begin_inset Quotes erd
\end_inset 

, conforme visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 e as implicações que isto traz sobre o tempo de vida dos objetos, abordadas
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Devido à tipagem estática de C, não é possível usar uma sintaxe transparente
 para chamada de funções registradas em tempo de execução.
 É necessário então que a API defina funções para realizar chamadas na linguagem
 de script.
\layout Standard

Nesta seção serão discutidas as facilidades oferecidas por cada API para
 a invocação de funções para execução na máquina virtual.
 As principais questões envolvidas são como referenciar a função a ser chamada,
 como passar argumentos a ela e como obter o valor de retorno, incluindo
 formas de notificação no caso de erros.
 Para fins de ilustração, será apresentado em cada linguagem um exemplo
 de chamada de uma função simples.
 Assume-se que tenha sido definida no espaço de cada linguagem de script
 uma função 
\family typewriter 
teste
\family default 
, que recebe um inteiro e uma string como parâmetros e retorna um inteiro
 como resultado.
 Para maior brevidade, a verificação de erros será omitida nos exemplos.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

Para chamar uma função Python a partir de C, deve-se inicialmente obter
 um ponteiro para o 
\family typewriter 
PyObject
\family default 
 correspondente à função, como visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Além de funções implementadas em Python e funções C registradas a partir
 da API, qualquer tipo de dado que implemente o método 
\family typewriter 
__call__
\family default 
 (ou declare uma função no campo 
\family typewriter 
tp_call
\family default 
 de sua estrutura 
\family typewriter 
PyTypeObject
\family default 
) pode ser chamado como uma função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções para chamar funções
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

A API de Python oferece diversas funções para realização de chamadas a partir
 de C.
 A função mais geral, 
\family typewriter 
PyObject_Call
\family default 
, recebe como parâmetros o objeto a ser chamado, uma tupla Python contendo
 os parâmetros a serem passados e opcionalmente um dicionário de argumentos
 
\emph on 
keyword
\emph default 
.
 Como conveniência, outras funções permitem passar os argumentos de outras
 formas.
 Por exemplo, 
\family typewriter 
PyObject_CallFunction
\family default 
 encapsula a chamada a 
\family typewriter 
Py_BuildValue
\family default 
 (vista na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), aceitando diretamente a string de formato desta e os valores a serem
 convertidos.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 é uma função 
\emph on 
vararg
\emph default 
 que aceita uma seqüência de ponteiros para 
\family typewriter 
PyObject
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Existem também funções de conveniência para a invocação de métodos.
 A função 
\family typewriter 
PyObject_CallMethod
\family default 
 é uma variante de 
\family typewriter 
PyObject_CallFunction
\family default 
 que recebe como parâmetros um 
\family typewriter 
PyObject
\family default 
 e uma string C contendo o nome do método.
 Assim, por exemplo, as duas formas abaixo são equivalentes à chamada Python
\size footnotesize 
 
\family typewriter 
\size default 
ret = uma_string.split(" ")
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* "s" indica que o parâmetro seguinte é do tipo string.
 */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(uma_string, "split", "s", " ");
\newline 
 
\newline 
PyObject* split = PyObject_GetAttrString(uma_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É interessante notar que quando um método é chamado como função, o argumento
 
\family typewriter 
self
\family default 
 não é passado explicitamente.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

O valor de retorno em todas as funções de chamada é um ponteiro para 
\family typewriter 
PyObject
\family default 
.
 Assim como ocorre em código Python, quando funções Python retornam múltiplos
 valores, estes são encapsulados em uma tupla.
 Para funções que não retornam valor, as funções\SpecialChar ~
C devem retornar 
\family typewriter 
Py_None
\family default 
.
 Em caso de erro na chamada, as funções retornam 
\family typewriter 
NULL
\family default 
.
 A ocorrência de exceções pode então ser verificada com a função 
\family typewriter 
PyErr_Occurred
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Uma forma típica para chamar uma função Python 
\family typewriter 
teste
\family default 
, incluindo a obtenção da função e a conversão dos valores de entrada e
 saída entre Python e C, é exibida a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* teste = PyDict_GetItemString(globals, "teste");
\layout LyX-Code


\size footnotesize 
\emph on 
/* "si" indica que seguem parâmetros string e inteiro */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(teste, "si", "entrada", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converte o valor para C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Libera o PyObject temporário retornado.
 */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Uma função global é obtida através do dicionário do módulo 
\family typewriter 
__main__
\family default 
.
 A conversão dos dados de entrada de C para Python é feita através da string
 de formato recebida por 
\family typewriter 
PyObject_CallFunction
\family default 
.
 Esta chamada equivale a 
\family typewriter 
obj_result = teste("entrada", 2)
\family default 
 em Python.
 O valor de saída é retornado como uma nova referência a um objeto Python
 e, desta forma, precisa ter a contagem de referências decrementada após
 o seu uso.
 As funções 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 e 
\family typewriter 
PyDict_GetItemString
\family default 
 retornam referências emprestadas, portanto a contagem de referências dos
 
\family typewriter 
PyObject
\family default 
s retornados por elas não precisam ser decrementadas após o seu uso.
 Todavia, após a chamada da função Python, não há garantia de que os ponteiros
 
\family typewriter 
globals
\family default 
 e 
\family typewriter 
teste
\family default 
 ainda apontem para objetos válidos -- precisaríamos ter incrementado a
 sua contagem de referências caso quiséssemos usá-los novamente.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções para chamar funções
\end_inset 


\layout Standard

Como métodos não são valores de primeira classe em Ruby, eles não são representa
dos como 
\family typewriter 
VALUE
\family default 
s na sua API de C.
 Para a chamada de métodos Ruby em C, a API oferece a função 
\family typewriter 
rb_funcall
\family default 
 e algumas variantes.
 Em comum, todas recebem como parâmetro o 
\family typewriter 
VALUE
\family default 
 indicando ao objeto sobre o qual o método se refere, um 
\family typewriter 
ID
\family default 
 referente à string internalizada contendo o nome do método e um inteiro
 informando o número de argumentos.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

Como em Python, as funções da API para invocação de métodos diferem na forma
 como os argumentos são passados.
 Por exemplo, a função 
\family typewriter 
rb_funcall
\family default 
 recebe os argumentos na forma de 
\family typewriter 
VALUE
\family default 
s passados como varargs C; 
\family typewriter 
rb_funcall2
\family default 
 recebe um array C de 
\family typewriter 
VALUE
\family default 
s; 
\family typewriter 
rb_apply
\family default 
 recebe um 
\family typewriter 
VALUE
\family default 
 que deve ser um array Ruby contendo os parâmetros.
 Todas elas retornam um 
\family typewriter 
VALUE
\family default 
 como parâmetro.
 Assim como em código Ruby, múltiplos valores de retorno são representados
 como um array Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Todas as rotinas de chamada de função na API se referem a métodos, precisando
 assim especificar um objeto sobre o qual o método deve ser aplicado.
 Funções globais em Ruby são definidas como métodos do módulo 
\family typewriter 
Kernel
\family default 
, que é incluído pela classe 
\family typewriter 
Object
\family default 
 e são, assim, acessíveis a partir de qualquer objeto, incluindo 
\family typewriter 
nil
\family default 
.
 Desta forma, pode-se invocar funções globais passando a constante C 
\family typewriter 
Qnil
\family default 
 como o objeto alvo do método.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A seguir, é apresentada a forma típica para chamar em C uma função global
 Ruby 
\family typewriter 
teste
\family default 
, novamente incluindo a conversão dos valores de entrada e saída entre C
 e o interpretador.
\layout LyX-Code


\size footnotesize 
ID teste = rb_intern("teste");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, teste, 2, rb_str_new2("entrada"), INT2NUM(2)
);
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Diferentemente de Python, não é necessário obter uma referência para a função,
 bastando passar o nome desta na forma de 
\family typewriter 
ID
\family default 
 e o objeto a que ela se refere (no caso, 
\family typewriter 
Qnil
\family default 
, indicando uma função global).
 A conversão dos dados de entrada de C para Ruby é feita através da função
 
\family typewriter 
rb_str_new2
\family default 
 e da macro 
\family typewriter 
INT2NUM
\family default 
, que criam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs.
 no exemplo
\end_inset 


\layout Standard

Conforme discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, o controle da validade de 
\family typewriter 
VALUE
\family default 
s é feito implicitamente.
 Assim, pode-se fazer a chamada de funções que criam 
\family typewriter 
VALUE
\family default 
s diretamente na passagem de parâmetros de 
\family typewriter 
rb_funcall
\family default 
.
 De fato, as três linhas acima poderiam ter sido condensadas, passando a
 chamada 
\family typewriter 
rb_funcall
\family default 
 como parâmetro para 
\family typewriter 
NUM2LONG
\family default 
 e a chamada 
\family typewriter 
rb_intern
\family default 
 como segundo parâmetro de 
\family typewriter 
rb_funcall
\family default 
, tendo sido separadas apenas para maior legibilidade.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: blocos Ruby
\end_inset 


\layout Standard

Um tipo de dados que possui um tratamento um tanto irregular em Ruby é o
 de blocos de código.
 A sintaxe em Ruby para a declaração de blocos é especial: blocos só podem
 ser definidos como o último argumento de uma chamada de método.
 Assim, eles não são valores de primeira classe, não podendo ser, por exemplo,
 declarados em uma atribuição a variável.
 Eles podem, no entanto, ser promovidos a valores de primeira classe, na
 forma de objetos da classe 
\family typewriter 
Proc
\family default 
.
 Isto pode ser feito de duas formas: explicitamente, passando um bloco para
 o método 
\family typewriter 
Proc.new
\family default 
, ou implicitamente, quando o bloco for passado para um método que declara
 um último parâmetro formal precedido de 
\family typewriter 
&
\family default 
.
 Esta variável conterá o bloco convertido para um 
\family typewriter 
Proc
\family default 
.
 Na chamada de funções que esperam blocos, 
\family typewriter 
&
\family default 
 converte o 
\family typewriter 
Proc
\family default 
 para um bloco.
 Objetos 
\family typewriter 
Proc
\family default 
 podem ser manipulados através da API de C como qualquer outro objeto Ruby,
 mas não há correspondente na API de C para a funcionalidade do operador
 
\family typewriter 
&
\family default 
 em chamadas de função.
\layout Standard

O status especial dos blocos de código complica a sua manipulação a partir
 de código\SpecialChar ~
C, e em particular a invocação de métodos que os esperam como
 parâmetro.
 Digamos que queremos invocar o seguinte método Ruby a partir de\SpecialChar ~
C:
\layout LyX-Code


\size footnotesize 
def uma_funcao_ruby()
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby vai invocar o bloco.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby encerrou.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função espera que um bloco de código seja passado para que seja invocado
 via o comando 
\family typewriter 
yield
\family default 
.
 Como vamos invocar a função a partir de C, queremos também passar código
 C como um bloco, representado na seguinte função: 
\layout LyX-Code


\size footnotesize 
VALUE um_bloco_C() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "um_bloco_C está rodando.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A conversão de objetos 
\family typewriter 
Proc
\family default 
 para blocos proporcionada pelo operador 
\family typewriter 
&
\family default 
 em Ruby não possui equivalente na API C.
 Assim, 
\family typewriter 
rb_funcall
\family default 
 não é capaz de passar 
\family typewriter 
Proc
\family default 
s para funções que aceitam blocos.
 A forma intuitiva de fazer a chamada de funções Ruby a partir de C, neste
 caso, então, não funciona:
\layout LyX-Code


\size footnotesize 
ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
\emph on 
/* O segundo parâmetro é um argumento adicional a ser
\layout LyX-Code


\size footnotesize 
\emph on 
   opcionalmente passado na invocação de um Proc */
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(um_bloco_C, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Não funciona! Um Proc não é um bloco de código.
 */
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_funcall(Qnil, uma_funcao_ruby, 1, um_proc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

As únicas formas de invocar um método Ruby passando um bloco de código são
 através de 
\family typewriter 
rb_eval_string
\family default 
 e 
\family typewriter 
rb_iterate
\family default 
.
 A primeira abordagem, além do custo de desempenho causado pelo 
\emph on 
parsing
\emph default 
 da string de código, tem a inconveniência de exigir o uso de variáveis
 temporárias para que se possa obter os valores de retorno de volta ao espaço
 de C.
 No modelo usando 
\family typewriter 
rb_eval_string
\family default 
, a função C que atuará como bloco deve ser declarada no espaço de Ruby.
 Há duas alternativas de como fazer isto: registrando o método em Ruby e
 invocando-o em um bloco 
\emph on 
wrapper
\emph default 
 declarado na string de código Ruby:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Declara uma função global com 0 parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
rb_define_global_function("um_bloco_C", um_bloco_C, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby { um_bloco_C() }");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard

Ou encapsulando a função em um objeto 
\family typewriter 
Proc
\family default 
 a partir de C com 
\family typewriter 
rb_proc_new
\family default 
 e então usando a notação 
\family typewriter 
&
\family default 
 na string de código Ruby avaliada:
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(um_bloco_C, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$um_proc", um_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby(&$um_proc)");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A segunda abordagem explora o fato de que a única função da API de C capaz
 de produzir blocos de código diretamente é 
\family typewriter 
rb_iterate
\family default 
.
 Esta função recebe dois ponteiros de função, um para a função a ser invocada
 e outro para a função que atuará como o bloco de código; chamadas a 
\family typewriter 
yield
\family default 
 dentro da primeira função invocarão a segunda.
 O bloco pode quebrar o fluxo de execução com 
\family typewriter 
rb_iter_break
\family default 
.
 Passando como 
\begin_inset Quotes eld
\end_inset 

função de iteração
\begin_inset Quotes erd
\end_inset 

 para 
\family typewriter 
rb_iterate
\family default 
 uma função 
\emph on 
wrapper
\emph default 
 que simplesmente chama o método Ruby desejado com 
\family typewriter 
rb_funcall
\family default 
, é possível simular uma chamada a 
\family typewriter 
rb_funcall
\family default 
 que recebe uma função\SpecialChar ~
C como bloco de código.
\layout LyX-Code


\size footnotesize 
VALUE chama_uma_funcao_ruby() {
\layout LyX-Code


\size footnotesize 
   ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, uma_funcao_ruby, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
\emph on 
/* Os argumentos Qnil indicam que não há parâmetros
\layout LyX-Code


\size footnotesize 
\emph on 
   nem para a função nem para o bloco */
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_iterate(chama_uma_funcao_ruby, Qnil, um_bloco_C, Qnil);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que nenhum argumento é passado em 
\family typewriter 
rb_funcall
\family default 
 -- a função 
\family typewriter 
rb_iterate
\family default 
 define 
\family typewriter 
um_bloco_C
\family default 
 como sendo o 
\begin_inset Quotes eld
\end_inset 

bloco de código atual
\begin_inset Quotes erd
\end_inset 

 e esta definição é herdada implicitamente por 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

Para o caso comum de realizar iterações sobre o método 
\family typewriter 
each
\family default 
 de coleções, Ruby oferece uma função 
\emph on 
wrapper
\emph default 
 
\family typewriter 
rb_each
\family default 
.
 Esta função foi projetada para ser passada como primeiro argumento de 
\family typewriter 
rb_iterate
\family default 
.
 Funções C executando como bloco de código podem quebrar o fluxo de execução
 com 
\family typewriter 
rb_iter_break
\family default 
.
 O mecanismo de 
\emph on 
yield
\emph default 
, tanto para código C quanto para chamadas nativas em Ruby, é implementado
 usando as funções C 
\family typewriter 
setjmp
\family default 
 e 
\family typewriter 
longjmp
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

Para o correto tratamento de erros, funções C que realizam chamadas a funções
 Ruby devem ser encapsuladas em uma chamada 
\family typewriter 
rb_protect
\family default 
 ou em uma de suas variantes, 
\family typewriter 
rb_ensure
\family default 
 e 
\family typewriter 
rb_rescue
\family default 
.
 Esta função captura exceções disparadas por código Ruby (ou código C usando
 
\family typewriter 
rb_raise
\family default 
).
 Caso o programa não use 
\family typewriter 
rb_protect
\family default 
, exceções em Ruby resultarão em erros fatais.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

De forma similar ao acesso a atributos, na chamada de métodos Java a partir
 de C deve-se inicialmente obter um identificador para o método, do tipo
 
\family typewriter 
jmethodID
\family default 
.
 Estes identificadores são tipicamente obtidos com a função 
\family typewriter 
GetMethodID
\family default 
, que recebe como parâmetros a classe (instância de 
\family typewriter 
jclass
\family default 
) e duas strings, uma com o nome do método e outra com a assinatura do método.
 A sintaxe que descreve assinaturas de métodos é similar à de descritores
 de campos discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Parâmetros são listados entre parênteses, seguidos do tipo de retorno.
 Por exemplo, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 indica uma função com parâmetros 
\family typewriter 
String[], int, int
\family default 
 e retorno 
\family typewriter 
void
\family default 
.
 Alternativamente ao uso de 
\family typewriter 
GetMethodID
\family default 
, a partir de Java 1.2 é possível obter um 
\family typewriter 
jmethodID
\family default 
 correspondente a um método aplicando a função 
\family typewriter 
FromReflectedMethod
\family default 
 sobre um objeto Java do tipo 
\family typewriter 
Method
\family default 
 -- isto é, um método reificado através da API de reflexão de Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API para invocar funções
\end_inset 


\layout Standard

Uma vez obtido o 
\family typewriter 
jmethodID
\family default 
, um método pode ser invocado através de alguma das 90 funções da família
 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
*.
 Os nomes das funções seguem a forma
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<tipo><retorno>
\family default 
\emph default 
Method
\family roman 
\emph on 
<argumentos>
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

O 
\emph on 
<tipo>
\emph default 
 pode ser 
\family typewriter 
Static
\family default 
 para funções estáticas, passando na chamada uma 
\family typewriter 
jclass
\family default 
 como parâmetro; 
\family typewriter 
Nonvirtual
\family default 
 para invocar implementações de um método em uma classe específica sobre
 um determinado objeto, passando uma 
\family typewriter 
jclass
\family default 
 e um 
\family typewriter 
jobject
\family default 
 como parâmetros; ou omitido para métodos de instância, passando o 
\family typewriter 
jobject
\family default 
 sobre o qual o método será aplicado.
 O tipo de retorno é indicado em 
\emph on 
<retorno>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Os argumentos do método podem ser passados de três formas: como 
\emph on 
varargs
\emph default 
, como um array C de 
\family typewriter 
jvalue
\family default 
s, ou propagando uma 
\family typewriter 
va_list
\family default 
 recebida.
 Por exemplo, na forma mais simples, um método de instância sem retorno
 e sem parâmetros é invocado com 
\family typewriter 
CallVoidMethod
\family default 
.
 Já 
\family typewriter 
CallStaticIntMethodA
\family default 
 chama um método estático que retorna um 
\family typewriter 
jint
\family default 
 com a lista de parâmetros passada em um array de 
\family typewriter 
jvalue
\family default 
s.
 Como Java é uma linguagem estaticamente tipada, não é preciso especificar
 o número ou o tipo dos parâmetros passados nas funções de chamada de métodos.
 Estas informações já estão especificadas nos 
\family typewriter 
jmethodID
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\end_inset 


\layout Standard

É importante notar que, ao obter identificadores de métodos e campos fazendo
 a resolução a partir do 
\family typewriter 
jobject
\family default 
 recebido na variável 
\family typewriter 
this
\family default 
 e do nome do método ou campo, com 
\family typewriter 
GetObjectClass
\family default 
 e 
\family typewriter 
GetFieldID
\family default 
, estamos efetivamente resolvendo nomes através de escopo dinâmico.
 Isto implica que, por exemplo, caso um método 
\family typewriter 
Pai.metodo
\family default 
 implementado em C acesse um atributo privado 
\family typewriter 
umAtributo
\family default 
 e uma subclasse 
\family typewriter 
Filho
\family default 
 também defina um atributo privado 
\family typewriter 
umAtributo
\family default 
, a chamada a esse método em uma instância 
\family typewriter 
f
\family default 
 de 
\family typewriter 
Filho
\family default 
 acabaria por acessar 
\family typewriter 
Filho.umAtributo
\family default 
 e não 
\family typewriter 
Pai.umAtributo
\family default 
.
 Este comportamento é diferente do que ocorreria se 
\family typewriter 
Pai.metodo
\family default 
 fosse implementado em Java, onde o 
\emph on 
binding
\emph default 
 de membros privados é definido lexicamente.
 Para garantir à implementação em C de 
\family typewriter 
Pai.metodo
\family default 
 que o atributo 
\family typewriter 
umAtributo
\family default 
 acessado é realmente 
\family typewriter 
Pai.umAtributo
\family default 
, deve-se armazenar no espaço de C o identificador do campo obtido a partir
 da 
\family typewriter 
jclass
\family default 
 de 
\family typewriter 
Pai
\family default 
 -- obtida, por exemplo, em uma função 
\family typewriter 
static native
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

O código C pode verificar a ocorrência de exceções através de 
\family typewriter 
ExceptionCheck
\family default 
 e optar por tratá-la, obtendo uma referência local da exceção com 
\family typewriter 
ExceptionOccurred
\family default 
 e posteriormente zerando-a com 
\family typewriter 
ExceptionClear
\family default 
, ou então mantê-la ativa de modo que seja propagada ao código Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Para realizar o exemplo da função 
\family typewriter 
teste
\family default 
, já que Java não possui funções globais, vamos assumir que 
\family typewriter 
teste
\family default 
 é um método estático de uma classe chamada 
\family typewriter 
Exemplo
\family default 
 e que estamos rodando o código C a seguir em um contexto onde possuímos
 uma referência a um ambiente de execução Java chamado 
\family typewriter 
J
\family default 
 (este ponteiro, do tipo 
\family typewriter 
JNIEnv
\family default 
, será discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass exemplo = (*J)->FindClass(J, "Exemplo");
\layout LyX-Code


\size footnotesize 
jmethodID teste = (*J)->GetStaticMethodID(J, exemplo,
\layout LyX-Code


\size footnotesize 
                        "teste", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring entrada = (*J)->NewStringUTF(J, "entrada");
\layout LyX-Code


\size footnotesize 
long retorno = (*J)->CallStaticIntMethod(J, exemplo, teste, entrada, (jint)2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Inicialmente, é obtida uma referência à classe 
\family typewriter 
Exemplo
\family default 
, a partir da qual requisitamos o identificador do método desejado, baseado
 no seu nome e assinatura.
 Como em Ruby, a string passada como parâmetro deve ser convertida para
 um tipo da máquina virtual.
 Já para o segundo argumento e para o valor de retorno, exploramos o fato
 de que o tipo 
\family typewriter 
jint
\family default 
, correspondente ao tipo Java 
\family typewriter 
int
\family default 
 (inteiro de 32 bits), é compatível com o tipo 
\family typewriter 
long
\family default 
 de C (inteiro de pelo menos 32 bits).
 Todas estas funções da API retornam referências locais, que serão liberadas
 automaticamente ao final da função C onde as chamadas à API foram feitas.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Tanto em funções C disparadas por Lua como em chamadas de funções Lua realizadas
 a partir de código C, os parâmetros de entrada e os valores de retorno
 são passados através da pilha virtual apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Verificação da ocorrência de erros
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Para chamar uma função Lua a partir de C, devemos inicalmente empilhar o
 objeto Lua referente a ela: para funções globais, obtendo-a com 
\family typewriter 
lua_getglobal
\family default 
, para funções armazenadas em tabelas, com 
\family typewriter 
lua_gettable
\family default 
.
 A seguir, empilhamos os seus parâmetros e então invocamos 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, indicando quantos valores da pilha devem ser passados como parâmetro.
 A diferença entre as duas funções está no tratamento de erros: 
\family typewriter 
lua_call
\family default 
 propaga os erros sinalizados, usando 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 captura os erros, retornando um código de 
\emph on 
status
\emph default 
 e a mensagem de erro na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

No caso de execução sem erros, a pilha conterá os valores de retorno da
 função chamada.
 O número de valores de retorno pode ser explicitamente requisitado na chamada
 de 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, ou ser definido em tempo de execução, requisitando o valor especial 
\family typewriter 
LUA_MULTRET
\family default 
.
 Se um número de valores de retorno for solicitado e este não for passado
 pela função chamada, o número de valores será ajustado adicionando elementos
 
\family typewriter 
nil
\family default 
 ou descartando valores em excesso.
 Para chamadas com 
\family typewriter 
LUA_MULTRET
\family default 
, todos os valores são empilhados.
 Nesse caso, a única forma de descobrir quantos valores foram retornados
 é comparando o tamanho da pilha antes e depois da chamada.
\layout Standard

A função 
\family typewriter 
lua_cpcall
\family default 
 permite chamar funções C realizando captura de erros de forma similar a
 
\family typewriter 
lua_pcall
\family default 
 sem precisar registrá-las como valores Lua.
 Esta funcionalidade é similar à oferecida por 
\family typewriter 
rb_protect
\family default 
 em Ruby.
 Ruby, todavia, não oferece função análoga a 
\family typewriter 
lua_pcall
\family default 
, sendo às vezes necessário encapsular a chamada de funções Ruby em funções\SpecialChar ~
C
 que obedeçam à assinatura esperada por 
\family typewriter 
rb_protect
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Lua não possui distinção entre funções e métodos, mas possui açúcar sintático
 que permite invocar funções armazenadas em tabelas com uma sintaxe de chamada
 de métodos: 
\family typewriter 
t:m(x)
\family default 
 significa 
\family typewriter 
t.m(t,x)
\family default 
.
 Todavia, não há na API de C uma chamada específica para replicar esta abreviaçã
o.
 Para funções armazenadas em tabelas, a função deve ser obtida com 
\family typewriter 
lua_gettable
\family default 
 e a tabela deve ser empilhada explicitamente juntamente com os demais parâmetro
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

O exemplo da chamada da função 
\family typewriter 
teste
\family default 
 demonstra a disciplina de pilha adotada na API de Lua.
 Similarmente ao exemplo de Java na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, iremos assumir a existência de um ponteiro 
\family typewriter 
L
\family default 
 do tipo 
\family typewriter 
lua_State
\family default 
, que será explicado mais adiante na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "teste");           
\emph on 
/* Empilha a função teste */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "entrada");        
\emph on 
/* Empilha a string "entrada" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Empilha o número 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Chama a função com 2 parâmetros,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        e espera 1 como retorno */
\layout LyX-Code


\size footnotesize 
long retorno = lua_tointeger(L, -1); 
\emph on 
/* Obtém o resultado no topo da pilha (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove-o da pilha */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs no exemplo
\end_inset 


\layout Standard

Com 
\family typewriter 
lua_getglobal
\family default 
, é empilhada a função global 
\family typewriter 
teste
\family default 
.
 Em seguida, os dois argumentos de entrada são empilhados.
 A função é então invocada com 
\family typewriter 
lua_call
\family default 
, indicando dois parâmetros de entrada e um de saída.
 O valor de retorno, no topo da pilha (índice\SpecialChar ~

\begin_inset Formula $-1$
\end_inset 

) é convertido para C com 
\family typewriter 
lua_tointeger
\family default 
.
 Esta última função não remove o valor da pilha: para retorná-la ao seu
 estado inicial, precisamos removê-lo explicitamente com 
\family typewriter 
lua_pop
\family default 
.
 Como em nenhum momento a API retorna ponteiros para objetos Lua, não há
 preocupações com coleta de lixo.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Funções vs.
 métodos
\end_inset 


\layout Standard

A chamada de funções Perl a partir de C se dá através de uma disciplina
 de pilha, como em Lua.
 Parâmetros de entrada são especificados através de operações de empilhamento
 e valores de retorno são obtidos na pilha após a chamada da função.
 As funções 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 e 
\family typewriter 
call_method
\family default 
 variam apenas na forma como a função a ser chamada é especificada: através
 de um 
\family typewriter 
SV
\family default 
, de uma string C ou de uma string C descrevendo o nome de um método de
 algum objeto ou classe inserido na pilha.
 A função 
\family typewriter 
call_argv
\family default 
, como conveniência, recebe como um argumento adicional um array C contendo
 strings C representando parâmetros a serem empilhados.
 Todas retornam o número de valores de retorno disponíveis na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: contextos Perl
\end_inset 


\layout Standard

As funções 
\family typewriter 
call_
\family default 
* possuem um argumento de flags a serem passadas que indicam a forma que
 a função deve ser chamada e como tratar os parâmetros de entrada e valores
 de retorno.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 e 
\family typewriter 
G_ARRAY
\family default 
 especificam o contexto como a função deve ser chamada.
 Em contextos escalares, por exemplo, somente um escalar é retornado na
 pilha; se a função chamada retornar uma lista, somente o último elemento
 desta estará disponível na pilha.
 
\family typewriter 
G_DISCARD
\family default 
 indica que os valores de retorno devem ser automaticamente descartados;
 
\family typewriter 
G_NOARGS
\family default 
 indica que o array padrão de parâmetros 
\family typewriter 
@_
\family default 
 não deve ser construído
\begin_inset Foot
collapsed true

\layout Standard

Isto tem o efeito colateral de que a função chamada herda o valor de 
\family typewriter 
@_
\family default 
 da função chamadora.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

O precedimento para verificação de erros depende do contexto e das flags
 passadas, que afetam como situações de erro são reportadas no valor de
 retorno das funções 
\family typewriter 
call_
\family default 
* e nos valores retornados na pilha.
 A flag 
\family typewriter 
G_EVAL
\family default 
 encapsula a chamada em um bloco 
\family typewriter 
eval
\family default 
, capturando erros.
 Assim, a ocorrência de erros pode ser verificada através da macro 
\family typewriter 
ERRSV
\family default 
, que retorna o 
\family typewriter 
SV
\family default 
 contendo a mensagem de erro.
 Acrescentando a flag 
\family typewriter 
G_KEEPERR
\family default 
, mensagens de erro não sobrescrevem a variável especial 
\family typewriter 
$@
\family default 
, mas são concatenadas a ela, acumulando seqüências de erros em níveis de
 chamada diferentes.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Uma série de macros descrevem um protocolo para a chamada de funções e a
 manipulação de parâmetros de entrada e saída.
 As principais serão explicadas a seguir, na apresentação da versão Perl
 da chamada da função 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("entrada", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("teste", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Controle de referências no exemplo
\end_inset 


\layout Standard

Inicialmente 
\family typewriter 
dSP
\family default 
 declara uma cópia local do ponteiro da pilha de Perl.
 Em seguida, 
\family typewriter 
ENTER
\family default 
 e 
\family typewriter 
SAVETMPS
\family default 
 criam um escopo para valores mortais.
 
\family typewriter 
PUSHMARK
\family default 
 inicia a contagem de parâmetros a serem passados para a função.
 Estes parâmetros são então empilhados com 
\family typewriter 
XPUSHs
\family default 
.
 Os valores criados com 
\family typewriter 
newSVpv
\family default 
 e 
\family typewriter 
newSViv
\family default 
 são convertidos para valores mortais com 
\family typewriter 
sv_2mortal
\family default 
, para que não tenham que ter sua contagem de referências decrementada explicita
mente após a chamada da função.
 
\family typewriter 
PUTBACK
\family default 
 encerra a contagem de parâmetros.
 É feita então a chamada da função global Perl 
\family typewriter 
teste
\family default 
, em contexto escalar, com 
\family typewriter 
call_pv
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Após o retorno desta função, a memória da pilha de Perl pode ter sido realocada,
 mudando o endereço do ponteiro de pilha obtido inicialmente com 
\family typewriter 
dSP
\family default 
.
 Para certificar-se que o seu valor está correto, deve-se chamar 
\family typewriter 
SPAGAIN
\family default 
 após funções 
\family typewriter 
call_
\family default 
*.
 A função 
\family typewriter 
POPl
\family default 
 desempilha um valor e o converte para 
\family typewriter 
long
\family default 
 (há funções similares para outros tipos, como 
\family typewriter 
POPs
\family default 
 para 
\family typewriter 
SV
\family default 
s e 
\family typewriter 
POPpx
\family default 
 para strings).
 Estas operações desempilham valores atualizando a cópia local do ponteiro
 de pilha.
 Assim, 
\family typewriter 
PUTBACK
\family default 
 deve ser chamado novamente para atualizar o ponteiro global.
 Finalmente, 
\family typewriter 
FREETMPS
\family default 
 e 
\family typewriter 
LEAVE
\family default 
 decrementam a contagem de referências dos valores mortais.
 
\layout Subsection

Comparação
\layout Standard

Em Python, Lua e Perl, funções podem ser acessadas como objetos da linguagem
 e invocadas.
 Em Ruby e Java, a API define tipos especiais usados para referenciar métodos.
 Como na manipulação de dados, Python oferece uma API extensa, com diversas
 funções de conveniência permitindo passar argumentos como tuplas Python,
 objetos Python passados como 
\emph on 
varargs
\emph default 
, valores C a serem convertidos pela função de chamada, etc.
 Java também oferece um grande número de funções para invocação de métodos
 e, devido à tipagem estática da linguagem, os parâmetros de entrada podem
 ser passados como 
\emph on 
varargs
\emph default 
 de forma direta, sem precisar especificar a forma como a conversão deles
 deve ser realizada.
 Ruby também oferece algumas variantes de funções de chamada.
\layout Standard

Lua, em contraste, separa a rotina da chamada da função da passagem dos
 parâmetros, que é feita anteriormente através da pilha.
 Isto é uma solução bastante simples, mas o código resultante é menos claro
 que as chamadas equivalentes em linguagens como Ruby e Python.
 Perl também faz chamadas de função utilizando um modelo de pilha, mas ao
 contrário de Lua o seu uso é demasiadamente complexo, por exigir um protocolo
 de macros que expõem o funcionamento interno do interpretador.
 Outro complicador é o tratamento de valores de retorno, pois estes variam
 de comportamento conforme o contexto Perl em que a função é chamada.
\layout Standard

Em Lua e Python, a ocorrência de erros pode ser verificada com o valor de
 retorno da função.
 De modo parecido, Perl permite detectar erros na chamada mais recente verifican
do uma variável especial; em Java, isto é feito chamando uma função da API.
 Somente o tratamento de erros em Ruby é mais convoluto, pois estranhamente
 a API oferece uma função que permite invocar funções C em modo protegido,
 mas não uma equivalente que permita chamar funções Ruby.
 Torna-se necessário escrever uma função 
\emph on 
wrapper
\emph default 
 nestes casos, o que será ilustrado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Section

Registro de funções C
\layout Standard

Para permitir a invocação de funções C a partir de código da linguagem de
 script, a API deve fornecer uma forma de registrar estas funções no ambiente
 de execução.
 Em linguagens de tipagem estática, como Java, para que seja possível chamar
 funções externas usando uma sintaxe igual à de funções nativas, o conjunto
 de funções externas deve ser declarado 
\emph on 
a priori
\emph default 
 de alguma forma.
 Já em linguagens com tipagem dinâmica, como é o caso de Python, Lua, Ruby
 e Perl, as funções podem ser usadas diretamente, bastando que sejam definidas
 em algum momento da execução antes de sua chamada.
 Assim, pode-se declarar as funções externas em tempo de execução através
 de código C usando a API da linguagem de script.
\layout Standard

Também nesta seção, a apresentação de cada linguagem encerrará com um exemplo.
 Uma função C que, assim como nos exemplos da seção anterior, recebe um
 inteiro e uma string e retorna um inteiro, será registrada.
 Apresentaremos também, para cada linguagem, a forma de registrar a função
 como a global
\begin_inset Foot
collapsed false

\layout Standard

Ou no caso de Java, método estático.
\end_inset 

 
\family typewriter 
teste
\family default 
 de modo que ela possa ser invocada diretamente a partir da linguagem ou
 através da API.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

Python não possui um tipo 
\begin_inset Quotes eld
\end_inset 

função
\begin_inset Quotes erd
\end_inset 

 propriamente dito declarável em C.
 Métodos de classes, no entanto, são objetos e possuem um tipo específico,
 que pode ser verificado com a função 
\family typewriter 
PyMethod_Check
\family default 
.
 Tipicamente, métodos são criados passando-se um array de estruturas 
\family typewriter 
PyMethodDef
\family default 
.
 Estas estruturas são compostas do nome da função, o ponteiro da função
 C, um vetor de flags e uma string de documentação.
 As flags são usadas para indicar a convenção adotada para os parâmetros
 de entrada na função C.
 As flags mais comuns são: 
\family typewriter 
METH_NOARGS
\family default 
, usada para funções Python que não recebem parâmetros, indicando que a
 função C deve receber um único ponteiro para 
\family typewriter 
PyObject
\family default 
, que irá conter o 
\family typewriter 
self
\family default 
 do método; 
\family typewriter 
METH_VARARGS
\family default 
, para funções que recebem como segundo parâmetro uma tupla Python que conterá
 um número variável de parâmetros passados de Python para C; e 
\family typewriter 
METH_KEYWORDS
\family default 
, para indicar que a função C recebe ainda como terceiro parâmetro um dicionário
 contendo os argumentos 
\emph on 
keywords
\emph default 
 passados à função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\end_inset 


\layout Standard

De posse destas informações, funções da API que operam sobre arrays de 
\family typewriter 
PyMethodDef
\family default 
 podem criar e associar objetos do tipo método no espaço de Python.
 
\family typewriter 
Py_InitModule
\family default 
, por exemplo, inicializa um módulo com funções de um array de 
\family typewriter 
PyMethodDef
\family default 
.
 Similarmente, os métodos de uma classe implementada em C podem ser dados
 no campo 
\family typewriter 
tp_methods
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 relativa à classe.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C registradas em Python devem retornar um ponteiro para 
\family typewriter 
PyObject
\family default 
, ou 
\family typewriter 
NULL
\family default 
 em caso de erro (opcionalmente declarando uma exceção com 
\family typewriter 
PyErr_SetString
\family default 
 ou 
\family typewriter 
PyErr_SetObject
\family default 
).
 Funções que não retornam valores devem retornar o objeto pré-definido 
\family typewriter 
Py_None
\family default 
, lembrando das questões de contagem de referência de valores retornados
 discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

O que são funções na linguagem
\end_inset 


\layout Standard

Embora métodos sejam usualmente criados em C usando estruturas 
\family typewriter 
PyMethodDef
\family default 
, é possível ainda criar um objeto do tipo método explicitamente a partir
 de C com a função 
\family typewriter 
PyMethod_New
\family default 
, passando como parâmetro um objeto Python 
\begin_inset Quotes eld
\end_inset 

chamável
\begin_inset Quotes erd
\end_inset 

 e o objeto ou classe a que ele deve se referir.
 Como visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, objetos Python podem ser tornados 
\begin_inset Quotes eld
\end_inset 

chamáveis
\begin_inset Quotes erd
\end_inset 

 implementando um método 
\family typewriter 
__call__
\family default 
 em Python ou associando uma função C ao campo 
\family typewriter 
tp_call
\family default 
 do seu 
\family typewriter 
PyTypeObject
\family default 
 correspondente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo
\end_inset 


\layout Standard

Uma implementação simples de uma função C que pode ser registrada em Python
 como a função global 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* teste_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* entrada; long n;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Em caso de erro nos argumentos, PyArg_ParseTuple
\layout LyX-Code


\size footnotesize 
\emph on 
      gera uma exceção apropriada automaticamente */
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &entrada, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Como os argumentos são recebidos em uma tupla no segundo parâmetro, a assinatura
 de função empregada corresponde à flag 
\family typewriter 
METH_VARARGS
\family default 
.
 Os parâmetros de entrada são convertidos para C e verificados com 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 O valor de retorno é convertido do tipo nativo C para um 
\family typewriter 
PyObject
\family default 
 com 
\family typewriter 
PyInt_FromLong
\family default 
, gerando uma nova referência.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de global
\end_inset 


\layout Standard

A API de Python é projetada primariamente para o desenvolvimento de módulos
 de extensão para a linguagem.
 Embora existam diversas funções para registrar métodos em classes e inicializar
 módulos com listas de funções, não há uma forma direta para registrar funções
 globais na máquina virtual.
 Uma maneira possível é usando a rotina utilitária para lookup de métodos
 
\family typewriter 
Py_FindMethod
\family default 
 e inserindo o método retornado no dicionário do módulo global 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef teste_def[] = {
\layout LyX-Code


\size footnotesize 
   { "teste", (PyCFunction) teste_py, METH_VARARGS, "um teste" },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* teste_obj = Py_FindMethod(teste_def, NULL, "teste");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "teste", teste_obj);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que foi passado 
\family typewriter 
NULL
\family default 
 para 
\family typewriter 
Py_FindMethod
\family default 
, indicando que não há um objeto do qual o método faz parte.
 O argumento 
\family typewriter 
self
\family default 
 recebido pela função C 
\family typewriter 
teste_py
\family default 
 será também 
\family typewriter 
NULL
\family default 
 e pode ser ignorado.
 O array 
\family typewriter 
teste_def
\family default 
 foi declarado 
\family typewriter 
static
\family default 
 para garantir que o 
\family typewriter 
PyMethodDef
\family default 
 continuará válido enquanto a função global estiver registrada, pois na
 criação de 
\family typewriter 
teste_obj
\family default 
 um ponteiro para ele é armazenado internamente no objeto criado.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\layout Standard

Convenção para parâmetros de entrada
\end_inset 


\layout Standard

Para que funções C possam ser chamadas a partir de Ruby, elas devem ser
 declaradas como métodos de alguma classe ou módulo, ou ainda como uma função
 global.
 Para isto, passa-se um ponteiro de uma função C e o número de argumentos
 que a função espera para uma das funções apropriadas da API de Ruby: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 ou 
\family typewriter 
rb_define_singleton\SpecialChar \-
_method
\family default 
.
 O número de parâmetros passado indica a assinatura esperada para a função\SpecialChar ~
C.
 Ruby suporta explicitamente funções C com até 15 argumentos; como alternativa,
 os valores especiais -1 e -2 indicam, respectivamente, que a função C irá
 receber os parâmetros na forma de um array C de 
\family typewriter 
VALUE
\family default 
s ou na forma de um 
\family typewriter 
VALUE
\family default 
 correspondente a um array Ruby.
\layout Standard

De forma que lembra a função 
\family typewriter 
PyArg_ParseTuple
\family default 
 discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

, Ruby possui uma função projetada para simplificar o processamento dos
 valores de entrada em funções\SpecialChar ~
C: 
\family typewriter 
rb_scan_args
\family default 
.
 Esta função pode ser usada quando os parâmetros de entrada são recebidos
 em um array Ruby.
 Como 
\family typewriter 
PyArg_ParseTuple
\family default 
, ela é uma função vararg que recebe uma string de formato indicando o número
 de parâmetros a serem coletados.
 Por outro lado, ela não realiza verificação de tipo dos argumentos.
 A string de formato permite indicar o número mínimo e máximo de parâmetros
 aceitos e se os parâmetros excedentes devem ser coletados em um array Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: blocos
\end_inset 


\layout Standard

Uma vez declarada no espaço de objetos de Ruby, uma função C pode ser chamada
 como qualquer outro método.
 A função C pode verificar se o código Ruby lhe passou um bloco de código
 através da função 
\family typewriter 
rb_block_given_p
\family default 
.
 O bloco pode então ser invocado com 
\family typewriter 
rb_yield
\family default 
, que recebe um 
\family typewriter 
VALUE
\family default 
 como argumento.
 Para passar múltiplos argumentos para 
\family typewriter 
rb_yield
\family default 
, deve-se passar um array Ruby.
 Para obter um 
\family typewriter 
VALUE
\family default 
 do tipo 
\family typewriter 
Proc
\family default 
 produzido a partir do bloco de código recebido é preciso usar 
\family typewriter 
rb_scan_args
\family default 
, que possui funcionalidade similar à do operador 
\family typewriter 
&
\family default 
 em declarações de funções Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C implementado métodos Ruby devem sempre retornar um 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 quando não há retorno).
 Funções que retornam múltiplos valores devem fazê-lo através de um array
 Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Dando continuidade à série de exemplos, a função global Ruby 
\family typewriter 
teste
\family default 
 pode ser implementada da seguinte forma em C:
\layout LyX-Code


\size footnotesize 
VALUE teste_rb(VALUE self, VALUE val_entrada, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* entrada = StringValuePtr(val_entrada);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A conversão dos 
\family typewriter 
VALUE
\family default 
s de entrada é feita com as macros 
\family typewriter 
StringValuePtr
\family default 
 e 
\family typewriter 
NUM2INT
\family default 
.
 Não há código explícito para tratamento de erros na conversão pois estas
 macros disparam exceções que saem da função via 
\family typewriter 
longjmp
\family default 
 caso a conversão não seja possível.
 Para a saída, é produzido um 
\family typewriter 
VALUE
\family default 
 com a macro 
\family typewriter 
INT2NUM
\family default 
.
 O primeiro parâmetro de entrada é necessário segundo a convenção de assinaturas
 de função da API, mas para funções globais ele deve ser ignorado.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de fn global
\end_inset 


\layout Standard

Como Ruby oferece uma função na API para a definição de funções globais,
 o registro de 
\family typewriter 
teste
\family default 
 é bastante simples:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("teste", teste_rb, 2); 
\layout Standard

É indicado o nome da função no espaço de Ruby, a função C correspondente
 e o número de parâmetros que ela espera (não incluindo o parâmetro 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: métodos native
\end_inset 


\layout Standard

Métodos declarados em Java que não são implementados na própria linguagem
 devem ser declarados através de um protótipo incluindo o modificador 
\family typewriter 
native
\family default 
.
 Assim, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 A implementação do método, usualmente encapsulada em uma biblioteca dinâmica
 C, deve ser carregada antes de sua execução usando a chamada 
\family typewriter 
System.loadLibrary
\family default 
 em Java, usualmente em um bloco 
\family typewriter 
static
\family default 
 da classe correspondente.
 Para cada método 
\family typewriter 
native
\family default 
, uma função C correspondente deve ser definida na biblioteca carregada.
\layout Standard

O utilitário 
\family typewriter 
javah
\family default 
 gera arquivos de cabeçalho C a partir de classes Java, com os protótipos
 de funções C no formato especificado pela JNI.
 Este formato especifica não apenas a assinatura dos parâmetros de entrada
 e tipo de retorno, mas também o nome da função, para que o 
\emph on 
loader
\emph default 
 realize a ligação entre a função C e o método Java na máquina virtual.
 As funções devem se chamar 
\family typewriter 
Java_
\family default 
\emph on 
<nome da classe>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<nome do método>
\emph default 
.
 No caso de sobrecarga de funções, um sufixo é adicionado indicando o tipo
 dos parâmetros de entrada (por exemplo, 
\family typewriter 
Java_Classe_metodo__DI
\family default 
 para a versão de 
\family typewriter 
Classe.metodo
\family default 
 que aceita um 
\family typewriter 
double
\family default 
 e um 
\family typewriter 
int
\family default 
 como parâmetros).
\layout Standard

Os parâmetros de entrada da função são um ponteiro para 
\family typewriter 
JNIEnv
\family default 
, que representa uma thread da JVM, um 
\family typewriter 
jobject
\family default 
 representando o objeto sobre o qual o método é aplicado (ou uma 
\family typewriter 
jclass
\family default 
 para métodos estáticos) e os demais parâmetros do método Java em suas represent
ações C, discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Como o tipos dos parâmetros passados são definidos estaticamente tanto
 em Java como em C, não é preciso realizar a verificação dos tipos dos dados
 recebidos no código C.
 A assinatura das funções que implementam métodos, especificados nos arquivos
 de cabeçalho gerados pela ferramenta 
\family typewriter 
javah
\family default 
, já declaram os tipos corretos.
\layout Standard

O tipo de retorno corresponde ao tipo\SpecialChar ~
C equivalente ao tipo de retorno do
 método Java.
 Valores representados com tipos de referência podem ser retornados tanto
 com referências locais como globais.
 Além de tratar ou propagar erros como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, funções C podem também gerar exceções com 
\family typewriter 
Throw
\family default 
 e 
\family typewriter 
ThrowNew
\family default 
 e retornar imediatamente.
 O valor de retorno será ignorado quando a exceção for capturada no código
 Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de função global
\layout Standard

Funções da API para registrar funções (não há)
\end_inset 


\layout Standard

Como o modo de expor à máquina virtual de Java funções implementadas em
 C é diferente do empregado nas linguagens vistas anteriormente, iniciaremos
 pela forma de declarar a função para o espaço de Java, para só então mostrar
 a implementação de 
\family typewriter 
teste
\family default 
 em C.
 Na classe em Java, declaramos um método 
\family typewriter 
native
\family default 
:
\layout LyX-Code


\size footnotesize 
public class Exemplo {
\layout LyX-Code


\size footnotesize 
   static native int teste(String entrada, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...demais membros da classe
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Exemplo");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Após compilar esta classe podemos passá-la para o comando 
\family typewriter 
javah
\family default 
, que gerará um arquivo de cabeçalho C.
 Este arquivo conterá o nome e assinatura da função C que a JVM irá procurar
 na biblioteca que será carregada por 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed false

\layout Standard

O parâmetro passado no código Java é usado como base na construção de um
 nome dependente de plataforma.
 Em sistemas Unix, por exemplo, o comando 
\family typewriter 
System.loadLibrary("Exemplo")
\family default 
 carrega o arquivo 
\family typewriter 
libExemplo.so
\family default 
.
\end_inset 

.
 Esta biblioteca deve implementar funções relativas aos métodos declarados
 como 
\family typewriter 
native
\family default 
.
\layout Standard

Abaixo, é dada uma implementação em C, usando o cabeçalho gerado por 
\family typewriter 
javah
\family default 
, para o método 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cabeçalho gerado por javah */
\layout LyX-Code


\size footnotesize 
#include "Exemplo.h" 
\layout LyX-Code


\size footnotesize 
 
\newline 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_teste(JNIEnv* J, jclass c, jstring obj_entrada, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = (*J)->GetStringUTFChars(J, obj_entrada, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_entrada, entrada);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 e 
\family typewriter 
JNICALL
\family default 
 são macros definidas em 
\family typewriter 
jni.h
\family default 
 para dar maior portabilidade ao código C resultante.
 Como o método foi declarado como 
\family typewriter 
static
\family default 
 em Java, uma referência para a classe é recebida como parâmetro para a
 função.
 Os demais parâmetros correspondem aos parâmetros do método Java, e são
 dados nos tipos equivalentes da JNI.
 Conforme discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, a JNI dá tratamentos diferentes para tipos de referência e tipos imediatos.
 Desta forma, somente o parâmetro 
\family typewriter 
obj_entrada
\family default 
 precisa ser convertido para C; tanto 
\family typewriter 
n
\family default 
 como o valor de retorno podem ser usados diretamente como tipos básicos
 de C.
\layout Standard

A string obtida com 
\family typewriter 
GetStringUTFChars
\family default 
 é convertida para UTF-8 a partir da representação Unicode interna de Java.
 O mesmo ponteiro pode ser retornado pela JVM a diferentes threads que solicitem
 a mesma string.
 Deste modo, o código C deve notificar a sua liberação explicitamente com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

Funções C expostas ao espaço de Lua devem ter o tipo 
\family typewriter 
lua_CFunction
\family default 
, recebendo como único parâmetro um ponteiro para uma variável do tipo 
\family typewriter 
lua_State
\family default 
 e retornando um 
\family typewriter 
int
\family default 
.
 Um 
\family typewriter 
lua_State
\family default 
 encapsula todo o estado da máquina virtual de Lua; múltiplos estados Lua
 podem ser mantidos em paralelo.
 Todas as funções da API 
\emph on 
core
\emph default 
 de Lua recebem um 
\family typewriter 
lua_State
\family default 
 como primeiro parâmetro, exceto 
\family typewriter 
lua_newstate
\family default 
, que cria um 
\family typewriter 
lua_State
\family default 
 novo.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Convenções p/ parâmetros de entrada
\end_inset 


\layout Standard

Ao início da função C, os argumentos passados a ela encontram-se inseridos
 na pilha virtual.
 Como em funções Lua, não há verificação sobre o número de argumentos passados
 para uma função C invocada a partir de Lua ou através da API.
 O código C pode verificar o número de argumentos passados inspecionando
 o tamanho da pilha recebida.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A biblioteca auxiliar provê ainda funções para verificar de forma mais convenien
te o tipo dos argumentos passados.
 Funções da família 
\family typewriter 
luaL_check
\family default 
* (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) verificam o tipo de elementos da pilha e os retornam, sinalizando
 erro caso o tipo do elemento não seja o requisitado.
 As funções 
\family typewriter 
luaL_opt
\family default 
* se comportam de forma similar, permitindo ainda indicar um valor padrão
 caso o elemento esteja ausente ou seja 
\family typewriter 
nil
\family default 
.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Valores de retorno também são passados pela função C de volta para Lua através
 da pilha virtual.
 O valor inteiro retornado da função C indica quantos elementos da pilha
 devem ser retornados à função chamadora.
 Os demais valores da pilha são descartados.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API p/ registrar funções
\end_inset 


\layout Standard

Uma função C do tipo 
\family typewriter 
lua_CFunction
\family default 
 pode ser passada para o espaço de Lua através da função 
\family typewriter 
lua_pushcfunction
\family default 
.
 Lua possui também algumas funções de conveniência para registrar um conjunto
 de funções C de uma só vez.
 Do mesmo modo que ocorre no uso de arrays 
\family typewriter 
PyMethodDef
\family default 
 em Python, a função 
\family typewriter 
luaL_register
\family default 
 registra uma lista de funções, recebendo um array de estruturas 
\family typewriter 
luaL_Reg
\family default 
 contendo nomes e ponteiros de função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

A função C implementando a função de exemplo 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
int teste_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = luaL_checkstring(L, 1); 
\emph on 
/* Obtém o primeiro parâmetro */
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);             
\emph on 
/* Obtém o segundo parâmetro */
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);                       
\emph on 
/* Empilha o valor de retorno */
\layout LyX-Code


\size footnotesize 
   return 1;                             
\emph on 
/* Retorna um valor, do topo da pilha */
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A função tem assinatura idêntica à definição de 
\family typewriter 
lua_CFunction
\family default 
.
 Os parâmetros de entrada são obtidos das posições 1 e 2 da pilha e os seus
 tipos são verificados usando as funções da biblioteca auxiliar 
\family typewriter 
luaL_checkstring
\family default 
 e 
\family typewriter 
luaL_checkinteger
\family default 
.
 Estas funções sinalizam erro em caso de falha na conversão, causando um
 
\family typewriter 
longjmp
\family default 
 como em Ruby.
\layout Standard

O tipo da string obtida é 
\family typewriter 
const char*
\family default 
, pois ela aponta um bloco de memória gerenciado pela máquina virtual.
 Em Lua, no entanto, não é preciso notificar a liberação da string explicitament
e, pois esta permanece válida enquanto o valor estiver na pilha.
 Como as funções 
\family typewriter 
luaL_check
\family default 
* não desempilham os parâmetros e a pilha é esvaziada implicitamente ao
 final da função C, a string C obtida permanecerá válida ao longo da função.
\layout Standard

Ao fim da função 
\family typewriter 
teste_lua
\family default 
, o valor de retorno para Lua é empilhado usando 
\family typewriter 
lua_push\SpecialChar \-
integer
\family default 
.
 O valor de retorno da função em C, 
\family typewriter 
1
\family default 
, indica à máquina virtual que há um único valor de saída a ser obtido da
 pilha e usado como retorno da função em Lua.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro
\end_inset 


\layout Standard

A função é registrada em Lua criando um objeto Lua do tipo 
\family typewriter 
function
\family default 
 a partir da função C e armazenando este objeto em uma variável global.
 Isto poderia ser feito com 
\family typewriter 
lua_pushcclosure
\family default 
 e 
\family typewriter 
lua_setglobal
\family default 
, mas o arquivo de cabeçalho 
\family typewriter 
lua.h
\family default 
 possui uma macro que encapsula estas duas chamadas.
 Assim, a função pode ser registrada simplesmente com:
\layout LyX-Code


\size footnotesize 
lua_register(L, "teste", teste_lua);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Usando a função 
\family typewriter 
lua_pushcclosure
\family default 
, é possível associar a uma função C valores Lua que serão acessíveis à
 função sempre que esta for chamada, de forma similar a variáveis locais
 
\family typewriter 
static
\family default 
 C.
 Este recurso provê uma funcionalidade similar às 
\emph on 
closures
\emph default 
 de Lua, porém mais limitado: os valores associados são privados às funções
 C, enquanto em Lua duas 
\emph on 
closures
\emph default 
 definidas num mesmo escopo terão acesso às mesmas variáveis, isto é, alterações
 nos valores em uma afetarão a outra.
 Esta forma restrita, porém, já permite a implementação em C de 
\begin_inset Quotes eld
\end_inset 

funções com estado
\begin_inset Quotes erd
\end_inset 

, como iteradores e geradores.
 Uma vez registrada no espaço de Lua, funções C passam a ser vistos como
 valores do tipo 
\family typewriter 
function
\family default 
, de forma igual a funções Lua.
 De fato, 
\family typewriter 
lua_pushcfunction
\family default 
 é um caso particular de 
\family typewriter 
lua_pushcclosure
\family default 
 onde nenhum valor Lua é associado à função.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas
\end_inset 


\layout Standard

Como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

, a interface entre Perl e C foi projetada tendo em mente que a ligação
 entre as funções C e o interpretador Perl é feita através de código gerado
 a partir de uma descrição feita em uma linguagem de mais alto nível, XS.
 Código\SpecialChar ~
XS consiste de declarações de assinaturas de função com uma sintaxe
 especial, indicando regras para conversão dos parâmetros de entrada e saída,
 e código C descrevendo a implementação das funções.
 XS é projetada para o desenvolvimento de extensões Perl incluindo funções
 implementadas em C: o resultado final da compilação do código gerado pelas
 ferramentas\SpecialChar ~
XS (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) são código C e Perl que juntos descrevem um pacote Perl (um conjunto de
 variáveis e funções armazenados sob um 
\emph on 
namespace
\emph default 
 comum).
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções (não tem)
\end_inset 


\layout Standard

Existe uma API pública para manipulação de dados Perl no código C, mas esta
 consiste basicamente das estruturas internas da implementação do interpretador
 expostas para uso pelo pré-processador XS, acrescida de macros para maior
 conveniência do programador.
 De fato, Perl não expõe uma API documentada para o registro de funções\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

.
 Assim, não é prático para uma aplicação embutir um interpretador Perl e
 expor a ele um conjunto de funções C usando apenas código C.
 A saída é criar uma extensão Perl usando XS que expõe funções da aplicação
 e importar o pacote resultante no interpretador embutido.
 O emprego desta abordagem foi observada nos plugins para scripting Perl
 de diversas aplicações 
\begin_inset Foot
collapsed false

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) e Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) são algumas aplicações que implementam plugins Perl através de extensões
 XS.
 No plugin de Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), não há arquivos 
\family typewriter 
.xs
\family default 
, mas os fontes 
\family typewriter 
.c
\family default 
 incluem funções declaradas com a API não documentada e o código Perl equivalent
e ao arquivo 
\family typewriter 
.pm
\family default 
 gerado por 
\family typewriter 
xsubpp
\family default 
 declarado como uma string C avaliada com 
\family typewriter 
eval_pv
\family default 
, dando a entender que o plugin foi implementado como uma extensão usando
 XS e depois convertido para um único arquivo-fonte C.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

O utilitário 
\family typewriter 
h2xs
\family default 
 gera um diretório contendo o esqueleto de um módulo Perl: um script gerador
 de Makefiles, arquivos 
\family typewriter 
.xs
\family default 
 e 
\family typewriter 
.pm
\family default 
 a serem acrescidos de código XS e Perl, além de arquivos auxiliares.
 Retomando o exemplo da função teste, ela seria declarada da seguinte forma
 em XS:
\layout LyX-Code


\size footnotesize 
long teste(entrada, n)
\layout LyX-Code


\size footnotesize 
        char* entrada
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

O arquivo 
\family typewriter 
.xs
\family default 
 é convertido para 
\family typewriter 
.c
\family default 
 com 
\family typewriter 
xsubpp
\family default 
.
 O código C para a conversão dos parâmetros de entrada e saída é gerado
 automaticamente.
 Em alguns casos, entretanto, precisamos manipular os valores da pilha de
 Perl explicitamente, como descrito na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 Em funções vararg, por exemplo, os argumentos adicionais devem ser acessados
 diretamente na pilha.
 O código para registrar as funções do módulo também é gerado automaticamente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

XS cria uma variável 
\family typewriter 
RETVAL
\family default 
 automaticamente para armazenamento do valor de retorno em código C.
 O conteúdo desta variável é convertido para um valor Perl pelo código C
 gerado.
 Para que funções que retornam arrays possam operar corretamente em contextos
 escalares, deve-se verificar o contexto em que a função é chamada com 
\family typewriter 
GIMME_V
\family default 
 e então retornar um 
\family typewriter 
SV
\family default 
 ou 
\family typewriter 
AV
\family default 
 conforme o caso.
 A função, nestes casos, deve ser declarada com tipo de retorno 
\family typewriter 
SV*
\family default 
, fazendo com que os valores de C devam ser convertidos para 
\family typewriter 
SV
\family default 
s Perl explicitamente.
 A documentação alerta que, para o caso de 
\family typewriter 
AV
\family default 
s, deve-se declarar o valor de retorno como variável mortal
\begin_inset Foot
collapsed false

\layout Standard

Este comportamento é descrito na documentação como 
\emph on 

\begin_inset Quotes eld
\end_inset 

an unfixable bug (fixing it would break lots of existing CPAN modules)
\begin_inset Quotes erd
\end_inset 


\emph default 
 
\begin_inset LatexCommand \cite{roehrich06perlxs}

\end_inset 

.
 
\end_inset 

.
\layout Standard

Uma vez compilada a extensão usando os Makefiles gerados por 
\family typewriter 
h2xs
\family default 
, esta pode ser carregada e usada a partir de Perl:
\layout LyX-Code


\size footnotesize 
use Teste;
\layout LyX-Code


\size footnotesize 
$ret = Teste::teste("entrada", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para expor funções de uma aplicação C a um interpretador Perl embutido nela,
 devemos criar uma extensão que encapsula estas funções usando XS, ligar
 a extensão à aplicação e carregá-la.
 A carga é feita passando para o interpretador durante a sua inicialização
 uma função C contendo chamadas 
\family typewriter 
newXS
\family default 
.
 O módulo Perl 
\family typewriter 
ExtUtils::Embed
\family default 
 possui uma rotina 
\family typewriter 
xsinit
\family default 
 para gerar o código C desta função.
 Na prática, gerar o código da função com 
\family typewriter 
xsinit
\family default 
 é a melhor abordagem, já que a inicialização depende de rotinas não documentada
s (o exemplo de função de inicialização incluído na documentação de Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

 está desatualizado).
\layout Subsection

Comparação
\layout Standard

Python e Ruby oferecem ao programador várias opções de assinaturas de função\SpecialChar ~
C
 reconhecidas pela API, o que é prático, uma vez que pode-se escolher assim
 diferentes representações em C para os parâmetros de entrada (agregados
 em um array, recebidos um a um, etc.) conforme o seu uso na função.
 Lua oferece apenas uma assinatura de função possível para funções C a serem
 registradas na máquina virtual, mas isto é apropriado para o modelo de
 pilha usado por sua API.
\layout Standard

Em Java, as assinaturas de função são criadas através da ferramenta 
\family typewriter 
javah
\family default 
 -- devido à tipagem estática, os tipos dos parâmetros de entrada passados
 por Java são convertidos automaticamente pela JNI, o que é bastante conveniente
 uma vez que evita operações explícitas de conversão e verificação de tipos
 na função.
 Por terem tipagem dinâmica, as demais linguagens oferecem funções na API
 específicas para realizar estas verificações.
 As assinaturas de função em Perl são criadas apenas através da ferramenta
 XS, mas diferentemente de Java elas não são expostas ao programador.
 Isto traz a inconveniência de termos que pré-processar o código C como
 uma extensão XS mesmo quando estamos embutindo Perl em uma aplicação.
\layout Standard

O registro de funções em Ruby e Lua é simples.
 Em Lua, em particular, trata-se de uma atribuição igual à de qualquer outro
 objeto.
 Já em Python, existem recursos para o registro de funções em lote, usando
 arrays 
\family typewriter 
PyMethodDef
\family default 
 (Lua oferece recurso similar com 
\family typewriter 
luaL_register
\family default 
), mas não há uma forma simples de registrar uma única função.
 Tanto em Java como em Perl o registro de funções é feito de forma implícita,
 e em nenhuma das duas APIs há funções para registrar novas funções C durante
 a execução do programa.
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de caso: LibScript
\layout Standard

No capítulo anterior, foram discutidas as principais questões envolvendo
 interfaces de linguagens para C e a forma como estas questões são tratadas
 pelas linguagens abordadas neste estudo.
 Neste capítulo, realizaremos uma comparação entre as APIs através de um
 exemplo concreto, de modo a colocar implementações em cada uma das linguagens
 lado a lado.
 O exemplo consiste em uma biblioteca genérica para scripting, chamada LibScript
, e uma série de plugins que realizam a interface com as diferentes linguagens
 de script.
\layout Section

LibScript
\layout Standard

LibScript é uma biblioteca projetada para tornar aplicações extensíveis
 através de scripting de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo a desacoplar a aplicação dos ambientes de execução providos pelas
 diversas linguagens.
 A biblioteca principal provê uma API para scripting independente de linguagem,
 permitindo a uma aplicação registrar as suas funções e disparar scripts
 que as utilizem.
 Esta biblioteca então invoca o plugin da linguagem apropriada para rodar
 o script (por exemplo, LibScript-Python para código Python).
 Desta forma, o desenvolvedor da aplicação permite ao seu usuário utilizar
 diferentes linguagens para scripting sem adicionar todas elas como dependências
 do programa.
\layout Standard

A biblioteca principal disponibiliza recursos para o registro de funções
 C por parte da aplicação e para a chamada destas funções por parte dos
 plugins (permitindo aos scripts acessar as funções), além de funções para
 a transferência de dados entre as duas partes.
 É possível também invocar funções implementadas nas máquinas virtuais embutidas
 nos plugins, possibilitando assim que scripts escritos em diferentes linguagens
 possam interagir.
\layout Subsection

Arquitetura de LibScript
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura1.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Visão-geral}

\end_inset 

Visão geral da arquitetura de LibScript
\end_inset 


\layout Standard

LibScript é composta de uma biblioteca dinâmica principal, 
\family typewriter 
libscript
\family default 
, e 
\emph on 
plugins
\emph default 
 para diferentes linguagens (Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Visão-geral}

\end_inset 

).
 A biblioteca principal é ligada a uma aplicação, e expõe a ela uma API
 de scripting independente de linguagem, que permite executar arquivos,
 strings de código e invocar funções.
 Esta biblioteca é uma fina camada que encaminha estas operações para os
 plugins, que são bibliotecas dinâmicas auxiliares, carregadas em tempo
 de execução pela biblioteca principal.
 Estes plugins embutem os ambientes de execução das linguagens de script.
\layout Standard

A aplicação pode registrar funções C na biblioteca principal (ilustrado
 pela função 
\family typewriter 
c_fun
\family default 
 na figura) e solicitar a ela que execute scripts que registram funções
 nas diferentes linguagens.
 Todavia, a aplicação não interage diretamente com os plugins.
 Quando a biblioteca principal recebe código a ser executado em uma determinada
 linguagem, ela carrega o plugin adeqüado (caso este ainda não esteja carregado)
 e encaminha o código.
 O plugin irá executar o script em sua máquina virtual, o que pode registrar
 nela novas funções (ilustrado pelas funções 
\family typewriter 
py_fun
\family default 
, 
\family typewriter 
r_fun
\family default 
, 
\family typewriter 
l_fun
\family default 
 e 
\family typewriter 
pl_fun
\family default 
 na figura).
\layout Standard

A biblioteca principal decide qual plugin carregar através de um identificador
 que especifica qual a linguagem do código a ser executado.
 Este identificador pode ser obtido a partir da extensão de arquivo de um
 script carregado, da linha de identificação 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 no início do script
\begin_inset Foot
collapsed true

\layout Standard

A linha 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 é usada apenas para detectar a linguagem em que o script é escrito.
 Por exemplo, uma linha 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 indicará a carga do plugin 
\family typewriter 
libscript-perl
\family default 
, mas o interpretador Perl em 
\family typewriter 
/usr/bin
\family default 
 não é usado e nem a flag 
\family typewriter 
-w
\family default 
 passada é considerada.
\end_inset 

 ou mesmo passado explicitamente pela aplicação.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura2.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ambientes-virtuais}

\end_inset 

Ambientes virtuais em LibScript
\end_inset 


\layout Standard

Funções são registradas em LibScript em um 
\emph on 
ambiente virtual
\emph default 
.
 A aplicação pode criar um ou mais ambientes na biblioteca principal, identifica
ndo-os com um nome.
 Um ambiente virtual ganha em cada plugin uma estrutura de dados específica
 da linguagem (classe, módulo, etc.) que o representará.
 No exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Ambientes-virtuais}

\end_inset 

 temos dois ambientes virtuais criados pela aplicação na biblioteca principal,
 
\family typewriter 
X
\family default 
 e 
\family typewriter 
Y
\family default 
.
 Em cada um destes ambientes, a aplicação registrou uma função C com o nome
 
\family typewriter 
c_fun
\family default 
 (que podem ou não corresponder à mesma função C).
 Scripts foram executados nestes ambientes, o que causou a carga dos plugins.
 No exemplo, estes scripts registraram algumas funções (
\family typewriter 
X.py_fn
\family default 
, 
\family typewriter 
Y.py_fn
\family default 
, 
\family typewriter 
X#r_fun
\family default 
, etc.).
\layout Standard

À parte da função para criação de ambientes virtuais, todas as demais funções
 da API de LibScript recebem como parâmetro um ambiente virtual sobre a
 qual elas devem operar.
 Isto indica em qual estrutura de C devem ser armazenadas mensagens de erro
 e valores de retorno.
 No caso de linguagens que permitem múltiplos estados de execução independentes,
 como Lua e Perl, isto indica também em qual estado o script deve executar.
\layout Standard

Quando um script declara uma função no ambiente virtual, esta função passa
 a ser acessível através da API de LibScript.
 Por exemplo, no plugin Lua, o ambiente virtual é representado por uma tabela
 com o nome do ambiente; uma vez que um método Ruby\SpecialChar ~

\family typewriter 
r
\family default 
 é declarado na classe 
\family typewriter 
X
\family default 
, esta função passa a poder ser invocada por C (através da API de LibScript)
 ou pelos outros plugins.
 Assim, por exemplo, embora na tabela Lua que implementa o ambiente virtual
 
\family typewriter 
X
\family default 
 só conste a função 
\family typewriter 
l_fun
\family default 
, scripts Lua podem invocar as demais funções através do ambiente virtual,
 como 
\family typewriter 
X.c_fun
\family default 
 e 
\family typewriter 
X.r_fun
\family default 
.
 Estas chamadas serão tratadas pela biblioteca principal e resolvidas por
 ela, no caso de funções C como 
\family typewriter 
X.c_fun
\family default 
, ou repassadas para o plugin apropriado, como no caso de 
\family typewriter 
X.r_fun
\family default 
, realizando a chamada no plugin Ruby e passando os valores de retorno para
 o plugin Lua.
 A biblioteca principal localiza a função a ser executada consultando os
 plugins, conforme será explicado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:A-API-de-plugins}

\end_inset 

.
\layout Standard

Na implementação dos plugins, utilizamos recursos oferecidos pelas linguagens
 para tratar acessos a elementos inexistentes nas estruturas, capturando
 estes acessos e repassando-os para a biblioteca principal.
 Estes recursos serão discutidos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

.
\layout Subsection


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

A API da biblioteca principal
\layout Standard

A API oferecida por LibScript isola a aplicação das diferentes APIs oferecidas
 pelas linguagens de script.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas,
 o que seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Outra abordagem é, ao invés de expor a API da linguagem à aplicação, expor
 apenas uma API de funções da aplicação para a linguagem e manter as estruturas
 de dados e recursos desta restrito ao domínio que será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas02ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy,vanrossum06ref}

\end_inset 

.
 Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby , 
\family typewriter 
perl_eval_sv
\family default 
 em Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename figura3.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:API-para-execução}

\end_inset 

API para execução de código em LibScript
\end_inset 


\layout Standard

LibScript adota esta abordagem mais minimalista para sua API: não são oferecidas
 operações específicas para manipulação de estruturas de dados, apenas para
 a 
\emph on 
execução de strings
\emph default 
 -- 
\family typewriter 
script_run
\family default 
 (e a função de conveniência 
\family typewriter 
script_run_file
\family default 
, que lê um arquivo e o envia para 
\family typewriter 
script_run
\family default 
) -- e 
\emph on 
chamadas de função
\emph default 
 com tipos básicos (números e strings) -- 
\family typewriter 
script_call
\family default 
.
 Operações sobre dados mais complexos de tipos específicos de cada linguagem,
 quando necessárias, podem ser encapsuladas em funções implementadas nas
 linguagens de script.
 Pode-se ainda referenciar objetos da linguagem a partir de C armazenando-as
 em estruturas na linguagem de script e retornando a C índices numéricos
 destas estruturas, servindo como 
\emph on 
handles
\emph default 
 de alto nível para os objetos.
\layout Standard

A Figura\SpecialChar ~

\begin_inset LatexCommand \ref{fig:API-para-execução}

\end_inset 

 ilustra a interação entre a aplicação, a biblioteca principal e os plugins
 em relação a estas duas operações fundamentais, simbolizadas pelas funções
 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_call
\family default 
.
 Para a execução de strings, a biblioteca principal recebe da aplicação
 a entrada e repassa o código a ser executado para o plugin apropriado.
 Em 
\family typewriter 
script_run
\family default 
, são passadas duas strings, uma identificando a linguagem e outra contendo
 o código; em 
\family typewriter 
script_run_file
\family default 
, um nome de arquivo
\begin_inset Foot
collapsed false

\layout Standard

Para código executado com 
\family typewriter 
script_run_file
\family default 
, a linguagem é automaticamente detectada como discutido na seção anterior.
\end_inset 

.
 O exemplo a seguir declara um ambiente virtual, registra uma função C chamada
 
\family typewriter 
hello
\family default 
 e a invoca a partir de código Lua:
\layout LyX-Code


\size footnotesize 
script_env* env = script_init("exemplo");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "exemplo.hello()");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O ambiente virtual é declarado com a função 
\family typewriter 
script_init
\family default 
, que recebe o nome que identificará o ambiente e retorna um identificador
 do tipo 
\family typewriter 
script_env
\family default 
, um ponteiro opaco que representa um ambiente virtual.
 A função C é registrada usando a função 
\family typewriter 
script_new_\SpecialChar \-
function
\family default 
, que recebe como parâmetros o ambiente, a função a ser registrada e o nome
 que a função terá no ambiente virtual.
 No código Lua, a função é acessada como um elemento 
\family typewriter 
hello
\family default 
 (nome registrado da função) da tabela 
\family typewriter 
exemplo
\family default 
 (nome do ambiente virtual).
\layout Standard

Para a chamada de funções, a aplicação deve passar os parâmetros de entrada
 (a forma será discutida mais adiante), e chamar 
\family typewriter 
script_call
\family default 
, indicando o nome de uma função registrada no ambiente virtual.
 A mesma função 
\family typewriter 
script_call
\family default 
 é usada pelos plugins quando eles desejam invocar funções do ambiente virtual
 registradas em C ou implementadas por outros plugins.
\layout Standard

Por este motivo, procuramos usar uma API para transferência de dados genérica,
 a ser usada tanto na entrada como na saída de dados, tanto na comunicação
 entre a aplicação e a biblioteca principal como entre a biblioteca principal
 e os plugins.
 Optamos por uma abordagem similar às empregadas em Lua (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) e Perl (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) para o envio de dados na passagem de parâmetros e obtenção de valores
 de retorno, usando um buffer interno como área de transferência.
 Diferentemente destas linguagens, entretanto, passamos índices para os
 parâmetros explicitamente ao invés de empregar uma disciplina de pilha.
 As funções 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} são usadas na entrada e saída de valores.
 As funções 
\family typewriter 
script_put_
\family default 
* armazenam valores no buffer interno e 
\family typewriter 
script_get_
\family default 
* os removem.
 Uma chamada a uma função teste passando uma string e um inteiro como parâmetros
 e obtendo um inteiro como resultado é realizada da seguinte forma:
\layout LyX-Code


\size footnotesize 
script_put_string(env, 0, "entrada"); /* índice 0: "entrada" */
\layout LyX-Code


\size footnotesize 
script_put_int(env, 1, 2);            /* índice 1: 2 */
\layout LyX-Code


\size footnotesize 
script_call(env, "teste");
\layout LyX-Code


\size footnotesize 
resultado = script_get_int(env, 0);   /* retorna índice 0 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Chamadas de função são disponibilizadas como uma operação primitiva pois
 elas permitem um grau mínimo de interoperabilidade de forma independente
 de linguagem.
 Dois objetivos são atingidos desta forma.
 O primeiro é que assim programas C embutindo LibScript podem acessar a
 funcionalidade de scripts carregados sem precisar incluir no seu código
 strings de texto em alguma linguagem específica, por exemplo, inserindo
 em seu código uma chamada a uma função de 
\emph on 
callback
\emph default 
 a ser definida via script.
 Note que no exemplo acima, não é especificada a linguagem em que a função
 
\family typewriter 
teste 
\family default 
é implementada.
 Se a chamada fosse feita via execução de string de código, isto atrelaria
 a aplicação a pelo menos uma linguagem de script.
 Usando 
\family typewriter 
script_run_file
\family default 
 e 
\family typewriter 
script_call
\family default 
, pode-se implementar uma aplicação extensível sem especificar explicitamente
 a linguagem de script a ser usada.
 O segundo objetivo é permitir que os próprios plugins possam invocar funções
 definidas em outros plugins.
 De qualquer forma, necessariamente teríamos que prover aos plugins uma
 função de chamada, para que eles pudessem invocar as funções C registradas
 em LibScript.
 Tornar a função de chamada genérica o suficiente para que possa invocar
 também funções implementadas nos próprios plugins não torna, então, a API
 da biblioteca principal mais complexa.
\layout Standard

O buffer de LibScript foi projetado para ser usado apenas como uma área
 de transferência temporária entre a biblioteca principal e os plugins,
 e não como uma facilidade geral para armazenamento e manipulação de dados.
 Assim, a sua API é voltada para a inserção e remoção seqüencial de elementos.
 Por exemplo, a inserção de um elemento na posição 0 automaticamente zera
 o buffer, evitando em muitos casos a necessidade de usar a função 
\family typewriter 
script_reset_buffer
\family default 
, que realiza tal operação explicitamente.
\layout Standard

Funções C registradas com 
\family typewriter 
script_new_function
\family default 
 devem receber o ambiente virtual como parâmetro e retornar um código de
 erro.
 As funções 
\family typewriter 
script_get_
\family default 
* e 
\family typewriter 
script_put_
\family default 
* são usadas para receber parâmetros e retornar valores ao implementar funções
 que podem ser chamadas via LibScript, da mesma forma que são usadas para
 passar parâmetros e obter valores de retorno ao realizar chamadas com 
\family typewriter 
script_call
\family default 
.
\layout LyX-Code


\size footnotesize 
script_err teste_lua(script_env* env) {
\layout LyX-Code


\size footnotesize 
   char* entrada = script_get_string(env, 0);  
\emph on 
/* Entrada, índice 0: string */
\layout LyX-Code


\size footnotesize 
   int n = script_get_int(env, 1);             
\emph on 
/* Entrada, índice 1: inteiro */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Sai da função com erro se algum script_get_* falhou */
\layout LyX-Code


\size footnotesize 
   SCRIPT_CHECK_INPUTS(env);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   free(entrada);
\layout LyX-Code


\size footnotesize 
   script_put_int(env, 0, 42);                 
\emph on 
/* Retorno, índice 0: inteiro */
\layout LyX-Code


\size footnotesize 
   return SCRIPT_OK;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript as strings retornadas por 
\family typewriter 
script_get_string
\family default 
 pertencem à função chamadora, sendo responsabilidade dela desalocar a memória,
 diferentemente do que ocorre nas funções similares das APIs das linguagens
 discutidas neste trabalho.
 Tal decisão foi tomada devido ao caráter temporário do buffer de LibScript:
 retornar ao chamador um ponteiro para uma string cuja validade seria restrita
 até a próxima chamada da API seria algo pouco intuitivo, e na prática forçaria
 freqüentemente o programador a fazer uma cópia da string.
\layout Subsection

A API de plugins
\begin_inset LatexCommand \label{sub:A-API-de-plugins}

\end_inset 


\layout Standard

Um plugin que embute uma linguagem de script deve implementar quatro operações:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 e 
\family typewriter 
done
\family default 
.
 A biblioteca principal espera que a biblioteca dinâmica que implementa
 o plugin de uma linguagem exporte quatro funções, com nomes do tipo
\family typewriter 
 script_plugin_
\family default 
\emph on 
<operação>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<linguagem>
\emph default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável pela inicialização de um plugin, e é chamada pela função
 
\family typewriter 
script_init
\family default 
 da biblioteca principal.
 Na inicialização de um plugin, a biblioteca principal passa à função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 um ponteiro 
\family typewriter 
script_env
\family default 
 e recebe um 
\family typewriter 
script_plugin_state
\family default 
, que é um tipo opaco que é sempre passado de volta ao plugin nas demais
 chamadas.
 Cada plugin define a sua representação interna para 
\family typewriter 
script_plugin_state
\family default 
.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
 Na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 discutiremos como cada plugin representa o ambiente e o seu estado interno
 em 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
 é invocada por 
\family typewriter 
script_run
\family default 
.
 Ela recebe uma string contendo código da linguagem de script, executa este
 código na máquina virtual e retorna um valor de status indicando sucesso
 ou a ocorrência de erros de compilação ou execução.
 No caso de erros, os plugins devem capturar exceções disparadas pela máquina
 virtual e retornar a constante 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
.
 Caso seja possível obter da linguagem uma mensagem de erro, esta pode ser
 propagada usando a função 
\family typewriter 
script_set_error_message
\family default 
 da biblioteca principal.
 A mensagem armazenada por ela poderá ser posteriormente consultada pela
 aplicação com a função 
\family typewriter 
script_error_message
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 é usada por 
\family typewriter 
script_call
\family default 
, e é responsável por realizar chamadas a funções implementadas na linguagem
 embutida pelo plugin.
 Se a função foi definida no plugin, isto é, se uma função com o nome solicitado
 foi registrada na estrutura de dados que descreve o ambiente na máquina
 virtual, ela será executada, e o sucesso ou falha da execução será reportado
 de forma igual a 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
.
 Caso a função solicitada não tenha sido definida na máquina virtual, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
\SpecialChar \-
<linguagem>
\emph default 
 deve retornar a constante 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
 Parâmetros de entrada e valores de retorno são passados através do buffer
 de parâmetros, usando as mesmas funções 
\family typewriter 
script_get_*
\family default 
 e 
\family typewriter 
script_put_*
\family default 
 da biblioteca principal que são usadas para a passagem de dados entre a
 aplicação e a biblioteca principal.
\layout Standard

A implementação da função 
\family typewriter 
script_call
\family default 
 na biblioteca principal faz uso deste comportamento dos plugins para invocar
 funções de modo independente de linguagem.
 Inicialmente, ela tenta encontrar uma função solicitada na lista de funções
 C registradas.
 Caso não haja uma função C no ambiente virtual com este nome, 
\family typewriter 
script_call
\family default 
 tenta localizar a função nos plugins carregados, chamando a função com
 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 em cada plugin, e tentando o próximo a cada vez que recebe 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
\layout Standard

Finalmente, a função 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<linguagem>
\emph default 
 é chamada por 
\family typewriter 
script_done
\family default 
 quando um ambiente virtual é encerrado.
 Dependendo da representação interna usada no plugin, a finalização de um
 estado pode ou não implicar na finalização da máquina virtual.
 Preferencialmente, esta função deve remover a estrutura que descreve o
 ambiente virtual, mas, como veremos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

, isto nem sempre é possível.
\layout Section

Implementação dos plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Standard

Nesta seção discutiremos os principais aspectos envolvidos na implementação
 dos plugins desenvolvidos neste estudo de caso.
 Implementamos plugins para as linguagens Python, Ruby, Lua e Perl.
 Apresentaremos aqui como é feita a representação dos estados virtuais em
 cada plugin (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

), questões envolvendo o encerramento de estados (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

), passagem de parâmetros entre a biblioteca principal e os plugins (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

), como a chamada de funções a partir de scripts é tratada pelos plugins
 (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

) e a captura de erros (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

).
\layout Subsection

Representação de estados
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

O design de LibScript permite que plugins mantenham múltiplos estados de
 execução independentes.
 Idealmente estes estados seriam totalmente isolados entre si, como por
 exemplo diferentes instâncias da máquina virtual, oferecendo maior segurança
 ao ambiente de execução dos scripts.
 Todavia, as linguagens oferecem diferentes graus de isolamento possível
 entre estados independentes.
 Lua e Perl permitem múltiplas instâncias isoladas do ambiente de execução
 de forma simples, uma vez que as chamadas à API incluem um identificador
 de estado
\begin_inset Foot
collapsed false

\layout Standard

O recurso de múltiplos estados independentes é opcional em Perl, selecionado
 durante a compilação da biblioteca do interpretador.
\end_inset 

.
 Já linguagens que mantêm estado de forma estática, como Python e Ruby,
 não permitem trabalhar com múltiplos estados isolados facilmente
\begin_inset Foot
collapsed false

\layout Standard

O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados.
 A documentação diz, desde 1999, que 
\begin_inset Quotes eld
\end_inset 


\emph on 
This is a hard-to-fix bug that will be addressed in a future release.
\emph default 

\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum99api,vanrossum06api}

\end_inset 


\end_inset 

.
 Nas linguagens que não permitem múltiplas instâncias da máquina virtual,
 podemos definir apenas espaços de nomes separados para os ambientes virtuais
 LibScript, que compartilham um único estado global de execução dentro do
 plugin.
 À representação de um estado de execução relativo a um ambiente virtual
 LibScript dentro de um plugin damos o nome de 
\emph on 
estado virtual
\emph default 
, que pode ou não corresponder a um estado de execução isolado.
\layout Standard

Como comentado na seção anterior, a função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 retorna à biblioteca principal um 
\family typewriter 
script_plugin_state
\family default 
, que é a representação opaca do seu estado virtual.
 O conteúdo desta representação varia de linguagem para linguagem, mas o
 princípio básico é que dois dados devem estar disponíveis a partir deste
 valor: uma referência para o ambiente virtual LibScript, recebido como
 parâmetro para 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
, para que o plugin possa fazer chamadas à biblioteca principal, e um identifica
dor que permita ao plugin acessar a estrutura de dados que representa na
 linguagem o espaço de nome de funções acessíveis via LibScript.
 No plugin Lua, esta estrutura é uma tabela; em Python, um módulo; em Ruby,
 uma classe; e em Perl, um pacote.
\layout Standard

Em LibScript-Lua, estados são implementados como 
\family typewriter 
lua_State
\family default 
s (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 Desta forma, scripts executados em um ambiente são plenamente isolados
 dos demais ambientes.
 Por exemplo, a alteração do valor de uma variável global em um ambiente
 não afeta os demais.
 De fato, o 
\family typewriter 
script_plugin_state
\family default 
 retornado pelo plugin Lua é simplesmente o 
\family typewriter 
lua_State
\family default 
 convertido via cast.
 O ponteiro para o ambiente LibScript é armazenado em Lua no registro, da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "LibScript.env"); 
\emph on 
  /* Empilha o índice */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);        
\emph on 
/* Empilha o ambiente LibScript */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX);   
\emph on 
/* registro["LibScript.env"] = env */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O plugin cria neste 
\family typewriter 
lua_State
\family default 
 uma tabela que representará o ambiente virtual para scripts Lua.
 Esta tabela é armazenada no 
\family typewriter 
lua_State
\family default 
 como uma variável global com o nome do ambiente virtual.
\layout Standard

Em LibScript-Perl os estados são isolados como em Lua.
 Cada estado criado inicializa uma nova instância de 
\family typewriter 
PerlInterpreter
\family default 
.
 Neste interpretador, é criado um pacote que será a representação do ambiente
 visível a partir de código Perl.
 O tipo 
\family typewriter 
script_plugin_state
\family default 
, então, é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PerlInterpreter
\family default 
*.
\layout Standard

Como discutido na seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-registro}

\end_inset 

, a implementação de funções C exportadas para um interpretador Perl é feita
 escrevendo um módulo de extensão usando o pré-processador XS, e a forma
 de obter comunicação no sentido Perl
\begin_inset Formula $\rightarrow$
\end_inset 

C em uma máquina virtual embutida é ligando um módulo de extensão juntamente
 com a máquina virtual.
 Assim, parte do plugin LibScript-Perl é implementado como um módulo XS,
 exposto na máquina virtual embutida como o pacote Perl 
\family typewriter 
LibScript
\family default 
.
 Durante a inicialização de um estado virtual, o ponteiro para o ambiente
 virtual LibScript é armazenado neste pacote, na variável 
\family typewriter 
$LibScript::env
\family default 
.
 O pacote que representa o ambiente virtual é criado pela função 
\family typewriter 
script_plugin_init_perl
\family default 
, executando a string de código 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 com a função 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

Como Python não dispõe de facilidades para disparar múltiplas máquinas virtuais
 plenamente isoladas, o plugin Python implementa estados virtuais apenas
 como módulos separados, compartilhando um mesmo estado global.
 Durante a inicialização de um estado, é criado um módulo Python com o nome
 do ambiente.
 O seguinte trecho da função 
\family typewriter 
script_plugin_init_python
\family default 
 exibe a seqüência onde o módulo é criado e importado:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o nome do ambiente */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o módulo.
 O primeiro parâmetro é o nome do módulo,
\layout LyX-Code


\size footnotesize 
\emph on 
   o segundo a lista de métodos do módulo, que será inicialmente vazio.
 */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém dicionário de globais */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o módulo à variável global com o seu nome.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O tipo 
\family typewriter 
script_plugin_state
\family default 
 é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PyObject*
\family default 
.
 O objeto retornado pela função de inicialização é o dicionário de elementos
 do módulo, obtido com 
\family typewriter 
PyModule_GetDict\SpecialChar \-
(module)
\family default 
.
 Neste dicionário, armazenamos o ponteiro do ambiente virtual como o atributo
 privado 
\family typewriter 
__env
\family default 
.
\layout Standard

De forma similar, em Ruby estados virtuais são implementados como classes
 que compartilham um mesmo estado global, já que Ruby também não permite
 múltiplos ambientes de execução isolados.
 Na função de inicialização 
\family typewriter 
script_plugin_init_ruby
\family default 
, uma classe com o nome do ambiente virtual é criada usando a função 
\family typewriter 
rb_define_class
\family default 
.
 O ponteiro do ambiente virtual é armazenado em uma constante da classe
 como um número.
 O 
\family typewriter 
VALUE
\family default 
 referente à classe é retornado como o 
\family typewriter 
script_plugin_state
\family default 
.
\layout LyX-Code


\size footnotesize 
VALUE state;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (inicialização do interpretador omitida) ...
 */
\layout LyX-Code


\size footnotesize 
\emph on 
/* class_name é o nome do ambiente virtual,
\layout LyX-Code


\size footnotesize 
\emph on 
   com a inicial convertida para maiúsculas,
\layout LyX-Code


\size footnotesize 
\emph on 
   respeitando a convenção de nomes de classe Ruby */
\layout LyX-Code


\size footnotesize 
state = rb_define_class(class_name, rb_cObject);
\layout LyX-Code


\size footnotesize 
/* Isto assume que void* cabe em um long */
\layout LyX-Code


\size footnotesize 
rb_const_set(state, rb_intern("@@LibScriptEnv"), INT2NUM((long)env));  
  
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
return (script_plugin_state) state;
\layout Subsection

Encerramento de estados
\begin_inset LatexCommand \label{sub:Encerramento-de-estados}

\end_inset 


\layout Standard

Como Lua e Perl representam estados de forma independente, o encerramento
 de um estado nestes plugins é simples: a estrutura da linguagem que encapsula
 o ambiente completo de execução é encerrada.
 A implementação da função de finalização no plugin Lua é a seguinte:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Em Lua, um state é um lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Encerra o estado.
 Não afeta outros ambientes.
 */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Perl, o processo, embora um tanto mais elaborado, é essencialmente similar:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas macros assumem que o ponteiro do interpretador
\layout LyX-Code


\size footnotesize 
\emph on 
      se chama my_perl.
 */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = (PerlInterpreter*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas operações operam sobre o 
\begin_inset Quotes eld
\end_inset 

estado atual
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      então a macro PERL_SET_CONTEXT deve ser usada para
\layout LyX-Code


\size footnotesize 
\emph on 
      alternar o interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Esta flag deve ser ativada para que a limpeza do
\layout LyX-Code


\size footnotesize 
\emph on 
      ambiente seja completa, o que é necessário quando
\layout LyX-Code


\size footnotesize 
\emph on 
      pode haver mais de um interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Encerramento do interpretador */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Em Python e Ruby, o plugin precisa manter o controle do número de estados
 ativos para desalocar a máquina virtual somente quando este chegar a zero.
 Além disso, tanto em Ruby como em Python não há recursos nas APIs (ou nas
 linguagens, de fato) para remover, respectivamente, classes ou módulos.
 Em Ruby, poderíamos atribuir 
\family typewriter 
nil
\family default 
 à constante que representa a classe que descreve o ambiente virtual, mas
 depois disso não é possível definir uma nova classe em seu lugar: tanto
 
\family typewriter 
rb_define_class
\family default 
 via C como 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 via Ruby geram um erro indicando que o valor já foi definido com outro
 tipo.
 Como Ruby possui classes abertas, uma construção 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 para um 
\emph on 
<Nome>
\emph default 
 já existente é entendida como a continuação da descrição da classe, e não
 como a redefinição de 
\emph on 
<Nome>
\emph default 
.
 Python, por sua vez, não disponibiliza recursos na API para a descarga
 de módulos, mas permite atribuir 
\family typewriter 
None
\family default 
 à global referente ao módulo.
 O módulo pode ser importado novamente, mas a mesma instância dele, armazenada
 internamente por Python, será retornada.
 A seguinte sessão interativa de linha de comando permite observar este
 comportamento, que ocorre tanto diretamente em Python como via a API de
 C:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, as estruturas de dados referentes aos estados LibScript não são encerrado
s nos plugins Python e Ruby.
 Esta é a implementação da rotina de encerramento no plugin Ruby:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrementa o contador de estados, uma variável global 
\emph default 
static
\emph on 
 do plugin.
 */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Finaliza o interpretador se este for o último estado.
 */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A implementação no plugin Python é basicamente igual:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Passagem de parâmetros
\begin_inset LatexCommand \label{sub:Passagem-de-parâmetros}

\end_inset 


\layout Standard

A transferência de dados entre a biblioteca principal e os plugins é concentrada
 em duas operações: uma para passar o conteúdo do buffer de parâmetros de
 LibScript para o espaço de dados da máquina virtual e outra para realizar
 a operação inversa.
 A primeira é usada na passagem de parâmetros de entrada quando funções
 da linguagem de script são chamadas por C e para a obtenção dos valores
 de retorno quando a linguagem de script faz chamadas que são tratadas C.
 A segunda operação, de forma complementar, é usada para os valores de retorno
 quando C chama a linguagem de script e para os parâmetros de entrada quando
 uma chamada feita pela linguagem de script é tratada por código C.
\layout Standard

Na implementação do plugin LibScript-Lua, a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 converte o conteúdo da pilha de Lua para o buffer de parâmetros de LibScript.
 A função do plugin responsável por invocar funções Lua a partir de C, 
\family typewriter 
script_plugin_call_lua
\family default 
, usa a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 para armazenar no buffer LibScript os valores de retorno da função Lua
 invocada, já que estes são retornados na pilha virtual.
 Quando o código Lua chama funções implementadas em C ou em outro plugin,
 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 é usada para converter os parâmetros de entrada da função, também recebidos
 na pilha virtual.
 A seguir, vemos a implementação desta função:
\layout LyX-Code


\size footnotesize 
static void script_lua_stack_to_buffer(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int nargs; int i; 
\layout LyX-Code


\size footnotesize 
   nargs = lua_gettop(L);    
\emph on 
/* Número de elementos na pilha de Lua */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env); 
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 1; i <= nargs; i++) {
\layout LyX-Code


\size footnotesize 
      
\emph on 
/* Verifica o tipo Lua do elemento na posição i da pilha */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, converte o elemento e o armazena no buffer */
\layout LyX-Code


\size footnotesize 
      switch(lua_type(L, i)) { 
\layout LyX-Code


\size footnotesize 
      case LUA_TNUMBER:
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, lua_tonumber(L, i)); break; 
\layout LyX-Code


\size footnotesize 
      case LUA_TSTRING:
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i-1, lua_tostring(L, i)); break;
\layout LyX-Code


\size footnotesize 
      case LUA_TBOOLEAN:
\layout LyX-Code


\size footnotesize 
         script_put_bool(env, i-1, lua_toboolean(L, i)); break;
\layout LyX-Code


\size footnotesize 
      default:
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Tipos não tratados são substituídos por zero.
 */
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, 0);
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumimos em LibScript strings no formato de C: a função 
\family typewriter 
script_put_string
\family default 
 copia a string passada até o primeiro 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Assim, ao obter strings de linguagens que permitem conteúdo arbitrário,
 estas serão truncadas caso contenham 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Por isso, no plugin Lua usamos diretamente a função 
\family typewriter 
lua_tostring
\family default 
, e não a função mais geral 
\family typewriter 
lua_tolstring
\family default 
 (que retorna também o tamanho do buffer).
\layout Standard

Os valores de tipos desconhecidos são substituídos pelo valor zero, o que
 mantém a posição dos demais valores na lista de argumentos.
 Optamos por não sinalizar erro nesta situação para evitar aqui a geração
 de exceções, o que complicaria a exposição.
 A captura e propagação de erros serão vistas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Standard

A segunda função de transferência de dados de LibScript-Lua, 
\family typewriter 
script_lua_buffer_to_stack
\family default 
, obtém os valores do buffer LibScript e os insere na pilha virtual de Lua.
 Esta função é usada para passar os parâmetros de entrada para Lua em 
\family typewriter 
script_plugin_call_lua
\family default 
 e para passar para Lua os valores obtidos pelo retorno da função 
\family typewriter 
script_call
\family default 
, que é invocada internamente pelo plugin quando Lua invoca uma função C.
\layout LyX-Code


\size footnotesize 
static int script_lua_buffer_to_stack(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int i; char* s;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env); 
\emph on 
/* Número de elementos no buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Verifica o tipo do elemento na posição i do buffer */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, o obtém e o insere na pilha de Lua */
\layout LyX-Code


\size footnotesize 
      type = script_get_type(env, i);
\layout LyX-Code


\size footnotesize 
      switch (type) {
\layout LyX-Code


\size footnotesize 
      case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
         lua_pushnumber(L, script_get_double(env, i)); break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
         s = script_get_string(env, i); 
\emph on 
/* A string pertence ao chamador.
 */
\layout LyX-Code


\size footnotesize 
         lua_pushstring(L, s);
\layout LyX-Code


\size footnotesize 
         free(s); 
\emph on 
/* Libera a string, já que Lua armazena sua própria cópia.
 */
\layout LyX-Code


\size footnotesize 
         break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
         lua_pushboolean(L, script_get_bool(env, i)); break;
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return len;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript-Python, não foi possível concentrar as operações de transferência
 de dados em apenas duas funções.
 Cada operação teve que ser dividida em duas partes.
 A conversão de dados recebidos de Python para o buffer de LibScript foi
 divida nas funções 
\family typewriter 
script_python_put_object
\family default 
 e 
\family typewriter 
script_python_tuple_to_buffer
\family default 
.
 A primeira função converte um único valor Python e o insere na posição
 solicitada no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_put_object(script_env* env, int i, PyObject* o)
 {
\layout LyX-Code


\size footnotesize 
   if (PyString_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, PyString_AS_STRING(o));
\layout LyX-Code


\size footnotesize 
   else if (PyInt_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, PyInt_AS_LONG(o));
\layout LyX-Code


\size footnotesize 
   else if (PyLong_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyLong_AsDouble(o));
\layout LyX-Code


\size footnotesize 
   else if (PyFloat_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyFloat_AS_DOUBLE(o));
\layout LyX-Code


\size footnotesize 
   else if (PyBool_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, o == Py_True ? 1 : 0);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É importante notar que os tipos Python 
\family typewriter 
PyInt
\family default 
 e 
\family typewriter 
PyLong
\family default 
 não correspondem aos tipos C 
\family typewriter 
int
\family default 
 e 
\family typewriter 
long
\family default 
: 
\family typewriter 
PyInt
\family default 
 é o tipo inteiro correspondente ao tamanho da palavra da máquina (análogo
 a 
\family typewriter 
int
\family default 
), mas 
\family typewriter 
PyLong
\family default 
 é um inteiro de precisão arbitrária.
 Em LibScript, representamos 
\family typewriter 
PyLong
\family default 
s como 
\family typewriter 
double
\family default 
s.
 A API de LibScript oferece a função 
\family typewriter 
script_put_int
\family default 
 como conveniência, mas internamente, como ocorre por exemplo em Lua, todos
 os números são armazenados como 
\family typewriter 
double
\family default 
s.
\layout Standard

A segunda função, 
\family typewriter 
script_python_tuple_to_buffer
\family default 
, insere os elementos de uma tupla no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_tuple_to_buffer(script_env* env, PyObject* tuple)
 {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = PyTuple_GET_SIZE(tuple); 
\emph on 
/* Número de elementos da tupla */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);          
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = PyTuple_GET_ITEM(tuple, i); 
\emph on 
/* Obtém elemento da tupla */
\layout LyX-Code


\size footnotesize 
      script_python_put_object(env, i, o);      
\emph on 
/* Insere-o no buffer.
 */
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A operação inversa, de transferência de dados do buffer LibScript para Python,
 também é implementada em duas funções, uma tratando objetos individualmente
 e outra tratando tuplas.
 A função 
\family typewriter 
script_get_object
\family default 
 converte um elemento do buffer para um 
\family typewriter 
PyObject
\family default 
 equivalente:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_get_object(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   PyObject* ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return PyFloat_FromDouble(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      PyObject* ret = PyString_FromString(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return PyBool_FromLong(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
script_python_buffer_to_tuple
\family default 
 gera uma tupla contendo todos os elementos do buffer LibScript:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_buffer_to_tuple(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   PyObject* ret = PyTuple_New(len);
\layout LyX-Code


\size footnotesize 
   for(i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = script_python_get_object(env, i);
\layout LyX-Code


\size footnotesize 
      PyTuple_SetItem(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, estes dois pares de funções realizam funções equivalentes às que
 
\family typewriter 
script_lua_\SpecialChar \-
stack_to_buffer
\family default 
 e 
\family typewriter 
script_lua_buffer_to_stack
\family default 
 exercem no plugin Lua.
 Elas foram separadas em duas partes em função do modelo de retorno de valores
 em funções Python: no caso de múltiplos valores de retorno, eles são retornados
 como uma tupla; para valores simples, eles são passados diretamente.
 Isto é evidenciado no seguinte trecho da função 
\family typewriter 
script_plugin_call_python
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject *ret, *args;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
args = script_python_buffer_to_tuple(env);  
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
ret = PyEval_CallObject(func, args); 
\emph on 
       /* Chama uma função Python */
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
if (ret == Py_None)                         
\emph on 
/* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);                
\emph on 
/* Apenas zere o buffer LibScript */
\layout LyX-Code


\size footnotesize 
else if (PyTuple_Check(ret))                
\emph on 
/* Se retornou uma tupla */
\layout LyX-Code


\size footnotesize 
   script_python_tuple_to_buffer(env, ret); 
\emph on 
/* Insira seus elementos no buffer */
\layout LyX-Code


\size footnotesize 
else                                        
\emph on 
/* Se retornou outro tipo de objeto */
\layout LyX-Code


\size footnotesize 
   script_python_put_object(env, 0, ret);   
\emph on 
/* Insira-o como único elemento */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

No tratador de chamadas a funções externas do plugin, a comunicação no sentido
 inverso emprega uma lógica similar:
\layout LyX-Code


\size footnotesize 
script_python_tuple_to_buffer(env, args);    
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
err = script_call(env, fn_name);             
\emph on 
/* Chama um função via LibScript */
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
switch(script_buffer_len(env)) {
\layout LyX-Code


\size footnotesize 
case 0:                                      
\emph on 
 /* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   Py_RETURN_NONE;                           
\emph on 
 /* Retorne o valor Python 'None' */
\layout LyX-Code


\size footnotesize 
case 1:                                      
\emph on 
 /* Se retornou um único valor */
\layout LyX-Code


\size footnotesize 
   return script_python_get_object(env, 0);  
\emph on 
 /* Converta e retorne-o */
\layout LyX-Code


\size footnotesize 
default:                                      
\emph on 
/* Se retornou mais de um valor */
\layout LyX-Code


\size footnotesize 
   return script_python_buffer_to_tuple(env); 
\emph on 
/* Retorne-os em uma tupla */
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim como em Python, funções em Ruby retornam múltiplos valores encapsulando-os
 em um tipo agregado.
 Desta forma, as operações de transferências de dados de LibScript-Ruby
 também são divididas em pares de funções, uma convertendo um valor do buffer,
 e outra operando sobre um array Ruby.
 A função análoga a 
\family typewriter 
script_python_put_object
\family default 
 é 
\family typewriter 
script_ruby_put_value
\family default 
:
\layout LyX-Code


\size footnotesize 
static void script_ruby_put_value(script_env* env, int i, VALUE arg) {
\layout LyX-Code


\size footnotesize 
   switch (TYPE(arg)) {
\layout LyX-Code


\size footnotesize 
   case T_FLOAT:
\layout LyX-Code


\size footnotesize 
   case T_FIXNUM:
\layout LyX-Code


\size footnotesize 
   case T_BIGNUM:
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, NUM2DBL(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_STRING:
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, StringValuePtr(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_TRUE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 1); break;
\layout LyX-Code


\size footnotesize 
   case T_FALSE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 0); break;
\layout LyX-Code


\size footnotesize 
   default:
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Aqui, alguns problemas da API de Ruby são aparentes.
 Além da inconsistência na nomenclatura das funções de conversão de objetos,
 o significado do valor retornado pela macro 
\family typewriter 
TYPE
\family default 
 só pode ser compreendido através da representação interna de 
\family typewriter 
VALUE
\family default 
s na implementação de Ruby, e não através da hierarquia de tipos dos objetos
 da linguagem.
 As classes que têm tratamento especial na estrutura interna de 
\family typewriter 
VALUE
\family default 
s possuem constantes associadas a si, como 
\family typewriter 
T_FLOAT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
; as demais são identificados apenas como 
\family typewriter 
T_OBJECT
\family default 
s.
 O uso de 
\family typewriter 
T_TRUE
\family default 
 e 
\family typewriter 
T_FALSE
\family default 
 pode dar a entender que alguns valores específicos também retornam resultados
 especiais para 
\family typewriter 
TYPE
\family default 
.
 De fato, estes valores são definidos como 
\family typewriter 
VALUE
\family default 
s que não correspondem a índices da heap de objetos de Ruby e são tratados
 de forma especial na implementação.
 Do ponto de vista de código Ruby, entretanto, esta classificação dos valores
 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em tipos separados na API C é justificada definindo-os como 
\emph on 
singletons
\emph default 
 das classes 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
, abordagem provavelmente influenciada por Smalltalk.
 Porém, diferentemente de Smalltalk, onde 
\family typewriter 
True
\family default 
 e 
\family typewriter 
False
\family default 
 são subclasses de 
\family typewriter 
Boolean
\family default 
, em Ruby 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
 são subclasses diretas de 
\family typewriter 
Object
\family default 
.
 Isto traz a inconveniência de que verificar se um tipo é um valor booleano
 incorre sempre em dois testes.
\layout Standard

Assim como LibScript-Python tem uma função para armazenar no buffer os elementos
 de uma tupla, LibScript-Ruby possui uma função para armazenar os elementos
 de um array:
\layout LyX-Code


\size footnotesize 
static void script_ruby_array_to_buffer(script_env* env, VALUE array) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = RARRAY(array)->len;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = rb_ary_entry(array, i);
\layout LyX-Code


\size footnotesize 
      script_ruby_put_value(env, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Ruby não possui uma função na API C para retornar o tamanho de um array;
 ao invés disso, a estrutura interna do 
\family typewriter 
VALUE
\family default 
 é exposta através da macro 
\family typewriter 
RARRAY
\family default 
 (que apenas encapsula um cast).
 
\layout Standard

As operações para conversão de valores do buffer LibScript para Ruby também
 são similares às implementadas no plugin Python.
 Novamente, onde em Python há uma função para manipulação de tuplas, temos
 em Ruby uma função que opera sobre arrays:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_get_value(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   VALUE ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return rb_float_new(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      ret = rb_str_new2(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return script_get_bool(env, i) ? Qtrue : Qfalse;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\newline 
static VALUE script_ruby_buffer_to_array(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   VALUE ret = rb_ary_new2(len);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = script_ruby_get_value(env, i);
\layout LyX-Code


\size footnotesize 
      rb_ary_store(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

De forma similar ao plugin Python, a implementação da chamada de funções
 Ruby a partir de LibScript usa a função 
\family typewriter 
script_ruby_buffer_to_array
\family default 
 para converter os parâmetros de entrada e as funções 
\family typewriter 
script_ruby_put_value
\family default 
 ou 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 para converter o valor de retorno, dependendo se a função retornou um ou
 mais valores (ou mais precisamente, se a função retornou ou não um array).
 Em chamadas de funções LibScript a partir de Ruby, os parâmetros de entrada
 são convertidos com 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 e os valores de retorno com 
\family typewriter 
script_ruby_get_value
\family default 
 ou 
\family typewriter 
script_ruby_buffer_to_array
\family default 
.
\layout Standard

No plugin Perl, temos três funções: a transferência de dados da pilha para
 o buffer LibScript pôde ser implementada em uma única função como em Lua,
 mas a transferência no sentido oposto teve que ser dividida em duas funções,
 como em Python e Ruby.
 Esta assimetria vem do fato de que o tratamento de valores de retorno é
 encapsulado pelo pré-processador XS através da variável especial 
\family typewriter 
RETVAL
\family default 
; assim, nesta situação não podemos manipular a pilha diretamente, mas apenas
 passar 
\family typewriter 
SV
\family default 
s como valores de saída.
 
\layout Standard

A transferência de dados da pilha de Perl para o buffer LibScript é razoavelment
e simples:
\layout LyX-Code


\size footnotesize 
void script_perl_stack_to_buffer(pTHX_ int ax, script_env* env,
\layout LyX-Code


\size footnotesize 
                                 int count, int offset) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < count; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém um ponteiro para o SV */
\layout LyX-Code


\size footnotesize 
      SV* o = ST(offset+i);
\layout LyX-Code


\size footnotesize 
      if (SvIOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, SvIV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvNOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i, SvNV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvPOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i, SvPV_nolen(o));
\layout LyX-Code


\size footnotesize 
      else
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os parâmetros de entrada desta função merecem comentário.
 Inicialmente, temos a macro 
\family typewriter 
pTHX_
\family default 
.
 Esta macro foi adicionada à API quando Perl passou a permitir múltiplos
 interpretadores simultâneos por processo: as funções da API foram transformadas
 em macros que encapsulam a passagem deste primeiro parâmetro.
 Por exemplo, a função 
\family typewriter 
eval_sv
\family default 
 pode ser chamada como 
\family typewriter 
Perl_eval_sv
\family default 
, passando a macro 
\family typewriter 
aTHX_
\family default 
 como parâmetro inicial.
 De maneira geral o uso destas macros fica implícito, mas ao escrever funções
 que usam a API de Perl torna-se necessário usar a macro 
\family typewriter 
pTHX_
\family default 
 na declaração
\begin_inset Foot
collapsed true

\layout Standard

A macro 
\family typewriter 
pTHX_
\family default 
 é usada sem a vírgula separando-a do argumento seguinte.
 Quando ela é o único argumento, deve-se usar 
\family typewriter 
pTHX
\family default 
.
\end_inset 

, para propagar a informação de estado do interpretador através de chamadas
 de função, e 
\family typewriter 
aTHX_
\family default 
 nas chamadas.
\layout Standard

Outro sintoma de que a API de Perl foi projetada mais para uso interno do
 pré-processador XS do que para manipulação direta transparece no segundo
 argumento, 
\family typewriter 
ax
\family default 
.
 Algumas macros assumem a existência deste valor, que não é propagado via
 
\family typewriter 
pTHX_
\family default 
, mas é declarado implicitamente quando funções são encapsuladas via XS.
 A API parece assumir que uma função XS não irá invocar outra função C que
 também use a API.
 Tivemos então que propagar esta variável (que é citada na documentação,
 mas apenas como 
\emph on 
"the 'ax' variable"\SpecialChar ~

\emph default 

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

, sem explicações do seu propósito).
\layout Standard

Os outros dois parâmetros, 
\family typewriter 
count
\family default 
 e 
\family typewriter 
offset
\family default 
, são necessários devido às diferentes formas que as informações que eles
 representam são obtidas nos dois contextos onde esta função é usada.
 Nos outros plugins, podemos obter a quantidade de elementos de entrada
 de forma uniforme (consultando o número de elementos da tupla em Python,
 por exemplo).
 Em Perl, nas duas situações onde a função é chamada, o número de elementos
 a serem lidos da pilha deve ser obtido de formas diferentes, e por isso
 o passamos como parâmetro 
\family typewriter 
count
\family default 
.
 Na rotina chamadora de funções LibScript, implementada no arquivo XS, o
 tamanho da pilha é obtido através de uma variável especial, 
\family typewriter 
items
\family default 
.
 Já na chamada de funções Perl, o valor de 
\family typewriter 
count
\family default 
 é obtido como retorno da função que realiza a invocação, 
\family typewriter 
Perl_call_pv
\family default 
.
 
\layout Standard

A posição inicial da pilha a partir da qual devemos obter os elementos (
\family typewriter 
offset
\family default 
) também varia.
 Dentro da função XS, os parâmetros de entrada começam a partir da posição
 2, pois LibScript passa o ponteiro do ambiente e o nome da função nos dois
 primeiros argumentos.
 Na chamada de funções Perl, o valor de 
\family typewriter 
offset
\family default 
 é zero pois, como visto no protocolo de chamada de funções Perl discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

, a base da pilha é ajustada após a chamada da função pela macro 
\family typewriter 
SPAGAIN
\family default 
.
 
\layout Standard

A conversão de valores do buffer LibScript para a pilha de Perl é dada em
 duas funções, uma que gera um único SV e outra que empilha todos os elementos:
\layout LyX-Code


\size footnotesize 
SV* script_perl_get_sv(pTHX_ script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE: return newSVnv(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* 0 indica que o tamanho da string deve ser calculado por Perl.
 */
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING: return newSVpv(script_get_string(env, i), 0);
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL: return newSViv(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
  
\newline 
SV** script_perl_buffer_to_stack(pTHX_ SV** sp, script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      XPUSHs(sv_2mortal(script_perl_get_sv(aTHX_ env, i)));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return sp;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Novamente, uma variável criada internamente por Perl teve que ser propagada
 explicitamente: 
\family typewriter 
sp
\family default 
, o 
\emph on 
stack pointer
\emph default 
.
 Esta variável é referenciada internamente pela macro 
\family typewriter 
xPUSHs
\family default 
.
 Além disso, como 
\family typewriter 
XPUSHs
\family default 
 pode redimensionar a pilha, precisamos retornar o valor atualizado de 
\family typewriter 
sp
\family default 
 de volta para o chamador.
 No mais, a geração de 
\family typewriter 
SV
\family default 
s, o registro destes como variáveis mortais e o seu empilhamento ocorre
 da forma usual, já apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
\layout Standard

Assim como nos demais plugins, a passagem de parâmetros de entrada em LibScript-
Perl, tanto para a chamada de funções Perl como de funções via LibScript,
 é feita chamando a função de conversão que opera sobre o buffer como um
 todo: na chamada de funções Perl usamos 
\family typewriter 
script_perl_buffer_to_stack
\family default 
 e na de funções via LibScript, 
\family typewriter 
script_perl_stack_to_buffer
\family default 
.
 Para tratar os valores de retorno de funções Perl, pudemos utilizar diretamente
 a função 
\family typewriter 
script_perl_stack_to_buffer
\family default 
, de forma similar à realizada em LibScript-Lua.
 Para o retorno de funções chamadas via LibScript, porém, precisamos lidar
 com a variável especial 
\family typewriter 
RETVAL
\family default 
 de XS e com os diferentes contextos de chamada de Perl.
 O trecho abaixo ilustra o tratamento de valores de retorno neste caso:
\layout LyX-Code


\size footnotesize 
err = script_call(env, function_name);
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (tratamento de erro omitido) ...
 */
\layout LyX-Code


\size footnotesize 
switch (GIMME_V) {
\layout LyX-Code


\size footnotesize 
case G_SCALAR:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna o primeiro item do buffer */
\layout LyX-Code


\size footnotesize 
   RETVAL = script_perl_get_sv(aTHX_ env, 0);
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_ARRAY:
\layout LyX-Code


\size footnotesize 
   len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um array */
\layout LyX-Code


\size footnotesize 
   RETVAL = (SV*)newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Arrays retornados devem ser marcados como mortais */
\layout LyX-Code


\size footnotesize 
   sv_2mortal((SV*)RETVAL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Insere o conteúdo do buffer no array */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++)
\layout LyX-Code


\size footnotesize 
      av_push((AV*)RETVAL, script_perl_get_sv(aTHX_ env, i));
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_VOID:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O valor de retorno é descartado em contextos void.
 */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retornamos então a constante Perl undef.
 */
\layout LyX-Code


\size footnotesize 
   RETVAL = &PL_sv_undef;
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
}
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Chamada de funções
\layout Standard

Nos plugins de LibScript, funções implementadas externamente (em C ou outros
 plugins) são localizadas somente no momento em que elas são chamadas.
 O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória no ambiente de execução da linguagem de script (ao evitar a declaração
 de funções que não serão utilizadas), é permitir a localização de funções
 declaradas após a inicialização do ambiente.
 Para permitir esta resolução de funções de forma dinâmica, é preciso capturar
 o acesso a elementos inexistentes na estrutura que descreve o ambiente
 virtual no plugin e encaminhar a chamada à biblioteca principal via 
\family typewriter 
script_call
\family default 
.
 Ao comparar as abordagens empregadas em cada plugin para obter tal comportament
o, podemos avaliar alguns recursos de meta-programação oferecidos por cada
 linguagem e a sua disponibilidade através das suas APIs.
\layout Standard

Como vimos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, em Lua, durante a inicialização do plugin, é criada uma tabela armazenada
 em uma variável global com o nome do ambiente.
 Funções são inseridas dinamicamente nesta tabela através da metatabela
 associada a ela logo após a sua criação em 
\family typewriter 
script_plugin_init_lua
\family default 
.
 O campo 
\family typewriter 
__index
\family default 
 da metatabela aponta para uma função\SpecialChar ~
C interna ao plugin, 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, que é então invocada sempre que um elemento inexistente for solicitado
 na tabela.
 A função 
\family typewriter 
script_lua_make_caller
\family default 
 cria uma 
\emph on 
closure
\emph default 
\SpecialChar ~
C, que consiste de outra função\SpecialChar ~
C interna ao plugin (
\family typewriter 
script_lua_caller
\family default 
) e o nome da função solicitada.
 Esta closure é associada à entrada da tabela do ambiente.
 Assim, chamadas a funções implementadas externamente serão resolvidas por
 
\family typewriter 
script_lua_caller
\family default 
, que as passará adiante para 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Python, ao chamar uma função no módulo do ambiente virtual, o
 
\emph on 
callback
\emph default 
 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_python_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 cria um objeto do tipo 
\family typewriter 
script_python_object
\family default 
, e o retorna como resultado de 
\family typewriter 
__getattro
\family default 
.
 Este tipo de dado é declarado no plugin como uma classe Python, cujas instância
s contêm um ponteiro para o ambiente virtual e uma string C com o nome da
 função que eles representam.
 Estes objetos possuem o seu 
\emph on 
callback
\emph default 
 
\family typewriter 
__call
\family default 
 definido como 
\family typewriter 
script_python_caller
\family default 
, uma função que, assim como 
\family typewriter 
script_lua_caller
\family default 
, converte os parâmetros recebidos para o buffer de LibScript, invoca 
\family typewriter 
script_call
\family default 
 e converte os valores de retorno de volta a Python.
 Assim, objetos deste tipo são 
\emph on 
functors
\emph default 
, e se comportam de forma similar à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
\layout Standard

A resolução de funções sob demanda em Ruby é implementada utilizando o método
 
\family typewriter 
method_missing
\family default 
, que é um fallback definido pela linguagem, chamado sempre que um método
 inexistente é invocado em uma classe.
 Diferentemente de 
\family typewriter 
__getattro
\family default 
 em Python e 
\family typewriter 
__index
\family default 
 em Lua, que são tratadores de acesso a atributos e portanto precisam retornar
 um objeto que é chamado em um passo seguinte, o método 
\family typewriter 
method_missing
\family default 
 trata chamadas diretamente.
 Assim, ao ser invocado, 
\family typewriter 
method_missing
\family default 
 recebe o nome do método solicitado e os parâmetros passados e os encaminha
 para a função 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Perl, como em Lua e Python, também há uma função C responsável
 por realizar a conversão de parâmetros e valores de retorno a invocação
 de 
\family typewriter 
script_call
\family default 
.
 Esta função, 
\family typewriter 
script_perl_caller
\family default 
, para que possa ser exposta ao interpretador Perl, é implementada em um
 módulo XS.
 Uma vez carregado o módulo, a função é visível em Perl como a função 
\family typewriter 
LibScript::caller
\family default 
.
 A resolução dinâmica de funções do pacote Perl que representa o ambiente
 virtual é feita usando a função 
\family typewriter 
AUTOLOAD
\family default 
 de Perl, que se comporta como 
\family typewriter 
method_missing
\family default 
 em Ruby, capturando chamadas a funções inexistentes.
 Na função de inicialização do plugin, código Perl é executado para carregar
 o módulo de extensão, inicializar o pacote do ambiente e inserir nele uma
 função 
\family typewriter 
AUTOLOAD
\family default 
 que chamará 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
   "bootstrap LibScript;"   
\emph on 
/* Inicializa o módulo de extensão */
\layout LyX-Code


\size footnotesize 
   "package %s;" 
\emph on 
           /* Declara o pacote do ambiente */
\layout LyX-Code


\size footnotesize 
   "$LibScript::env = %p;"  
\emph on 
/* Armazena o ponteiro do ambiente em Perl */
\layout LyX-Code


\size footnotesize 
   "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
      "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Extrai o nome do método do nome qualificado 
\begin_inset Quotes eld
\end_inset 

pacote::método
\begin_inset Quotes erd
\end_inset 

 */
\layout LyX-Code


\size footnotesize 
      "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Invoca caller passando o endereço do ambiente, */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o nome do método, e o array de argumentos */
\layout LyX-Code


\size footnotesize 
\emph on 
      
\emph default 
"LibScript::caller(%p, $AUTOLOAD, @_);"  
\layout LyX-Code


\size footnotesize 
   "}",
\layout LyX-Code


\size footnotesize 
   state->package, env, env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Avalia a string de código;
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indica que erros devem ser sinalizados.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Subsection

Captura de erros
\begin_inset LatexCommand \label{sub:Captura-de-erros}

\end_inset 


\layout Standard

Os plugins devem capturar a ocorrência de erros na execução de strings de
 código e em chamadas de função.
 Em Lua, ambas as operações são realizadas usando a função 
\family typewriter 
lua_pcall
\family default 
, cujo valor de retorno indica a ocorrência de erros.
 No caso de erros, a mensagem de erro é obtida no topo da pilha virtual
 de Lua e propagada para a biblioteca principal usando 
\family typewriter 
script_set_error_message
\family default 
.
 No caso da execução de strings de código, erros de compilação são detectados
 através do valor de retorno da função 
\family typewriter 
luaL_loadstring
\family default 
, que carrega o código a ser executado por 
\family typewriter 
lua_pcall
\family default 
.
\layout Standard

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno das
 funções de execução de strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, e de chamada de funções, 
\family typewriter 
PyEval_CallObject
\family default 
.
 No caso de erros, chamamos a função 
\family typewriter 
PyErr_Occurred
\family default 
, que retorna um objeto Python representando a exceção.
 A mensagem de erro é obtida convertendo este objeto para uma string Python
 usando 
\family typewriter 
PyObject_Str
\family default 
, e finalmente para uma string C com 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

Em Perl, erros são sinalizados na variável especial 
\family typewriter 
$@
\family default 
, cujo conteúdo pode ser verificado através da API de C com a macro 
\family typewriter 
ERRSV
\family default 
.
 O teste para ocorrência de erros é 
\family typewriter 
SvTRUE(ERRSV)
\family default 
, e a mensagem de erro pode ser obtida convertendo esta variável para uma
 string C com a macro 
\family typewriter 
SvPV
\family default 
.
\layout Standard

Ruby disponibiliza uma função para execução de strings de código, 
\family typewriter 
rb_eval_string
\family default 
, e uma versão desta que captura erros e sinaliza a sua ocorrência através
 do valor de retorno, 
\family typewriter 
rb_eval_string_protect
\family default 
.
 Entretanto, para chamadas de método, não há uma versão protegida da função
 
\family typewriter 
rb_funcall
\family default 
.
 A função disponibilizada pela API para proteger chamadas, 
\family typewriter 
rb_protect
\family default 
, não recebe como parâmetro um método Ruby, mas sim uma função\SpecialChar ~
C.
 Para chamar métodos Ruby de forma protegida, precisamos escrever uma função
 C que encapsula a chamada:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_pcall(VALUE args) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai nome do método do array de argumentos */
\layout LyX-Code


\size footnotesize 
   ID fn_id = SYM2ID(rb_ary_pop(args)); 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai a classe do array de argumentos */
\layout LyX-Code


\size footnotesize 
   VALUE klass = rb_ary_pop(args);
\layout LyX-Code


\size footnotesize 
   return rb_apply(klass, fn_id, args);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

e então invocá-la usando 
\family typewriter 
rb_protect
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere a classe no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, klass);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere o nome do método no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, ID2SYM(rb_intern(fn)));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Chama a função wrapper */
\layout LyX-Code


\size footnotesize 
ret = rb_protect(script_ruby_pcall, args, &error); 
\layout LyX-Code


\size footnotesize 
if (error) {
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   script_set_error_message(env, StringValuePtr(ruby_errinfo));
\layout LyX-Code


\size footnotesize 
   ruby_errinfo = Qnil;
\layout LyX-Code


\size footnotesize 
   return SCRIPT_ERRLANGRUN;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como a função 
\family typewriter 
rb_protect
\family default 
 passa apenas um 
\family typewriter 
VALUE
\family default 
 para a função C, precisamos armazenar a classe, o identificador do método
 e os parâmetros de entrada do método Ruby a ser invocado em um array Ruby.
 A ocorrência de erros é sinalizada em uma variável passada no terceiro
 parâmetro de 
\family typewriter 
rb_protect
\family default 
, e a mensagem de erro é obtida no 
\family typewriter 
VALUE
\family default 
 global 
\family typewriter 
ruby_errinfo
\family default 
.
\layout Section

Conclusões
\layout Standard

O estudo de caso apresentado aqui ilustrou, através da implementação dos
 plugins, o processo de embutir quatro linguagens de script realizando interface
 com uma mesma API C.
 Diversos aspectos da interação entre C e as linguagens de script foram
 abordados, contemplando inicialização e encerramento do ambiente de execução,
 passagem de dados e chamadas de função nos dois sentidos e a sinalização
 de erros.
 A partir disto, podemos fazer algumas observações sobre a adequabilidade
 destas linguagens como ambientes embutidos em aplicações.
\layout Standard

Em muitas aplicações é importante que haja isolamento entre os scripts executado
s, como por exemplo, em scripts de diferentes clientes rodando em um servidor
 web.
 Como vimos, Lua e Perl permitem disparar múltiplos ambientes de execução,
 o que garante isolamento.
 Já Python e Ruby permitem apenas um estado, reduzindo sua aplicabilidade
 para cenários onde os scripts devem executar isolados uns dos outros
\begin_inset Foot
collapsed true

\layout Standard

Em Python é possível alternar a tabela de globais durante a execução de
 diferentes threads, o que oferece uma alternativa, um tanto mais trabalhosa,
 para obter isolamento.
 Ainda assim, o estado global compartilhado por módulos de extensão é o
 mesmo.
 
\end_inset 

.
 Estas duas linguagens trazem ainda outro problema: em alguns casos não
 é possível trazer o seu espaço de dados de volta ao estado original durante
 a execução de uma aplicação.
 Em Python, módulos importados não podem ser descarregados.
 Em Ruby, uma classe não pode ser redefinida (somente estendida) e 
\family typewriter 
ID
\family default 
s não são coletados.
\layout Standard

Na implementação do plugin de Perl fica evidente que a sua API não foi projetada
 visando embutir o interpretador em aplicações.
 Além de exigir o desenvolvimento de um módulo de extensão para que o código
 Perl possa ter acesso a funções C, observamos aqui que a sua API é incompleta
 no que diz respeito ao seu uso como linguagem embutida.
 Muitas macros foram desenvolvidas assumindo que seriam sempre invocadas
 a partir de código escrito em arquivos XS, ou mesmo por código gerado pelo
 pré-processador XS.
 Isto é confirmado pela necessidade de passar parâmetros adicionais não-document
ados para que as macros funcionem, como pôde ser observado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

.
\layout Standard

Lua, por sua vez, mostrou-se apropriada como linguagem embutida, não compartilha
ndo das limitações aqui descritas sobre as outras linguagens.
 Além disso, ela possui uma API simples, que trata as construções da linguagem
 de forma completa e ortogonal, o que se deve tanto ao foco da implementação
 de Lua como linguagem embutida, quanto ao projeto minimalista da linguagem
 em si.
 Mesmo em exemplos pequenos como os apresentados aqui, que exercitam apenas
 uma parte pequena das APIs, podemos observar que aspectos onde as linguagens
 definem tratamentos especiais ou possuem menor uniformidade transparecem
 nas APIs para C.
 Tanto em Python como em Ruby, funções que retornam múltiplos valores geram
 conversões implícitas para tipos agregados (listas e arrays).
 De forma similar, múltiplos retornos são representados em Perl através
 de contextos do tipo array.
 Nos seus respectivos plugins LibScript, estas características tiveram que
 ser tratadas de forma especial.
 No plugin Lua, em contraste, o tratamento para um valor único de retorno
 é igual ao de valores múltiplos, assim como ocorre na linguagem.
 
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Conclusões
\layout Standard

A escolha de uma linguagem de script depende de uma série de fatores, varios
 deles relativos à linguagem em si, outros relativos à sua implementação.
 Quando lidamos com cenários de desenvolvimento multi-linguagem, um aspecto
 que não deve ser negligenciado é o projeto das interfaces entre as linguagens.
 Seja estendendo a linguagem de script através de código C, ou tornando
 uma aplicação C extensível através de uma linguagem de script, a API oferecida
 pela linguagem tem um papel fundamental, muitas vezes influenciando o projeto
 da aplicação.
\layout Standard

Este trabalho traçou um panorama dos problemas gerais enfrentados na interação
 entre código C e o ambiente de execução de uma linguagem de script.
 Apresentamos as formas como as APIs de cinco linguagens tratam estes problemas,
 apontando pontos positivos e negativos das diferentes abordagens utilizadas.
 Realizamos uma comparação prática do uso destas APIs através de um estudo
 de caso onde as linguagens de script foram embutidas em bibliotecas C exportand
o uma mesma interface.
 A implementação consiste de uma biblioteca genérica para scripting, chamada
 LibScript, e uma série de plugins que realizam a interface com as diferentes
 linguagens.
 Pudemos assim observar como elas tratam aspectos importantes relativos
 a linguagens embutidas, como a passagem de dados, chamadas de funções entre
 as duas linguagens, tratamento de erros e o isolamento dos ambientes de
 execução em aplicações.
\layout Standard

Embora os mesmos problemas gerais, como transferência de dados, registro
 e chamada de funções, sejam comuns aos diferentes cenários de uso de uma
 API de linguagem de script, aplicações embutindo uma máquina virtual tendem
 a demandar mais da API do que bibliotecas implementando módulos de extensão.
 Este ponto é ilustrado pelas dificuldades impostas pela API de Python tanto
 no acesso a variáveis como no registro de funções globais; e principalmente
 pela complexidade da API de chamada de funções de Perl.
\layout Standard

O fato de que a API de Python dificulta o uso de variáveis e funções globais,
 favorecendo o uso de módulos, pode ser justificado como uma forma de promover
 um modelo de programação mais estruturada.
 Isto é interessante para o uso da API no desenvolvimento de módulos de
 extensão, uma vez que o uso de variáveis e funções globais é extremamente
 prejudicial nestes casos, já que poluiria o espaço de nomes das aplicações
 Python.
 Já para o caso onde a linguagem é embutida para prover suporte à execução
 de scripts em uma aplicação C, a ausência de uma forma conveniente para
 definir funções globais no espaço de nomes dos scripts é questionável.
\layout Standard

A abordagem empregada por Perl, usando um pré-processador com o objetivo
 de gerar automaticamente o código para a conversão de dados na passagem
 de parâmetros e valores de retorno, se mostrou inadequada para o cenário
 envolvendo interpretadores embutidos.
 Embora o uso do pré-processador simplifique os casos simples de declaração
 de funções C, a falta de uma API bem definida para tratar a transferência
 de dados entre o interpretador Perl e o código C se faz perceber nos casos
 mais elaborados.
 Duas destas situações se fizeram presentes no estudo de caso: o recebimento
 de parâmetros 
\emph on 
varargs
\emph default 
 e a passagem de valores de retorno tratando múltiplos contextos de execução.
 Ambas exigiram manipulações de estruturas e construções de mais baixo nível,
 que o pré-processador tem por objetivo ocultar.
\layout Standard

Observações interessantes resultaram da comparação da API de Java com a
 das demais quatro linguagens de script, uma vez que, embora possua diversas
 características em comum com estas linguagens, Java não seja considerada
 uma linguagem de script.
 Enquanto a tipagem estática reduz bastante a necessidade de conversões
 de dados explícitas no código C para tipos primitivos da linguagem, na
 prática a verificação de tipos para objetos e a ligação de campos e métodos
 acontece de forma dinâmica, já que estes têm que ser realizados em tempo
 de execução pela JNI.
 Assim, no contexto da interação de uma máquina virtual com código C, as
 vantagens trazidas pela tipagem estática são reduzidas.
 Além disso, a resolução dinâmica de campos e métodos faz com que a manipulação
 de objetos via C tenha diferenças sutis de comportamento em relação ao
 que ocorre em código Java, o que pode ser uma fonte de erros do programador.
\layout Standard

Ao comparar as APIs, consideramos apenas as suas interfaces, fazendo uma
 análise qualitativa da usabilidade de cada uma da perspectiva do programador
 C, e não uma análise quantitativa das suas implementações.
 O custo de desempenho adicionado pelo código que realiza a ligação entre
 duas linguagens, por exemplo, não pode ser desprezado.
 Muitas decisões de projeto de uma API são influenciadas por requisitos
 da implementação como restrições de portabilidade ou desempenho.
 Por exemplo, o tratamento automático de controle de escopo de 
\family typewriter 
VALUE
\family default 
s em Ruby, varrendo a pilha de C, traz grande conveniência para o programador,
 mas reduz a portabilidade da implementação.
\layout Standard

Merece comentário também a disparidade entre as linguagens no que concerne
 à disponibilidade de documentação.
 Java, Python e Lua possuem extensa documentação, tanto para a linguagem
 como para as suas APIs para C.
 Para estas linguagens, pudemos basear largamente nosso estudo e a implementação
 dos exemplos para o estudo de caso na documentação fornecida.
 A documentação de Ruby relativa à sua API de C é mais escassa; em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 é coberta apenas parte da API pública.
 Precisamos fazer uso de funções não documentadas para tarefas fundamentais
 como liberar referências globais registradas via C.
 Durante o desenvolvimento do plugin Ruby no estudo de caso, consultamos
 freqüentemente o código-fonte de Ruby para compreender os aspectos que
 não são cobertos pela documentação do comportamento das suas funções públicas.
 A documentação da API de C de Perl também é incompleta, espalhada através
 de diversas 
\emph on 
man pages
\emph default 
 incluídas na sua distribuição e em certos casos desatualizada.
 Para compreender os diversos protocolos envolvidos no uso prático da API
 de Perl, precisamos recorrer ao código-fonte de aplicações que fazem uso
 dela.
\layout Standard

O equilíbrio entre simplicidade e conveniência é outro tema recorrente ao
 compararmos as APIs.
 A extensa API de Python, contendo 656 funções públicas, contrasta com as
 113 funções expostas pela API de Lua (79 na API 
\emph on 
core
\emph default 
, 34 na API auxiliar).
 Em diversas situações, funções na API de Python abreviam duas, três ou
 até mais chamadas, como no caso de funções poderosas como 
\family typewriter 
Py_BuildValue
\family default 
 e 
\family typewriter 
PyObject_CallFunction
\family default 
, tornando o código C sucinto e legível.
 A abordagem defendida por Lua é a de uma API minimalista, oferecendo mecanismos
 sobre os quais funcionalidades mais elaboradas possam ser construídas.
 De fato, em\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 é apresentada uma função C equivalente a 
\family typewriter 
PyObject_CallFunction
\family default 
 usando a API de Lua.
\layout Standard

Ruby exporta 530 funções em seu cabeçalho e Perl 1209, mas como apenas uma
 pequena fração destas é documentada, torna-se difícil avaliar o tamanho
 da 
\begin_inset Quotes eld
\end_inset 

API pública
\begin_inset Quotes erd
\end_inset 

 destas linguagens e quantas destas são apenas funções para uso interno
 expostas nos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

Algumas funções são marcadas como sendo de uso interno, mas a maioria não
 possui qualquer indicação.
\end_inset 

.
 Isto mostra também que a documentação não é relevante apenas enquanto material
 de apoio para o desenvolvimento, mas também indica o quão bem definida
 é uma API.
\layout Standard

A API de Java é bem documentada como a de Python e Lua, mas o número de
 funções exportadas não é um bom parâmetro para comparações com as demais
 APIs porque, em função dos tipos estaticamente definidos, muitas funções
 possuem uma variante para cada tipo primitivo.
 Java exporta sua API como uma estrutura contendo ponteiros para função;
 228 funções ao todo são exportadas nesta estrutura.
\layout Standard

Outro aspecto que pôde ser observado neste trabalho é que a consistência
 da API depende largamente da consistência da linguagem que ela expõe.
 Construções onde a linguagem tem pouca ortogonalidade, como o tratamento
 de blocos em Ruby ou as diferenças nos tratamentos de valores escalares
 e arrays em Perl, acabam por aumentar a complexidade da API da linguagem
 e demandam tratamento específico por parte do programador no código C.
\layout Standard

Como possibilidades de trabalhos futuros, este trabalho pode ser estendido
 através do estudo de outros aspectos de APIs de linguagens de script.
 Um foco possível é o impacto de desempenho de diferentes projetos de API
 em aplicações multi-linguagem.
 Outro é a relação entre o projeto de uma máquina virtual e o de sua respectiva
 API.
 Além disso, outra perspectiva de trabalho é a continuação do desenvolvimento
 da biblioteca LibScript.
 Possibilidades incluem adicionar novos plugins, revisar a sua API e exercitá-la
 embutindo a biblioteca em aplicações reais.
 LibScript e os quatro plugins implementados são software livre e estão
 disponíveis para download em\SpecialChar ~

\begin_inset LatexCommand \url{http://libscript.sourceforge.net}

\end_inset 

.
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{dissert}

\end_inset 


\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

API de LibScript
\layout Section

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ponteiro para o ambiente virtual.
 O parâmetro 
\family typewriter 
namespace
\family default 
 indica o nome a ser usado nas estruturas a serem criadas no espaço de nomes
 das máquinas virtuais para representar o ambiente virtual.
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente virtual.
\layout Section

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo das funções C a serem registradas no ambiente virtual.
 Ao expor uma API existente para LibScript, a função tipicamente será uma
 função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente virtual.
\layout Section

Buffer de parâmetros
\layout Itemize


\family typewriter 
double script_get_double(script_env* env, int index)
\newline 
int script_get_int(script_env* env, int index)
\newline 
int script_get_bool(script_env* env, int index)
\newline 
const char* script_get_string(script_env* env, int index)
\family default 

\newline 
Obtêm dados do buffer.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_get_string
\family default 
, a string retornada pertence ao chamador, que passa a ser responsável por
 desalocá-la.
\layout Itemize


\family typewriter 
script_type script_get_type(script_env* env, int index)
\newline 
int script_buffer_len(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_get_type
\family default 
 obtém o tipo do elemento do buffer solicitado e 
\family typewriter 
script_buffer_len
\family default 
 retorna o número de parâmetros no buffer.
\layout Itemize


\family typewriter 
void script_put_double(script_env* env, int index, double value)
\newline 
void script_put_int(script_env* env, int index, int value)
\newline 
void script_put_bool(script_env* env, int index, int value)
\newline 
void script_put_string(script_env* env, int index, const char* value)
\newline 

\family default 
Inserem dados no buffer.
 Ao final de uma função, os valores de retorno devem ser passados com chamadas
 a estas funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Itemize


\family typewriter 
void script_reset_buffer(script_env* env)
\family default 

\newline 
Esvazia o buffer.
\layout Section

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_put_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_get_*
\family default 
.
 Inicialmente, a tabela de funções C do ambiente virtual é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas na representação do ambiente virtual definido para
 a LibScript na máquina virtual da linguagem (isto é, no nome criado com
 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\newline 
void script_set_error_message(script_env* env, const char* message)
\newline 

\family default 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
 A função 
\family typewriter 
script_set_error_message
\family default 
 define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente virtual deve ser
 exposto à máquina virtual de alguma forma apropriada para a linguagem (como
 uma tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 O estado da máquina virtual e o ponteiro para o ambiente LibScript devem
 ser armazenados de modo a ser posteriormente acessíveis a partir deste
 handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_get_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_put_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\the_end
