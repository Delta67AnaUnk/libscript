#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{indentfirst}
\end_preamble
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize a4paper
\paperpackage widemarginsa4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Comment


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Comment


\backslash 
autor{Hisham H.
 Muhammad}
\layout Comment


\backslash 
autorR{Muhammad, Hisham H.}
\layout Comment


\backslash 
orientador{Roberto Ierusalimschy}
\layout Comment


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Comment


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Comment


\backslash 
cidade{Rio de Janeiro}
\layout Comment


\backslash 
departamento{Informática}
\layout Comment


\backslash 
programa{Informática}
\layout Comment


\backslash 
centro{Centro Técnico Científico} 
\layout Title

Estudo sobre APIs de linguagens de script
\layout Author

Hisham H.
 Muhammad
\layout Standard
\added_space_top bigskip \added_space_bottom bigskip \align center 
Resumo
\layout Standard

Um cenário comum atualmente é o de aplicações desenvolvidas usando duas
 linguagens de programação a fim de otimizar partes onde o desempenho é
 crítico e permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
 Há várias formas de se obter esse tipo de interoperabilidade; idealmente,
 entretanto, uma linguagem deve prover uma interface de acesso externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem.
 
\layout Standard

Este trabalho discute as principais questões envolvendo o projeto de APIs
 para integração de ambientes de execução de linguagens em aplicações C.
 Apresentamos os principais problemas enfrentados na interação entre código
 executando em um ambiente com características inerentemente dinâmicas como
 o de uma linguagem de script com código C.
 Comparamos aqui as abordagens empregadas por cinco linguagens no tratamento
 da comunicação entre os espaços de dados de C e do ambiente de execução
 embutido e as conseqüências destas abordagens no gerenciamento de memória,
 bem como no compartilhamento de código entre a aplicação C e o da linguagem
 de script.
 
\layout Standard

Ilustramos as diferenças das APIs destas linguagens e o impacto destas no
 código resultante de uma aplicação C através de um estudo de caso.
 Diferentes linguagens de script são embutidas como plugins de uma mesma
 biblioteca, que por sua vez expõe a aplicações clientes uma API genérica
 de scripting.
 Assim, o código de cada plugin permite observar de forma clara e isolada
 os procedimentos adotados em cada linguagem para chamada de funções, registro
 de funções C e conversão de dados entre os ambientes.
\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
pagebreak
\end_inset 


\layout Standard
\added_space_top bigskip \added_space_bottom bigskip \align center 

\lang english
Abstract
\layout Standard


\lang english
Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard


\lang english
This work discusses the main issues involving the design of APIs for the
 integration of language environments within C applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C application and that from the scripting language.
\layout Standard


\lang english
We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C functions and conversion of data between the environments.
\layout Chapter

Introdução
\layout Comment


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Comment


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\layout Standard

Existem muitas situações onde é necessário ou interessante que haja interação
 entre programas escritos em diferentes linguagens.
 Um caso típico é o emprego de bibliotecas externas, como 
\emph on 
toolkits
\emph default 
 gráficos, APIs de acesso a banco de dados, ou até mesmo chamadas ao sistema
 operacional.
 Outro cenário ainda envolve aplicações desenvolvidas usando mais de uma
 linguagem de programação a fim de otimizar partes onde o desempenho é crítico
 ou permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
\layout Standard

Independentemente da finalidade, a comunicação entre programas escritos
 em linguagens diferentes traz consigo uma série de questões de projeto,
 não apenas no desenvolvimento das aplicações, mas das linguagens em si.
 Há várias formas de se obter esse tipo de interoperabilidade, desde tradução
 de código de uma linguagem para outra até o uso de uma máquina virtual
 comum.
 Idealmente, entretanto, uma linguagem deve prover uma interface de acesso
 externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem 
\begin_inset LatexCommand \cite{finne-fli}

\end_inset 

.
 Entre os fatores que devem ser levados em consideração no desenvolvimento
 de tal interface estão as diferenças entre os sistemas de tipos, problemas
 de gerência de memória (como coleta de lixo e acesso direto a ponteiros)
 e modelos de concorrência.
 Além de lidar com diferenças semânticas, o projeto de uma interface envolve
 questões pragmáticas como o equilíbrio entre o isolamento seguro dos ambientes
 de execução, o desempenho e a simplicidade da API resultante.
\layout Standard

Pode-se observar nas implementações existentes de FLIs um número de abordagens
 para estes problemas.
 De fato, FLIs de diferentes linguagens (ou mesmo de diferentes revisões
 de uma mesma linguagem) tendem a ser bastante distintas entre si.
 Ainda assim é possível traçar paralelos entre as técnicas utilizadas, uma
 vez que os problemas fundamentais que elas atacam são os mesmos.
 Além disso, em função da popularidade da linguagem C e do suporte oferecido
 a ela pelos sistemas operacionais mais utilizados, grande parte das implementaç
ões de interfaces de acesso externo são, na prática, APIs para C, o que
 também facilita a sua comparação.
 Adicionalmente, C se tornou também uma popular 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 na interação entre FLIs.
\layout Section

Objetivo
\layout Standard

Este trabalho realiza, a partir da pesquisa de implementações de FLIs, um
 estudo e comparação de interfaces entre diferentes linguagens de programação.
 Partindo de uma análise das abordagens gerais para interação entre linguagens,
 o estudo é baseado na análise de um conjunto de interfaces com C providas
 por linguagens de script.
 Além de se tratar da classe de linguagens mais popular atualmente para
 desenvolvimento multi-linguagem, características típicas de linguagens
 de script como coleta de lixo e tipagem dinâmica, por não estarem presentes
 em C, ilustram bem os problemas envolvendo a comunicação de dados entre
 diferentes ambientes de programação.
 Linguagens com tipagem estática podem apresentar necessidades de conversão
 de tipos semelhantes, mas o problema tende a ser simplificado pela definição
 de tipos equivalentes na API e inferência em tempo de compilação (vide
 exemplos nas API com C de Ada e Fortran).
 Linguagens funcionais possuem preocupações adicionais com efeitos colaterais
 no código C, mas isto é equivalente ao problema de quebra do paradigma
 causada tratamento de entrada e saída que todas elas enfrentam.
\layout Standard

O estudo consiste da análise em profundidade de um conjunto de FLIs -- especific
amente, Python, Perl 
\begin_inset LatexCommand \cite{wall-perl}

\end_inset 

, Ruby 
\begin_inset LatexCommand \cite{thomas-ruby}

\end_inset 

, Lua 
\begin_inset LatexCommand \cite{lua}

\end_inset 

 e Java 
\begin_inset LatexCommand \cite{gosling-java}

\end_inset 

 -- e um estudo de caso onde estas FLIs são exercitadas em tarefas semelhantes.
 Diferentemente das demais, Java possui tipagem estática, mas com a sua
 biblioteca de reflexão, que oferece recursos de intercessão como carga
 de classes em tempo de execução e invocação dinâmica de métodos, é possível
 encará-la, para os fins de interação com código C, como uma linguagem dinâmica.
\layout Comment


\emph on 
\color red
[TODO: Continuar essa seção, botar um 
\begin_inset Quotes eld
\end_inset 

fecho
\begin_inset Quotes erd
\end_inset 

 na coisa.]
\layout Section

Estrutura do Texto
\layout Standard

O trabalho está organizado da seguinte forma.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, é dada uma visão geral sobre as várias abordagens para interação entre
 código escrito em diferentes linguagens de progamação.
 A partir daí, o foco se concentra no método de interface externa mais comum
 nas linguagens da atualidade: interfaces com a linguagem C.
 São abordados no Capítulo 
\begin_inset LatexCommand \ref{cha:Interfaces-com-C}

\end_inset 

 os problemas comumente envolvidos na comunicação com código escrito em
 C.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

 são apresentadas em detalhe APIs para C de um conjunto de linguagens de
 script.
 Ao discutir estas interfaces, as diferentes soluções empregadas para os
 problemas levantados no capítulo anterior são comparadas.
 O Capítulo 
\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercita estas diferentes APIs através de um estudo de caso: uma biblioteca
 baseada em plugins que oferece uma interface uniforme simplificada entre
 linguagens de script e C.
 Ao examinar a implementação de cada plugin, podemos comparar as APIs de
 cada linguagem realizando operações equivalentes.
 Finalmente, no Capítulo 
\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

, são apresentadas as conclusões do trabalho, bem como apontados caminhos
 para trabalhos futuros.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interação entre Linguagens de Programação
\layout Standard

As abordagens aplicadas na interação entre diferentes linguagens de programação
 variam bastante entre si, mas é possível identificar algumas técnicas tipicamen
te utilizadas: tradução de linguagens, seja de uma para outra ou de ambas
 para uma terceira; comunicação através de protocolo ou linguagem intermediária;
 compartilhamento de um ambiente de execução comum, seja de máquina virtual
 ou através de convenção de chamadas.
\layout Section

Tradução de Código
\layout Standard

Permitir o uso de duas linguagens diferentes em um programa traduzindo o
 código de uma delas para a outra minimiza o problema de comunicação entre
 as partes do programa escritas em linguagens diferentes, uma vez que o
 programa final utilizará um espaço único de dados.
 Em contrapartida, ao ter de se descrever uma linguagem em termos de outra,
 a diferença de semântica das construções pode se tornar um problema.
 Se a linguagem de destino não possui construções oferecidas pela linguagem
 de origem, simulá-las pode ser custoso.
\layout Standard

Um exemplo típico é a complexidade adicionada pela simulação de funções
 de alta ordem e recursão final ao traduzir-se o código de linguagens funcionais
 para outra que não possui estes recursos.
 Em 
\begin_inset LatexCommand \cite{tarditi92no}

\end_inset 

 é descrito o desenvolvimento de um tradutor de Standard ML para ANSI C.
 Medições evidenciaram o custo de adaptação destes recursos de ML para C,
 resultando em código em média 2 vezes mais lento que o gerado pelo compilador
 ML nativo.
 Em 
\begin_inset LatexCommand \cite{tolmach-from}

\end_inset 

, são discutidos desafios similares na tradução de ML para Ada: na solução
 adotada, o processo possui um passo intermediário onde as construções de
 alta ordem são 
\begin_inset Quotes eld
\end_inset 

aplainadas
\begin_inset Quotes erd
\end_inset 

 para construções de primeira ordem envolvendo registros, para que pudessem
 assim ser representados em Ada.
\layout Standard

Além de problemas como este, diferenças na representação dos dados ainda
 é algo a ser tratado no processo de tradução de uma linguagem para outra.
 No caso particular de C, as facilidades de baixo nível para manipulação
 de memória permitem a descrição de estruturas de dados de linguagens de
 mais alto nível sem maiores problemas.
 Isto faz de C uma candidata freqüente para uso como representação de baixo
 nível portável.
 O compilador de Haskell GHC oferece, como alternativa à geração de código
 nativo, geração de código C para uso com o GCC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 Uma das vantagens deste recurso é permitir o 
\emph on 
bootstrapping
\emph default 
 do compilador em novas arquiteturas, dado que o próprio GHC é escrito em
 Haskell.
 De fato, a ubiqüitude dos compiladores C faz com que a linguagem seja utilizada
 também como 
\emph on 
lingua franca
\emph default 
 entre diferentes linguagens, como será visto na Seção 
\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Compartilhamento de Máquinas Virtuais
\layout Standard

Outra abordagem envolve o uso de um ambiente de execução comum, como uma
 máquina virtual.
 O código das diferentes linguagens é compilado de modo a produzir representaçõe
s compatíveis entre si, de acordo com os tipos de dados oferecidos pelo
 ambiente de execução.
 Diversas implementações utilizam a Java Virtual Machine 
\begin_inset LatexCommand \cite{gosling-java}

\end_inset 

 com essa finalidade.
 Jython 
\begin_inset LatexCommand \cite{hugunin-jython}

\end_inset 

 é uma implementação da linguagem Python 
\begin_inset LatexCommand \cite{lutz-python}

\end_inset 

 que produz bytecodes Java.
 SMLj 
\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 é um compilador Standard ML que gera bytecodes Java e permite acesso de
 classes e métodos Java a estruturas e funções ML e vice-versa.
 O fato da Java Virtual Machine não ter sido projetada para comportar diferentes
 linguagens de programação, entretanto, transparece nas limitações apresentadas
 por estes projetos.
 SMLj define extensões à linguagem ML para permitir acesso a construções
 específicas de Java; Jython possui limitações ao realizar a interface de
 Python com a API de reflexão e carga dinâmica de classes de Java.
 Além disso, o conjunto de instruções da máquina virtual privilegia operações
 que condizem com a semântica de Java, tornando, por exemplo, implementações
 de 
\emph on 
arrays
\emph default 
 com semântica diferente menos eficientes.
\layout Standard

O .NET Framework 
\begin_inset LatexCommand \cite{box-net}

\end_inset 

 é um ambiente de execução baseado em máquina virtual que vem sendo indicado
 pela Microsoft como plataforma de programação preferencial em sistemas
 Windows.
 Apesar de com ele ter sido introduzida a linguagem C# 
\begin_inset LatexCommand \cite{hejlsberg-csharp}

\end_inset 

, o ambiente tem como um de seus objetivos oferecer suporte a múltiplas
 linguagens---evidenciado pelo próprio nome Common Language Runtime (CLR)---em
 contraste com as limitações que o ambiente de Java impõe àqueles que tentam
 utilizá-lo com outras linguagens.
 Todavia, adaptações às linguagens continuam necessárias com o ambiente
 .NET: A versão .NET de Visual Basic inclui alterações na linguagem de modo
 a tornar a sua semântica mais similar à de C#; um novo dialeto de C++,
 Managed C++, foi introduzido adaptando o modelo de gerenciamento de memória
 ao do CLR 
\begin_inset LatexCommand \cite{managedcpp}

\end_inset 

; de forma similar, foi desenvolvido um novo dialeto de ML chamado F#, para,
 entre outros motivos, proporcionar melhor integração com componentes .NET
 desenvolvidos em outras linguagens 
\begin_inset LatexCommand \cite{syme-fsharp}

\end_inset 

.
\layout Standard

Outra implementação de uma máquina virtual para múltiplas linguagens vem
 sendo feita pelo projeto Parrot 
\begin_inset LatexCommand \cite{randal-perl6}

\end_inset 

.
 O escopo deste projeto é mais restrito, visando ser um 
\emph on 
back-end
\emph default 
 comum para linguagens dinâmicas como Perl e Python.
 O foco do projeto, entretanto, está atualmente na implementação de Perl
 6.
\layout Standard

Um tipo de comunicação que pode ser considerada ainda uma forma de ambiente
 de execução comum é a comunicação entre executáveis e bibliotecas nativos
 através de convenções de chamada: regras para a passagem de parâmetros
 na pilha de execução, uso de registradores e 
\emph on 
mangling
\emph default 
 de nomes.
 Este pode ser considerado o método de interação entre código em diferentes
 linguagens de mais baixo nível.
 Convenções de chamada, entretanto, são um recurso limitado de comunicação,
 já que assumem tipos de dados com representação em memória idêntica nas
 as duas linguagens.
 Tal compatibilidade dificilmente ocorre a não ser que uma das linguagens
 explicitamente considere este tipo de interação na sua definição: o padrão
 de Ada, por exemplo, requer que as suas implementações sejam compatíveis
 com as convenções de C, COBOL e Fortran 
\begin_inset LatexCommand \cite{ada95}

\end_inset 

.
 De forma similar, C++ permite especificar funções com linkagem compatível
 com C (
\family typewriter 
extern 
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 

C
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 


\family default 
).
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Modelos de Objetos Independentes de Linguagem
\layout Standard

Adotar um modelo de tipos independente de linguagem é uma outra forma de
 tratar as questões de interoperabilidade de dados entre linguagens.
 Assim, na definição dos dados de uma aplicação, as suas interfaces são
 definidas de forma neutra, tipicamente utilizando alguma linguagem projetada
 especificamente para este fim (uma IDL, 
\emph on 
interface description language
\emph default 
) enquanto as implementações são feitas nas linguagens específicas.
 A arquitetura CORBA (
\emph on 
Common Object Request Broker Architecture
\emph default 
) 
\begin_inset LatexCommand \cite{omg-corba}

\end_inset 

 é uma das principais representantes deste modelo.
 A motivação principal para o desenvolvimento de CORBA foi permitir o desenvolvi
mento de aplicações distribuídas em ambientes heterogêneos; a heterogeneidade
 de linguagens foi um dos aspectos levados em consideração.
\layout Standard

Os desafios existentes ao projetar um modelo de dados ou objetos 
\begin_inset Quotes eld
\end_inset 

independente de linguagens
\begin_inset Quotes erd
\end_inset 

, entretanto, são similares aos de uma interface entre duas linguagens quaisquer
, já que esse modelo, por sua vez, descreve também um sistema de tipos.
 Ao implementar 
\emph on 
bindings
\emph default 
 para algum destes modelos de objetos é necessário definir uma correspondência
 entre os tipos definidos pelo modelo e os oferecidos pela linguagem destino
 e prover a esta uma API para interação com o ambiente de execução---no
 caso de CORBA, com o ORB (
\emph on 
Object Request Broker
\emph default 
).
 
\layout Standard

Se por um lado a tarefa pode ser facilitada pelo fato de o modelo ter sido
 projetado visando interação com outras linguagens (diferentemente, por
 exemplo, do sistema de tipos de C), por outro espera-se usualmente um grau
 de transparência maior na representação dos dados.
 Por exemplo, enquanto em uma aplicação integrando C++ e Python a distinção
 entre objetos C++ e objetos Python é clara e a API Python define o limite
 entre os dois universos, em uma aplicação desenvolvida utilizando CORBA
 espera-se que, tanto em uma linguagem como em outra, a manipulação dos
 objetos seja igual, sejam eles implementados em C++ ou Python.
 Para isso, a solução adotada é o uso de 
\emph on 
stubs
\emph default 
, objetos que dão uma aparência nativa uniforme aos dados, indepentemente
 da linguagem em que foram implementados e no caso de modelos distribuídos
 como CORBA, da localização dos mesmos na rede.
 A correspondência entre os ciclos de vida dos 
\emph on 
stubs
\emph default 
 e dos objetos que eles representam é outro fator que deve ser levado em
 consideração.
 Nos 
\emph on 
bindings
\emph default 
 Java, por exemplo, isto é realizado com o auxílio do coletor de lixo da
 própria linguagem.
 Já em linguagens como C++ o controle das referências é explícito.
\layout Standard

Outras abordagens de mais alto nível têm sido propostas para a integração
 de aplicações desenvolvidas em múltiplas linguagens.
 Linguagens de coordenação como Linda 
\begin_inset LatexCommand \cite{gelernter-linda}

\end_inset 

 e Opus 
\begin_inset LatexCommand \cite{chapman-opus}

\end_inset 

 definem mecanismos para troca de mensagens e um conjunto restrito de construçõe
s para indicar o fluxo destas entre agentes implementados em outras linguagens.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C como Linguagem Intermediária
\layout Standard

O desejo de uma linguagem intermediária universal é antigo no mundo da computaçã
o.
 Diversas propostas surgiram ao longo dos anos, desde o projeto UNCOL 
\begin_inset LatexCommand \cite{conway-uncol}

\end_inset 

 às linguagens de sintaxe extensível da década de 70 
\begin_inset LatexCommand \cite{metzner-xl}

\end_inset 

 até os mais recentes ambientes de máquina virtual como .NET.
 Na prática, as necessidades que estes projetos visavam atender vêm sendo
 supridas ao longo dos anos de forma mais pragmática, ainda que menos ideal:
 usando C.
 Dois motivos fazem de C uma escolha comum como linguagem intermediária.
 Primeiro, a sua característica de linguagem de 
\begin_inset Quotes eld
\end_inset 

médio nível
\begin_inset Quotes erd
\end_inset 

, ao permitir ao mesmo tempo independência de hardware e manipulação direta
 de memória.
 Segundo, a grande disponibilidade de compiladores C, alavancada pela proliferaç
ão dos sistemas Unix nas mais diferentes arquiteturas.
 Assim, com o passar do tempo, oferecer uma interface para interoperabilidade
 com outras linguagens passou a significar oferecer uma interface para comunicaç
ão com código C.
 Isto é especialmente verdadeiro para linguagens dinâmicas que oferecem
 recursos para extensibilidade de aplicações.
 Não por acaso, estas são tipicamente implementadas em C.
\layout Standard

A disponibilidade de APIs para C oferecidas pelas diferentes linguagens
 faz com que C seja bastante usada também como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

.
 A integração entre Python e Fortran se dá através de um módulo Python escrito
 em C que acessa uma biblioteca Fortran, que por sua vez expõe funções com
 convenção de chamada compatível com C 
\begin_inset LatexCommand \cite{peterson-fpy}

\end_inset 

.
 LunaticPython 
\begin_inset LatexCommand \cite{lunatic-python}

\end_inset 

 oferece pontes de Lua para Python e de Python para Lua, implementadas através
 de um par de módulos de extensão para cada linguagem de origem escritos
 em C.
\layout Standard

Todavia, linguagens intermediárias genéricas continuam a ser propostas como
 alternativas a C.
 C-- 
\begin_inset LatexCommand \cite{jones99portable}

\end_inset 

 é um projeto que tenta superar as limitações de C enquanto linguagem intermediá
ria tornando mais explícita a representação em memória dos tipos de dados
 e adicionando suporte a construções não facilmente representáveis em C,
 como recursão final.
 Versões recentes da suíte de compiladores GCC padronizaram uma linguagem
 intermediária para comunicação entre os seus diversos 
\emph on 
back-ends
\emph default 
 e 
\emph on 
front-ends
\emph default 
 
\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces com C
\layout Standard

A linguagem C tem, na atualidade, um papel especial no mundo das linguagens
 de programação.
 Além de ser bastante utilizada na implementação de compiladores, interpretadore
s e máquinas virtuais (as principais implementações de Perl, Python, Ruby,
 Tcl e Lua são apenas alguns exemplos), é tambem usada em compiladores como
 formato de saída na geração de código portável (dois exemplos notáveis
 são os compiladores GHC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

 e o SmartEiffel 
\begin_inset LatexCommand \cite{collin-eiffel}

\end_inset 

, que geram C a partir de Haskell e Eiffel, respectivamente).
 Isto faz com que a API para C seja um formato conveniente para uma FLI.
\layout Standard

Na grande maioria dos casos, a representação interna de código produzida
 por compiladores de outras linguagens não é compatível com C, seja por
 diferenças em convenções de chamadas ou de nomes, ou por produzirem código
 para execução em máquinas virtuais.
 Desta forma, para permitir a um programa em C acessar este código, cabe
 à linguagem expor uma biblioteca de funções C que realizem a tradução necessári
a.
 Em ambientes de máquina virtual, esta biblioteca de funções normalmente
 é genérica, oferecendo facilidades para comunicação com a própria máquina
 virtual.
 Para linguagens estáticas, normalmente é necessário criar uma biblioteca
 específica que realize a conversão das chamadas, como ocorre em interfaces
 C para APIs C++.
\layout Standard

Para linguagens não imperativas, há ainda o problema de código C potencialmente
 gerar efeitos colaterais.
 Algum recurso para isolamento das chamadas deve ser oferecido.
 No GHC, a construção para chamadas em C, 
\family typewriter 
_ccall_
\family default 
, é definida na mônada de IO; no adendo do padrão Haskell 98, a diretiva
 
\family typewriter 
ccall
\family default 
 foi integrada, mas o uso da mônada é opcional, cabendo ao programador garantir
 que funções que não a utilizem sejam puras
\begin_inset Foot
collapsed true

\layout Standard

Diversas convenções de chamada são definidas (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
) mas 
\family typewriter 
ccall
\family default 
 é a única declarada como obrigatória pelo documento.
\end_inset 

.
\layout Standard

Outra possível fonte de incompatibilidade entre linguagens que deve ser
 tratada quando estas interagem é a diferença entre modelos de concorrência.
 C, em particular, não define construções de concorrência, sendo estas implement
adas através de bibliotecas.
 Ao mesmo tempo que isto traz grande flexibilidade à linguagem, implica
 também em problemas de portabilidade para linguagens que dependam da disponibil
idade de mecanismos de concorrência em C compatíveis com os modelos que
 elas utilizam.
\layout Standard

Por exemplo, APIs entre C e Java devem levar em conta o modelo de 
\emph on 
multithreading
\emph default 
 preemptivo adotado por Java.
 A JNI (
\emph on 
Java Native Interface
\emph default 
) 
\begin_inset LatexCommand \cite{liang-jni}

\end_inset 

 define funções para controlar exclusão mútua entre dados compartilhados
 entre C e Java.
 O programador deve tomar o cuidado de buscar o equilíbrio entre o tempo
 gasto bloqueando a máquina virtual acessando dados compartilhados e o tempo
 gasto realizando cópia de dados entre os ambientes para reduzir o compartilhame
nto.
 Outra situação em que o modelo de concorrência da linguagem demanda cuidados
 por parte do programador na integração com C ocorre no uso de co-rotinas
 em Lua.
 A combinação de dois recursos de Lua, multitarefa cooperativa com múltiplas
 pilhas de execução e a capacidade de alternar entre chamadas a funções
 Lua e C em uma pilha, traz consigo uma limitação: uma co-rotina não pode
 executar a operação de 
\emph on 
yield
\emph default 
 caso haja uma função C na sua pilha, uma vez que não há uma forma portável
 de alternar entre múltiplas pilhas em C 
\begin_inset LatexCommand \cite{moura-colua}

\end_inset 

.
 
\layout Standard

Uma das motivações mais freqüentes para integração com código C é o uso
 de bibliotecas externas.
 Expor uma biblioteca C através da FLI para acesso em uma linguagem pode
 incorrer no registro de centenas de funções.
 É comum definir também tipos de dados que dêem às estruturas definidas
 pela biblioteca uma aparência mais nativa, como por exemplo converter funções
 C que registram 
\emph on 
callbacks
\emph default 
 em métodos Ruby que aceitam blocos de código como parâmetro.
 Essas inicializações e adaptações são usualmente definidas em uma biblioteca
 de 
\emph on 
bindings
\emph default 
, que serve de ponte entre a linguagem e a biblioteca C encapsulando a interação
 com a FLI.
\layout Standard

Os padrões que ocorrem na produção de bindings são tão comuns que deram
 origem a programas visam automatizar o processo.
 Estes geradores de 
\emph on 
bindings
\emph default 
 costumam trabalhar a partir de alguma representação preparada para o seu
 uso, já que analisar os cabeçalhos C pode-se mostrar insuficiente: por
 exemplo, o programa muitas vezes não seria capaz de interpretar a intenção
 de uma construção como 
\family typewriter 
int**
\family default 
.
 SWIG 
\begin_inset LatexCommand \cite{beazley-swig}

\end_inset 

 é uma popular ferramenta multi-linguagem para geração de 
\emph on 
bindings
\emph default 
 de bibliotecas C e C++ que utiliza um formato próprio para descrição de
 interfaces.
 FLIs podem ainda utilizar geradores de 
\emph on 
stubs
\emph default 
 para poupar o programador de escrever código C repetitivo ou não portável.
 Java possui um gerador de cabeçalhos C contendo os protótipos dos métodos
 nativos a serem implementados.
 Pyrex 
\begin_inset LatexCommand \cite{ewing-pyrex}

\end_inset 

 é um gerador de módulos C para Python a partir de uma sintaxe baseada na
 própria linguagem Python.
\layout Comment

Falar de tolua, outros geradores.
\layout Comment

a qualidade da conversão depende do código C, não da api
\layout Comment

vc não pode ter conversores que funcionem 100% automaticos
\layout Comment

alguém tem que explicar pro gerador se char** é um array de strings, um
 ponteiro pra uma string, um array de array de caracteres, um ponteiro pra
 um ponteiro pra um caracter, um..........
\layout Comment

ah, o código tem que ser "anotado" pra ser passado como entrada pra ele.
 se tu passa um .h intocado ele dá o melhor chute que ele puder.
 sem contar que se o .h estiver cheio de macros, o parserzinho dele vai pedir
 água 
\layout Comment

o swig é o cara mais porrada nesse aspecto, porque segundo reza a lenda
 ele "entende ANSI C", então pelo menos a dança das macros ele consegue
 fazer (mas ainda assim precisa de um arquivo anotado pra fazer a conversão
 correta)
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

APIs de Linguagens de Script
\layout Standard

Interfaces providas por linguagens de script são usualmente compreendidas
 como 
\begin_inset Quotes eld
\end_inset 

APIs de extensão
\begin_inset Quotes erd
\end_inset 

: elas servem para estender a máquina virtual com recursos não oferecidos
 por esta, ou ainda para estender uma aplicação externa com os recursos
 oferecidos pelo ambiente de execução da linguagem, embutindo-o nesta aplicação.
 O primeiro cenário é o utilizado no modelo de programação onde a coordenação
 de alto nível é realizada em uma linguagem interpretada e módulos compilados
 em linguagens como C e C++ são usados para acesso a bibliotecas externas
 ou implementação de partes onde o desempenho é crítico.
 O segundo cenário, via de regra, irá englobar também o primeiro, ao expor
 à máquina virtual ou interpetador embutido extensões que a permitam comunicar-s
e com a aplicação hospedeira.
\layout Standard

As seções seguintes discutem as principais questões envolvidas na comunicação
 entre código C e de linguagens de script, e apresenta as abordagens empregadas
 pelas APIs de Python, Ruby, Java, Lua e Perl no tratamento destas questões.
\layout Section

Transferência de dados
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

O principal complicador na interação entre linguagens de programação não
 é a diferença de sintaxe ou semântica das construções de fluxo de controle,
 mas a representação dos dados.
 Na comunicação entre código escrito em duas linguagens diferentes, dados
 trafegam de várias formas: como parâmetros, atributos de objetos, elementos
 de estruturas de dados, etc.
\layout Standard

Freqüentemente, o formato como estes dados são representados difere.
 Nestes casos, há três alternativas para realizar a transferência de dados
 entre as duas linguagens.
 A mais simples é expor o dado à linguagem de destino como uma entidade
 opaca.
 A linguagem de destino recebe apenas algum tipo de 
\emph on 
handle
\emph default 
 que permite identificar unicamente o dado em operações requisitadas posteriorme
nte.
 Esta abordagem é útil, por exemplo, se uma linguagem está apenas armazenando
 os dados para a outra, a fim de aproveitar estruturas de dados de mais
 alto nível que a linguagem ofereça.
 
\layout Standard

Outra abordagem envolve realizar algum tipo de conversão dos dados do sistema
 de tipos de uma linguagem para o da outra.
 A duplicação que ocorre na conversão limita a aplicabilidade deste método,
 restringindo o seu uso tipicamente para tipos numéricos e, em menor grau,
 strings.
 Finalmente, a linguagem de origem pode explicitamente oferecer facilidades
 na linguagem de destino para a manipulação destes dados, ou seja, uma linguagem
 oferecer uma API para a outra.
\layout Standard

C, por ser orientada à manipulação de ponteiros e estruturas, possui um
 conjunto pequeno de tipos básicos.
 Além disso, C é bastante liberal em relação à representação interna dos
 tipos estruturados, cabendo às diferentes plataformas definirem interfaces
 binárias (
\emph on 
application binary interfaces
\emph default 
, ABIs).
 Assim, mesmo em casos onde é possível li\SpecialChar \-
gar código C diretamente utilizando
 tipos básicos compatíveis e convenções de chamada apropriadas (como em
 Free Pascal ou em diversos compiladores Fortran), uma biblioteca de 
\emph on 
bindings
\emph default 
 é usualmente necessária para tornar mais conveniente a manipulação de tipos
 mais complexos.
\layout Standard

Até nos tipos numéricos fundamentais, há vários cuidados que devem ser tomados.
 Algumas linguagens, como Smalltalk e Ruby, realizam conversão automática
 de inteiros para 
\begin_inset Quotes eld
\end_inset 

inteiros grandes
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 Em Ruby, particularmente, os inteiros primitivos têm 1 bit a menos de precisão
 do que o tamanho de palavra da máquina.
 Pode haver ainda a necessidade de conversão de 
\emph on 
endianness
\emph default 
 e formato de números de ponto flutuante.
\layout Standard

Para tipos como strings, o tamanho dos valores traz ainda preocupações com
 desempenho.
 Em diversos casos a representação interna usada para strings é a mesma
 que a usada em C, então uma opção é simplesmente passar ao código C um
 ponteiro para o endereço onde a string está armazenada, o que evita a cópia
 de dados, sob risco de permitir ao programa C modificar o conteúdo da string.
 Isto é uma possível fonte de erros, especialmente em linguagens como Lua,
 onde strings são internalizadas.
 Expor ao código C ponteiros para endereços de memória dentro do ambiente
 de execução da outra linguagem pode trazer ainda problemas de concorrência,
 caso o ambiente em questão utilize múltiplas 
\emph on 
threads
\emph default 
.
\layout Standard

Ao expor ao código C dados de tipos estruturados, a conversão para um tipo
 de dado nativo de C, em muitos casos, não é uma opção.
 Além da questão da quantidade de dados, tipos estruturados em C são definidos
 estaticamente, não servindo assim para representar convenientemente dados
 de estruturas dinâmicas, como objetos que podem ganhar ou perder atributos
 e até mesmo mudar de classe em tempo de execução.
 Mesmo em linguagens com tipos estáticos, como Java, a cópia de objetos
 não costuma ser uma opção interessante em função do volume de dados.
 A cópia de objetos estruturados costuma se restringir a operações específicas
 como manipulação de arrays de elementos primitivos.
\layout Standard

A alternativa para permitir que código C opere sobre dados estruturados,
 então, é fornecer a ele uma API que exponha, em forma de funções, as operações
 definidas sobre os tipos em questão.
 Isto evita também a necessidade de controlar a consistência entre duas
 cópias de uma mesma estrutura.
 Problemas de consistência, entretanto, podem ocorrer caso a API permita
 ao código C armazenar ponteiros para objetos da linguagem---isto torna
 necessário ao programador gerenciar explicitamente a sincronia entre os
 ponteiros e o ciclo de vida dos objetos, que podem estar sujeitos a coleta
 de lixo.
 A Seção 
\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discute esta questão em mais detalhe.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

Todos os valores na máquina virtual de Python são representados como objetos,
 mapeados para a API de C como a estrutura 
\family typewriter 
PyObject
\family default 
 
\begin_inset LatexCommand \cite{vanrossum-extpy}

\end_inset 

.
 Tipos mais específicos como 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 e 
\family typewriter 
PyListObject
\family default 
 são 
\family typewriter 
PyObject
\family default 
s por equivalência estrutural, isto é, podem ser convertidos através de
 um 
\emph on 
cast
\emph default 
 C.
 Refletindo o modelo de tipagem dinâmica de Python, as funções da API usam
 
\family typewriter 
PyObject*
\family default 
 como tipo sempre que se referem a objetos Python, mesmo quando são projetadas
 para atuar sobre valores Python de tipos mais específicos, como por exemplo
 a função 
\family typewriter 
PyString_Size
\family default 
, que retorna o tamanho de uma string.
 Cada tipo específico possui uma função de verificação na API, como 
\family typewriter 
PyNumber_Check
\family default 
 e 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python é uma linguagem fortemente tipada: cada objeto é amarrado a um tipo.
 Tipos são representados por estruturas 
\family typewriter 
PyTypeObject
\family default 
, que também são estruturalmente equivalentes a 
\family typewriter 
PyObject
\family default 
.
 Cada tipo Python possui um 
\family typewriter 
PyObject
\family default 
 pré-definido na API, como 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 e 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compara o tipo de um 
\family typewriter 
PyObject
\family default 
 a um 
\family typewriter 
PyTypeObject
\family default 
 passado como parâmetro.
\layout Standard

Para a conversão de dados de C para Python, a linguagem oferece uma série
 de funções que recebem valores de tipos primitivos de C como parâmetro,
 como 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 e 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Cada uma destas funções retorna ao código C um ponteiro para um novo objeto
 
\family typewriter 
PyObject
\family default 
.
 Strings passadas são copiadas por Python.
 O exemplo a seguir ilustra a criação de objetos Python através da conversão
 de objetos C e a verificação de tipo:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout LyX-Code


\size footnotesize 
\emph on 
/* As duas linhas abaixo são equivalentes: */
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Sim.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Sim.
\backslash 
n");
\layout Standard

Para o retorno de dados de Python para C, um conjunto complementar de funções
 é oferecido, mapeando os tipos básicos de Python de volta a tipos de C.
 Alguns exemplos destas funções que recebem um ponteiro para um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam o dado correspondente em C são 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 e 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Diferentemente das funções de entrada, nas fun\SpecialChar \-
ções de saída as strings
 retornadas são ponteiros para a área armazenada internamente por Python.
 A documentação recomenda não modificar o conteúdo da string exceto no caso
 de esta área de memória haver sido retornada por uma chamada a 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
tamanho
\family typewriter 
\emph default 
)
\family default 
.
 Desta forma, é possível alocar uma string para armazenamento em Python
 e preenchê-la posteriormente através de código C, como no exemplo a seguir:
\layout LyX-Code


\size footnotesize 
\emph on 
/* alocando uma string não-inicializada em Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtendo o ponteiro para a área de memória da string */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Agora, podemos preencher a string em C.
 Um exemplo qualquer: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard

Para alguns de seus tipos básicos que não possuem correspondente direto
 em ANSI C 89, Python define tipos em C equivalentes: 
\family typewriter 
Py_UNICODE
\family default 
 e 
\family typewriter 
Py_complex
\family default 
.
 Estes tipos foram adicionados com o objetivo de expor a representação interna
 dos dados usada por Python aos módulos para manipulação numérica ou de
 texto Unicode implementados em C, evitando conversões freqüentes de e para
 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python oferece ainda algumas versões de funções de conversão para C implementada
s como macros sem a verificação de tipo, assumindo que o 
\family typewriter 
PyObject
\family default 
 passado será compatível, oferecendo melhor desempenho às custas de segurança.
 Estas funções podem ser identificadas pelos nomes em maiúsculas.
 Entre as macros de conversão oferecidas estão 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 e 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Além de funções para conversão de tipos entre Python e C, a API de Python
 oferece ainda algumas funções de conversão entre tipos de Python.
 Estas funções recebem um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam um novo 
\family typewriter 
PyObject
\family default 
 com o resultado da conversão, e são equivalentes a funções Python que realizam
 estas conversões (na verdade chamadas a tipos 
\family typewriter 
PyTypeObject
\family default 
 que respondem ao método 
\family typewriter 
__call__
\family default 
).
 Por exemplo, a função 
\family typewriter 
PyObject_Str
\family default 
 é equivalente à função Python 
\family typewriter 
str
\family default 
.
 
\layout Standard

Em Python, objetos são armazenados em módulos, que são espaços de nomes
 declarados globalmente, ou como atributos de objetos.
 Variáveis são armazenadas em um 
\emph on 
ambiente
\emph default 
, representado como um dicionário.
 Funções como 
\family typewriter 
PyRun_File
\family default 
 recebem, entre seus parâmetros, um dicionário de variáveis globais e outro
 de variáveis locais.
 O conjunto de variáveis e funções globais é representado como o dicionário
 do módulo 
\family typewriter 
__main__
\family default 
.
 Objetos 
\emph on 
built-in
\emph default 
 são acessíveis através do módulo 
\family typewriter 
__builtin__
\family default 
.
 Por exemplo, para obter o objeto 
\family typewriter 
str
\family default 
, obtemos inicialmente uma referência ao módulo 
\family typewriter 
__builtin__
\family default 
 com a função 
\family typewriter 
PyImport_AddModule
\family default 
 e em seguida o dicionário do módulo com a função 
\family typewriter 
PyModule_GetDict
\family default 
.
 
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard

Em Python, 
\family typewriter 
str
\family default 
 é um objeto chamável, que atua como a função de conversão para strings.
 Assim, uma vez que obtivemos uma referência para o 
\family typewriter 
PyObject
\family default 
 correspondente a 
\family typewriter 
str
\family default 
, a chamada seguinte equivale a chamar 
\family typewriter 
PyObject_Str
\family default 
 sobre um objeto Python qualquer 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Esta é uma função vararg que recebe como argumentos adicionais uma lista
\layout LyX-Code


\size footnotesize 
\emph on 
   terminada em NULL de PyObjects a serem passados à função Python indicada
\layout LyX-Code


\size footnotesize 
\emph on 
   no primeiro argumento.
 */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard

O armazenamento de dados de C no espaço de objetos de Python pode ser feito
 de duas formas.
 Uma maneira consiste em criar um objeto do tipo 
\family typewriter 
CObject
\family default 
 encapsulando um ponteiro C qualquer, construindo assim um valor opaco para
 Python.
 As funções de construção deste objetos deste tipo permitem associar ao
 dado uma função C a ser chamada quando o 
\family typewriter 
CObject
\family default 
 for desalocado.
 Segundo a documentação de Python, 
\family typewriter 
CObject
\family default 
s têm como objetivo principal permitir a passagem de dados em C de um módulo
 de extensão para outro 
\begin_inset LatexCommand \cite{pyvhll_cobjects}

\end_inset 

.
\layout Standard

A outra forma consiste em declarar novos tipos Python através de estruturas
 em C.
 Em C, um tipo Python é descrito em duas partes: um tipo 
\emph on 
struct,
\emph default 
 a partir do qual instâncias do tipo serão produzidas, e uma instância da
 struct 
\family typewriter 
PyTypeObject
\family default 
, que descreverá o tipo para Python.
 O exemplo a seguir ilustra a criação de um novo tipo Python em C.
 Inicialmente, temos 
\family typewriter 
point
\family default 
, que será o tipo C das instâncias dos objetos:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard

A macro 
\family typewriter 
PyObject_HEAD
\family default 
 garante equivalência estrutural com 
\family typewriter 
PyObject
\family default 
.
 Quando funções retornarem o objeto ao código C como um 
\family typewriter 
PyObject*
\family default 
, este pode ser convertido de volta para 
\family typewriter 
point
\family default 
 via cast, dando assim acesso aos atributos 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
.
 Todavia, para que estes atributos sejam visíveis a partir de Python, precisarem
os implementar rotinas de acesso.
\layout Standard

Em seguida, definiremos 
\family typewriter 
point_type
\family default 
, que será o 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo Python relativo a eles
\begin_inset Foot
collapsed true

\layout Standard

Para maior brevidade, apresentamos o exemplo usando a sintaxe para descrição
 de structs de C99, evitando-nos de listar os elementos a serem inicializados
 com 
\family typewriter 
NULL
\family default 
, já que a struct 
\family typewriter 
PyTypeObject
\family default 
 possui 54 campos ao todo.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",          
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),
\layout LyX-Code


\size footnotesize 
   .tp_methods = point_methods, 
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT
\layout LyX-Code


\size footnotesize 
}; 
\layout Standard

Novamente, uma macro foi usada no início da definição do tipo para garantir
 equivalência entrutural.
 
\family typewriter 
PyTypeObject
\family default 
 possui vários outros campos, mas os manteremos como 
\family typewriter 
NULL
\family default 
 de modo que sejam preenchidos com valores default quando da construção
 do tipo em tempo de execução.
 Na definição de point_type, referenciamos 
\family typewriter 
point_methods
\family default 
 e 
\family typewriter 
point_getattr
\family default 
, que devem ter sido declarados anteriormente.
 O campo 
\family typewriter 
tp_methods
\family default 
 aponta para um array de 
\family typewriter 
PyMethodDef
\family default 
s, que armazenará os métodos do tipo:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard

O tipo 
\family typewriter 
PyTypeObject
\family default 
 contém uma série de campos que permitem descrever o comportamento do tipo
 declarado.
 No exemplo, o array 
\family typewriter 
point_methods
\family default 
 indica que a função C 
\family typewriter 
point_distance
\family default 
 implementa o método 
\family typewriter 
distance
\family default 
.
 A função é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(pow(p->x,2)+pow(p->y,2)) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Já no campo 
\family typewriter 
tp_getattr
\family default 
 de 
\family typewriter 
point_type
\family default 
, é especificada uma função C para tratar acesso a atributos, 
\family typewriter 
point_getattr
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard

Através desta função, podemos expor ao ambiente Python atributos armazenados
 na struct C.
 A busca de métodos também é feita através de 
\family typewriter 
tp_getattr
\family default 
.
 A implementação padrão quando 
\family typewriter 
tp_getattr
\family default 
 é 
\family typewriter 
NULL
\family default 
 procura métodos no array 
\family typewriter 
tp_methods
\family default 
.
 Como redefinimos 
\family typewriter 
tp_getattr
\family default 
, a busca de métodos é implementada em 
\family typewriter 
point_getattr
\family default 
 usando 
\family typewriter 
Py_FindMethod
\family default 
.
\layout Standard

Embora a representação em memória de objetos Python do tipo definido pelo
 usuário sejam instâncias de 
\family typewriter 
point
\family default 
, para criar um novo objeto não basta alocar uma instância da struct 
\family typewriter 
point
\family default 
 e usá-la como 
\family typewriter 
PyObject
\family default 
 via cast.
 É preciso inicializar o objeto para que este seja registrado no mecanismo
 de coleta de lixo e tenha os campos de seu cabeçalho 
\family typewriter 
PyObject
\family default 
 devidamente inicializados.
 A alocação em C de novos objetos de um tipo definido pelo usuário deve
 ser feita através da macro 
\family typewriter 
PyObject_New
\family default 
, que recebe como parâmetros o tipo da struct a ser alocada e o 
\family typewriter 
PyTypeObject
\family default 
 correspondente ao tipo.
 Antes de alocar objetos do tipo em C, deve-se completar a inicialização
 de 
\family typewriter 
point_type
\family default 
 em tempo de execução.
 A documentação recomenda inicializar em tempo de execução a função padrão
 de construção de objetos, 
\family typewriter 
PyType_GenericNew
\family default 
, por razões de portabilidade 
\begin_inset LatexCommand \cite{vanrossum-extpy}

\end_inset 

.
 Finalmente, o preenchimento dos campos não definidos na declaração da struct
 é feita pela função 
\family typewriter 
PyType_Ready
\family default 
.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

A partir daí, instâncias podem ser criadas com 
\family typewriter 
PyObject_New
\family default 
, como no exemplo abaixo:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria uma instância */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena a instância na global Python 
\emph default 
P
\emph on 
,
\layout LyX-Code


\size footnotesize 
\emph on 
   assume que o dicionário de globais já foi armazenado em 
\emph default 
globals
\emph on 
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Uma vez declarado em C, este valor pode ser usado em Python:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard

A API de Python possui um grande número de funções para manipulação de tipos
 pré-definidos da linguagem.
 
\emph on 
Tuplas
\emph default 
 merecem menção especial no que tange à transferência de dados entre Python
 e C, pois são usadas em diversos contextos: na passagem de parâmetros em
 chamadas a funções Python a partir de C, no recebimento dos parâmetros
 de entrada em funções C e também na passagem e recebimento de múltiplos
 valores de retorno, como será visto nas Seções 
\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 e 
\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

Como tuplas são usadas com freqüência como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 entre Python e C, a API possui uma função de conveniência, 
\family typewriter 
PyArg_ParseTuple
\family default 
, que evita que o acesso aos elementos da tupla e a verificação dos seus
 tipos seja feita item a item pelo programador.
 Trata-se de uma função C 
\emph on 
vararg
\emph default 
 que recebe como parâmetros a tupla, uma string indicando os tipos dos parâmetro
s esperados e os endereços dos ponteiros para os 
\family typewriter 
PyObject
\family default 
s onde os parâmetros devem ser armazenados.
 A função define uma sintaxe para os indicadores de tipo da string passada
 e os tipos C correspondentes.
 Por exemplo: 
\family typewriter 
"s#"
\family default 
 indica que a tupla deve conter um objeto Python de tipo 
\family typewriter 
string
\family default 
 ou 
\family typewriter 
Unicode
\family default 
 e que dois parâmetros devem ser passados à função C, de tipos const 
\family typewriter 
char**
\family default 
 e 
\family typewriter 
int*
\family default 
, que irão retornar o ponteiro para a string e o seu tamanho.
 Em um exemplo mais elaborado, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indica que a função espera dois endereços de inteiros (
\family typewriter 
"ii"
\family default 
), seguido do endereço de um ponteiro 
\family typewriter 
PyObject
\family default 
 (
\family typewriter 
"O"
\family default 
) e de um objeto 
\family typewriter 
PyTypeObject
\family default 
 a ser usado na verificação do tipo do objeto recebido (
\family typewriter 
"!"
\family default 
) e opcionalmente (
\family typewriter 
"|"
\family default 
), dois endereços de valores 
\family typewriter 
double
\family default 
 passados via Python através de uma outra tupla (
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

De forma similar, a API de Python possui a função 
\family typewriter 
Py_BuildValue
\family default 
, que permite a construção de objetos estruturados em uma só chamada.
 A sintaxe da string de parâmetros é similar à de 
\family typewriter 
PyArg_ParseTuple
\family default 
, mas possui um conjunto diferente de indicadores de tipo, além de permitir
 descrever listas e dicionários.
 Por exemplo, a seguinte chamada cria uma lista contendo um inteiro, um
 número de ponto flutuante e um dicionário contendo um elemento de chave
 string e valor inteiro:
\layout LyX-Code


\size footnotesize 
PyObject* lista = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

Esta função é útil tanto para construir tuplas em funções C que desejem
 passar múltiplos valores de retorno de volta a Python, como para construir
 a tupla de parâmetros ao chamar funções Python a partir de C.
\layout Subsection

Ruby
\layout Standard

Para a comunicação de dados entre Ruby e C, a API de Ruby define um tipo
 de dados em C chamado 
\family typewriter 
VALUE
\family default 
, que referencia um objeto Ruby.
 
\family typewriter 
VALUE
\family default 
 pode representar tanto uma referência para um objeto (isto é, um ponteiro
 para a 
\emph on 
heap
\emph default 
 de Ruby) como um valor imediato.
 Em particular, as constantes 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 e 
\family typewriter 
Qnil
\family default 
 são definidas como valores imediatos, permitindo a comparação destas em
 C usando o operador 
\family typewriter 
==
\family default 
.
 Para os tipos numéricos, a conversão entre C e Ruby é feita através de
 macros como 
\family typewriter 
INT2NUM
\family default 
 e de funções como 
\family typewriter 
rb_float_new
\family default 
, que recebem ou retornam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

Para a verificação de tipos, Ruby disponibiliza as macros 
\family typewriter 
Check_Type
\family default 
 e 
\family typewriter 
TYPE
\family default 
.
 
\family typewriter 
Check_Type
\family default 
 que permite comparar valores a constantes representando alguns tipos básicos
 de Ruby como 
\family typewriter 
T_OBJECT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 retorna a constante relativa ao tipo de um valor passado.
 Para a verificação da classe de um objeto, devemos usar 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

Para a passagem de strings para Ruby a partir de C, são oferecidas as funções
 
\family typewriter 
rb_str_new
\family default 
, que recebe um ponteiro e um argumento numérico de tamanho, de modo a permitir
 a passagem de strings contendo caracteres nulos, e 
\family typewriter 
rb_str_new2
\family default 
, que assume uma string padrão de C, com o caracter nulo como terminador.
 Estas funções fazem uma cópia da string C para o espaço de Ruby.

\family typewriter 
 VALUE
\family default 
s que apontam para strings de Ruby permitem acessar o seu conteúdo através
 do 
\emph on 
cast
\emph default 
 
\family typewriter 
RSTRING(uma_string)->ptr
\family default 
.
 Todavia, a API recomenda o uso da macro 
\family typewriter 
StringValue
\family default 
, que retorna o próprio 
\family typewriter 
VALUE
\family default 
 passado caso este seja uma string, ou um novo 
\family typewriter 
VALUE
\family default 
 da classe 
\family typewriter 
String
\family default 
 produzido através do método de conversão 
\family typewriter 
to_s
\family default 
 aplicado ao objeto passado (ou ainda causa uma exceção 
\family typewriter 
TypeError
\family default 
 caso a conversão não seja possível).
\layout LyX-Code


\size footnotesize 
void mostra_valor(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Faria um acesso ilegal se TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Funciona para qualquer tipo que aceite obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         dispara uma exceção em caso contrário */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Valor: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Sob a justificativa de aumentar o desempenho no acesso, alguns outros tipos
 de Ruby como 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 e 
\family typewriter 
File
\family default 
 permitem acesso de baixo nível aos membros das estruturas utilizadas na
 implementação dos objetos.
 Por exemplo, 
\family typewriter 
RARRAY(um_array)->len
\family default 
 permite ler o tamanho de um array diretamente.
 A recomendação da API é utilizar este tipo de acesso somente para leitura,
 já que a alteração destes valores pode facilmente tornar o estado interno
 dos objetos inconsistente.
\layout Standard

Para o armazenamento de dados de C no espaço de objetos de Ruby, a API oferece
 uma macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, que recebe um ponteiro C e cria um objeto Ruby que encapsula este ponteiro.
 O ponteiro pode ser acessado a partir de código C usando 
\family typewriter 
Data_Get_Struct
\family default 
, mas não a partir de Ruby.
 Em 
\family typewriter 
Data_Wrap_Struct
\family default 
 é passada também uma função C a ser executada quando o objeto for coletado.
 Por exemplo, criemos uma classe 
\family typewriter 
Point
\family default 
, similar ao tipo definido em Python na seção anterior.
 Inicialmente definiremos um tipo C:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard

Funções de alocação (
\family typewriter 
point_alloc
\family default 
) e desalocação (
\family typewriter 
point_free
\family default 
) para a classe 
\family typewriter 
Point
\family default 
 são dadas a seguir:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, 0, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Note que 
\family typewriter 
Data_Wrap_Struct
\family default 
 faz uso de um VALUE que representa a classe Point em Ruby.
 Classes são criadas em C com a função 
\family typewriter 
rb_define_class
\family default 
.
 Esta função recebe uma string C com o nome da nova classe e um 
\family typewriter 
VALUE
\family default 
 a ser usado como superclasse (como por exemplo a constante C 
\family typewriter 
rb_cObject
\family default 
, que representa a classe Ruby 
\family typewriter 
Object
\family default 
) e retorna um 
\family typewriter 
VALUE
\family default 
 representando a nova classe.
 Para classes como 
\family typewriter 
Point
\family default 
, cujas instâncias irão conter dados de C, é possível registrar uma função
 C responsável por realizar a alocação de memória das instâncias usando
 a função 
\family typewriter 
rb_define_alloc_func
\family default 
.
 A criação da classe e o registro da função de alocação, então, se dão da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard

Como em código Ruby, a declaração de atributos de objetos é feita no método
 
\family typewriter 
initialize
\family default 
, que pode ser implementado em C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Para que a cópia de objetos através dos métodos Ruby 
\family typewriter 
dup
\family default 
 e 
\family typewriter 
clone
\family default 
 trate corretamente os dados armazenados via C, é preciso ainda registrar
 o método 
\family typewriter 
initialize_copy
\family default 
.
 Uma possível implementação em C é dada abaixo:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby pode chamar esta função com o mesmo objeto nos dois parâmetros;
\layout LyX-Code


\size footnotesize 
\emph on 
      nesse caso, ignore a chamada e retorne o objeto */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter os ponteiros armazenados nos objetos */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cópia da 
\begin_inset Quotes eld
\end_inset 

parte C
\begin_inset Quotes erd
\end_inset 

 do objeto */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna a cópia */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Completemos o exemplo implementando uma função C implementando o método
 
\family typewriter 
distance
\family default 
 como feito na seção anterior para Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(pow(p->x,2)+pow(p->y,2)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

De posse do 
\family typewriter 
VALUE
\family default 
 referente à classe, podemos inserir funções C que seguem as convenções
 esperadas por Ruby como métodos com 
\family typewriter 
rb_define_method
\family default 
, da forma descrita abaixo (o registro de funções C em Ruby será discutido
 em detalhe na Seção 
\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard

A função 
\family typewriter 
rb_class_new_instance
\family default 
 produz novos objetos Ruby que são instâncias da classe, recebendo um array
 de 
\family typewriter 
VALUE
\family default 
s a ser passados na inicialização e o 
\family typewriter 
VALUE
\family default 
 da classe.
 
\layout Standard

O acesso a variáveis Ruby se dá através da família de funções 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
, que retornam os 
\family typewriter 
VALUE
\family default 
s relativos a atributos de objetos ou classes, variáveis globais e constantes.
 Para cada uma destas há uma função 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 análoga
\begin_inset Foot
collapsed true

\layout Standard

Constantes podem ser criadas com o valor 
\family typewriter 
Qundef
\family default 
 e terem o seu valor definido posteriormente com 
\family typewriter 
rb_const_set
\family default 
, porém uma única vez.
\end_inset 

.
 As funções 
\family typewriter 
rb_iv_get
\family default 
 e 
\family typewriter 
rb_ivar_get
\family default 
, por exemplo, obtêm atributos de objetos (
\emph on 
instance variables
\emph default 
).
 A primeira forma usa strings C como nomes, a segunda usa 
\family typewriter 
ID
\family default 
s, identificadores que substituem strings internalizadas na tabela de símbolos
 de Ruby, que podem ser obtidos usando a função 
\family typewriter 
rb_intern
\family default 
.
 De fato, 
\family typewriter 
ID
\family default 
s correspondem ao tipo 
\emph on 
símbolo
\emph default 
 de Ruby, que na prática são strings imutáveis.
 
\layout Standard


\family typewriter 
ID
\family default 
s nunca são coletados: observamos que a tabela de símbolos não é zerada
 mesmo com 
\family typewriter 
ruby_finalize
\family default 
.
 Assim, uma aplicação C que oferece uma interface para scripting criando
 ambientes supostamente isolados, com 
\family typewriter 
ruby_init
\family default 
 e 
\family typewriter 
ruby_finalize
\family default 
 cercando cada execução de script, pode ter o seu consumo de memória aumentado
 indefinidamente à medida que os scripts criam símbolos.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

A JNI define no cabeçalho 
\family typewriter 
jni.h
\family default 
 tipos em C equivalentes a cada um dos tipos primitivos de Java (
\family typewriter 
jint
\family default 
 para 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 para 
\family typewriter 
float
\family default 
, e assim por diante).
 Os 
\begin_inset Quotes eld
\end_inset 

tipos de referências
\begin_inset Quotes erd
\end_inset 

, como classes e objetos, são expostos a C como referências opacas, instâncias
 de 
\family typewriter 
jobject
\family default 
.
 Strings e arrays também são objetos em Java e são portanto também expostos
 como instâncias de
\family typewriter 
 jobject
\family default 
.
 Entretanto, a JNI define como conveniência alguns tipos em C que agem como
 
\begin_inset Quotes eld
\end_inset 

subtipos
\begin_inset Quotes erd
\end_inset 

 de 
\family typewriter 
jobject
\family default 
: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, além de um tipo array para cada tipo primitivo (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 O tipo 
\family typewriter 
jvalue
\family default 
 é uma 
\emph on 
union
\emph default 
 dos tipos primitivos e de referências.
 O valor C 
\family typewriter 
NULL
\family default 
 equivale a 
\family typewriter 
null
\family default 
 em Java.
\layout Standard

Diferentes métodos são utilizados para a leitura de tipos primitivos, strings,
 arrays e outros objetos.
 A leitura do conteúdo de uma 
\family typewriter 
jstring
\family default 
 em C requer a conversão do formato interno usado por Java, UTF-16.
 A API oferece uma função utilitária que aloca uma string contendo a representaç
ão do texto em UTF-8 (formato compatível com ASCII), 
\family typewriter 
GetStringUTFChars
\family default 
.
 Esta string deve ser posteriormente desalocada com 
\family typewriter 
ReleaseString\SpecialChar \-
UTFChars
\family default 
.
 A função 
\family typewriter 
GetStringChars
\family default 
 permite acesso direto à string em formato UTF-16; ela possui um parâmetro
 de saída que indica se a string retornada é o 
\emph on 
buffer
\emph default 
 interno da JVM ou uma cópia.
 Ao mesmo tempo que isto permite ao código C evitar duplicação da string
 nos casos onde deseja-se modificá-la e a JVM tenha optado por retornar
 uma cópia, tal parâmetro expõe na API questões de baixo nível da gerência
 de strings na JVM.
 Alternativamente, as funções 
\family typewriter 
GetStringRegion
\family default 
 e 
\family typewriter 
GetStringUTFRegion
\family default 
 realizam a cópia da string para um buffer pré-alocado pelo programador.
 
\family typewriter 
GetStringCritical
\family default 
 permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
 cuidados especiais em relação à coleta de lixo, discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays de elementos primitivos são tratados de forma similar a strings,
 diferentemente de arrays de objetos
\begin_inset Foot
collapsed true

\layout Standard

Arrays multi-dimensionais são considerados 
\begin_inset Quotes eld
\end_inset 

arrays de arrays
\begin_inset Quotes erd
\end_inset 

 e, portanto, são, exceto na última dimensão, também arrays de objetos.
\end_inset 

.
 Há funções para realizar a cópia de arrays (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), funções que retornam ponteiros para o array podendo ou não realizar cópias,
 de forma similar a 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) e que podem acessar o buffer interno da JVM diretamente, como em 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 Para arrays de objetos, é possível apenas obter elementos do array um a
 um, sob forma de referências 
\family typewriter 
jobject
\family default 
, com 
\family typewriter 
GetObjectArrayElement
\family default 
.
\layout Standard

A obtenção de valores de atributos se dá através de métodos como 
\family typewriter 
GetObjectField
\family default 
 e 
\family typewriter 
GetStaticField
\family default 
, que retornam referências do tipo 
\family typewriter 
jobject
\family default 
.
 Para cada um dos tipos primitivos existe uma chamada equivalente, como
 
\family typewriter 
GetIntField
\family default 
 e 
\family typewriter 
GetStaticIntField
\family default 
.
 Todas estas funções recebem como parâmetro um 
\emph on 
identificador de campo
\emph default 
, do tipo 
\family typewriter 
jfieldID
\family default 
.
 Estes valores são obtidos com uma chamada a 
\family typewriter 
GetFieldID
\family default 
, que recebe entre seus parâmetros uma string chamada de 
\begin_inset Quotes eld
\end_inset 

descritor de campo JNI
\begin_inset Quotes erd
\end_inset 

 com uma sintaxe especial.
 Por exemplo, o tipo Java 
\family typewriter 
int[][]
\family default 
 é descrito com 
\family typewriter 
"[[I"
\family default 
 e o tipo 
\family typewriter 
java.lang.String
\family default 
 como 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este é outro ponto onde detalhes da implementação transparecem na API.
 Não por coincidência, esta sintaxe é a mesma usada na representação interna
 de tipos em 
\emph on 
bytecodes
\emph default 
 da JVM.
\end_inset 

.
 É possível ainda obter um 
\family typewriter 
jfieldID
\family default 
 a partir de um objeto 
\family typewriter 
java.lang.reflect.Field
\family default 
 usando a função 
\family typewriter 
FromReflectedField
\family default 
.
 Diferentemente de 
\family typewriter 
ID
\family default 
s de Ruby, 
\family typewriter 
jfieldID
\family default 
s contêm informação de tipo e são específicos para o campo de uma determinada
 classe.
 
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExemploJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elementos = { "Terra", "Ar", "Fogo", "Agua" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaração do método implementado externamente */
\layout LyX-Code


\size footnotesize 
   private native void segundoElemento();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Cria uma instância e invoca o método nativo */
\layout LyX-Code


\size footnotesize 
      new ExemploJNI().segundoElemento();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Carrega o código externo na JVM que
\layout LyX-Code


\size footnotesize 
\emph on 
         implementará o método segundoElemento */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExemploJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Classe Java contendo um método implementado externamente
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExemploJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExemploJNI_segundoElemento(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter a classe ExemploJNI (this) */
\layout LyX-Code


\size footnotesize 
   jclass classe = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o campo ExemploJNI.elementos, de tipo String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, classe,
\layout LyX-Code


\size footnotesize 
      "elementos", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o conteúdo do campo ExemploJNI.elementos */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elementos[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* obter representação de elems_1 como uma string C */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* exibir a string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* liberar memória da string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

Código C implementando um método Java
\end_inset 


\layout Standard

O acesso a atributos Java em código C é ilustrado através do seguinte exemplo.
 Inicialmente, na Figura 
\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, é implementada uma classe Java que possui um atributo privado, o array
 
\family typewriter 
elementos
\family default 
, e define uma função, 
\family typewriter 
segundoElemento
\family default 
, a ser implementada em C
\begin_inset Foot
collapsed true

\layout Standard

Os detalhes sobre a declaração e registro de funções implementadas em C
 serão discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

A implementação de 
\family typewriter 
segundoElemento
\family default 
 é mostrada na Fig.
 
\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, mostrando a seqüência de chamadas até obter em C o elemento do array Java.
 Para acessar o atributo 
\family typewriter 
elementos
\family default 
, a função deve obter o identificador do campo.
 Para tal, devemos inicialmente obter uma referência da classe atual com
 
\family typewriter 
GetObjectClass
\family default 
 a partir da referência ao objeto (
\family typewriter 
this
\family default 
) passada como parâmetro à função.
 De posse da referência da classe (
\family typewriter 
classe
\family default 
), obtemos o identificador do campo com 
\family typewriter 
GetFieldID
\family default 
.
 O conteúdo do campo é então obtido com 
\family typewriter 
GetObjectField
\family default 
: uma referência para o array.
 Com este, o elemento do array é obtido com 
\family typewriter 
GetObjectArrayElement
\family default 
.
 Uma cópia do elemento, convertido para uma string C codificada em UTF-8,
 é retornada com 
\family typewriter 
GetStringUTFChars
\family default 
.
 Como discutido anteriormente, após o uso, a string deve ser liberada com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

É interessante ainda notar que as chamadas à JNI têm o formato 
\family typewriter 
(*J)->
\family default 
\emph on 
função
\family typewriter 
\emph default 
(J, ...)
\family default 
: funções da JNI são acessadas através de ponteiros para função armazenados
 em uma tabela apontada pela estrutura 
\family typewriter 
JNIEnv
\family default 
, que por sua vez é propagada nas chamadas.
 O objetivo destes dois níveis de indireção é desacoplar a ligação das chamadas
 no código C e a biblioteca que implementa a JNI, permitindo ligar o código
 em tempo de execução a diferentes implementações da JVM 
\begin_inset LatexCommand \cite{stepanian-jni}

\end_inset 

.
\layout Standard

A manipulação de objetos do tipo 
\family typewriter 
Class
\family default 
 também é feita através de funções específicas.
 É possível criar uma nova classe Java em tempo de execução a partir da
 API C usando a função 
\family typewriter 
DefineClass
\family default 
, que recebe um buffer contendo a representação de uma classe Java pré-compilada.
 Referências do tipo 
\family typewriter 
jclass
\family default 
 podem ser obtidas através do nome da classe usando 
\family typewriter 
FindClass
\family default 
, que utiliza uma sintaxe de descritores de classe similar à de descritor
 de campos usada por 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Tanto em descritores de classe como de campo, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 representam 
\family typewriter 
String[]
\family default 
.
 Para o tipo 
\family typewriter 
String
\family default 
, entretanto, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 é o descritor de campo e 
\family typewriter 
"java/lang/String"
\family default 
 o de classe.
\end_inset 

.
\layout Standard

Para a atribuição de valores de C que podem ser convertidos para tipos primitivo
s de Java, a JNI possui funções como 
\family typewriter 
SetIntField
\family default 
 e 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 Para os demais tipos, não há uma provisão específica para o armazenamento
 de dados de C no espaço de objetos de Java.
 Nestes casos, a documentação sugere o armazenamento de ponteiros em tipos
 numéricos, apesar dos problemas de portabilidade em que tal abordagem incorre.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

A API de Lua define uma abordagem diferente para a manipulação de dados
 em C: não são expostos ao código C ponteiros ou 
\emph on 
handles
\emph default 
 para objetos Lua.
 As operações são definidas em termos de índices de uma pilha virtual.
 Assim, a transferência de dados de C para Lua se dá através de funções
 que recebem tipos de C, os convertem para valores Lua e os empilham, como
 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 e 
\family typewriter 
lua_pushlstring
\family default 
.
 Diversas operações da API operam sobre o valor no topo da pilha, como por
 exemplo 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

O parâmetro 
\family typewriter 
L
\family default 
 será explicado mais adiante, na Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Insere o número 123 na pilha */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Atribui o número 123 na global 
\emph default 
foo
\emph on 
 */
\layout Standard

A maioria das funções de consulta, entretanto, permitem especificar um índice
 qualquer da pilha (com valores positivos para indexação a partir da base
 e negativos para índices a partir do topo).
\layout Standard

A conversão de dados de Lua para C é feita através de funções como 
\family typewriter 
lua_tonumber
\family default 
 e 
\family typewriter 
lua_tolstring
\family default 
, que recebem um índice da pilha, convertem o valor no índice para o tipo
 Lua especificado, e retornam o valor no tipo C equivalente.
 Números têm o tipo C 
\family typewriter 
lua_Number
\family default 
, que corresponde a 
\family typewriter 
double
\family default 
 por padrão mas é um parâmetro na compilação de Lua.
 Strings, em particular, são objetos imutáveis e têm sua representação internali
zada: duas strings de conteúdo idêntico compartilham a mesma representação
 interna.
\layout Standard

Assim, diferentemente de linguagens como Python e Ruby, não é possível modificar
 o conteúdo de uma string Lua através de C via a sua representação em memória
 como um 
\family typewriter 
char*
\family default 
.
 Para tornar mais eficiente a construção em etapas de strings Lua a partir
 de C, a biblioteca auxiliar define um tipo C 
\family typewriter 
luaL_Buffer
\family default 
 e funções como 
\family typewriter 
luaL_addstring
\family default 
 e 
\family typewriter 
luaL_addvalue
\family default 
, que permitem a construção de uma string em etapas até que ela possa ser
 finalmente convertida para uma string Lua com 
\family typewriter 
luaL_pushresult
\family default 
.
 Assim, evitam-se consecutivas operações de concatenação de string através
 da API de Lua.
\layout Standard

Lua define dois tipos de dados específicos para o armazenamento de dados
 para C, 
\emph on 
full userdata
\emph default 
 e 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 descrevem blocos de memória gerenciados por Lua e utilizados por código
 C.
 Eles existem em Lua como objetos opacos, e são criados por 
\family typewriter 
lua_newuserdata
\family default 
, que insere o novo objeto na pilha de Lua e retorna a C um ponteiro com
 a área de memória do tamanho requisitado.
 Objetos do tipo 
\emph on 
light userdata
\emph default 
, criados através de 
\family typewriter 
lua_pushlightuserdata
\family default 
, permitem armazenar ponteiros de C em Lua; a alocação e gerência do bloco
 de memória ficam a cargo do código C.
 O seguinte exemplo ilustra as diferenças entre full e light userdata.
 Comparemos a criação de dois objetos, assumindo a mesma struct 
\family typewriter 
point
\family default 
 definida na seção anterior.
 Primeiro, a criação de um full userdata:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o full userdata e o insere na pilha e retorna
\layout LyX-Code


\size footnotesize 
\emph on 
   o ponteiro para C.
 A memória é alocada por Lua.
 */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Utilizamos então o ponteiro em C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o objeto à variável global Lua 
\emph default 
PontoFull
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "PontoFull");
\layout Standard


\family roman 
E, em seguida, de um light userdata:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Aloca um 
\emph default 
point
\emph on 
 a ser referenciado via light userdata.
 */
\layout LyX-Code


\size footnotesize 
point* light_p = (point*) malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena o ponteiro na pilha de Lua.
 O bloco de memória
\layout LyX-Code


\size footnotesize 
\emph on 
   para que ele aponta ainda é responsabilidade do código C.
 */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, light_p);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Utilizamos então o ponteiro em C...
 */
\layout LyX-Code


\size footnotesize 
light_p->x = 100; light_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o objeto à variável global 
\emph default 
PontoLight
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "PontoLight");
\layout Standard


\family roman 
O acesso a ambos é 
\family default 
feito de forma 
\family roman 
igual:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Empilha as globais 
\emph default 
PontoFull
\emph on 
 e 
\emph default 
PontoLight
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "PontoFull");
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "PontoLight");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro C do userdata no topo da pilha (posição -1),
\layout LyX-Code


\size footnotesize 
\emph on 
   e o do userdata logo abaixo dele (posição -2) */
\layout LyX-Code


\size footnotesize 
point* pl = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
point* pf = (point*) lua_touserdata(L, -2);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d), (%d,%d)
\backslash 
n", pl->x, pl->y, pf->x, pf->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restaura a pilha à posição original, removendo os 2 itens.
\layout LyX-Code


\size footnotesize 
\emph on 
   Eles não serão coletados pois estão associados às variáveis globais.
 */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 2);
\layout Standard

A desalocação dos objetos, entretanto, ocorre de forma diferente, já que
 um bloco de memória é gerenciado por Lua e outro por C.
 Assumindo que a global 
\family typewriter 
PontoFull
\family default 
 é a única referência para este bloco, para liberá-lo basta sobrescrevermos
 
\family typewriter 
PontoFull
\family default 
, por exemplo, com 
\family typewriter 
nil
\family default 
; a memória do full userdata poderá então ser liberada pelo coletor de lixo,
 como a de qualquer valor Lua sem referências.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "PontoFull");
\layout Standard

Para light userdata, devemos obter o ponteiro e liberar a memória manualmente,
 em C.
 Como usaremos 
\family typewriter 
free
\family default 
 de forma explícita,
\emph on 
 
\emph default 
a memória é liberada instantaneamente.
 Entretanto, se houverem outros light userdata apontando para este bloco,
 eles passarão a conter ponteiros inválidos.
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "PontoLight");
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
free(p);
\layout Standard

A área de armazenamento da pilha não se ajusta dinamicamente e as funções
 da API não realizam controle de 
\emph on 
overflow
\emph default 
.
 Assim, o programador é responsável por controlar o tamanho da pilha, através
 da função 
\family typewriter 
lua_checkstack
\family default 
.
 Na prática, o tamanho da pilha só irá crescer na ocorrência de laços empilhando
 elementos, já que seqüências típicas de operações tendem a empilhar valores
 e desempilhá-los em seguida.
\layout Standard

Tabelas são o único tipo para construção de estruturas de dados em Lua.
 Lua oferece uma API completa para manipulação de tabelas a partir de C.
 Tabelas podem ser criadas com 
\family typewriter 
lua_newtable
\family default 
 ou 
\family typewriter 
lua_createtable
\family default 
; a segunda forma permite pré-alocar memória para os elementos da tabela.
 As funções 
\family typewriter 
lua_gettable
\family default 
 e 
\family typewriter 
lua_settable
\family default 
 implementam a semântica de leitura e atribuição de campos em uma tabela
 em Lua, incluindo a possível chamada a metamétodos; para chamadas sem a
 invocação de metamétodos existem as funções 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, equivalentes a 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 em Lua (além das variantes 
\family typewriter 
lua_rawgeti
\family default 
 e 
\family typewriter 
lua_rawseti
\family default 
 para conveniência).
 Há ainda a função 
\family typewriter 
lua_next
\family default 
, equivalente à função Lua 
\family typewriter 
next
\family default 
, que permite percorrer os elementos de uma tabela.
 Um exemplo de manipulação de tabelas é dado a seguir:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tabela["chave"] = 12345, em C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tabela");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "chave");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable insere na tabela especificada como argumento
\layout LyX-Code


\size footnotesize 
\emph on 
   o item localizado no topo da pilha,
\layout LyX-Code


\size footnotesize 
\emph on 
   usando como chave o elemento logo abaixo do topo: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard

Diversos conceitos de Lua são representados através de tabelas -- ambiente
 global, metatabelas, registro -- e são assim tratados em C usando as funções
 da API para manipulação de tabelas.
 A tabela do ambiente global da 
\emph on 
thread
\emph default 
 em execução pode ser acessada através de um índice especial da pilha virtual,
 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 Pode-se ainda definir uma tabela de ambiente da função, indexada em 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, para isolar dados a serem compartilhados internamente em funções de módulos
 escritos em C.
 Neste exemplo, mostramos como o ambiente global pode ser manipulado como
 uma tabela:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Isto...
 */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "PontoLight");
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...equivale a: */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "PontoLight");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

Os processos de estender e embutir Perl são bastante distintos.
 Para extensões, Perl oferece uma linguagem para descrição de interfaces
 chamada XS.
 Ao invés de isolar o acesso às estruturas internas de Perl através de uma
 API pública, a abordagem proposta é encapsular o processo de geração de
 código 
\emph on 
wrapper
\emph default 
 para a comunicação entre funções escritas em C e as estruturas internas
 de Perl usando interfaces escritas em XS.
 Arquivos 
\family typewriter 
.xs
\family default 
 contêm código C acompanhado de anotações que simplificam o tratamento dos
 parâmetros de entrada e saída.
 Estes são alimentados ao pré-processador 
\family typewriter 
xsubpp
\family default 
, que geram então o código usando a API oferecida pela biblioteca de Perl.
 Esta biblioteca oferece acesso de baixo nível ao funcionamento do interpretador
, permitindo, por exemplo, manipular o ponteiro da sua pilha interna.
 O objetivo de XS é ocultar ao desenvolvedor de extensões estes detalhes.
\layout Standard

Para embutir o interpretador Perl em uma aplicação, a biblioteca que a implement
a oferece algumas funções que permitem disparar um interpretador.
 Na API de mais alto nível, pode-se construir um array de parâmetros a serem
 passados para o interpretador de forma equivalente às opções do interpretador
 Perl de linha de comando, inclusive usando a opção 
\family typewriter 
"-e"
\family default 
 para executar trechos de código.
\layout Standard

Os tipos de variáveis Perl são mapeados para structs em C: 
\family typewriter 
SV
\family default 
 para escalares, 
\family typewriter 
AV
\family default 
 para arrays, 
\family typewriter 
HV
\family default 
 para hashes.
 Estes valores C são melhor entendidos como 
\emph on 
containers
\emph default 
 para valores Perl: uma variável escalar em Perl tem um 
\family typewriter 
SV
\family default 
 associado a si; todavia, pode-se criar em C um 
\family typewriter 
SV
\family default 
 que não esteja associado a nenhum nome de variável Perl.
\layout Standard

Os 
\emph on 
typedefs
\emph default 
 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 e 
\family typewriter 
PV
\family default 
 representam valores C correspondentes aos tipos primitivos de Perl, e correspon
dem, respectivamente, a inteiros com e sem sinal, valores de ponto flutuante
 e strings.
 Estes valores podem ser copiados para 
\family typewriter 
SV
\family default 
s.
 Referências Perl são representadas como 
\family typewriter 
RV
\family default 
, e também são um tipo de 
\family typewriter 
SV
\family default 
.
 Há ainda o tipo 
\family typewriter 
GV
\family default 
, capaz de referenciar qualquer tipo representável em uma variável Perl.
\layout Standard

Variáveis do espaço de Perl são acessadas com 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 e 
\family typewriter 
get_hv
\family default 
.
 Estas funções recebem uma string C com o nome da variável (possivelmente
 qualificado da forma 
\family typewriter 
"pacote::variavel"
\family default 
).
 O conteúdo de valores escalares é convertido de volta para um tipo C com
 as macros 
\family typewriter 
Sv
\family default 
*: 
\family typewriter 
SvIV
\family default 
 retorna um inteiro, 
\family typewriter 
SvPV
\family default 
 retorna um 
\family typewriter 
char*
\family default 
 e o comprimento da string no segundo parâmetro, etc.
 O seguinte código C exibe o conteúdo da variável Perl 
\family typewriter 
$a
\family default 
, assumindo que ela contenha um valor inteiro:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard

A flag passada como segundo parâmetro de 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 Passando um nome de variável inexistente e usando 
\family typewriter 
TRUE
\family default 
 no segundo parâmetro de , criamos uma nova variável acessível no espaço
 de C já realizando o 
\emph on 
binding
\emph default 
 do nome no espaço de Perl.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria uma variável do tipo array,
\layout LyX-Code


\size footnotesize 
\emph on 
   acessível em Perl como a global @arr e em C como o AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard

Um 
\family typewriter 
SV
\family default 
 pode ser criado em C com as funções 
\family typewriter 
newSV
\family default 
*: 
\family typewriter 
newSViv
\family default 
 gera um novo 
\family typewriter 
SV
\family default 
 armazenando um inteiro com sinal; 
\family typewriter 
newSVpv
\family default 
 a partir de uma string, e assim por diante.
 A função 
\family typewriter 
newSV
\family default 
 permite criar um 
\family typewriter 
SV
\family default 
 com área de memória não inicializada, acessível através da função 
\family typewriter 
SvPVX
\family default 
, permitindo assim criar escalares com valores arbitrários gerenciados por
 código C.
 Usando o mesmo exemplo da struct 
\family typewriter 
point
\family default 
 das seções anteriores, podemos armazenar um objeto C em um valor Perl da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Aloca um SV não inicializado do tamanho de um 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro para a área de memória do 
\emph default 
SV
\emph on 
 */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipula o 
\emph default 
point
\emph on 
 em C.
 Quando v for retornado para Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
ele será uma variável opaca (seu conteúdo não será acessível via Perl).
 */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard

Valores são atribuídos a 
\family typewriter 
SV
\family default 
s usando as funções 
\family typewriter 
sv_set
\family default 
*: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 As funções para manipulação de strings possuem variantes como 
\family typewriter 
newSVpvn
\family default 
 e 
\family typewriter 
sv_setpvf
\family default 
, que permitem especificar o comprimento da string ou realizar formatação
 como em 
\family typewriter 
sprintf
\family default 
.
 Para strings, há ainda funções 
\family typewriter 
sv_cat
\family default 
*, que atuam como 
\family typewriter 
sv_set
\family default 
* mas concatenam o valor dado ao conteúdo atual da string ao invés de substituí-
lo.
 A função 
\family typewriter 
sv_setsv
\family default 
 copia o valor de um 
\family typewriter 
SV
\family default 
 para outro.
 O 
\family typewriter 
SV
\family default 
 criado no exemplo anterior pode ser atribuído para uma variável global
 da seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o SV da variável global 
\emph default 
$ponto
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* ponto = get_sv("ponto", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o valor de v para ponto */
\layout LyX-Code


\size footnotesize 
sv_setsv(ponto, v);
\layout Standard

O tipo dos dados armazenados em 
\family typewriter 
SV
\family default 
s é verificado com as macros 
\family typewriter 
SvIOK
\family default 
 para inteiros, 
\family typewriter 
SvNOK
\family default 
 para valores de ponto flutuante e 
\family typewriter 
SvPOK
\family default 
 para strings.
 Estas funções retornam sucesso se o escalar é conversível para o tipo especific
ado -- as variantes 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verificam se o valor armazenado no 
\family typewriter 
SV
\family default 
 é realmente do tipo.
\layout Standard

Arrays e hashes são criados com 
\family typewriter 
newAV
\family default 
 e 
\family typewriter 
newHV
\family default 
.
 Arrays podem ser populados com um array C de ponteiros para 
\family typewriter 
SV
\family default 
 através de 
\family typewriter 
av_make
\family default 
.
 Operações como 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 e 
\family typewriter 
hv_exists
\family default 
 permitem operar sobre elementos das estruturas -- referências para elementos
 são retornadas como ponteiros para 
\family typewriter 
SV
\family default 
.
 No exemplo a seguir, criaremos um array Perl contendo os 10 primeiros elementos
 da série de Fibonacci:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria um novo array.
 */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena dois valores, 0 e 1, nas primeiras posições do array.
 */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviamente seria mais eficiente armazenar os valores em variáveis
\layout LyX-Code


\size footnotesize 
\emph on 
      temporárias em C, mas obtenhamos os dois últimos valores da
\layout LyX-Code


\size footnotesize 
\emph on 
      seqüência de volta do array Perl para fins de ilustração: */
\layout LyX-Code


\size footnotesize 
   SV** penultimo_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** ultimo_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém os inteiros armazenados nos SVs */
\layout LyX-Code


\size footnotesize 
   int penultimo = SvIV(*penultimo_sv);
\layout LyX-Code


\size footnotesize 
   int ultimo = SvIV(*ultimo_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um novo SV e o insere no final do array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( penultimo + ultimo ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Uma vez criado este 
\family typewriter 
AV
\family default 
, entretanto, não há uma forma de associá-lo a uma variável Perl.
 Seu conteúdo deve ser copiado item a item.
 Para que este seja acessível a partir de Perl, deveríamos tê-lo criado
 com 
\family typewriter 
get_av
\family default 
, e não 
\family typewriter 
newAV
\family default 
.
 A utilidede de 
\family typewriter 
AV
\family default 
s não associados a variáveis está na passagem de parâmetros na chamada de
 funções e como valores de retorno.
\layout Standard

Algumas funções para manipulação de hashes expõem os pares chave/valor como
 ponteiros 
\family typewriter 
HE
\family default 
.
 As macros 
\family typewriter 
HeSVKEY
\family default 
 e 
\family typewriter 
HeVAL
\family default 
 permitem extrair a chave e valor de um 
\family typewriter 
HE
\family default 
.
 A seguinte função exibe em C os elementos de uma hash Perl:
\layout LyX-Code


\size footnotesize 
void imprime_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cada HV mantém o seu controle interno de iteração */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém o próximo par chave/valor da iteração */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém a representação string dos escalares
\layout LyX-Code


\size footnotesize 
\emph on 
         representando chave e valor do item */
\layout LyX-Code


\size footnotesize 
      char* chave = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* valor = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", chave, valor);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Cuidados especiais devem ser tomados ao utilizar os valores 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em arrays e hashes, embora Perl exponha estas constantes na API de C (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 A constante 
\family typewriter 
PL_sv_undef
\family default 
 é usada internamente na implementação de 
\family typewriter 
AV
\family default 
s e 
\family typewriter 
HV
\family default 
s, e a atualização de valores em 
\family typewriter 
HV
\family default 
s ocorre 
\emph on 
in-place
\emph default 
, o que gera problemas ao atualizar elementos contendo estas constantes.
 A documentação recomenda gerar cópias destes valores ao usá-los em estruturas
 
\family typewriter 
AV
\family default 
 e 
\family typewriter 
HV
\family default 
 
\begin_inset LatexCommand \cite{perlguts}

\end_inset 

.
\layout Standard

Referências Perl são criadas com 
\family typewriter 
newRV_inc
\family default 
 e 
\family typewriter 
newRV_noinc
\family default 
, que recebem um ponteiro para 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 como parâmetro (as duas funções diferem entre si no que tange à contagem
 de referências, que será abordada na Seção 
\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 O valor apontado por uma referência é obtido com 
\family typewriter 
SvRV
\family default 
.
 O retorno desta macro deve ser convertido via 
\emph on 
cast
\emph default 
 para o tipo apropriado (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), que pode ser verificado com 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Diversas funções da API têm tipo de parâmetros ou retorno declarados como
 
\family typewriter 
SV
\family default 
 quando na verdade aceitam 
\family typewriter 
AV
\family default 
s ou 
\family typewriter 
HV
\family default 
s; isto é análogo ao conceito de 
\emph on 
contextos
\emph default 
 de Perl, onde um mesmo valor pode ser tratado como lista (array ou hash)
 ou escalar dependendo da expressão onde ele é inserido.
 Em código Perl, o contexto em que uma função está executando pode ser verificad
o com 
\family typewriter 
wantarray
\family default 
.
 Em C, o contexto pode ser verificado com a macro 
\family typewriter 
GIMME_V
\family default 
, que retorna 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 ou 
\family typewriter 
G_ARRAY
\family default 
.
\layout Section

Coleta de lixo
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

A partir do momento em que código C ganha acesso a referências a dados armazenad
os no espaço de armazenamento de outra linguagem, sejam ponteiros ou identificad
ores, o programador deve levar em consideração as diferenças entre os modelos
 de gerência de memória envolvidos, já que código executado na outra linguagem
 pode liberar o dado (destruir o objeto, remover um elemento de uma estrutura).
 Em princípio, isto não é diferente da gerência de memória realizada normalmente
 pelo programador em C.
 Entretanto, a interação com algumas linguagens adiciona um complicador:
 mecanismos de coleta de lixo realizam liberação de dados da memória de
 forma implícita.
 O princípio fundamental da coleta de lixo dita que um objeto não é coletado
 caso haja algum elemento (variável, estrutura de dados) apontando para
 ele.
 Todavia, o mesmo não vale para o ambiente C: a presença de um ponteiro
 apontando para um objeto não garante que ele não será coletado, uma vez
 que o coletor de lixo não gerencia os ponteiros do código C.
\layout Standard

É preciso, então, indicar a partir do código C que os dados que continuam
 acessíveis por ele não devem ser coletados.
 De forma complementar, ao transferir o controle de objetos C para o domínio
 da outra linguagem---por exemplo, para armazená-los em uma estrutura de
 dados desta---é necessário indicar à linguagem como desalocar a memória
 da estrutura quando o coletor de lixo detectar que ela não está mais em
 uso.
 A forma como a FLI irá fornecer estas funcionalidades depende não só do
 projeto da API para C, mas também do modelo de coleta de lixo empregado
 pela implementação da linguagem.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

A máquina virtual de Python possui um coletor de lixo baseado em contagem
 de referências.
 Como a API de Python retorna ao código C ponteiros a 
\family typewriter 
PyObject
\family default 
s, o programador deve ter o cuidado de garantir que eles se mantenham válidos.
 Para isto, é necessário incrementar e decrementar o contador de referências
 do objeto apontado conforme deseja-se manter a validade dos ponteiros em
 código C.
\layout Standard

De maneira geral, uma vez que código C deseja reter um 
\family typewriter 
PyObject*
\family default 
, ele deve utilizar a macro 
\family typewriter 
Py_INCREF
\family default 
 para incrementar a sua contagem de referências e assim impedi-lo de ser
 coletado.
 Uma vez que o valor não seja mais necessário, decrementa-se a contagem
 similarmente com 
\family typewriter 
Py_DECREF
\family default 
.
 Python trabalha com o conceito de 
\emph on 

\begin_inset Quotes eld
\end_inset 

propriedade de referências
\begin_inset Quotes erd
\end_inset 


\emph default 
 para definir quando o programador deve incrementar ou decrementar o contador
 de referências retornadas pelas funções da API.
 A maior parte das funções da API que retornam ponteiros a 
\family typewriter 
PyObject
\family default 
s 
\emph on 
transferem
\emph default 
 referências para o chamador; a referência passa então a ser sua responsabilidad
e -- ele pode passá-la adiante ou terá o dever de decrementá-la com 
\family typewriter 
Py_DECREF
\family default 
 assim que não precisar mais usá-la (o código C pode guardar referências
 que sejam de sua propriedade em suas estruturas de dados; elas continuarão
 válidas mesmo após o retorno da função, até serem explicitamente decrementadas).
 Outras funções 
\emph on 
emprestam
\emph default 
 referências; o código que recebe uma referência deste tipo não precisa
 decrementá-la ao terminar de utilizá-la, mas a validade do objeto está
 atrelado à validade da referência no objeto que a retornou ao código C.
 Por exemplo, 
\family typewriter 
PyList_GetItem
\family default 
 empresta uma referência a um elemento da lista.
 O ponteiro retornado continuará válido enquanto este item continuar contido
 na lista.
 Pode-se obter a 
\begin_inset Quotes eld
\end_inset 

propriedade
\begin_inset Quotes erd
\end_inset 

 de uma referência emprestada incrementando a contagem do objeto com 
\family typewriter 
Py_INCREF
\family default 
: a validade do ponteiro passa a ser independente o objeto 
\emph on 
container
\emph default 
 que o retornou, mas o código C passa a ser responsável por decrementar
 a referência posteriormente com 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

Para referências de objetos passadas de código C de volta para Python, há
 dois casos na API em que funções 
\emph on 

\begin_inset Quotes eld
\end_inset 

roubam
\begin_inset Quotes erd
\end_inset 


\emph default 
 referências, isto é, em que a referência deixa de pertencer à função C
 chamadora: 
\family typewriter 
PyList_SetItem
\family default 
 e 
\family typewriter 
PyTuple_SetItem
\family default 
.
 A referência passada, que deve pertencer ao chamador, passa então a ser
 uma referência emprestada após a chamada.
 O objetivo disto é permitir chamadas de função aninhadas onde, por exemplo,
 o parâmetro de 
\family typewriter 
PyList_SetItem
\family default 
 é uma chamada gera um novo objeto a ser armazenado na lista.
 Assim, evita-se que o programador tenha que armazenar um ponteiro para
 o objeto apenas para decrementar a sua referência posteriormente.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Acesso possivelmente inválido em 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 é garantidamente válido em 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Acesso possivelmente inválido a uma referência a um 
\family typewriter 
PyObject
\family default 
 em código C
\end_inset 


\layout Standard

A interação com o contador de referências pode ser bastante sutil.
 O exemplo da Figura 
\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extraído da documentação de Python, demonstra que uma referência pode
 ser invalidada por código aparentemente não relacionado
\begin_inset Foot
collapsed true

\layout Standard

De fato, a documentação informa que versões antigas de Python continham
 variantes deste 
\emph on 
bug
\emph default 
 em alguns de seus módulos.
\end_inset 

.
 À primeira vista, a inclusão de um elemento em 
\family typewriter 
list[1]
\family default 
 parece não afetar a referência 
\family typewriter 
item
\family default 
, que corresponde a 
\family typewriter 
list[0]
\family default 
.
 Todavia, a inclusão de 
\family typewriter 
list[1]
\family default 
 pode haver removido da lista um elemento que se encontrava nesta posição.
 Caso a lista fosse a última referência válida para o elemento, este poderia
 ser coletado.
 A coleta do objeto pode invocar o seu método finalizador 
\family typewriter 
__del__
\family default 
, que pode rodar código Python arbitrário.
 Se este código remove o elemento da posição 0 de 
\family typewriter 
list
\family default 
 e isto causar a sua coleta, a referência 
\family typewriter 
item
\family default 
 passa a ser inválida, porque 
\family typewriter 
PyList_GetItem
\family default 
 retorna uma referência emprestada.
\layout Standard

Ao implementar funções em C que retornam referências a 
\family typewriter 
PyObject
\family default 
s, o mesmo cuidado de definir a política de tempo de vida da referência
 deve ser tomado.
 Para retornar uma referência nova, pode ser necessário incrementar a contagem
 do objeto.
 Isto se manifesta, por exemplo, na forma correta de uma função C retornar
 o valor 
\family typewriter 
None
\family default 
, que envolve chamar 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este padrão é tão comum que a seqüência 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 foi encapsulada na macro 
\family typewriter 
Py_RETURN_NONE
\family default 
.
\end_inset 

.
 Mesmo objetos Python representando números devem ter a sua contagem de
 referências controlada pelo programador C.
 
\layout Standard

Para que o código C possa realizar operações de finalização sobre os dados
 armazenados em um tipo Python definido em C, é possível definir uma função
 de desalocação no campo 
\family typewriter 
tp_dealloc
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo.
 Esta função é normalmente responsável por liberar recursos alocados via
 código C (arquivos abertos, ponteiros para áreas de memória não acessíveis
 por Python, etc.) e decrementar referências a outros objetos Python mantidas
 pelo objeto.
\layout Standard

Ao desalocar estruturas de dados como listas pode-se provocar uma cadeia
 arbitrariamente grande de desalocações, à medida que o decremento da contagem
 de referências de cada elemento reduz o número de referências do objeto
 seguinte da estrutura para zero, disparando a função de desalocação recursivame
nte.
 Isto pode facilmente causar estouro da pilha de C.
 Para contornar este problema, Python inclui um par de macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 e 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, que controla o número de níveis de recursão aceitos.
 Quando a pilha de chamadas excede um valor limite definido na constante
 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 (50 por padrão), 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 armazena o objeto em uma lista e salta diretamente para 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, adiando a execução da função de desalocação.
 Quando a pilha diminui de volta ao tamanho original, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 dispara novamente 
\family typewriter 
tp_dealloc
\family default 
 sobre os elementos da lista de pendências, reiniciando assim a recursão.
 
\layout Standard

O modelo de coleta de lixo utilizando contagem de referências traz consigo
 preocupações sobre referências circulares: uma cadeia de objetos que mantêm
 referências entre si mantém a contagem de cada um dos seus elementos acima
 de zero, mesmo que eles não sejam alcançáveis a partir de nenhum outro
 objeto.
 Python inclui um detector de ciclos, mas provisões especiais devem ser
 tomadas para que tipos implementados em C se comportem corretamente caso
 possam gerar ciclos.
 Deve-se implementar uma função para percorrer referências contidas no objeto
 e uma função que decremente a contagem destas referências.
 Estas funções devem ser registradas nos campos 
\family typewriter 
tp_traverse
\family default 
 e 
\family typewriter 
tp_clear
\family default 
 de 
\family typewriter 
PyTypeObject
\family default 
.
 A função 
\family typewriter 
tp_clear
\family default 
 deve ter o cuidado de zerar o valor de seus campos 
\family typewriter 
PyObject*
\family default 
 para 
\family typewriter 
NULL
\family default 
 antes de decrementar cada referência, uma vez que a operação de decremento
 pode iniciar a desalocação do objeto e disparar uma chamada a 
\family typewriter 
tp_traverse
\family default 
 que, devido ao ciclo, retorne ao objeto anterior.
 O tipo deve ser, então, identificado com a flag 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 em 
\family typewriter 
tp_flags
\family default 
.
\layout Standard

Além disso, a implementação de objetos Python que suportem coleta cíclica
 em C implica ainda em outros cuidados.
 Objetos devem ser alocados com 
\family typewriter 
PyObject_GC_New
\family default 
 ou 
\family typewriter 
PyObject_GC_NewVar
\family default 
 ao invés da funções usuais 
\family typewriter 
PyObject_New
\family default 
 e 
\family typewriter 
PyObject_NewVar
\family default 
.
 Durante a construção do objeto, após os campos a serem visitados por tp_travers
e terem sido preenchidos, é necessário ainda chamar uma função de notificação
 
\family typewriter 
PyObject_GC_Track
\family default 
 e durante a desalocação, antes de invalidar os campos do objeto, chamar
 
\family typewriter 
PyObject_GC_UnTrack
\family default 
.
 Para objetos que necessitem do mecanismo de 
\emph on 

\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 


\emph default 
 para evitar estouro de pilha, é ainda preciso tomar o cuidado de desmarcar
 o objeto com 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 antes de entrar no bloco 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
.
\layout Comment

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\layout Standard

Apesar de oferecer um mecanismo de detecção de ciclos, Python é incapaz
 de coletar ciclos cujos objetos contenham finalizadores implementados em
 Python (métodos 
\family typewriter 
__del__
\family default 
); a única forma de acessar estes objetos é então através da lista 
\family typewriter 
garbage
\family default 
 no módulo 
\family typewriter 
gc
\family default 
.
 Este módulo (acessível a partir de C através de chamadas de função Python
 via API) oferece uma interface com o coletor de lixo, incluindo funções
 como 
\family typewriter 
enable
\family default 
 e 
\family typewriter 
disable
\family default 
, para ativar e desativar o coletor de lixo; 
\family typewriter 
collect
\family default 
 para executar uma coleta; 
\family typewriter 
get_objects
\family default 
, que retorna uma lista contendo todos os objetos controlados pelo coletor
 (exceto a própria lista); 
\family typewriter 
get_referrers
\family default 
 e 
\family typewriter 
get_referents
\family default 
, que retornam a lista de objetos que referenciam ou são referenciados por
 um dado objeto -- estas listas são obtidas percorrendo objetos com a função
 
\family typewriter 
tp_traverse
\family default 
, o que pode não apontar para todos os objetos realmente alcançáveis, ou
 ainda retornar objetos em estado inválido (como objetos em ciclos ainda
 não coletados ou objetos ainda não totalmente construídos) e assim devem
 ser usadas apenas para fins de depuração.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby utiliza um coletor de lixo 
\emph on 
mark-and-sweep
\emph default 
 
\begin_inset LatexCommand \cite{wilson-gc}

\end_inset 

: ele funciona em duas passadas, inicialmente marcando os objetos alcançáveis
 e depois percorrendo a lista completa de objetos coletando aqueles que
 não tenham sido marcados.
 Esta técnica evita o problema de referências cíclicas enfrentado por Python.
\layout Standard

Objetos Ruby criados com 
\family typewriter 
Data_Wrap_Struct
\family default 
 e 
\family typewriter 
Data_Make_Struct
\family default 
 contêm 
\emph on 
structs
\emph default 
 C que podem conter referências a 
\family typewriter 
VALUE
\family default 
s Ruby.
 A 
\emph on 
struct
\emph default 
 encapsulada, entretanto, é opaca para o universo Ruby.
 Então, para garantir que estes 
\family typewriter 
VALUE
\family default 
s sejam marcados como alcançáveis durante a coleta de lixo é necessário
 fazer isto via código C.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 e 
\family typewriter 
Data_Make_Struct
\family default 
 recebem, além da 
\emph on 
struct
\emph default 
 a encapsular, dois ponteiros, um para uma função de marcação e outra para
 uma função de desalocação.
 Quando o coletor de lixo visita o objeto na fase de marcação, ele invoca
 a função registrada, que deve chamar 
\family typewriter 
rb_gc_mark
\family default 
 em cada um dos 
\family typewriter 
VALUE
\family default 
s armazenados na 
\emph on 
struct
\emph default 
 do objeto, informando assim que os objetos são alcançáveis.
 Quando um objeto encapsulado via 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 for dado como não alcançável, a função de desalocação registrada é chamada.
 Para estruturas que não armazenam outros 
\family typewriter 
VALUE
\family default 
s, pode-se definir a função de marcação como 
\family typewriter 
NULL
\family default 
 e a de desalocação como 
\family typewriter 
free
\family default 
.
\layout Standard

Muitas funções de API de Ruby retornam 
\family typewriter 
VALUE
\family default 
s.
 Caso estes objetos não sejam alcançáveis a partir do espaço de objetos
 de Ruby -- por exemplo, tendo sido atribuídos a uma variável global Ruby
 ou inserido em alguma estrutura de dados alcançável em Ruby -- estes objetos
 estarão, a princípio, sujeitos à coleta de lixo.
 A documentação alerta que, para armazenar objetos Ruby em variáveis globais
 ou estruturas de dados de C, é necessário notificar à máquina virtual que
 o valor não deve ser coletado, usando 
\family typewriter 
rb_global_variable
\family default 

\begin_inset Foot
collapsed false

\layout Standard

Embora a documentação não informe, é possível desmarcar um valor global
 com 
\family typewriter 
rb_gc_unregister_address
\family default 
.
\end_inset 

.
\layout Standard

Objetos de escopo local a uma função C, entretanto, não precisam ser notificados.
 A forma como Ruby garante a validade de 
\family typewriter 
VALUE
\family default 
s locais é bastante peculiar: ao realizar a fase de marcação, o coletor
 de lixo varre a pilha de C em busca de valores que se pareçam com endereços
 de 
\family typewriter 
VALUE
\family default 
s (isto é, seqüências numéricas que correspondam a endereços de 
\family typewriter 
VALUE
\family default 
s válidos).
 Cada 
\family typewriter 
VALUE
\family default 
 encontrado na pilha é então marcado.
 Isto garante que nenhum 
\family typewriter 
VALUE
\family default 
 localmente alcançável por código C seja invalidado, mas pode gerar 
\begin_inset Quotes eld
\end_inset 

falsos positivos
\begin_inset Quotes erd
\end_inset 

 evitando que dados que poderiam ser coletados o sejam.
\layout Standard

Apesar da conveniência para o programador, tal abortagem é extremamente
 não-portável.
 A implementação do coletor de lixo em Ruby 1.8.2 possui 
\family typewriter 
#ifdef
\family default 
s para IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC e Motorola 68000.
 Além disso, o coletor força a descarga dos registradores para a pilha usando
 
\family typewriter 
setjmp
\family default 
, para evitar que variáveis do tipo 
\family typewriter 
VALUE
\family default 
 que tenham sido otimizadas pelo compilador deixem de ser verificadas.
\layout Standard

Ruby possui um módulo 
\family typewriter 
GC
\family default 
 que disponibiliza funções para ativar e desativar o coletor (
\family typewriter 
GC.enable
\family default 
 e 
\family typewriter 
GC.disable
\family default 
), bem como disparar uma coleta imediatamente (
\family typewriter 
GC.start
\family default 
).
 Na API em C há funções equivalentes: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 A API de C inclui ainda uma função que insere um objeto imediatamente na
 lista de objetos a serem reciclados pelo alocador de memória de Ruby, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 Esta função deve ser usada com cuidado, já que se houverem outras referências
 apontando ao objeto elas passarão a apontar para outro objeto quando a
 área de memória for reutilizada pelo alocador de Ruby.
\layout Standard

Ruby oferece ainda como conveniência alguns 
\emph on 
wrappers
\emph default 
 para as funções 
\family typewriter 
malloc
\family default 
 e 
\family typewriter 
realloc
\family default 
 que interagem com o coletor de lixo, forçando a execução do coletor durante
 alocações grandes
\begin_inset Foot
collapsed true

\layout Standard

O limite para definir 
\begin_inset Quotes eld
\end_inset 

grande
\begin_inset Quotes erd
\end_inset 

 se ajusta de acordo com o funcionamento do coletor e com as alocações realizada
s anteriormente.
\end_inset 

 ou em situações de pouca memória disponível.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Assim como Python e Ruby, a API de Java retorna referências a objetos da
 máquina virtual que podem ser armazenados em variáveis C.
 A JNI define três tipos de referências, 
\emph on 
locais
\emph default 
, 
\emph on 
globais
\emph default 
 e 
\emph on 
globais fracas
\emph default 
, para auxiliar no controle do tempo de vida destas e a sua interação com
 o coletor de lixo.
\layout Standard

Referências locais são retornadas pela maioria das funções da JNI e são
 válidas até o retorno da função C que a obteve.
 Não é necessário desalocar explicitamente uma referência local: durante
 a execução de uma função C, a JVM mantém uma lista de referências locais
 passadas à função e libera todas elas quando o controle retorna à máquina
 virtual.
 Isto faz com que, de maneira geral, o programador não precise se preocupar
 com o coletor de lixo enquanto manipula valores retornados durante uma
 função.
 Por outro lado, em código que pode utilizar uma grande quantidade de referência
s locais é mais eficiente desalocar referências locais explicitamente, usando
 
\family typewriter 
DeleteLocalRef
\family default 
.
 A partir da versão 1.2 de Java, funções foram adicionadas para permitir
 a gerência de referências locais em blocos.
 
\family typewriter 
PushLocalFrame
\family default 
 e 
\family typewriter 
PopLocalFrame
\family default 
 permitem criar escopos aninhados de referências locais, que são desalocados
 de uma só vez.
 
\family typewriter 
PushLocalFrame
\family default 
 recebe ainda um parâmetro indicando um número de 
\emph on 
slots
\emph default 
 a serem pré-alocados, como otimização.
 Esse valor pode ser configurado também com 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Referências globais são geradas a partir de referências locais usando 
\family typewriter 
NewGlobalRef
\family default 
.
 Referências deste tipo mantêm-se válidas até serem explicitamente desalocadas
 com 
\family typewriter 
Delete\SpecialChar \-
GlobalRef
\family default 
.
 Uma referência global impede o objeto de ser coletado, podendo assim, ser
 utilizada para armazenar objetos Java no espaço de C além da duração de
 uma função, por exemplo, em variáveis globais ou estáticas.
\layout Standard

A Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 mostra um exemplo do tipo de gerência de referências necessário quando
 se tem um laço criando referências temporárias sobre um número arbitrário
 de objetos.
 No exemplo, a função 
\family typewriter 
Java_Exemplo_concatArray
\family default 
 (equivalente, portanto, ao método 
\family typewriter 
concatArray
\family default 
 de uma classe 
\family typewriter 
Exemplo
\family default 
) converte os elementos de um array para strings usando 
\family typewriter 
Object.toString
\family default 
 e os concatena usando 
\family typewriter 
String.concat
\family default 
.
 Note que, como o número de vezes que o laço executa depende do tamanho
 do array passado, deve-se evitar que o número de referências cresça em
 cada iteração.
 Para isso, as opções seriam ou usar 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, ou destruir as referências uma a uma com 
\family typewriter 
DeleteLocalRef
\family default 
.
 Se usássemos 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 no exemplo, teríamos que manter a string concatenada até o momento em uma
 referência global.
 Além disso, esta referência teria que ser destruída e recriada a cada iteração,
 já que strings são imutáveis em Java.
 Como o número de locais é pequeno, é mais conveniente neste caso controlá-las
 explicitamente com 
\family typewriter 
DeleteLocalRef
\family default 
 do que recorrer a referências globais.
 
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 permite, através de um parâmetro adicional, transferir uma referência local
 do conjunto que está sendo desempilhado para o escopo exterior de referências
 locais, criando assim uma nova referência.
 Para o exemplo da Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, isto ainda não evitaria a necessidade de liberar referências locais explicitam
ente a cada iteração do laço, já que cada 
\family typewriter 
PopLocalFrame
\family default 
 criaria uma referência local nova.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

 
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\layout LyX-Code


\size footnotesize 
\emph on 
      /* os = o.toString */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\layout LyX-Code


\size footnotesize 
\emph on 
      /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Rotina para concatenar os elementos de um array representados como strings.
\end_inset 


\layout Standard

Uma técnica comum consiste em fazer o 
\emph on 
caching
\emph default 
 de classes Java em referências globais associadas a variáveis estáticas
 dentro de funções C, como também pode ser visto na Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

.
\layout Standard

A partir da versão 1.2, a JNI inclui referências globais fracas, com o objetivo
 de oferecer uma forma simplificada das referências fracas de Java (
\family typewriter 
java.lang.ref
\family default 
) -- um objeto que esteja sendo apontado apenas por referências globais
 fracas pode ser coletado.
 Originalmente, a API incluiu a função 
\family typewriter 
IsSameObject
\family default 
 como forma de verificar a validade de uma referência fraca, mas evidentemente
 este método é insuficiente: como Java é 
\emph on 
multi-threaded
\emph default 
, o coletor de lixo pode invalidar a referência entre o teste e a instrução
 seguinte no código C.
 A documentação revisada avisa sobre esta limitação e recomenda a aquisição
 de referências globais, além de comportamentos indefinidos nas relações
 entre referências globais fracas em C e os tipos de referências fracas
 definidos em Java.
\layout Standard

Além desta, outras questões surgem a partir da combinação do modelo 
\emph on 
multi-threaded
\emph default 
 de Java com a exposição de referências a objetos da máquina virtual ao
 código C.
 Para reduzir a quantidade de cópia de dados entre Java e C, a JNI oferece
 algumas funções que retornam ponteiros para a representação interna de
 strings e arrays de tipos pri\SpecialChar \-
mi\SpecialChar \-
ti\SpecialChar \-
vos: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 e 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 O uso destas funções, porém, possui importantes restrições.
 A API especifica que, uma vez obtido um ponteiro através destas funções,
 o código C não deve chamar outras funções da JNI ou realizar chamadas de
 sistema que possam bloquear a thread atual e fazer com que ela espere por
 outra thread Java.
 Recomenda-se não manter blocos de memória bloqueados usando estas funções
 por muito tempo já que uma das técnicas possíveis para a implementação
 desta 
\begin_inset Quotes eld
\end_inset 

região crítica
\begin_inset Quotes erd
\end_inset 

 consiste em desabilitar o coletor de lixo da JVM.
 É importante notar ainda que referências locais e o ponteiro para o ambiente
 JNI passado para funções nativas são válidos apenas na thread onde foram
 criados; referências globais podem ser compartilhadas entre threads.
\layout Standard

Além do mecanismo de referências fracas fornecido pelas classes do pacote
 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
, a única forma oferecida por Java para interagir de maneira mais direta
 com o coletor de lixo é através da chamada 
\family typewriter 
System.gc()
\family default 
, que solicita à máquina virtual que dispare tão logo quanto possível a
 thread de coleta para que esta desaloque objetos não alcançáveis.
 Não há uma função C equivalente na JNI, mas este método pode ser invocado
 a partir de C com 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

Por não retornar referências explícitas a objetos Lua ao código C, a interação
 do código nativo com o coletor de lixo é bastante simplificada.
 Operações sobre objetos Lua são sempre especificadas através de índices
 da pilha virtual.
 Assim, a máquina virtual mantém o controle sobre quais os objetos são acessívei
s a partir de C em qualquer dado momento.
 
\layout Standard

Embora ponteiros para objetos não sejam manipulados na API, algumas funções
 retornam ponteiros para estruturas gerenciadas por Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_\SpecialChar \-
push
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_touserdata
\family default 
 e 
\family typewriter 
lua_topointer
\family default 
.
 Esta última função permite obter ponteiros para alguns tipos de objetos
 (
\emph on 
userdata
\emph default 
, tabelas, 
\emph on 
threads
\emph default 
 e funções), mas somente com o objetivo de obter informação para depuração,
 já que não é possível converter o ponteiro de volta para um valor Lua.
 A validade dos ponteiros retornados por estas funções é dependente do tempo
 de vida do objeto correspondente a eles; para strings em particular, o
 ponteiro retornado só é garantidamente válido enquanto o dado estiver na
 pilha.
\layout Standard

O conteúdo da pilha virtual é zerado quando a função C retorna o controle
 à máquina virtual de Lua.
 Dessa forma, não é possível reter ponteiros retornados por valores Lua
 para uso posterior em variáveis globais ou estruturas de C.
 Para acessar novamente um dado de Lua posteriormente, é necessário armazená-lo
 em uma variável no espaço de Lua e trazê-lo de volta à pilha através de
 chamadas da API.
\layout Standard

Uma forma conveniente de armazenar referências a dados do espaço de Lua
 em estruturas de dados em C consiste em armazenar os dados em uma tabela
 Lua e os índices desta tabela na estrutura C.
 A biblioteca auxiliar de Lua encapsula tal idioma através de duas funções,
 
\family typewriter 
luaL_ref
\family default 
 e 
\family typewriter 
luaL_unref
\family default 
.
 A função 
\family typewriter 
luaL_ref
\family default 
 associa o valor Lua passado a um a chave numérica inteira em uma tabela
 especial, o 
\emph on 
registro
\emph default 
, e retorna este número.
 Como o tabela que implementa o registro não é coletada ao longo da execução,
 a inclusão do objeto nesta tabela o impede de ser coletado.
 A chave numérica pode então ser vista como um 
\emph on 
handle
\emph default 
 de alto nível para o objeto: o código C pode armazená-la em variáveis ou
 estruturas e utilizá-la para referenciar-se ao objeto através do campo
 no registro.
 A função 
\family typewriter 
luaL_unref
\family default 
 remove o valor Lua do registro e libera o índice para reuso.
 Para o bom funcionamento deste mecanismo, chaves inteiras não devem ser
 utilizadas diretamente pelo programador para armazenar dados no registro.
\layout Standard

A API permite associar a objetos do tipo 
\emph on 
full userdata
\emph default 
 uma função de desalocação, 
\family typewriter 
__gc
\family default 
, na sua metatabela.
 Quando presente, esta função será tipicamente implementada em C, realizando
 a finalização de recursos.
 Por exemplo, o metamétodo 
\family typewriter 
__gc
\family default 
 de objetos retornados pela função Lua 
\family typewriter 
io.open
\family default 
 é uma função C que fecha o descritor de arquivo correspondente com a função
 C 
\family typewriter 
fclose
\family default 
.
 
\layout Standard

A princípio, o fato de que é possível obter e modificar a metatabela de
 um userdata pode parecer problemático, já que pode-se substituir o seu
 finalizador em 
\family typewriter 
__gc
\family default 
.
 Entretanto, funções de coleta implementadas em C tipicamente validam o
 userdata recebido verificando o seu 
\begin_inset Quotes eld
\end_inset 

tipo
\begin_inset Quotes erd
\end_inset 

, identificado através da metatabela.
 Duas funções da biblioteca auxiliar que implementam este mecanismo: 
\family typewriter 
luaL_newmetatable
\family default 
 cria uma metatabela e a associa a uma entrada no registro; 
\family typewriter 
luaL_checkudata
\family default 
 compara a metatabela de um userdata com uma entrada do registro especificada.
 Assim, mesmo que código Lua manipule a metatabela, uma função de coleta
 implementada em C que use 
\family typewriter 
luaL_checkudata
\family default 
 não será levada a operar sobre um 
\emph on 
userdata
\emph default 
 de tipo incorreto.
 Para impedir o código Lua de alterar a função de coleta de um objeto 
\emph on 
userdata
\emph default 
, pode-se atribuir um valor qualquer, como 
\family typewriter 
false
\family default 
, ao campo 
\family typewriter 
__metatable
\family default 
 da metatabela, que, quando presente, é retornado por 
\family typewriter 
getmetatable
\family default 
.
\layout Standard

Outro recurso relacionado à gerência de memória oferecido por Lua é a possibilid
ade de configurar, em tempo de execução, a função de alocação de memória
 a ser usada pela máquina virtual.
 Na criação de um novo estado com 
\family typewriter 
lua_newstate
\family default 
, passa-se como parâmetro uma função de alocação que deve oferecer funcionalidad
e similar às funções C 
\family typewriter 
free
\family default 
 e 
\family typewriter 
realloc
\family default 
, dependendo se o tamanho de bloco passado for igual ou maior do que zero.
 A função auxiliar 
\family typewriter 
luaL_newstate
\family default 
 cria um estado usando um alocador padrão baseado em 
\family typewriter 
realloc
\family default 
 e 
\family typewriter 
free
\family default 
.
\layout Standard

Lua oferece uma interface com o coletor de lixo através das funções 
\family typewriter 
lua_gc
\family default 
 em C e 
\family typewriter 
collectgarbage
\family default 
 em Lua.
 O coletor de Lua implementa 
\emph on 
mark-and-sweep
\emph default 
 incremental e permite ao programador configurar parâmetros relacionados
 aos intervalos de coleta, bem como ativar, desativar e disparar ciclos
 completos ou passos do coletor.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Como Python, Perl realiza coleta de lixo baseada em contagem de referências.
 A API provê funções para o controle explícito da contagem: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 para incremento e decremento e um 
\emph on 
getter
\emph default 
, 
\family typewriter 
SvREFCNT
\family default 
.
 Outra forma de alterar a contagem de referências de um valor é atribuindo-o
 a uma referência Perl com 
\family typewriter 
newRV_inc
\family default 
.
 A contagem do valor referenciado será incrementada, fazendo com que --
 salvo tenha sua contagem alterada explicitamente -- este se mantenha válido
 enquanto for referenciado pelo 
\family typewriter 
RV
\family default 
.
 É importante notar, porém, que as funções da API que criam valores, como
 
\family typewriter 
newSViv
\family default 
, inicializam os seus contadores de referências com 1.
 Isto tem o efeito de que se um valor criado é em uma função C, armazenado
 em um 
\family typewriter 
RV
\family default 
 com 
\family typewriter 
newRV_inc
\family default 
 e esta referência é retornada a Perl, o valor nunca será coletado, pois
 o seu contador não retornará a 0 quando a referência for destruída.
 A forma correta, então, é usar 
\family typewriter 
newRV_noinc
\family default 
 para 
\family typewriter 
RV
\family default 
s contendo valores recém-criados e 
\family typewriter 
newRV_inc
\family default 
 quando um 
\family typewriter 
RV
\family default 
 deve manter válido um valor já existente.
\layout Standard

A inicialização da contagem de referências em 1 garante que valores criados
 continuarão válidos durante a execução de uma função C sem que seja necessário
 armazenar o valor no espaço de Perl.
 Estes valores podem também ser armazenados em variáveis globais e estruturas
 de dados de C e se manterão válidos até que a sua contagem de referências
 seja decrementada.
 Para valores cujo tempo de vida é restrito a uma função, a API de Perl
 define o conceito de valores 
\begin_inset Quotes eld
\end_inset 

mortais
\begin_inset Quotes erd
\end_inset 

 como uma forma de permitir desalocar todos os valores temporários de uma
 função de uma só vez.
 Um 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 pode ser criado com 
\family typewriter 
sv_newmortal
\family default 
 ou mais comumente convertido para mortal com 
\family typewriter 
sv_2mortal
\family default 
.
 Na prática, marcar um valor como mortal corresponde a indicar que ele deve
 ter a sua contagem de referências decrementada na chamada da macro 
\family typewriter 
FREETMPS
\family default 
 ao término da função, conforme será visto na Seção 
\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Algumas funções da API retornam valores mortais: por exemplo, 
\family typewriter 
hv_delete
\family default 
 remove um elemento de uma hash e, caso a flag 
\family typewriter 
G_DISCARD
\family default 
 não seja passada, retorna o elemento removido como um 
\family typewriter 
SV
\family default 
 mortal.
\layout Standard

A API de Perl não possui facilidades de interface com o coletor de lixo,
 mas possui algumas funções para auxílio em depuração que reportam informações
 sobre o status da coleta de lixo.
 A função 
\family typewriter 
sv_report_used
\family default 
 exibe o conteúdo de todos os 
\family typewriter 
SV
\family default 
s do interpretador.
 O módulo 
\family typewriter 
Devel::Peek
\family default 
 permite examinar a partir de Perl o conteúdo de valores (contagem de referência
s, 
\emph on 
flags
\emph default 
, etc.) -- a partir de C, estas informações estão disponíveis diretamente
 já que as estruturas não são opacas.
\layout Section

Chamada de funções a partir de C
\layout Standard

A API deve prover uma forma de invocar a partir de C funções a serem executadas
 pela linguagem de script.
 Isto envolve a passagem de dados entre estes dois 
\begin_inset Quotes eld
\end_inset 

espaços
\begin_inset Quotes erd
\end_inset 

, conforme visto na Seção 
\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 e as implicações que isto traz sobre o tempo de vida dos objetos, abordadas
 na Seção 
\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Devido à tipagem estática de C, não é possível usar uma sintaxe transparente
 para chamada de funções registradas em tempo de execução.
 É necessário então que a API defina funções para realizar chamadas na linguagem
 de script.
\layout Standard

Nesta seção serão discutidas as facilidades oferecidas por cada API para
 a invocação de funções para execução na máquina virtual ou interpretador.
 As principais questões envolvidas são como referenciar a função a ser chamada,
 como passar argumentos a ela e como obter o valor de retorno, incluindo
 formas de notificação no caso de erros.
 Para fins de ilustração, será apresentado em cada linguagem um exemplo
 de chamada de uma função simples.
 Assume-se que tenha sido definida no espaço de cada linguagem de script
 uma função 
\family typewriter 
teste
\family default 
, passando um inteiro e uma string como parâmetros e obtendo um inteiro
 como resultado.
 Para maior brevidade, a verificação de erros será omitida.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Comment

Como obter/referenciar uma função
\layout Standard

Para chamar uma função Python a partir de C, deve-se inicialmente obter
 um ponteiro para o 
\family typewriter 
PyObject
\family default 
 correspondente à função, como visto na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Além de funções implementadas em Python e funções C registradas a partir
 da API, qualquer tipo de dado que implemente o método 
\family typewriter 
__call__
\family default 
 (ou declare uma função no campo 
\family typewriter 
tp_call
\family default 
 de sua estrutura 
\family typewriter 
PyTypeObject
\family default 
) pode ser chamado como uma função, e retornará sucesso em 
\family typewriter 
PyCallable_Check
\family default 
.
\layout Comment

Funções para chamar funções
\layout Comment

Passando argumentos
\layout Standard

A API de Python oferece diversas funções para realização de chamadas a partir
 de C.
 A chamada mais geral, 
\family typewriter 
PyObject_Call
\family default 
, recebe como parâmetros o objeto a ser chamado, uma tupla Python contendo
 os parâmetros a serem passados e opcionalmente um dicionário de argumentos
 
\emph on 
keyword
\emph default 
.
 Como conveniência, outras funções permitem passar os argumentos de outras
 formas.
 Por exemplo, 
\family typewriter 
PyObject_CallFunction
\family default 
 encapsula a chamada a 
\family typewriter 
Py_BuildValue
\family default 
 (vista na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), aceitando diretamente a string de formato desta e os valores a serem
 convertidos diretamente.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 é uma função 
\emph on 
vararg
\emph default 
 que aceita uma seqüência de ponteiros para 
\family typewriter 
PyObject
\family default 
s.
\layout Comment

Função vs.
 método
\layout Standard

Existem também funções de conveniência para a invocação de métodos.
 A função 
\family typewriter 
PyObject_CallMethod
\family default 
 é uma variante de 
\family typewriter 
PyObject_CallFunction
\family default 
 que recebe como parâmetros um 
\family typewriter 
PyObject
\family default 
 e uma string C contendo o nome do método.
 Assim, a chamada:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Equivalente C a: ret = uma_string.split(" ")
\layout LyX-Code


\size footnotesize 
\emph on 
   "s" indica que o parâmetro seguinte é do tipo string.
 */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(uma_string, "split", "s", " ");
\layout Standard

é equivalente a:
\layout LyX-Code


\size footnotesize 
PyObject* split = PyObject_GetAttrString(uma_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard

É interessante notar que mesmo quando um método é chamado como função, o
 argumento 
\family typewriter 
self
\family default 
 não é passado explicitamente.
 
\layout Comment

Valor de retorno
\layout Comment

Múltiplos valores de retorno
\layout Comment

Verificação da ocorrência de erros
\layout Standard

O valor de retorno em todas as funções de chamada é um ponteiro para 
\family typewriter 
PyObject
\family default 
.
 Assim como ocorre em código Python, quando funções Python retornam múltiplos
 valores, estes são encapsulados em uma tupla.
 Para funções que não retornam valor, as funções retornam 
\family typewriter 
Py_None
\family default 
.
 Em caso de erro na chamada, as funções retornam 
\family typewriter 
NULL
\family default 
.
 A ocorrência de exceções pode então ser verificada com 
\family typewriter 
PyErr_Occurred
\family default 
.
\layout Comment

Exemplo de chamada de função
\layout Standard

Uma forma típica para chamar uma função Python 
\family typewriter 
teste
\family default 
, incluindo a obtenção da função e a conversão dos valores de entrada e
 saída entre Python e C, é exibida a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* teste = PyDict_GetItemString(globals, "teste");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Equivalente C a: obj_result = teste("entrada", 2)
\layout LyX-Code


\size footnotesize 
\emph on 
   "si" indica que seguem parâmetros string e inteiro */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(teste, "si", "entrada", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converte o valor para C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Libera o PyObject temporário retornado.
 */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Comment

Controle das referências no exemplo
\layout Standard

Uma função global é obtida através do dicionário do módulo 
\family typewriter 
__main__
\family default 
.
 A conversão dos dados de entrada de C para Python é feita através da string
 de formato recebida por 
\family typewriter 
PyObject_CallFunction
\family default 
.
 O valor de retorno é retornado como uma nova referência a um objeto Python
 e, desta forma, precisa ter a contagem de referências decrementada após
 o seu uso.
 As funções 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 e 
\family typewriter 
PyDict_GetItemString
\family default 
 retornam referências emprestadas, portanto a contagem de referências dos
 PyObjects retornados por elas não precisam ser decrementadas após o seu
 uso.
 Todavia, após a chamada da função Python, não há garantia de que os ponteiros
 globals e teste ainda apontem para objetos válidos -- precisaríamos incrementar
 a sua contagem de referências caso quiséssemos usá-los novamente.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Comment

Como obter/referenciar uma função
\layout Comment

Funções para chamar funções
\layout Standard

Para a chamada de métodos Ruby em C, a API oferece a função 
\family typewriter 
rb_funcall
\family default 
 e algumas variantes.
 Em comum, todas recebem como parâmetro o 
\family typewriter 
VALUE
\family default 
 referente ao objeto sobre o qual o método se refere, um 
\family typewriter 
ID
\family default 
 referente à string internalizada contendo o nome do método e um inteiro
 indicando o número de argumentos.
 Como métodos não são valores de primeira classe em Ruby, eles não são represent
ados como 
\family typewriter 
VALUE
\family default 
s na sua API de C.
\layout Comment

Passando argumentos
\layout Comment

Valor de retorno
\layout Comment

Múltiplos valores de retorno
\layout Standard

As funções da API para invocação de métodos diferem na forma como os argumentos
 são passados.
 Por exemplo, a função 
\family typewriter 
rb_funcall
\family default 
 recebe os argumentos na forma de 
\family typewriter 
VALUE
\family default 
s passados como varargs C; 
\family typewriter 
rb_funcall2
\family default 
 recebe um array C de 
\family typewriter 
VALUE
\family default 
s; 
\family typewriter 
rb_apply
\family default 
 recebe um 
\family typewriter 
VALUE
\family default 
 que deve ser um array Ruby contendo os parâmetros.
 Todas elas retornam um 
\family typewriter 
VALUE
\family default 
 como parâmetro.
 Múltiplos valores de retorno são representados como um array Ruby.
\layout Comment

Função vs.
 método
\layout Standard

Todas as rotinas de chamada de função na API se referem a métodos, precisando
 assim especificar um objeto sobre o qual o método deve ser aplicado.
 Funções globais em Ruby são definidas como métodos do módulo 
\family typewriter 
Kernel
\family default 
, que é incluído pela classe 
\family typewriter 
Object
\family default 
 e são, assim, acessíveis a partir de qualquer objeto, incluindo 
\family typewriter 
nil
\family default 
.
 Desta forma, pode-se invocar funções globais passando a constante C 
\family typewriter 
Qnil
\family default 
 como o objeto alvo do método.
\layout Comment

Exemplo de chamada de função
\layout Standard

A seguir, é apresentada a forma típica para chamar uma função global Ruby
 
\family typewriter 
teste
\family default 
, novamente incluindo a conversão dos valores de entrada e saída entre C
 e o interpretador.
\layout LyX-Code


\size footnotesize 
ID teste = rb_intern("teste");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, teste, 2, rb_str_new2("entrada"), INT2NUM(2)
);
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard

Diferentemente de Python, não é necessário obter uma referência para a função,
 bastando passar o nome desta na forma de 
\family typewriter 
ID
\family default 
 e o objeto a que ela se refere (no caso, 
\family typewriter 
Qnil
\family default 
, indicando uma função global).
 A conversão dos dados de entrada de C para Ruby é feita através da função
 
\family typewriter 
rb_str_new2
\family default 
 e da macro 
\family typewriter 
INT2NUM
\family default 
, que criam 
\family typewriter 
VALUE
\family default 
s.
\layout Comment

Controle das refs.
 no exemplo
\layout Standard

Conforme discutido na Seção 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, o controle da validade de 
\family typewriter 
VALUE
\family default 
s é feito implicitamente.
 Assim, pode-se fazer a chamada de funções que criam 
\family typewriter 
VALUE
\family default 
s diretamente na passagem de parâmetros de 
\family typewriter 
rb_funcall
\family default 
.
 De fato, as três linhas acima poderiam ter sido condensadas, passando a
 chamada 
\family typewriter 
rb_funcall
\family default 
 como parâmetro para 
\family typewriter 
NUM2LONG
\family default 
 e a chamada 
\family typewriter 
rb_intern
\family default 
 como segundo parâmetro de 
\family typewriter 
rb_funcall
\family default 
, tendo sido separadas apenas para maior legibilidade.
\layout Comment

Questões específicas da linguagem: blocos Ruby
\layout Standard

Um tipo de dados que possui um tratamento um tanto irregular em Ruby é o
 de blocos de código.
 A sintaxe em Ruby para a declaração de blocos é especial: blocos só podem
 ser definidos como o último argumento de uma chamada de método.
 Assim, eles não são valores de primeira classe, não podendo ser, por exemplo,
 declarados em uma atribuição a variável.
 Eles podem, no entanto, ser 
\begin_inset Quotes eld
\end_inset 

promovidos
\begin_inset Quotes erd
\end_inset 

 a valores de primeira classe, na forma de objetos da classe 
\family typewriter 
Proc
\family default 
.
 Isto pode ser feito de duas formas: explicitamente, passando um bloco para
 o método 
\family typewriter 
Proc.new
\family default 
, ou implicitamente, declarando em um método um último parâmetro formal
 precedido de 
\family typewriter 
&
\family default 
.
 Esta variável conterá o bloco convertido para um 
\family typewriter 
Proc
\family default 
.
 Na chamada de funções que esperam blocos, 
\family typewriter 
&
\family default 
 converte o 
\family typewriter 
Proc
\family default 
 para um bloco.
 Objetos 
\family typewriter 
Proc
\family default 
 podem ser manipulados através da API de C como qualquer outro objeto Ruby,
 mas não há correspondente na API de C para a funcionalidade do operador
 
\family typewriter 
&
\family default 
 em chamadas de função.
\layout Standard

O status especial dos blocos de código complica a sua manipulação a partir
 de código C, e em particular a invocação de métodos que os esperam como
 parâmetro.
 Digamos que queremos invocar o seguinte método Ruby a partir de C:
\layout LyX-Code


\size footnotesize 
def uma_funcao_ruby()
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby vai invocar o bloco.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby encerrou.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard

A função espera que um bloco de código seja passado para que seja invocado
 via o comando 
\family typewriter 
yield
\family default 
.
 Como vamos invocar a função a partir de C, queremos também passar código
 C como um bloco, representado na seguinte função: 
\layout LyX-Code


\size footnotesize 
VALUE um_bloco_C() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "um_bloco_C está rodando.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard

A conversão objetos 
\family typewriter 
Proc
\family default 
 para blocos proporcionada pelo operador 
\family typewriter 
&
\family default 
 em Ruby não possui equivalente na API C.
 Assim, 
\family typewriter 
rb_funcall
\family default 
 não é capaz de passar 
\family typewriter 
Proc
\family default 
s para funções que aceitam blocos.
 A forma intuitiva de fazer a chamada de funções Ruby a partir de C, neste
 caso, então, não funciona:
\layout LyX-Code


\size footnotesize 
ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Não funciona! Um Proc não é um bloco de código.
 */
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_funcall(Qnil, uma_funcao_ruby, 1, um_proc);
\layout Standard

As únicas formas de invocar um método Ruby passando um bloco de código são
 através de 
\family typewriter 
rb_eval_string
\family default 
 e 
\family typewriter 
rb_iterate
\family default 
.
 A primeira abordagem, além do custo de desempenho causado pelo 
\emph on 
parsing
\emph default 
 da string de código, tem a inconveniência de exigir o uso de variáveis
 temporárias para que se possa obter os valores de retorno de volta ao espaço
 de C.
 No modelo usando 
\family typewriter 
rb_eval_string
\family default 
, a função C que atuará como bloco deve ser declarada no espaço de Ruby.
 Há duas alternativas de como fazer isto: registrando o método em Ruby e
 invocando-o em um bloco 
\emph on 
wrapper
\emph default 
 declarado no texto da string Ruby:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("um_bloco_C", um_bloco_C, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby { um_bloco_C }");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard

Ou encapsulando a função em um objeto 
\family typewriter 
Proc
\family default 
 a partir de C com 
\family typewriter 
rb_proc_new
\family default 
 e então usando a notação 
\family typewriter 
&
\family default 
 na string de código Ruby avaliada:
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(um_bloco_C, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$um_proc", um_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby(&$um_proc)");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard

A segunda abordagem explora o fato de que a única função da API de C capaz
 de produzir blocos de código diretamente é 
\family typewriter 
rb_iterate
\family default 
.
 Esta função recebe dois ponteiros de função, um para a função a ser invocada
 e outro para a função que atuará como o bloco de código; chamadas a 
\family typewriter 
yield
\family default 
 dentro da primeira função invocarão a segunda.
 O bloco pode quebrar o fluxo de execução com 
\family typewriter 
rb_iter_break
\family default 
.
 Passando como 
\begin_inset Quotes eld
\end_inset 

função de iteração
\begin_inset Quotes erd
\end_inset 

 para 
\family typewriter 
rb_iterate
\family default 
 uma função 
\emph on 
wrapper
\emph default 
 que simplesmente chama o método Ruby desejado com 
\family typewriter 
rb_funcall
\family default 
, é possível simular uma chamada a 
\family typewriter 
rb_funcall
\family default 
 que recebe uma função C como bloco de código.
\layout LyX-Code


\size footnotesize 
VALUE chama_uma_funcao_ruby() {
\layout LyX-Code


\size footnotesize 
   ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, uma_funcao_ruby, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_iterate(chama_uma_funcao_ruby, Qnil, um_bloco_C, Qnil);
\layout Standard

Note que nenhum argumento é passado em 
\family typewriter 
rb_funcall
\family default 
 -- a função 
\family typewriter 
rb_iterate
\family default 
 define 
\family typewriter 
um_bloco_C
\family default 
 como sendo o 
\begin_inset Quotes eld
\end_inset 

bloco de código atual
\begin_inset Quotes erd
\end_inset 

 e esta definição é herdada implicitamente por 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

Para o caso comum de realizar iterações sobre o método 
\family typewriter 
each
\family default 
 de coleções, Ruby oferece uma função 
\emph on 
wrapper
\emph default 
 
\family typewriter 
rb_each
\family default 
.
 Esta função foi projetada para ser passada como primeiro argumento de 
\family typewriter 
rb_iterate
\family default 
.
 Funções C executando como bloco de código podem quebrar o fluxo de execução
 com 
\family typewriter 
rb_iter_break
\family default 
.
 O mecanismo de 
\emph on 
yield
\emph default 
, tanto para código C quanto para chamadas nativas em Ruby, é implementado
 usando as funções C 
\family typewriter 
setjmp
\family default 
 e 
\family typewriter 
longjmp
\family default 
.
\layout Comment

Verificação da ocorrência de erros.
\layout Standard

Para o correto tratamento de erros, funções C que realizam chamadas a funções
 Ruby devem ser encapsuladas em uma chamada 
\family typewriter 
rb_protect
\family default 
 ou em uma de suas variantes, 
\family typewriter 
rb_ensure
\family default 
 e 
\family typewriter 
rb_rescue
\family default 
.
 Esta função captura exceções disparadas por código Ruby (ou código C usando
 
\family typewriter 
rb_raise
\family default 
).
 Caso o programa não use 
\family typewriter 
rb_protect
\family default 
, exceções em Ruby resultarão em erros fatais.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Comment

Como obter/referenciar uma função
\layout Standard

De forma similar ao acesso a atributos, na chamada de métodos deve-se inicialmen
te obter um identificador para o método, do tipo 
\family typewriter 
jmethodID
\family default 
.
 Estes identificadores são tipicamente obtidos com a função 
\family typewriter 
GetMethodID
\family default 
, que recebe como parâmetros a classe (instância de 
\family typewriter 
jclass
\family default 
) e duas strings, uma com o nome do método e outra com a assinatura do método.
 A sintaxe que descreve assinaturas de método é similar à de descritores
 de campos discutida na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Parâmetros são listados entre parênteses, seguidos do tipo de retorno.
 Por exemplo, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 indica uma função com parâmetros 
\family typewriter 
String[], int, int
\family default 
 e retorno 
\family typewriter 
void
\family default 
.
 Alternativamente, a partir de Java 1.2 é possível obter um 
\family typewriter 
jmethodID
\family default 
 correspondente a um objeto Java do tipo 
\family typewriter 
Method
\family default 
 -- isto é, um método reificado através da API de reflexão de Java -- usando
 a função 
\family typewriter 
FromReflectedMethod
\family default 
.
\layout Comment

Funções da API para invocar funções
\layout Standard

Uma vez obtido o 
\family typewriter 
jmethodID
\family default 
, um método pode ser invocado através de alguma das 90 funções da família
 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
*.
 Os nomes das funções seguem a forma
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<tipo><retorno>
\family default 
\emph default 
Method
\family roman 
\emph on 
<argumentos>
\layout Comment

Valor de retorno
\layout Standard

O 
\emph on 
<tipo>
\emph default 
 pode ser 
\family typewriter 
Static
\family default 
 para funções estáticas, recebendo na chamada uma 
\family typewriter 
jclass
\family default 
 como parâmetro; 
\family typewriter 
Nonvirtual
\family default 
 para invocar implementações de um método em uma classe específica sobre
 um determinado objeto, passando uma 
\family typewriter 
jclass
\family default 
 e um 
\family typewriter 
jobject
\family default 
 como parâmetros; ou omitido para métodos de instância, passando o 
\family typewriter 
jobject
\family default 
 sobre o qual o método será aplicado.
 O tipo de retorno é indicado em 
\emph on 
<retorno>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
 Em funções que retornam valores não-primitivos, como 
\family typewriter 
jarray
\family default 
 ou 
\family typewriter 
jobject
\family default 
, o tipo de referência retornada é local.
\layout Comment

Passando argumentos
\layout Standard

Os argumentos do método podem ser passados de três formas: como 
\emph on 
varargs
\emph default 
; como um array de 
\family typewriter 
jvalue
\family default 
s; ou propagando uma 
\family typewriter 
va_list
\family default 
 recebida.
 Por exemplo, na forma mais simples, um método de instância sem retorno
 e sem parâmetros é invocado com 
\family typewriter 
CallVoidMethod
\family default 
.
 Já 
\family typewriter 
CallStaticIntMethodA
\family default 
 chama um método estático que retorna um 
\family typewriter 
jint
\family default 
 com a lista de parâmetros passada em um array de 
\family typewriter 
jvalue
\family default 
s.
\layout Comment

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\layout Standard

É importante notar que, ao obter identificadores de métodos e campos fazendo
 a resolução a partir do 
\family typewriter 
jobject
\family default 
 recebido na variável 
\family typewriter 
this
\family default 
 e do nome do método ou campo, com 
\family typewriter 
GetObjectClass
\family default 
 e 
\family typewriter 
GetFieldID
\family default 
, estamos efetivamente resolvendo nomes através de escopo dinâmico.
 Isto implica que, por exemplo, caso um método 
\family typewriter 
Pai.metodo
\family default 
 implementado em C acesse um atributo privado 
\family typewriter 
umAtributo
\family default 
 e uma subclasse 
\family typewriter 
Filho
\family default 
 também defina um atributo privado 
\family typewriter 
umAtributo
\family default 
, a chamada a esse método em uma instância 
\family typewriter 
f
\family default 
 de 
\family typewriter 
Filho
\family default 
 acabaria por acessar 
\family typewriter 
Filho.umAtributo
\family default 
 e não 
\family typewriter 
Pai.umAtributo
\family default 
.
 Este comportamento é diferente do que ocorreria se 
\family typewriter 
Pai.metodo
\family default 
 fosse implementado em Java, onde o 
\emph on 
binding
\emph default 
 de membros privados é definido lexicamente.
 Para garantir à implementação em C de 
\family typewriter 
Pai.metodo
\family default 
 que o atributo 
\family typewriter 
umAtributo
\family default 
 acessado é realmente 
\family typewriter 
Pai.umAtributo
\family default 
, deve-se armazenar no espaço de C o identificador do campo obtido a partir
 da 
\family typewriter 
jclass
\family default 
 de 
\family typewriter 
Pai
\family default 
 -- obtida, por exemplo, em uma função 
\family typewriter 
static native
\family default 
.
 
\layout Comment

Verificação da ocorrência de erros
\layout Standard

O código C pode verificar a ocorrência de exceções através de 
\family typewriter 
ExceptionCheck
\family default 
 e optar por tratá-la, obtendo uma referência local da exceção com 
\family typewriter 
ExceptionOccurred
\family default 
 e posteriormente zerando-a com 
\family typewriter 
ExceptionClear
\family default 
, ou então mantê-la ativa de modo que seja propagada ao código Java.
\layout Comment

Exemplo de chamada de função
\layout Comment

Função vs.
 método
\layout Standard

Para realizar o exemplo da função 
\family typewriter 
teste
\family default 
, já que Java não possui funções globais, vamos assumir que teste é um método
 estático de uma classe chamada 
\family typewriter 
Exemplo
\family default 
 e que estamos rodando o código C a seguir em um contexto onde possuímos
 uma referência a um ambiente de execução Java chamado 
\family typewriter 
J
\family default 
 (este ponteiro, do tipo 
\family typewriter 
JNIEnv
\family default 
, será discutido na Seção 
\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass exemplo = (*J)->FindClass(J, "Exemplo");
\layout LyX-Code


\size footnotesize 
jmethodID teste = (*J)->GetStaticMethodID(J, exemplo,
\layout LyX-Code


\size footnotesize 
                        "teste", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring entrada = (*J)->NewStringUTF(J, "entrada");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, exemplo, teste, entrada, (jint)2);
\layout Comment

Controle das referências no exemplo
\layout Standard

Inicialmente, é obtida uma referência à classe 
\family typewriter 
Exemplo
\family default 
, a partir da qual é obtido o identificador do método desejado, baseado
 no seu nome e assinatura.
 Como em Ruby, a string passada como parâmetro deve ser convertida para
 um tipo da máquina virtual.
 Já para o segundo argumento e para o valor de retorno, exploramos o fato
 de que o tipo 
\family typewriter 
jint
\family default 
, correspondente ao tipo Java 
\family typewriter 
int
\family default 
 (inteiro de 32 bits), é compatível com o tipo 
\family typewriter 
long
\family default 
 de C (inteiro de pelo menos 32 bits).
 Todas estas funções da API retornam referências locais, que serão liberadas
 automaticamente ao final da função C onde as chamadas à API foram feitas.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Tanto em funções C disparadas por Lua como em chamadas de funções Lua realizadas
 a partir de código C, os parâmetros de entrada e os valores de retorno
 são passados através da pilha virtual apresentada na Seção 
\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Comment

Como obter/referenciar uma função
\layout Comment

Funções da API para invocar funções
\layout Comment

Verificação da ocorrência de erros
\layout Comment

Passando argumentos
\layout Standard

Para chamar uma função Lua a partir de C, devemos inicalmente empilhar o
 objeto Lua referente a ela: para funções globais, obtendo-a com 
\family typewriter 
lua_getglobal
\family default 
, para funções armazenadas em tabelas, com 
\family typewriter 
lua_gettable
\family default 
.
 A seguir, empilhamos os seus parâmetros e então invocamos 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, indicando quantos valores da pilha devem ser passados como parâmetro.
 A diferença entre as duas funções está no tratamento de erros: 
\family typewriter 
lua_call
\family default 
 propaga os erros sinalizados, usando 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 os captura os erros, retornando um código de 
\emph on 
status
\emph default 
 e a mensagem de erro na pilha.
\layout Comment

Valores de retorno
\layout Comment

Múltiplos valores de retorno
\layout Standard

No caso de execução sem erros, a pilha conterá os valores de retorno da
 função chamada.
 O número de valores de retorno pode ser explicitamente requisitado na chamada
 de 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, ou ser definido em tempo de execução, requisitando o valor especial 
\family typewriter 
LUA_MULTRET
\family default 
.
 Se um número de valores de retorno for solicitado e este não for passado
 pela função chamada, o número de valores será ajustado adicionando elementos
 
\family typewriter 
nil
\family default 
 ou descartando valores em excesso.
 Para chamadas com 
\family typewriter 
LUA_MULTRET
\family default 
, todos os valores são empilhados.
 Nesse caso, a única forma de descobrir quantos valores foram retornado
 é comparando o tamanho da pilha antes e depois da chamada.
\layout Standard

A função 
\family typewriter 
lua_cpcall
\family default 
 permite chamar funções C realizando captura de erros de forma similar a
 
\family typewriter 
lua_pcall
\family default 
 sem precisar registrá-las como valores Lua.
 Esta funcionalidade é similar à oferecida por 
\family typewriter 
rb_protect
\family default 
 em Ruby.
 Ruby, todavia, não oferece função análoga a 
\family typewriter 
lua_pcall
\family default 
, sendo às vezes necessário encapsular a chamada de funções Ruby em funções
 C que obedeçam à assinatura esperada por 
\family typewriter 
rb_protect
\family default 
.
\layout Comment

Função vs.
 método
\layout Standard

Lua não possui distinção entre funções e métodos, mas possui açúcar sintático
 que permite invocar funções armazenadas em tabelas com uma sintaxe de chamada
 de métodos: 
\family typewriter 
t:m(x)
\family default 
 significa 
\family typewriter 
t.m(t,x)
\family default 
.
 Todavia, não há na API de C uma chamada específica para replicar esta abreviaçã
o.
 Para funções armazenadas em tabela, a função deve ser obtida com 
\family typewriter 
lua_gettable
\family default 
 e a tabela deve ser empilhada explicitamente juntamente com os demais parametro
s.
\layout Comment

Exemplo de chamada de função
\layout Standard

O exemplo da chamada da função 
\family typewriter 
teste
\family default 
 demonstra a disciplina de pilha adotada na API de Lua.
 De forma similar a Java, iremos assumir a existência de um ponteiro 
\family typewriter 
L
\family default 
 do tipo 
\family typewriter 
lua_State
\family default 
, que será explicado mais adiante na Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "teste");           
\emph on 
/* Empilha a função teste */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "entrada");        
\emph on 
/* Empilha a string "entrada" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Empilha o número 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Chama a função com 2 parâmetros,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        e espera 1 como retorno */
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1);  
\emph on 
/* Obtém o resultado no topo da pilha (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove-o da pilha */
\layout Comment

Controle das refs no exemplo
\layout Standard

Com 
\family typewriter 
lua_getglobal
\family default 
, é empilhada a função global 
\family typewriter 
teste
\family default 
.
 Em seguida, os dois argumentos de entrada são empilhados.
 A função é então invocada com 
\family typewriter 
lua_call
\family default 
, indicando dois parâmetros de entrada e um de saída.
 O valor de retorno, no topo da pilha (índice -1) é convertido para C com
 
\family typewriter 
lua_tointeger
\family default 
.
 Esta última função não remove o valor da pilha: para retorná-la ao seu
 estado inicial, precisamos removê-lo explicitamente com 
\family typewriter 
lua_pop
\family default 
.
 Como em nenhum momento a API retorna ponteiros para objetos Lua, não há
 preocupações com coleta de lixo.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Comment

Como obter/referenciar uma função
\layout Comment

Funções da API para invocar funções
\layout Comment

Funções vs.
 métodos
\layout Standard

A chamada de funções Perl a partir de C se dá através de uma disciplina
 de pilha, como em Lua.
 Parâmetros de entrada são especificados através de operações de empilhamento
 e valores de retorno são obtidos na pilha após a chamada da função.
 As funções 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 e 
\family typewriter 
call_method
\family default 
 variam apenas na forma como a função a ser chamada é especificada: através
 de um 
\family typewriter 
SV
\family default 
, de uma string C ou de uma string C descrevendo o nome de um método de
 algum objeto ou classe inserido na pilha.
 A função 
\family typewriter 
call_argv
\family default 
, como conveniência, recebe como um argumento adicional um array C contendo
 strings C representando parâmetros a serem empilhados.
 Todas retornam o número de valores de retorno disponíveis na pilha.
\layout Comment

Questões específicas da linguagem: contextos Perl
\layout Standard

As funções 
\family typewriter 
call_
\family default 
* possuem um argumento indicando flags a serem passadas que indicam a forma
 que a função deve ser chamada e como tratar os argumentos e valores de
 retorno.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 e 
\family typewriter 
G_ARRAY
\family default 
 especificam um contexto como a função deve ser chamada.
 Em contextos escalares, por exemplo, somente um escalar é retornado na
 pilha; se a função chamada retornar uma lista, somente o último elemento
 desta estará disponível na pilha.
 
\family typewriter 
G_DISCARD
\family default 
 indica que os valores de retorno devem ser automaticamente descartados;
 
\family typewriter 
G_NOARGS
\family default 
 indica que o array padrão de parâmetros 
\family typewriter 
@_
\family default 
 não deve ser construído
\begin_inset Foot
collapsed true

\layout Standard

Isto tem o efeito colateral de que a função chamada herda o valor de 
\family typewriter 
@_
\family default 
 da função chamadora.
\end_inset 

.
\layout Comment

Verificação da ocorrência de erros.
\layout Standard

O precedimento para verificação de erros depende do contexto e das flags
 passadas, que afetam como situações de erro são reportadas no valor de
 retorno das funções 
\family typewriter 
call_
\family default 
* e nos valores retornados na pilha.
 A flag 
\family typewriter 
G_EVAL
\family default 
 encapsula a chamada em um bloco 
\family typewriter 
eval
\family default 
, capturando erros.
 A ocorrência de erros pode ser verificada através da macro 
\family typewriter 
ERRSV
\family default 
, que se refere a um escalar contendo a mensagem de erro.
 Acrescentando a flag 
\family typewriter 
G_KEEPERR
\family default 
, o valor da variável de retorno contendo a mensagem de erro não é zerado,
 acumulando seqüências de erros em níveis de chamada diferentes.
 
\layout Comment

Exemplo de chamada de função
\layout Standard

Uma série de macros descrevem um protocolo para a chamada de funções e a
 manipulação de parâmetros de entrada e saída.
 As principais serão explicadas a seguir, na apresentação da versão Perl
 da chamada da função 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("entrada", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("teste", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Comment

Passando argumentos
\layout Comment

Controle de referências no exemplo
\layout Standard

Inicialmente 
\family typewriter 
dSP
\family default 
 declara uma cópia local do ponteiro da pilha de Perl.
 Em seguida, 
\family typewriter 
ENTER
\family default 
 e 
\family typewriter 
SAVETMPS
\family default 
 criam um escopo para valores mortais.
 
\family typewriter 
PUSHMARK
\family default 
 inicia a contagem de parâmetros a serem passados para a função.
 Estes parâmetros são então empilhados com 
\family typewriter 
XPUSHs
\family default 
.
 Os valores criados com 
\family typewriter 
newSVpv
\family default 
 e 
\family typewriter 
newSViv
\family default 
 são convertidos para valores mortais com 
\family typewriter 
sv_2mortal
\family default 
, para que não tenham que ter sua contagem de referências decrementada explicita
mente após a chamada da função.
 
\family typewriter 
PUTBACK
\family default 
 encerra a contagem de parâmetros.
 É feita então a chamada da função global Perl 
\family typewriter 
teste
\family default 
, em contexto escalar, com 
\family typewriter 
call_pv
\family default 
.
\layout Comment

Valores de retorno
\layout Standard

Após o retorno desta função, a memória da pilha de Perl pode ter sido realocada,
 mudando o endereço do ponteiro de pilha obtido inicialmente com 
\family typewriter 
dSP
\family default 
.
 Para certificar-se que o seu valor está correto, deve-se chamar 
\family typewriter 
SPAGAIN
\family default 
 após funções 
\family typewriter 
call_
\family default 
*.
 A função 
\family typewriter 
POPl
\family default 
 desempilha um valor e o converte para 
\family typewriter 
long
\family default 
 (há funções similares para outros tipos, como 
\family typewriter 
POPs
\family default 
 para 
\family typewriter 
SV
\family default 
s e 
\family typewriter 
POPpx
\family default 
 para strings).
 Estas operações desempilham valores atualizando a cópia local do ponteiro
 de pilha.
 Assim, 
\family typewriter 
PUTBACK
\family default 
 deve ser chamado novamente para atualizar o ponteiro global.
 Finalmente, 
\family typewriter 
FREETMPS
\family default 
 e 
\family typewriter 
LEAVE
\family default 
 decrementam a contagem de referências dos valores mortais.
 
\layout Section

Registro de funções C
\layout Standard

Para permitir a invocação de funções C a partir de código da linguagem de
 script, a FLI deve fornecer uma forma de registrar estas funções no ambiente
 de execução.
 Em linguagens de tipagem estática como Java, para que seja possível chamar
 funções externas usando uma sintaxe igual à de funções nativas, o conjunto
 de funções externas deve ser declarado 
\emph on 
a priori
\emph default 
 de alguma forma.
 Já em linguagens com tipagem dinâmica, como é o caso de Python, Lua, Ruby
 e Perl, as funções podem ser usadas diretamente, bastando que sejam definidas
 em algum momento da execução antes de sua chamada.
 Assim, pode-se declarar as funções externas em tempo de execução através
 de código C usando a API da linguagem de script.
\layout Standard

Também nesta seção, a apresentação de cada linguagem encerrará com um exemplo.
 Em cada dos exemplos será apresentada uma função C declarada com a assinatura
 de formato esperado pela máquina virtual ou interpretador.
 Esta função obtém os valores de entrada e retorna um valor na saída.
 Será apresentada também, para cada linguagem, a forma de registrar a função
 como a global
\begin_inset Foot
collapsed true

\layout Standard

ou no caso de Java, método estático
\end_inset 

 
\family typewriter 
teste
\family default 
 de modo que ela possa ser invocada diretamente a partir da linguagem ou
 através da API do modo descrito na seção anterior.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Comment

O que são funções na linguagem
\layout Standard

Como visto na Seção 
\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, instâncias de classes Python podem ser tornadas 
\begin_inset Quotes eld
\end_inset 

chamáveis
\begin_inset Quotes erd
\end_inset 

 implementando um método 
\family typewriter 
__call__
\family default 
 em Python ou associando uma função C ao campo 
\family typewriter 
tp_call
\family default 
 do seu 
\family typewriter 
PyTypeObject
\family default 
 correspondente.
 Assim, Python não possui um tipo 
\begin_inset Quotes eld
\end_inset 

função
\begin_inset Quotes erd
\end_inset 

 propriamente dito.
 Métodos de classes, no entanto, possuem um tipo específico, que pode ser
 verificado com 
\family typewriter 
PyMethod_Check
\family default 
.
 Um objeto do tipo método pode ser criado explicitamente a partir de C com
 
\family typewriter 
PyMethod_New
\family default 
, passando como parâmetro um objeto Python 
\begin_inset Quotes eld
\end_inset 

chamável
\begin_inset Quotes erd
\end_inset 

 e o objeto ou classe a que ele deve se referir.
\layout Comment

Parâmetros de entrada
\layout Standard

Tipicamente, entretanto, funções C são registradas passando-se um array
 de estruturas 
\family typewriter 
PyMethodDef
\family default 
.
 Estas estruturas são compostas do nome da função, o ponteiro da função
 C, uma string de documentação e um vetor de flags.
 Estas flags são usadas para indicar a convenção adotada para os parâmetros
 de entrada na função C.
 Por exemplo, a flag 
\family typewriter 
METH_NOARGS
\family default 
 é usada para funções que não recebem parâmetros; 
\family typewriter 
METH_VARARGS
\family default 
 para funções que recebem um número variável de parâmetros passados para
 C como uma tupla Python; 
\family typewriter 
METH_KEYWORDS
\family default 
 para indicar que a função recebe como parâmetro adicional um dicionário
 contendo os argumentos 
\emph on 
keywords
\emph default 
 passados à função.
\layout Comment

API para registrar funções
\layout Standard

De posse destas informações, funções da API que operam sobre arrays de 
\family typewriter 
PyMethodDef
\family default 
 podem criar e associar objetos do tipo método no espaço de Python.
 
\family typewriter 
Py_InitModule
\family default 
, por exemplo, inicializa um módulo com funções de um array de 
\family typewriter 
PyMethodDef
\family default 
.
 Similarmente, os métodos de uma classe implementada em C podem ser dados
 no campo 
\family typewriter 
tp_methods
\family default 
.
\layout Comment

Valores de retorno
\layout Standard

Funções C registradas em Python devem retornar um ponteiro para 
\family typewriter 
PyObject
\family default 
, ou 
\family typewriter 
NULL
\family default 
 em caso de erro (opcionalmente declarando uma exceção com 
\family typewriter 
PyErr_SetString
\family default 
 ou 
\family typewriter 
PyErr_SetObject
\family default 
).
 Funções que não retornam valores devem retornar o objeto pré-definido 
\family typewriter 
Py_None
\family default 
, lembrando das questões de contagem de referência de valores retornados
 discutidas na Seção 
\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Comment

Exemplo
\layout Standard

Uma implementação simples de uma função C que pode ser registrada em Python
 como a função global 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* teste_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* entrada; long n;
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &entrada, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Comment

Verificar valores de entrada
\layout Standard

A assinatura de função empregada corresponde à flag 
\family typewriter 
METH_VARARGS
\family default 
.
 Os parâmetros de entrada são convertidos para C e verificados com 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 O valor de retorno é convertido do tipo nativo C para um 
\family typewriter 
PyObject
\family default 
 com 
\family typewriter 
PyInt_FromLong
\family default 
, gerando uma nova referência.
\layout Comment

Exemplo de registro de global
\layout Standard

A API de Python é projetada primariamente para o desenvolvimento de módulos
 de extensão para a linguagem.
 Embora existam diversas funções para registrar métodos em classes e inicializar
 módulos com listas de funções, não há uma forma direta para registrar funções
 globais na máquina virtual.
 Uma maneira possível é usando a rotina utilitária para lookup de métodos
 
\family typewriter 
Py_FindMethod
\family default 
 e inserindo o método retornado no dicionário do módulo global 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef teste_def[] = {
\layout LyX-Code


\size footnotesize 
   { "teste", (PyCFunction) teste_py, METH_VARARGS, NULL },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* teste_obj = Py_FindMethod(teste_def, NULL, "teste");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "teste", teste_obj);
\layout Standard

Note que foi passado 
\family typewriter 
NULL
\family default 
 para 
\family typewriter 
Py_FindMethod
\family default 
, indicando que não há um objeto a que o método se refere.
 O argumento 
\family typewriter 
self
\family default 
 recebido pela função C 
\family typewriter 
teste_py
\family default 
 será também 
\family typewriter 
NULL
\family default 
 e pode ser ignorado.
 O array 
\family typewriter 
teste_def
\family default 
 foi declarado 
\family typewriter 
static
\family default 
 pois na criação de 
\family typewriter 
teste_obj
\family default 
 um ponteiro para ele é armazenado internamente no objeto criado.
 Desta forma, o 
\family typewriter 
PyMethodDef
\family default 
 deve continuar válido enquanto a função global estiver registrada.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Comment

API para registrar funções
\layout Comment

Convenção para parâmetros de entrada
\layout Standard

Para que funções C possam ser chamadas a partir de Ruby, elas devem ser
 declaradas como métodos de alguma classe ou módulo, ou ainda como uma função
 global.
 Para isto, passa-se um ponteiro de uma função C e o número de argumentos
 que a função espera para uma das funções apropriadas da API de Ruby: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 ou 
\family typewriter 
rb_define_singleton_method
\family default 
.
 O número de parâmetros passado indica a assinatura esperada para a função
 C.
 Ruby suporta explicitamente funções C com até 15 argumentos; como alternativa,
 os valores especiais -1 e -2 indicam, respectivamente, que a função C irá
 receber os parâmetros na forma de um array C de 
\family typewriter 
VALUE
\family default 
s ou na forma de um 
\family typewriter 
VALUE
\family default 
 correspondente a um array Ruby.
\layout Standard

De forma similar à função 
\family typewriter 
PyArg_ParseTuple
\family default 
, Ruby possui uma função projetada para simplificar o processamento dos
 valores de entrada em funções C: 
\family typewriter 
rb_scan_args
\family default 
.
 Esta função pode ser usada quando os parâmetros de entrada são recebidos
 em um array Ruby.
 Como 
\family typewriter 
PyArg_ParseTuple
\family default 
, ela é uma função vararg que recebe uma string de formato indicando o número
 de parâmetros a serem coletados.
 Por outro lado, ela não realiza verificação de tipo dos argumentos.
 A string de formato permite indicar o número mínimo e máximo de parâmetros
 aceitos e se os parâmetros excedentes devem ser coletados em um array Ruby.
\layout Comment

Questões específicas: blocos
\layout Standard

Uma vez declarada no espaço de objetos de Ruby, uma função C pode ser chamada
 como qualquer outro método.
 A função C pode verificar se o código Ruby lhe passou um bloco de código
 através da função 
\family typewriter 
rb_block_given_p
\family default 
.
 O bloco pode então ser invocado com 
\family typewriter 
rb_yield
\family default 
, que recebe um 
\family typewriter 
VALUE
\family default 
 como argumento.
 Para passar múltiplos argumentos para 
\family typewriter 
rb_yield
\family default 
, deve-se passar um array Ruby.
 Para obter um 
\family typewriter 
VALUE
\family default 
 do tipo 
\family typewriter 
Proc
\family default 
 produzido a partir do bloco de código recebido é preciso usar 
\family typewriter 
rb_scan_args
\family default 
, que possui funcionalidade similar à do operador 
\family typewriter 
&
\family default 
 em declarações de funções Ruby.
\layout Comment

Valores de retorno
\layout Standard

Funções C implementado métodos Ruby devem sempre retornar um 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 quando não há retorno).
 Funções que retornam múltiplos valores devem fazê-lo através de um array
 Ruby.
\layout Comment

Exemplo de função
\layout Standard

Dando continuidade à série de exemplos, a função global Ruby 
\family typewriter 
teste
\family default 
 pode ser implementada da seguinte forma em C:
\layout LyX-Code


\size footnotesize 
VALUE teste_rb(VALUE self, VALUE val_entrada, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* entrada = StringValuePtr(val_entrada);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Comment

Verificar valores de entrada
\layout Standard

A conversão dos 
\family typewriter 
VALUE
\family default 
s de entrada é feita com as macros 
\family typewriter 
StringValuePtr
\family default 
 e 
\family typewriter 
NUM2INT
\family default 
.
 Não há código explícito para tratamento de erros na conversão pois estas
 macros disparam exceções que saem da função via 
\family typewriter 
longjmp
\family default 
 caso a conversão não seja possível.
 Para a saída, é produzido um 
\family typewriter 
VALUE
\family default 
 com a macro 
\family typewriter 
INT2NUM
\family default 
.
 O primeiro parâmetro de entrada é necessário segundo a convenção de assinaturas
 de função da API, mas para funções globais ele deve ser ignorado.
\layout Comment

Exemplo de registro de fn global
\layout Standard

Como Ruby oferece uma função na API para a definição de funções globais,
 o registro de 
\family typewriter 
teste
\family default 
 é bastante simples:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("teste", teste_rb, 2); 
\layout Standard

É indicado o nome da função no espaço de Ruby, a função C correspondente
 e o número de parâmetros a serem passados para ela (não incluindo o parâmetro
 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Comment

Questões específicas: métodos native
\layout Standard

Métodos não implementados em Java devem ser declarados através de um protótipo
 incluindo o modificador 
\family typewriter 
native
\family default 
.
 Assim, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 A implementação do método, usualmente encapsulada em uma biblioteca dinâmica
 C, deve ser carregada antes de sua execução usando a chamada 
\family typewriter 
System.loadLibrary
\family default 
 em Java, usualmente em um bloco 
\family typewriter 
static
\family default 
 da classe correspondente.
 Para cada método 
\family typewriter 
native
\family default 
, uma função C correspondente deve ser definida na biblioteca carregada.
\layout Standard

O utilitário 
\family typewriter 
javah
\family default 
 gera arquivos de cabeçalho C a partir de classes Java, com os protótipos
 de funções C no formato especificado pela JNI.
 Este formato especifica não apenas a assinatura dos parâmetros de entrada
 e tipo de retorno, mas também o nome da função, para que o 
\emph on 
loader
\emph default 
 realize a ligação entre a função C e o método Java na máquina virtual.
 As funções devem se chamar 
\family typewriter 
Java_
\family default 
\emph on 
<nome da classe>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<nome do método>
\emph default 
.
 No caso de sobrecarga de funções, um sufixo é adicionado indicando o tipo
 dos parâmetros de entrada (por exemplo, 
\family typewriter 
Java_Classe_metodo__DI
\family default 
 para a versão de 
\family typewriter 
Classe.metodo
\family default 
 que aceita um 
\family typewriter 
double
\family default 
 e um 
\family typewriter 
int
\family default 
 como parâmetros).
\layout Standard

Os parâmetros de entrada da função são um ponteiro para 
\family typewriter 
JNIEnv
\family default 
, que representa uma thread da JVM, um 
\family typewriter 
jobject
\family default 
 representando o objeto sobre o qual o método é aplicado (ou uma 
\family typewriter 
jclass
\family default 
 para métodos estáticos) e os demais parâmetros da função Java em suas represent
ações C, discutidas na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 As funções da JNI são expostas como ponteiros para funções dentro da estrutura
 descrita por 
\family typewriter 
JNIEnv
\family default 
.
\layout Standard

O tipo de retorno corresponde ao tipo C equivalente ao tipo de retorno do
 método Java.
 O valor retornado pode ser uma referência local ou global.
 Além de tratar ou propagar erros como discutido na Seção 
\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, funções C podem também gerar exceções com 
\family typewriter 
Throw
\family default 
 e 
\family typewriter 
ThrowNew
\family default 
 e retornar imediatamente.
 O valor de retorno será ignorado quando a exceção for capturada no código
 Java.
\layout Comment

Exemplo de registro de função global
\layout Comment

Funções da API para registrar funções (não há)
\layout Standard

Como o modo de expor à máquina virtual de Java funções implementadas em
 C é diferente do empregado nas linguagens vistas anteriormente, não iniciaremos
 pelo exemplo mostrando a implementação de 
\family typewriter 
teste
\family default 
 em C, mas pela forma de declarar a função para o espaço de Java.
 Na classe em Java, declaramos um método 
\family typewriter 
native
\family default 
:
\layout LyX-Code


\size footnotesize 
public class Exemplo {
\layout LyX-Code


\size footnotesize 
   static native int teste(String entrada, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...demais membros da classe
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Exemplo");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Comment

Exemplo de função
\layout Standard

Após compilar esta classe podemos passá-la para o comando 
\family typewriter 
javah
\family default 
, que gerará um arquivo de cabeçalho C.
 Este arquivo conterá o nome e assinatura da função C que a JVM irá procurar
 na biblioteca que será carregada por 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed true

\layout Standard

O parâmetro passado no código Java é usado como base na construção de um
 nome dependente de plataforma.
 Em sistemas Unix, por exemplo, o comando 
\family typewriter 
System.loadLibrary("Exemplo")
\family default 
 carrega o arquivo 
\family typewriter 
libExemplo.so
\family default 
.
\end_inset 

.
 Abaixo, é dada uma implementação possível para esta função:
\layout LyX-Code


\size footnotesize 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_teste(JNIEnv* J, jclass c, jstring obj_entrada, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = (*J)->GetStringUTFChars(J, obj_entrada, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_entrada, entrada);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Comment

Parâmetros de entrada
\layout Comment

Verificar valores de entrada
\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 e 
\family typewriter 
JNICALL
\family default 
 são macros definidas em 
\family typewriter 
jni.h
\family default 
 para dar maior portabilidade ao código C gerado.
 Como a função foi declarada como 
\family typewriter 
static
\family default 
, uma referência para a classe é passada como parâmetro.
 Os demais parâmetros correspondem aos parâmetros do método Java, e são
 dados nos tipos equivalentes da JNI.
 Conforme discutido na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, a JNI dá tratamentos diferentes para tipos de referência e tipos imediatos.
 Desta forma, somente o parâmetro 
\family typewriter 
obj_entrada
\family default 
 precisa ser convertido para C; tanto 
\family typewriter 
n
\family default 
 como o valor de retorno podem ser usados diretamente como tipos básicos
 de C.
 Como Java é uma linguagem tipada estaticamente, não é preciso verificar
 os tipos dos parâmetros de entrada na função C.
\layout Standard

A string obtida com 
\family typewriter 
GetStringUTFChars
\family default 
 é convertida para UTF-8 a partir da representação Unicode interna de Java.
 O mesmo ponteiro pode ser retornado pela JVM a diferentes threads que solicitem
 a mesma string.
 Deste modo, o código C deve notificar a sua liberação explicitamente com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Comment

Valor de retorno
\layout Standard

Neste exemplo, a função retorna um valor imediato.
 Valores representados com tipos de referência podem ser retornados tanto
 com referências locais como globais.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

Funções C expostas ao espaço de Lua devem ter o tipo 
\family typewriter 
lua_CFunction
\family default 
, isto é, retornar um 
\family typewriter 
int
\family default 
 e receber como único parâmetro um ponteiro para uma variável do tipo 
\family typewriter 
lua_State
\family default 
.
 Um 
\family typewriter 
lua_State
\family default 
 encapsula todo o estado da máquina virtual de Lua; múltiplos estados Lua
 podem ser mantidos em paralelo.
 Todas as funções da API 
\emph on 
core
\emph default 
 de Lua recebem um 
\family typewriter 
lua_State
\family default 
 como primeiro parâmetro, exceto 
\family typewriter 
lua_newstate
\family default 
, que cria um 
\family typewriter 
lua_State
\family default 
 novo.
\layout Comment

Convenções p/ parâmetros de entrada
\layout Standard

Ao início da função C, os argumentos passados a ela encontram-se inseridos
 na pilha virtual.
 Como em funções Lua, não há verificação sobre o número de argumentos passados
 para uma função C invocada a partir de Lua ou através da API.
 O código C pode verificar o número de argumentos passados inspecionando
 o tamanho da pilha recebida.
\layout Comment

Verificar valores de entrada
\layout Standard

A biblioteca auxiliar provê ainda funções para verificar de forma mais convenien
te o tipo dos argumentos passados.
 Funções da família 
\family typewriter 
luaL_check
\family default 
* (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) verificam o tipo de um elemento da pilha e o retornam, sinalizando
 erro caso o tipo do elemento não seja o requisitado.
 As funções 
\family typewriter 
luaL_opt
\family default 
* se comportam de forma similar, permitindo ainda indicar um valor padrão
 caso o elemento esteja ausente ou seja 
\family typewriter 
nil
\family default 
.
 
\layout Comment

Valores de retorno
\layout Standard

Valores de retorno também são passados pela função C de volta para Lua através
 da pilha virtual.
 O valor inteiro retornado da função C indica quantos elementos da pilha
 devem ser retornados ao à função chamadora.
 Os demais valores da pilha são descartados.
\layout Comment

Funções da API p/ registrar funções
\layout Standard

Uma função C do tipo 
\family typewriter 
lua_CFunction
\family default 
 é passada para o espaço de Lua através da função 
\family typewriter 
lua_pushcclosure
\family default 
.
 É possível associar à função valores Lua que serão acessíveis à função
 sempre que esta for chamada, de forma similar a variáveis locais 
\family typewriter 
static
\family default 
 C.
 Este recurso provê uma funcionalidade similar às 
\emph on 
closures
\emph default 
 de Lua, porém mais limitado: os valores associados são privados às funções
 C, enquanto em Lua duas 
\emph on 
closures
\emph default 
 definidas num mesmo escopo terão acesso às mesmas variáveis, isto é, alterações
 nos valores em uma afetarão a outra.
 Esta forma restrita, porém, já permite a implementação em C de 
\begin_inset Quotes eld
\end_inset 

funções com estado
\begin_inset Quotes erd
\end_inset 

, como iteradores e geradores.
 Uma vez registrada no espaço de Lua, funções C passam a ser vistos como
 valores do tipo 
\family typewriter 
function
\family default 
, de forma igual a funções Lua.
\layout Standard

Lua possui algumas funções de conveniência para registrar funções C no espaço
 de Lua.
 De forma similar ao array de 
\family typewriter 
PyMethodDef
\family default 
s em Python, a função 
\family typewriter 
luaL_register
\family default 
 registra uma lista de funções em lote, recebendo um array de estruturas
 
\family typewriter 
luaL_Reg
\family default 
, contendo nomes e ponteiros de função.
\layout Comment

Exemplo de função
\layout Standard

A função C implementando a função de exemplo 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
int teste_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = luaL_checkstring(L, 1);
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);
\layout LyX-Code


\size footnotesize 
   return 1;
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A função tem assinatura compatível com 
\family typewriter 
lua_CFunction
\family default 
, recebendo apenas o 
\family typewriter 
lua_State
\family default 
 e retornando um inteiro.
 Os parâmetros de entrada são obtidos da pilha e os seus tipos são verificados
 usando as funções da biblioteca auxiliar 
\family typewriter 
luaL_checkstring
\family default 
 e 
\family typewriter 
luaL_checkinteger
\family default 
.
 Estas funções sinalizam erro em caso de falha na conversão, causando um
 
\family typewriter 
longjmp
\family default 
 como em Ruby.
\layout Standard

Assim como em Java, o tipo da string obtida é 
\family typewriter 
const char*
\family default 
 pois ela aponta um bloco de memória gerenciado pela máquina virtual.
 Em Lua, no entanto, não é preciso notificar a liberação da string explicitament
e, pois esta permanece válida enquanto o valor estiver na pilha.
 Como as funções 
\family typewriter 
luaL_check
\family default 
* não desempilham os parâmetros e a pilha é esvaziada implicitamente ao
 final da função C, as string C obtida permanecerá válida ao longo da função.
 Ao fim da função, o valor de retorno para Lua é empilhado e 
\family typewriter 
return 1
\family default 
 indica à máquina virtual que há um único valor de saída.
\layout Comment

Exemplo de registro
\layout Standard

A função é registrada em Lua criando um objeto Lua do tipo 
\family typewriter 
function
\family default 
 a partir da função C e armazenando este objeto em uma variável global.
 Isto poderia ser feito com 
\family typewriter 
lua_pushcclosure
\family default 
 e 
\family typewriter 
lua_setglobal
\family default 
, mas a biblioteca auxiliar possui uma macro que encapsula estas duas chamadas.
 Assim, a função pode ser registrada simplesmente com:
\layout LyX-Code


\size footnotesize 
luaL_register(L, "teste", teste_lua);
\layout Subsection

Perl
\layout Comment

Questões específicas
\layout Standard

Como discutido na Seção 
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 

, a interface entre Perl e C foi projetada tendo em mente que a ligação
 entre as funções C e o interpretador Perl é feita através de código gerado
 a partir de uma descrição feita em uma linguagem de mais alto nível, XS.
 Código XS consiste de declarações de assinaturas de função com uma sintaxe
 especial, indicando regras para conversão dos parâmetros de entrada e saída,
 e código C descrevendo a implementação das funções.
 XS é projetada para o desenvolvimento de extensões Perl incluindo funções
 implementadas em C: o resultado final da compilação do código gerado pelas
 ferramentas XS (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) são código C e Perl que juntos descrevem um pacote Perl (um conjunto de
 variáveis e funções armazenados sob um 
\emph on 
namespace
\emph default 
 comum).
\layout Comment

API para registrar funções (não tem)
\layout Standard

Existe uma API pública para manipulação de dados Perl no código C, mas esta
 consiste basicamente das estruturas internas da implementação do interpretador
 expostas para uso pelo pré-processador XS, acrescida de macros para maior
 conveniência do programador.
 De fato, Perl não expõe uma API documentada para o registro de funções
 
\begin_inset LatexCommand \cite{perlapi}

\end_inset 

.
 Assim, não é prático para uma aplicação embutir um interpretador Perl e
 expor a ele um conjunto de funções C usando apenas código C.
 A saída é criar uma extensão Perl usando XS que expõe funções da aplicação
 e importar o pacote resultante no interpretador embutido.
 O emprego desta abordagem foi observada nos plugins para scripting Perl
 de diversas aplicações 
\begin_inset Foot
collapsed true

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) e Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) são algumas aplicações que implementam plugins Perl através de extensões
 XS.
 No plugin de Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), não há arquivos 
\family typewriter 
.xs
\family default 
, mas os fontes 
\family typewriter 
.c
\family default 
 incluem funções declaradas com a API não documentada e o código Perl equivalent
e ao arquivo 
\family typewriter 
.pm
\family default 
 gerado por 
\family typewriter 
xsubpp
\family default 
 declarado como uma string C avaliada com 
\family typewriter 
eval_pv
\family default 
, dando a entender que o plugin foi implementado como uma extensão usando
 XS e depois convertido para um único arquivo-fonte C.
\end_inset 

.
\layout Comment

Exemplo de função
\layout Standard

O utilitário 
\family typewriter 
h2xs
\family default 
 gera um diretório contendo o esqueleto de um módulo Perl: um script gerador
 de Makefiles, arquivos 
\family typewriter 
.xs
\family default 
 e 
\family typewriter 
.pm
\family default 
 a serem acrescidos de código XS e Perl, além de arquivos auxiliares.
 Retomando o exemplo da função teste, ela seria declarada da seguinte forma
 em XS:
\layout LyX-Code


\size footnotesize 
long teste(entrada, n)
\layout LyX-Code


\size footnotesize 
        char* entrada
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Comment

Parâmetros de entrada
\layout Standard

O arquivo 
\family typewriter 
.xs
\family default 
 é convertido para 
\family typewriter 
.c
\family default 
 com 
\family typewriter 
xsubpp
\family default 
.
 O código C conversão dos parâmetros de entrada e saída é gerado automaticamente.
 Em alguns casos, entretanto, precisamos manipular os valores da pilha de
 Perl explicitamente, como descrito na Seção 
\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 Em funções vararg, por exemplo, os argumentos adicionais devem ser acessados
 diretamente na pilha.
 O código para registrar as funções do módulo também é gerado automaticamente.
\layout Comment

Valores de retorno
\layout Standard

XS cria uma variável 
\family typewriter 
RETVAL
\family default 
 automaticamente para armazenamento do valor de retorno em código C.
 O conteúdo desta variável é convertido para um valor Perl pelo código C
 gerado.
 Para que funções operem corretamente em diferentes contextos Perl, entretanto,
 deve-se verificar o contexto em que a função é chamada com 
\family typewriter 
GIMME_V
\family default 
 e então retornar um 
\family typewriter 
SV
\family default 
 ou 
\family typewriter 
AV
\family default 
 conforme o caso.
 A função, nestes casos, deve ser declarada com tipo de retorno 
\family typewriter 
SV*
\family default 
, fazendo com que os valores de C devam ser convertidos para 
\family typewriter 
SV
\family default 
s Perl explicitamente.
 A documentação alerta que, para o caso de 
\family typewriter 
AV
\family default 
s, deve-se declarar o valor de retorno como variável mortal
\begin_inset Foot
collapsed true

\layout Standard

Este comportamento de exceção é descrito na documentação como um 
\begin_inset Quotes eld
\end_inset 

bug que não pode ser resolvido
\begin_inset Quotes erd
\end_inset 

 pois 
\begin_inset Quotes eld
\end_inset 

muitas extensões dependem do comportamento atual
\begin_inset Quotes erd
\end_inset 

.
\end_inset 

.
\layout Standard

Uma vez compilada a extensão usando os Makefiles gerados por 
\family typewriter 
h2xs
\family default 
, a extensão pode ser carregada e usada a partir de Perl:
\layout LyX-Code


\size footnotesize 
use Teste;
\layout LyX-Code


\size footnotesize 
$ret = Teste::teste("entrada", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard

Para expor funções de uma aplicação C a um interpretador Perl embutido nela,
 devemos criar uma extensão que encapsula estas funções usando XS, ligar
 a extensão à aplicação e carregá-la.
 A carga é feita passando para o interpretador uma função C contendo chamadas
 
\family typewriter 
newXS
\family default 
 durante a sua inicialização.
 O módulo Perl 
\family typewriter 
ExtUtils::Embed
\family default 
 possui uma rotina 
\family typewriter 
xsinit
\family default 
 para gerar o código C desta função.
 Na prática, gerar o código da função com 
\family typewriter 
xsinit
\family default 
 é a melhor abordagem, já que a inicialização depende de rotinas não documentada
s (o exemplo de função de inicialização incluído na documentação de Perl
 está desatualizado).
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de Caso: LibScript
\layout Standard

No capítulo anterior, foram discutidas as principais questões envolvendo
 interfaces de linguagens para C e a forma como estas questões são tratadas
 pelas linguagens abordadas neste estudo.
 Neste capítulo, realizaremos uma comparação entre as FLIs através de um
 exemplo concreto, de modo a colocar implementações em cada uma das linguagens
 lado a lado.
 O exemplo consiste em uma biblioteca genérica para scripting, chamada LibScript
, e uma série de plugins que realizam a interface com as diferentes linguagens
 de script.
\layout Section

LibScript
\layout Standard

LibScript é uma biblioteca projetada para permitir a extensibilidade a aplicaçõe
s através de scripting de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de plugin
\emph on 
s
\emph default 
, de modo a desacoplar a aplicação dos ambientes de execução providos pelas
 diversas linguagens.
 A biblioteca principal, 
\family typewriter 
libscript
\family default 
, é uma fina camada que provê uma API para scripting independente de linguagem,
 permitindo à aplicação registrar as suas funções e invocar código a ser
 executado.
 Esta biblioteca então invoca o plugin da linguagem apropriada para rodar
 o código (por exemplo, 
\family typewriter 
libscript-python
\family default 
 para código Python).
 Desta forma, o desenvolvedor da aplicação permite ao seu usuário utilizar
 diferentes linguagens para scripting sem adicionar todas elas como dependências
 do programa.
\layout Standard

A biblioteca principal oferece uma API para o registro de funções C por
 parte da aplicação e para a chamada destas funções por parte dos plugin
\emph on 
s
\emph default 
, além de funções para a transferência de dados entre as duas partes.
 A API de chamada de funções permite ainda invocar funções implementadas
 nas máquinas virtuais embutidas nos plugin
\emph on 
s
\emph default 
, permitindo assim que scripts escritos em diferentes linguagens possam
 interagir.
 A Seção 
\begin_inset LatexCommand \ref{sec:A-Camada-Independente}

\end_inset 

 discute a biblioteca principal em maior detalhe.
\layout Standard

Cada plugin, além de embutir um ambiente de execução, registra nele uma
 estrutura de dados específica da linguagem (classe, módulo, tabela) que
 agirá como o espaço de nomes para funções registradas através de LibScript.
 Implementamos plugins para as linguagens Python, Ruby, Lua e Perl.
 Estes plugins serão discutidos na Seção 
\begin_inset LatexCommand \ref{sec:Implementação-dos-plugins}

\end_inset 

.
 A API de LibScript é descrita por completo no Apêndice 
\begin_inset LatexCommand \ref{cha:API-de-LibScript}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

A Camada Independente de Linguagem
\layout Standard

A API oferecida por LibScript isola a aplicação das diferentes APIs oferecidas
 pelas linguagens de script.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas,
 o que seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Outra abordagem é, ao invés de expor a API da linguagem à aplicação, expor
 apenas uma API de funções da aplicação para a linguagem e manter as estruturas
 de dados e recursos desta restrito ao domínio que será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em 
\begin_inset LatexCommand \cite{ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{pyvhll_ext,pyvhll_ref}

\end_inset 

.
 Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python 
\begin_inset LatexCommand \cite{pyvhll_ref}

\end_inset 

, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby 
\begin_inset LatexCommand \cite{ext_ruby}

\end_inset 

, 
\family typewriter 
perl_eval_sv
\family default 
 em Perl 
\begin_inset LatexCommand \cite{perlembed}

\end_inset 

.
\layout Standard

LibScript adota esta abordagem mais minimalista para sua API: não são oferecidas
 funções específicas para manipulação de estruturas de dados, apenas para
 a execução de strings e chamadas de função com tipos básicos (números e
 strings).
 Operações sobre dados mais complexos de tipos específicos de cada linguagem
 podem ser especificados diretamente nas strings de código.
 Referências a estes dados podem ser mantidas em C usando identificadores
 numéricos, como no registro de Lua, apresentado na Seção 
\begin_inset LatexCommand \ref{sub:Lua-GC}

\end_inset 

.
\layout Standard

Chamadas de função são disponibilizadas como a única operação primitiva
 além de execução de strings pois elas permitem um grau mínimo de interoperabili
dade de forma independente de linguagem.
 Dois objetivos são atingidos desta forma.
 O primeiro é que programas C embutindo LibScript podem acessar a funcionalidade
 de scripts carregados sem precisar incluir no seu código strings de texto
 em alguma linguagem específica.
 O segundo objetivo é permitir que os próprios plugins possam invocar funções
 definidas em outros plugins.
 De qualquer forma, necessariamente teríamos que prover uma forma de permitir
 aos plugins chamarem as funções C registradas em LibScript.
 Tornar esta função de chamada -- 
\family typewriter 
script_call
\family default 
 -- genérica o suficiente para que pudesse invocar também funções implementadas
 nos próprios plugins não torna, então, a API da biblioteca principal mais
 complexa.
 
\layout Standard

Além disso, um dos objetivos do projeto de LibScript foi compartilhar o
 máximo possível a API a ser usada pela aplicação e pelos plugins.
 Por este motivo, optamos por uma abordagem similar às empregadas em Lua
 (Seção 
\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) e Perl (Seção 
\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) para a passagem de dados na passagem de parâmetros e obtenção de valores
 de retorno, usando um buffer interno como área de transferência.
 Diferentemente destas linguagens, entretanto, passamos índices para os
 parâmetros explicitamente ao invés de empregar uma disciplina de pilha.
 As funções 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} são usadas na entrada e saída de valores.
 As funções 
\family typewriter 
script_put_
\family default 
* armazenam valores no buffer interno e 
\family typewriter 
script_get_
\family default 
* os removem.
 Elementos que não tenham sido consumidos do buffer, como por exemplo valores
 de retorno ignorados, são descartados na chamada seguinte.
\layout Standard

Tanto nas funções da aplicação C a serem registradas em LibScript como no
 tratamento de chamadas de função nos plugins, usam-se as funções 
\family typewriter 
script_get_
\family default 
* para obter os parâmetros de entrada e 
\family typewriter 
script_put_
\family default 
* para fazer a saída dos valores de retorno.
 De forma inversa, na implementação de chamadas a funções C em plugins bem
 como no uso de 
\family typewriter 
script_call
\family default 
 em funções C, usa-se 
\family typewriter 
script_put_
\family default 
* para passar os parâmetros passados e 
\family typewriter 
script_get_
\family default 
* para obter os valores de retorno.
\layout Standard

A carga de plugins é feita de forma implícita, pelas duas funções de execução
 de código: 
\family typewriter 
script_run_file
\family default 
, que executa um script contido em um arquivo, ou 
\family typewriter 
script_run
\family default 
, que executa um script contido em uma string.
 Para código executado com 
\family typewriter 
script_run_file
\family default 
, o plugin a ser carregado é detectado a partir da extensão do arquivo ou
 da linha de identificação 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 no início do script
\begin_inset Foot
collapsed true

\layout Standard

A linha 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 é usada apenas para detectar a linguagem em que o script é escrito.
 Por exemplo, uma linha 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 indicará a carga do plugin 
\family typewriter 
libscript-perl
\family default 
, mas o interpretador Perl em 
\family typewriter 
/usr/bin
\family default 
 não é usado e nem a flag 
\family typewriter 
-w
\family default 
 passada é considerada.
\end_inset 

.
 Na função 
\family typewriter 
script_run
\family default 
, um parâmetro adicional deve indicar explicitamente a linguagem do código.
 O exemplo a seguir registra uma função C chamada 
\family typewriter 
hello
\family default 
 e a invoca a partir de código Lua:
\layout LyX-Code


\size footnotesize 
env = script_init("exemplo");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "exemplo.hello()");
\layout Standard

Um plugin consiste de uma biblioteca dinâmica chamada 
\family typewriter 
libscript-
\family default 
\emph on 
<linguagem>
\emph default 
 e arquivos 
\emph on 
<identificador>
\family typewriter 
\emph default 
.id
\family default 
 que associam diferentes nomes à biblioteca.
 Estes nomes são usados por em 
\family typewriter 
script_run_file
\family default 
 para associar extensões de arquivo ou o nome do executável interpretador
 a um plugin.
 Por exemplo, o plugin 
\family typewriter 
libscript-python
\family default 
 inclui o arquivo 
\family typewriter 
py.id
\family default 
, contendo a string 
\family typewriter 
"python"
\family default 
.
 Desta forma, um arquivo de extensão 
\family typewriter 
.py
\family default 
 carregado via 
\family typewriter 
script_run_file
\family default 
 dispara a carga do plugin apropriado.
\layout Section

A API de plugins
\layout Standard

Um plugin que embute uma linguagem de script deve implementar quatro operações:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 e 
\family typewriter 
done
\family default 
.
 Estas operações são representadas em funções exportadas pela biblioteca
 do plugin com nomes do tipo
\family typewriter 
 script_plugin_
\family default 
\emph on 
<operação>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<linguagem>
\emph default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável pela inicialização de um plugin, e é chamada pela função
 
\family typewriter 
script_init
\family default 
 da biblioteca principal.
 A função 
\family typewriter 
script_init
\family default 
 recebe uma string como parâmetro que representa o nome de um 
\emph on 
ambiente
\emph default 
 a ser criado.
 Um ambiente consiste de um conjunto de funções C nele registradas e os
 estados correspondentes nos plugins carregados.
 Ambientes são representados como um ponteiros opacos do tipo 
\family typewriter 
script_env
\family default 
, e são passados como primeiro parâmetro para todas as demais funções da
 API de LibScript.
 Na inicialização de um plugin, a biblioteca passa à função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 um 
\family typewriter 
script_env
\family default 
 e recebe um 
\family typewriter 
script_plugin_state
\family default 
, que é um tipo opaco que é sempre retornado ao plugin nas demais chamadas.
 Cada plugin define a sua representação interna para 
\family typewriter 
script_plugin_state
\family default 
, de modo a descrever de forma apropriada para a linguagem um espaço de
 nomes.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
 Na Seção 
\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 discutiremos como cada plugin representa seus estados em 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
 envia código para ser executado pelo plugin.
 Ela recebe uma string contendo código a ser executado e retorna um código
 de status indicando sucesso ou a ocorrência de erros de compilação ou execução.
 No caso de erros, os plugins devem capturar exceções disparadas pela máquina
 virtual e representá-las como erros de execução, retornar a constante 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 e, caso seja possível obter uma mensagem de erro, propagá-la usando a função
 
\family typewriter 
script_set_error_message
\family default 
 da biblioteca principal, que poderá ser posteriormente consultada pela
 aplicação com 
\family typewriter 
script_error_message
\family default 
.
 
\layout Standard

Assim como a função 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
 implementa a lógica específica de linguagem das funções 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
 da biblioteca principal, a função 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 é usada por 
\family typewriter 
script_call
\family default 
.
 A função 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável por realizar chamadas a funções implementadas na linguagem
 embutida pelo plugin.
 Ao chamar uma função do ambiente, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função usando o plugin.
 A implementação de script_call tenta encontrar uma função solicitada inicialmen
te na lista de funções C registradas, e posteriormente tentando invocá-la
 nos plugins.
 Se a função foi definida no plugin, isto é, se uma função com o nome solicitado
 foi registrada na estrutura de dados que descreve o ambiente na máquina
 virtual, ela será executada, e o sucesso ou falha da execução será reportado
 de forma igual a 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
.
 Caso a função solicitada não tenha sido definida na máquina virtual, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 deve retornar a constante 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
, para que LibScript tente o próximo plugin.
 Parâmetros de entrada e valores de retorno são passados através do buffer
 de parâmetros, com as funções 
\family typewriter 
script_get_*
\family default 
 e 
\family typewriter 
script_get_*
\family default 
 da biblioteca principal.
\layout Standard

Finalmente, 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável pelo encerramento de um estado.
 Estados são encerrados quando um ambiente é finalizado pela biblioteca
 principal com a função 
\family typewriter 
script_done
\family default 
.
 Dependendo da representação interna de um estado no plugin, a finalização
 de um estado pode ou não implicar na finalização da máquina virtual.
\layout Section

Implementação dos plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Subsection

Representação de estados
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

O design de LibScript permite que plugins mantenham múltiplos estados independen
tes.
 Idealmente estes estados seriam totalmente isolados entre si, oferecendo
 maior segurança ao ambiente de execução dos scripts.
 As linguagens, entretanto, oferecem diferentes graus de isolamento entre
 estados independentes.
 Lua e Perl são linguagens que permitem múltiplas instâncias isoladas do
 ambiente de execução de forma simples, uma vez que as chamadas à API incluem
 um identificador de estado
\begin_inset Foot
collapsed true

\layout Standard

O recurso de múltiplos estados independentes é opcional em Perl, selecionado
 durante a compilação da biblioteca do interpretador.
\end_inset 

.
 Já linguagens que mantêm estado de forma estática, como Python e Ruby,
 não permitem trabalhar com múltiplos estados isolados facilmente.
 O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados
\begin_inset Foot
collapsed true

\layout Standard

A documentação diz que 
\begin_inset Quotes eld
\end_inset 

este é um bug difícil de ser resolvido que será tratado em uma versão futura
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{py-hardtofix}

\end_inset 

.
\end_inset 

.
\layout Standard

Além de inicializar o ambiente de execução da máquina virtual, a função
 de inicialização de um plugin retorna à biblioteca principal uma representação
 opaca do seu estado, que é repassada às chamadas subseqüentes de funções
 do plugin.
 O conteúdo desta representação varia de linguagem para linguagem, mas o
 princípio básico é que dois dados devem estar disponíveis a partir deste
 estado: uma referência para o ambiente LibScript, passado como parâmetro
 para 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
, para que o plugin possa fazer chamadas à biblioteca principal, e um identifica
dor que permita acessar a partir de C a estrutura de dados que representa
 na linguagem o espaço de nome de funções acessíveis via LibScript.
 No plugin Lua, esta estrutura é uma tabela; em Python, um módulo; em Ruby,
 uma classe; e em Perl, um pacote.
\layout Standard

Em 
\family typewriter 
libscript-lua
\family default 
, estados são implementados como 
\family typewriter 
lua_State
\family default 
s (Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 Desta forma, scripts executados em um ambiente são plenamente isolados
 dos demais ambientes.
 Por exemplo, a alteração do valor de uma variável global em um ambiente
 não afeta os demais.
 De fato, o 
\family typewriter 
script_plugin_state
\family default 
 retornado pelo plugin Lua é simplesmente o 
\family typewriter 
lua_State
\family default 
 convertido via cast.
 O ponteiro para o ambiente LibScript é armazenado em Lua no registro, usando
 o endereço do 
\family typewriter 
lua_State
\family default 
 como chave, da seguinte forma:
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, L);        
\emph on 
/* Empilha o estado */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);      
\emph on 
/* Empilha o ambiente LibScript */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX); 
\emph on 
/* registro[L] = env */
\layout Standard

O plugin cria neste 
\family typewriter 
lua_State
\family default 
 uma tabela que representará o ambiente, para que funções registradas via
 LibScript estarão disponíveis como elementos desta tabela e que funções
 Lua inseridas nesta tabela sejam acessíveis a partir de C e de outros plugins.
 Esta tabela é armazenada no 
\family typewriter 
lua_State
\family default 
 como uma variável global com o nome do ambiente.
 As demais funções de 
\family typewriter 
libscript-lua
\family default 
 localizam esta tabela obtendo o ponteiro para o ambiente LibScript no registro
 e consultando o nome do ambiente usando a função 
\family typewriter 
script_namespace
\family default 
.
\layout Standard

Como nas demais linguagens não há uma forma conveniente de armazenar o ambiente
 LibScript de forma isolada como no ocorre no registro de Lua, os estados
 são representados como structs que armazenam o ponteiro para o ambiente
 e o identificador representando a estrutura de dados específica da linguagem
 que o representa.
\layout Standard

Em 
\family typewriter 
libscript-perl
\family default 
 os estados são isolados como em Lua.
 Cada estado criado inicializa uma nova instância de 
\family typewriter 
PerlInterpreter
\family default 
.
 Neste interpretador, é criado um pacote que será a representação do ambiente
 visível a partir de código Perl.
 O estado é descrito com a seguinte estrutura:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* P;
\layout LyX-Code


\size footnotesize 
   script_env* env;
\layout LyX-Code


\size footnotesize 
   char* package;
\layout LyX-Code


\size footnotesize 
} script_perl_state;
\layout Standard

Em 
\family typewriter 
script_perl_state
\family default 
 são armazenadas referências para o interpretador e para o ambiente LibScript,
 bem como o nome do pacote (que é o nome do ambiente com a inicial em maiúscula,
 seguindo a convenção de pacotes de Perl).
 O pacote em si é criado durante 
\family typewriter 
script_plugin_init_perl
\family default 
, executando a string de código 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 com a função 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

Como Python não dispõe de facilidades para disparar múltiplas máquinas virtuais
 plenamente isoladas, o plugin Python implementa estados apenas como módulos
 separados, compartilhando um mesmo estado global.
 Durante a inicialização de um estado, é criado um módulo Python com o nome
 do ambiente.
 O seguinte trecho da função 
\family typewriter 
script_plugin_init_python
\family default 
 exibe a seqüência onde o módulo é criado e importado:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o nome do ambiente */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o módulo.
 O primeiro parâmetro é o nome do módulo,
\layout LyX-Code


\size footnotesize 
\emph on 
   o segundo a lista de métodos do módulo, que será inicialmente vazio.
 */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém dicionário de globais */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o módulo à variável global com o seu nome.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard

A representação no plugin do estado consiste de um ponteiro para o ambiente
 e outro para o dicionário de elementos do módulo, obtido com 
\family typewriter 
PyModule_GetDict(module)
\family default 
:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   script_env* env;
\layout LyX-Code


\size footnotesize 
   PyObject* dict;
\layout LyX-Code


\size footnotesize 
} script_python_state;
\layout Standard

De forma similar, estados em Ruby são implementados como classes que compartilha
m um mesmo estado global, já que Ruby também não permite múltiplos ambientes
 de execução isolados.
 Uma classe é criada em Ruby com a função 
\family typewriter 
rb_define_class
\family default 
 e armazenada na struct do estado juntamente com um ponteiro para o ambiente.
 Um estado é representado em 
\family typewriter 
libscript-ruby
\family default 
 da seguinte forma:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   script_env* env;
\layout LyX-Code


\size footnotesize 
   VALUE klass;
\layout LyX-Code


\size footnotesize 
} script_ruby_state;
\layout Subsection

Encerramento de estados
\layout Standard

Como Lua e Perl representam estados de forma independente, o encerramento
 de um estado nestes plugins é simples: a estrutura da linguagem que encapsula
 o ambiente completo de execução é encerrado.
 A implementação da função de finalização no plugin Lua é a seguinte:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Em Lua, um state é um lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Encerra o estado.
 Não afeta outros ambientes.
 */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Em Perl, o processo, embora um tanto mais elaborado, é essencialmente similar:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas macros assumem que o ponteiro do interpretador
\layout LyX-Code


\size footnotesize 
\emph on 
      se chama my_perl.
 */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = state->P;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas operações operam sobre o 
\begin_inset Quotes eld
\end_inset 

estado atual
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      então a macro PERL_SET_CONTEXT deve ser usada para
\layout LyX-Code


\size footnotesize 
\emph on 
      alternar o interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Esta flag deve ser ativada para que a limpeza do
\layout LyX-Code


\size footnotesize 
\emph on 
      ambiente seja completa, o que é necessário quando
\layout LyX-Code


\size footnotesize 
\emph on 
      pode haver mais de um interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Encerramento do interpretador */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Desaloca o resto do estado do plugin */
\layout LyX-Code


\size footnotesize 
   free(state->package); free(state);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Em Python e Ruby, como não há instâncias independentes do ambiente de execução
 das linguagens, o plugin precisa manter o controle do número de estados
 ativos para desalocar a máquina virtual somente quando este chegar a zero.
 Além disso, em Ruby não há como como em Python não há recursos nas APIs
 (ou nas linguagens, de fato) para remover, respectivamente, classes ou
 módulos.
 Em Ruby, poderíamos atribuir 
\family typewriter 
nil
\family default 
 à constante que representa a classe que descreve o estado, mas depois disso
 não é possível definir uma nova classe em seu lugar: tanto 
\family typewriter 
rb_define_class
\family default 
 via C como 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 via Ruby geram um erro indicando que o valor já foi definido com outro
 tipo.
 Como Ruby possui classes abertas, uma construção 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 para um 
\emph on 
<Nome>
\emph default 
 já existente é entendida como a continuação da descrição da classe, e não
 como a redefinição de 
\emph on 
<Nome>
\emph default 
.
 Python, por sua vez, não disponibiliza recursos na API para a descarga
 de módulos, mas permite atribuir 
\family typewriter 
None
\family default 
 à global referente ao módulo.
 O módulo pode ser importado novamente, mas será retornada a mesma instância
 do módulo, armazenada internamente por Python.
 A seguinte sessão interativa de linha de comando permite observar este
 comportamento, que ocorre tanto diretamente em Python como via a API de
 C:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard

Assim, as estruturas de dados referentes aos estados LibScript não são encerrado
s nos plugins Python e Ruby.
 Esta é implementação no plugin Ruby:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state* state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrementa o contador de estados, uma variável global 
\emph default 
static
\emph on 
 do plugin.
 */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Finaliza o interpretador se este for o último estado.
 */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Desaloca o resto do estado do plugin */
\layout LyX-Code


\size footnotesize 
   free(state);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A implementação no plugin Python é basicamente igual:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state* state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
   Py_DECREF(state->dict); free(state);
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Transferência de dados
\layout Standard

TODO
\layout Comment

A transferência de dados entre a biblioteca principal e os plugins é concentrada
 em duas operações: uma para passar o conteúdo do buffer de parâmetros de
 LibScript para o espaço de dados da máquina virtual e outra para realizar
 a operação inversa.
 Em cada plugin, procuramos isolar estas operações em um par de funções.
 
\layout Comment

Na implementação do plugin 
\family typewriter 
libscript-lua
\family default 
, a função 
\family typewriter 
script_lua_stack_to_params
\family default 
 converte o conteúdo da pilha de Lua para o buffer de parâmetros de LibScript.
 Esta função é usada tanto para receber os valores de retorno obtidos após
 uma chamada de função Lua como para fazer a passagem de parâmetros no back-end
 Lua da função 
\family typewriter 
script_call
\family default 
.
\layout Comment

A API para implementação de funções em C a serem registradas em LibScript
 permite declarar funções com múltiplos valores de retorno.
 Muitas linguagens não possuem este recurso, mas é possível, ao detectar
 no plugin que mais de um valor foi retornado, construir um tipo de dado
 agregado e armazenar nele os valores, retornando então um valor de retorno
 único.
\layout Comment

Em Lua, uma função pode retornar múltiplos valores através da pilha, como
 discutido na Seção 
\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

.
 
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Resolução de funções sob demanda
\layout Standard

Nos plugins de LibScript a ligação entre a função C declarada e uma função
 
\emph on 
stub
\emph default 
 nativa só é realizada no momento em que esta é chamada.
 O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória no ambiente de execução da linguagem de script (ao evitar a criação
 de 
\emph on 
stubs
\emph default 
 que não serão utilizados), é permitir a localização de funções declaradas
 após a inicialização do ambiente -- possivelmente funções implementadas
 em outras linguagens, declaradas em outros plugins.
 Ao comparar as abordagens empregadas em cada plugin podemos avaliar os
 recursos de introspecção oferecidos por cada API.
\layout Standard

Como vimos na Seção 
\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, em Lua, durante a inicialização do plugin, é criada uma tabela armazenada
 em uma variável global com o nome do ambiente.
 Funções são inseridas dinamicamente nesta tabela através da metatabela
 associada a ela logo após a sua criação em 
\family typewriter 
script_plugin_init_lua
\family default 
.
 O índice 
\family typewriter 
__index
\family default 
 da metatabela aponta para uma função C interna ao plugin, 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, que é então invocada sempre que um elemento inexistente for solicitado
 na tabela.
 A função 
\family typewriter 
script_lua_make_caller
\family default 
 cria uma 
\emph on 
closure
\emph default 
 C, que consiste de outra função C interna ao plugin, 
\family typewriter 
script_lua_caller
\family default 
 e o nome da função solicitada.
 Esta closure é associada à entrada da tabela do ambiente.
 Assim, chamadas a funções não contidas na tabela serão finalmente resolvidas
 por 
\family typewriter 
script_lua_caller
\family default 
, que as passará adiante para 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Python, o espaço de nomes é declarado na inicialização como um
 módulo.
 É declarado também um tipo de dado, 
\family typewriter 
script_python_object
\family default 
, definido como um objeto Python contendo um ponteiro de função C representando
 uma função registrada em LibScript.
 Estes objetos possuem o seu callback 
\family typewriter 
__call
\family default 
 definido como 
\family typewriter 
script_python_object_call
\family default 
, uma função que, assim como 
\family typewriter 
script_lua_caller
\family default 
, converte os parâmetros recebidos para o buffer de LibScript, invoca a
 função armazenada no ponteiro C e converte os valores de entrada de volta
 à linguagem.
 Assim, objetos deste tipo são 
\emph on 
functors
\emph default 
, e se comportam de forma similar à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
 O módulo é automaticamente importado na inicialização do plugin.
\layout Standard

Ao chamar 
\family typewriter 
\emph on 
namespace
\emph default 
.f()
\family default 
, o callback 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_python_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 obtém o endereço de 
\begin_inset Formula $f$
\end_inset 

 da lista de funções do ambiente.
 É declarado então um objeto 
\family typewriter 
script_python_object
\family default 
 contendo o atributo 
\begin_inset Formula $f$
\end_inset 

, que é em seguida armazenado em 
\family typewriter 
\emph on 
namespace
\emph default 
.f
\family default 
.
 A função callback do módulo retorna e o rotina 
\family typewriter 
__call
\family default 
 do objeto é invocada em seguida, executando 
\family typewriter 
script_python_object_call
\family default 
, que registra os parâmetros de entrada no ambiente LibScript, invoca a
 função C armazenada no atributo interno do objeto e retorna a Python os
 valores de saída da função.
\layout Standard

O espaço de nomes é implementado em Ruby como uma classe.
 A resolução de funções sob demanda é implementada utilizando o método 
\family typewriter 
method_missing
\family default 
, que é um fallback definido pela linguagem, chamado sempre que um método
 inexistente é invocado em uma classe.
 Como métodos não são valores de primeira classe em Ruby, não é possível
 construir o método stub através de funções C da API.
 A saída então é declarar o método através de código Ruby enviado ao interpretad
or como uma string.
 No corpo do método, armazenamos o endereço do ponteiro da função C a ser
 chamada como um número.
 Quando invocado, o método realizará uma chamada ao método 
\family typewriter 
caller
\family default 
.
 Este método, registrado na classe durante a inicialização, corresponde
 à função C 
\family typewriter 
script_ruby_caller
\family default 
.
 A ele é passado o endereço da função C como um número e os argumentos passados
 como um array Ruby.
 Ao receber estes dados em C, 
\family typewriter 
script_ruby_caller
\family default 
 irá então converter os parâmetros para o buffer LibScript e invocar a função
 usando 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Perl, também há uma função C responsável por realizar a conversão
 de parâmetros e valores de retorno a invocação de 
\family typewriter 
script_call
\family default 
.
 Esta função, 
\family typewriter 
script_perl_caller
\family default 
, para que possa ser exposta ao interpretador Perl, é implementada em um
 arquivo XS, e compilada como parte de um módulo de extensão Perl, que é
 então ligado ao código do plugin.
 Uma vez carregado o módulo, a função é visível em Perl como a função 
\family typewriter 
LibScript::caller
\family default 
.
 A resolução dinâmica de funções do pacote Perl correspondente ao ambiente
 LibScript é feita usando a função 
\family typewriter 
AUTOLOAD
\family default 
 de Perl, que se comporta como method_missing em Ruby, capturando chamadas
 a funções inexistentes.
 Na função de inicialização do plugin, código Perl é executado para carregar
 o módulo de extensão, inicializar o pacote do ambiente e inserir nele uma
 função 
\family typewriter 
AUTOLOAD
\family default 
 que chamará 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
        
\emph on 
 /* Inicializa o módulo de extensão */
\layout LyX-Code


\size footnotesize 
         "bootstrap LibScript;"
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Declara o pacote do ambiente */
\layout LyX-Code


\size footnotesize 
         "package %s;"
\layout LyX-Code


\size footnotesize 
         "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
            "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
            /* Extrai o nome do método do nome qualificado 
\begin_inset Quotes eld
\end_inset 

pacote::método
\begin_inset Quotes erd
\end_inset 

 */
\layout LyX-Code


\size footnotesize 
            "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
            /* Invoca caller passando o endereço do estado,
\layout LyX-Code


\size footnotesize 
\emph on 
               o nome do método, e o array de argumentos */
\layout LyX-Code


\size footnotesize 
            "LibScript::caller(%p, $AUTOLOAD, @_);"
\layout LyX-Code


\size footnotesize 
         "}",
\layout LyX-Code


\size footnotesize 
         state->package, state);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Avalia a string de código;
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indica que erros devem ser sinalizados.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Considerações Finais
\layout Comment


\emph on 
\color red
[TODO: Concluir alguma coisa :-) ]
\layout Comment

as pessoas quando escolhem uma linguagem, tendem a olhar mais pra linguagem
 e esquecem de olhar pras apis.
\layout Comment

por isso que puxei a brasa pro lado do embedding mais do que do extending,
 um pouco
\layout Comment

as apis todas tornam escrever extensões algo fácil.
 lua bate elas na parte do embedding, imho
\layout Comment

conversores podem simplificar extensões, mas embedding tende a interagir
 mais diretamente com a API
\layout Comment

conversores: aí a gente está falando de outro problema altogether, que é
 "a difícil tarefa de entender código C".
 trabalho futuro, possibly.
\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

API de LibScript
\layout Comment

Revisar e sicronizar API com o código no SVN
\layout Section

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ambiente.
 Um ambiente define um espaço de funções a serem expostas à biblioteca e
 de 
\begin_inset Quotes eld
\end_inset 

estados
\begin_inset Quotes erd
\end_inset 

 de plugins carregados.
 Assim, várias máquinas virtuais podem estar carregadas em um ambiente.
 O parâmetro 
\family typewriter 
namespace
\family default 
 refere-se ao identificador a ser inicializado no espaço de nomes da máquina
 virtual para armazenar as funções expostas.
 
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente.
\layout Section

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo de funções a serem registradas no ambiente.
 Tipicamente será uma função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente.
\layout Itemize


\family typewriter 
double script_in_double(script_env* env)
\newline 
int script_in_int(script_env* env)
\newline 
const char* script_in_string(script_env* env)
\family default 

\newline 
Obtêm parâmetros do ambiente.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada, em ordem.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_in_string
\family default 
, é retornada uma referência que pertence ao ambiente.
 O código deve realizar uma cópia caso queira modificar a string.
\layout Itemize


\family typewriter 
script_type script_in_type(script_env* env)
\newline 
int script_param_count(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_in_type
\family default 
 obtém o tipo do próximo parâmetro a ser obtido com a função 
\family typewriter 
script_in_*
\family default 
 e 
\family typewriter 
script_param_count
\family default 
 retorna o número de parâmetros disponíveis para consumo.
\layout Itemize


\family typewriter 
void script_out_double(script_env* env, double value)
\newline 
void script_out_int(script_env* env, int value)
\newline 
void script_out_string(script_env* env, const char* value)
\newline 

\family default 
Inserem parâmetros no ambiente.
 Estas funções permitem retornar os valores de saída.
 Ao final de uma função 
\emph on 
wrapper
\emph default 
, os valores de retorno da função devem ser passados com chamadas a estas
 funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Standard

As funções 
\family typewriter 
script_{in,out}_*
\family default 
 também devem são utilizadas na implementação dos plugins, de maneira inversa:
 antes de chamar o 
\emph on 
wrapper
\emph default 
, o plugin registra no ambiente os valores de entrada (devidamente convertidos
 para C) usando as funções 
\family typewriter 
out
\family default 
, e após a chamada, repassa o retorno para a máquina virtual obtendo os
 valores usando as funções 
\family typewriter 
in
\family default 
.
\layout Section

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_out_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_in_*
\family default 
.
 Inicialmente, a tabela de funções C é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas no namespace definido para a LibScript na máquina
 virtual da linguagem (isto é, no nome criado com 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\family default 

\newline 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
\layout Section

Funções para Implementação de Plugins
\layout Itemize


\family typewriter 
script_fn script_get_function(script_env* env, const char* name)
\family default 

\newline 
Localiza uma função no ambiente.
 Na implementação atual, todos os plugins estão fazendo o registro de funções
 na máquina virtual sob demanda: na inicialização, um objeto é criado com
 o nome do 
\emph on 
namespace
\emph default 
 do ambiente (uma tabela em Lua, um módulo em Python e Ruby) e acessos a
 funções deste objeto são resolvidas chamando esta função.
\layout Itemize


\family typewriter 
void script_set_error_message(script_env* env, const char* message)
\family default 

\newline 
Define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
void script_start_params(script_env* env)
\family default 

\newline 
Usada para zerar a lista interna de parâmetros de entrada e saída.
 Deve ser usada na implementação da chamada de funções para garantir que
 parâmetros que não tenham sido consumidos sejam removidos.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\emph on 
lang
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente deve ser exposto
 à máquina virtual de alguma forma apropriada para a linguagem (como uma
 tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\emph on 
lang
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\emph on 
lang
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_in_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_out_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\emph on 
lang
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\layout Bibliography
\bibitem {finne-fli}

FINNE, S.; LEIJEN, D.; MEIJER, E.; PEYTON JONES, S.
 
\series bold 
H/Direct: a Binary Foreign Language Interface for Haskell
\series default 
, Em: THIRD ACM SIGPLAN INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING,
 PROCEEDINGS, p.
 153--162, Baltimore, EUA, 1998.
 ACM Press, New York, EUA.
 ISBN: 1581130244
\layout Bibliography
\bibitem {ada95}

ANSI/ISO/IEC-8652:1995; 
\series bold 
Ada 95 Reference Manual
\series default 
.
 volume 1246 de 
\series bold 
Lecture Notes in Computer Science
\series default 
, 1995.
 Springer-Verlag.
\layout Bibliography
\bibitem {tarditi92no}

TARDITI, D.; LEE, P.; ACHARYA, A.
 
\series bold 
No Assembly Required: Compiling Standard ML to C
\series default 
.
 Em: ACM LETTERS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 1, número
 2, p.
 161--177, junho 1992.
 ACM Press.
\layout Bibliography
\bibitem {tolmach-from}

TOLMACH, A.; OLIVA, D.
 
\series bold 
From ML to Ada: Strongly-typed Language Interoperability via Source Translation
\series default 
.
 Em: JOURNAL OF FUNCTIONAL PROGRAMMING, volume 8, número 4, p.
 367--412, 1998.
\layout Bibliography
\bibitem {jones93glasgow}

PEYTON JONES, S.; HALL, C.; HAMMOND, K.; PARTAIN, W.; WADLER, P.
 
\series bold 
The Glasgow Haskell compiler: a technical overview
\series default 
.
 Em: UK JOINT FRAMEWORK FOR INFORMATION TECHNOLOGY (JFIT) TECHNICAL CONFERENCE,
 PROCEEDINGS, 1993.
\layout Bibliography
\bibitem {gosling-java}

GOSLING, J.; JOY, B.; STEELE, G.
 
\series bold 
The Java Language Specification
\series default 
.
 Addison-Wesley Professional, Reading, EUA, 3a.
 Edição, junho 2005.
 ISBN: 0321246780
\layout Bibliography
\bibitem {hugunin-jython}

HUGUNIN, J.
 
\series bold 
Java and Python: the Best of Both Worlds
\series default 
.
 Em: 6TH INTERNATIONAL PYTHON CONFERENCE.
 San Jose, EUA, 1997.
\layout Bibliography
\bibitem {lutz-python}

LUTZ, M.
 
\series bold 
Programming Python
\series default 
.
 O'Reilly Media Inc.
 2a.
 Edição, março 2001.
 ISBN: 0596000855
\layout Bibliography
\bibitem {luajava}

Kepler Project.

\series bold 
 LuaJava
\series default 
.
 
\begin_inset LatexCommand \url{http://www.keplerproject.org/luajava/}

\end_inset 


\layout Bibliography
\bibitem {lua}

IERUSALIMSCHY, R.; FIGUEIREDO, L.H.; CELES, W.; 
\series bold 
Lua -- an Extensible Extension Language
\series default 
.
 Em: Software--Practice and Experience, volume 26, número 6, p.
 635--652, 1996.
\layout Bibliography
\bibitem {benton99interlanguage}

BENTON, N.; KENNEDY, A.
 
\series bold 
Interlanguage Working Without Tears: Blending SML with Java
\series default 
.
 Em: INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING, PROCEEDINGS, p.
 126--137, 1999.
 
\layout Bibliography
\bibitem {box-net}

BOX, D.; SELLS, C.
 
\series bold 
Essential .NET, Volume I: The Common Language Runtime
\series default 
.
 Addison-Wesley Professional, 1a.
 Edição, novembro 2002.
 ISBN: 0201734117
\layout Bibliography
\bibitem {hejlsberg-csharp}

HEJLSBERG, A.; WILTAMUTH, S.
 
\series bold 
C# Language Specification
\series default 
.
 Microsoft Corporation, 2000.
\layout Bibliography
\bibitem {managedcpp}

Microsoft Corporation.
 
\series bold 
Managed Extensions for C++ Specification
\series default 
.
 
\begin_inset LatexCommand \url{http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmxspec/html/vcmanagedextensionsspec_start.asp}

\end_inset 

 
\layout Bibliography
\bibitem {syme-fsharp}

SYME, D.; MARGETSON, J.; MARLOW, S.

\series bold 
 F#.

\series default 
 Microsoft Corporation.
 
\begin_inset LatexCommand \url{http://research.microsoft.com/projects/ilx/fsharp.aspx}

\end_inset 

 
\layout Bibliography
\bibitem {randal-perl6}

RANDAL, A.; SUGALSKI, D.; TOETSCH, L.
 
\series bold 
Perl 6 and Parrot Essentials
\series default 
.
 O'Reilly Media, Inc.
 2a.
 Edição, junho 2004.
 ISBN: 059600737X
\layout Bibliography
\bibitem {conway-uncol}

CONWAY, M.
 
\series bold 
Proposal for an UNCOL
\series default 
.
 Em: COMMUNICATIONS OF THE ACM, volume 1, número 10.
 p.
 5--8, ACM Press, New York, NY, EUA.
 ISSN: 0001-0782
\layout Bibliography
\bibitem {metzner-xl}

METZNER, J.
 
\series bold 
A Graded Bibliography on Macro Systems and Extensible Languages
\series default 
.
 Em: ACM SIGPLAN NOTICES, volume 14, número 1, p.
 57--64, 1979.
 ACM Press.
 New York, NY, EUA.
 ISSN: 0362-1340
\layout Bibliography
\bibitem {peterson-fpy}

PETERSON, P.; MARTINS, J.R.R.A; ALONSO, J.J.; 
\series bold 
Fortran to Python Interface Generator with an Application to Aerospace Engineeri
ng
\series default 
.
 Em: 9TH INTERNATIONAL PYTHON CONFERENCE, PROCEEDINGS, Long Beach, EUA,
 março 2001.
\layout Bibliography
\bibitem {lunatic-python}

NIEMEYER, G.
 
\series bold 
Lunatic Python
\series default 
.
 
\begin_inset LatexCommand \url{http://labix.org/lunatic-python}

\end_inset 

 
\layout Bibliography
\bibitem {jones99portable}

PEYTON JONES, S.; RAMSEY, N.; REIG, F.
 
\series bold 
C--: a Portable Assembly Language that Supports Garbage Collection
\series default 
, Em: INTERNATIONAL CONFERENCE ON PRINCIPLES AND PRACTICE OF DECLARATIVE
 PROGRAMMING, PROCEEDINGS.
 1999.
\layout Bibliography
\bibitem {dvorak05gcc}

DVORAK, Z.
 
\series bold 
Gimplification Improvements.
 
\series default 
Em: GCC DEVELOPERS' SUMMIT, PROCEEDINGS.
 p.
 47--56.
 Ottawa, Canada.
 junho 2005.
\layout Bibliography
\bibitem {omg-corba}

Object Management Group, Inc.
 
\series bold 
The Common Object Request Broker: Architecture and Specification
\series default 
, Versão 3.0, Framingham, MA, EUA, julho 2002.
\layout Bibliography
\bibitem {gelernter-linda}

GELERNTER, D.
 
\series bold 
Generative communication in Linda
\series default 
.
 Em: ACM TRANSACTIONS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 7, número
 1, p.
 80--112.
 New York, NY, EUA.
 ACM Press.
 ISSN: 0164-0925
\layout Bibliography
\bibitem {chapman-opus}

CHAPMAN, B.; HAINES, M.; MEHROTRA, P.; ZIMA, H.; VAN ROSENDALE, J.
 
\series bold 
Opus: A Coordination Language for Multidisciplinary Applications
\series default 
.
 Em: SCIENTIFIC PROGRAMMING, volume 6, número 4.
 p 345--362.
 1997.
\layout Bibliography
\bibitem {collin-eiffel}

COLLIN, S.; COLNET, D.; ZENDRA, O.
 
\series bold 
Type Inference for Late Binding
\series default 
.
 The SmallEiffel Compiler.
 Em: JOINT MODULAR LANGUAGES CONFERENCE, (JMLC'97), 1997, volume 1204 de
 
\series bold 
Lecture Notes in Computer Science
\series default 
, p.
 67--81.
 IEEE, Springer-Verlag.
\layout Bibliography
\bibitem {thomas-ruby}

THOMAS, D.; FOWLER, C.; HUNT, A.
 
\series bold 
Programming Ruby: The Pragmatic Programmer's Guide
\series default 
.
 2a.
 Edição.
 Pragmatic Bookshelf, outubro 2004.
\layout Bibliography
\bibitem {vanrossum-extpy}

VAN ROSSUM, G.
 
\series bold 
Extending and Embedding the Python Interpreter
\series default 
.
 Versão 2.4.2.
 Python Software Foundation, setembro 2005.
\layout Bibliography
\bibitem {wilson-gc}

WILSON, P.
 
\series bold 
Uniprocessor Garbage Collection Techniques
\series default 
.
 Em: INTERNATIONAL WORKSHOP ON MEMORY MANAGEMENT, PROCEEDINGS, p.
 637.
 Saint-Malo, França, 1992.
 Springer-Verlag.
\layout Bibliography
\bibitem {liang-jni}

LIANG, S.
 
\series bold 
Java Native Interface: Programmer's Guide and Specification
\series default 
.
 Addison-Wesley Professional, junho 1999.
 ISBN: 0201325772
\layout Bibliography
\bibitem {moura-colua}

MOURA, A.L.; RODRIGUEZ, N.; IERUSALIMSCHY, R.
 
\series bold 
Coroutines in Lua
\series default 
.
 Em: JOURNAL OF UNIVERSAL COMPUTER SCIENCE, volume 10, número 7, p.
 910--925, julho 2004.
 
\layout Bibliography
\bibitem {beazley-swig}

BEAZLEY, D.; 
\series bold 
SWIG and Automated C/C++ Scripting Extensions
\series default 
.
 Em: DR.
 DOBB'S JOURNAL, fevereiro 1998.
\layout Bibliography
\bibitem {ewing-pyrex}

EWING, G.; 
\series bold 
Pyrex - a Language for Writing Python Extension Modules
\series default 
.
 
\begin_inset LatexCommand \url{http://nz.cosc.canterbury.ac.nz/~greg/python/Pyrex/}

\end_inset 


\layout Bibliography
\bibitem {wall-perl}

WALL, L.; CHRISTIANSEN, T.; ORWANT, J.
 Programming Perl.
 3a.
 Edição.
 O'Reilly, julho 2000.
\layout Bibliography
\bibitem {ltn004}

http://www.lua.org/notes/ltn004.html
\layout Bibliography
\bibitem {pyvhll_ext}

http://www.python.org/doc/ext/high-level-embedding.html
\layout Bibliography
\bibitem {pyvhll_cobjects}

http://www.python.org/doc/ext/using-cobjects.html
\layout Bibliography
\bibitem {pyvhll_ref}

http://www.python.org/doc/api/veryhigh.html
\layout Bibliography
\bibitem {ext_ruby}

http://www.rubycentral.com/book/ext_ruby.html
\layout Bibliography
\bibitem {perlembed}

ORWANT, J., MacEACHERN, D.
 et al.
 PERLEMBED(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\layout Bibliography
\bibitem {perlguts}

OKAMOTO, J.
 et al.
 PERLGUTS(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\layout Bibliography
\bibitem {perlapi}

OKAMOTO, J., ROEHRICH, D.
 et al.
 PERLAPI(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\layout Bibliography
\bibitem {key-4}

ROEHRICH, D.
 et al.
 PERLXS(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\layout Bibliography
\bibitem {janino}

http://www.janino.net
\layout Bibliography
\bibitem {py-hardtofix}

http://www.python.org/doc/api/initialization.html
\layout Bibliography
\bibitem {java-weak}

http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/functions.html#weak
\layout Bibliography
\bibitem {key-5}

MARQUESS, P.
 PERLCALL(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\layout Bibliography
\bibitem {stepanian-jni}

STEPANIAN, L.
 Inlining Java Native Calls at Runtime.
 Tese de mestrado, Graduate Department of Computer Science, University of
 Toronto.
\the_end
