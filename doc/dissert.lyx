#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\language brazil
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize a4paper
\paperpackage widemarginsa4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Comment


\backslash 
titulo{Estudo sobre APIs para Máquinas Virtuais}
\layout Comment


\backslash 
autor{Hisham H.
 Muhammad}
\layout Comment


\backslash 
autorR{Muhammad, Hisham H.}
\layout Comment


\backslash 
orientador{Roberto Ierusalimschy}
\layout Comment


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Comment


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Comment


\backslash 
cidade{Rio de Janeiro}
\layout Comment


\backslash 
departamento{Informática}
\layout Comment


\backslash 
programa{Informática}
\layout Comment


\backslash 
centro{Centro Técnico Científico} 
\layout Title

Estudo sobre APIs para máquinas virtuais
\layout Author

Hisham H.
 Muhammad
\layout Chapter

Introdução
\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\layout Standard

Existem muitas situações onde é necessário ou interessante que haja interação
 entre programas escritos em diferentes linguagens.
 Um caso típico é o emprego de bibliotecas externas, como 
\emph on 
toolkits
\emph default 
 gráficos, APIs de acesso a banco de dados, ou até mesmo chamadas ao sistema
 operacional.
 Outro cenário ainda envolve aplicações desenvolvidas usando mais de uma
 linguagem de programação a fim de otimizar partes onde o desempenho é crítico
 ou permitir extensibilidade através de 
\emph on 
scripts
\emph default 
 escritos pelo usuário.
\layout Standard

Independentemente da finalidade, a comunicação entre programas escritos
 em linguagens diferentes traz consigo uma série de questões de projeto,
 não apenas no desenvolvimento das aplicações, mas das linguagens em si.
 Há várias formas de se obter esse tipo de interoperabilidade, desde tradução
 de código de uma linguagem para outra até o uso de uma máquina virtual
 comum.
 Idealmente, entretanto, uma linguagem deve prover uma interface de acesso
 externo (
\emph on 
foreign language interface
\emph default 
, FLI) que permita ao programador receber e enviar tanto chamadas como dados
 para outra linguagem 
\begin_inset LatexCommand \cite{finne-fli}

\end_inset 

.
 Entre os fatores que devem ser levados em consideração no desenvolvimento
 de tal interface estão as diferenças entre os sistemas de tipos, problemas
 de gerência de memória (como coleta de lixo e acesso direto a ponteiros)
 e modelos de concorrência.
 Além de lidar com diferenças semânticas, o projeto de uma interface envolve
 questões pragmáticas como o equilíbrio entre o isolamento seguro dos ambientes
 de execução, o desempenho e a simplicidade da API resultante.
\layout Standard

Pode-se observar nas implementações existentes de FLIs um número de abordagens
 para estes problemas.
 De fato, FLIs de diferentes linguagens (ou mesmo de diferentes revisões
 de uma mesma linguagem) tendem a ser bastante distintas entre si.
 Ainda assim é possível traçar paralelos entre as técnicas utilizadas, uma
 vez que os problemas fundamentais que elas atacam são os mesmos.
 Além disso, em função da popularidade da linguagem C e do suporte oferecido
 a ela pelos sistemas operacionais mais utilizados, grande parte das implementaç
ões de interfaces de acesso externo são, na prática, APIs para C, o que
 também facilita a sua comparação.
 Adicionalmente, C se tornou também uma popular 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 na interação entre FLIs.
\layout Section

Objetivo
\layout Standard

Este trabalho realiza, a partir da pesquisa de implementações de FLIs, um
 estudo e comparação de interfaces entre diferentes linguagens de programação.
 Partindo de uma análise das abordagens gerais para interação entre linguagens,
 o estudo é baseado na análise de um conjunto de interfaces com C providas
 por linguagens imperativas baseadas em máquina virtual.
 Além de se tratar da classe de linguagens mais popular atualmente para
 desenvolvimento multi-linguagem, características típicas de máquinas virtuais
 como coleta de lixo e tipagem dinâmica, por não estarem presentes em C,
 ilustram bem os problemas envolvendo a comunicação de dados entre diferentes
 ambientes de programação.
 Linguagens com tipagem estática podem apresentar necessidades de conversão
 de tipos semelhantes, mas o problema tende a ser simplificado pela definição
 de tipos equivalentes na API e inferência em tempo de compilação (vide
 exemplos nas API com C de Ada e Fortran).
 Linguagens funcionais possuem preocupações adicionais com efeitos colaterais
 no código C, mas isto é equivalente ao problema de quebra do paradigma
 causada tratamento de entrada e saída que todas elas enfrentam.
\layout Standard

O estudo consiste da análise em profundidade de um conjunto de FLIs -- especific
amente, Python, Perl 
\begin_inset LatexCommand \cite{wall-perl}

\end_inset 

, Ruby 
\begin_inset LatexCommand \cite{thomas-ruby}

\end_inset 

, Lua 
\begin_inset LatexCommand \cite{lua}

\end_inset 

 e Java 
\begin_inset LatexCommand \cite{gosling-java}

\end_inset 

 -- e um estudo de caso onde estas FLIs são exercitadas em tarefas semelhantes.
 Diferentemente das demais, Java possui tipagem estática, mas com a sua
 biblioteca de reflexão, que oferece recursos de intercessão como carga
 de classes em tempo de execução e invocação dinâmica de métodos, é possível
 encará-la, para os fins de interação com código C, como uma linguagem dinâmica.
\layout Standard


\emph on 
\color red
[TODO: Continuar essa seção, botar um 
\begin_inset Quotes eld
\end_inset 

fecho
\begin_inset Quotes erd
\end_inset 

 na coisa.]
\layout Section

Estrutura do Texto
\layout Standard

O trabalho está organizado da seguinte forma.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, é dada uma visão geral sobre as várias abordagens para interação entre
 código escrito em diferentes linguagens de progamação.
 A partir daí, o foco se concentra no método de interface externa mais comum
 nas linguagens da atualidade: interfaces com a linguagem C.
 São abordados no Capítulo 
\begin_inset LatexCommand \ref{cha:Interfaces-com-C}

\end_inset 

 os problemas comumente envolvidos na comunicação com código escrito em
 C.
 No Capítulo 
\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

 são apresentadas em detalhe APIs para C de um conjunto de máquinas virtuais.
 Ao discutir estas interfaces, as diferentes soluções empregadas para os
 problemas levantados no capítulo anterior são comparadas.
 O Capítulo 
\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercita estas diferentes APIs através de um estudo de caso: uma biblioteca
 baseada em plug-ins que oferece uma interface uniforme simplificada entre
 máquinas virtuais e C.
 Ao examinar a implementação de cada plug-in, podemos comparar as APIs de
 cada linguagem realizando operações equivalentes.
 Finalmente, no Capítulo 
\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

, são apresentadas as conclusões do trabalho, bem como apontados caminhos
 para trabalhos futuros.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interação entre Linguagens de Programação
\layout Standard

As abordagens aplicadas na interação entre diferentes linguagens de programação
 variam bastante entre si, mas é possível identificar algumas técnicas tipicamen
te utilizadas: tradução de linguagens, seja de uma para outra ou de ambas
 para uma terceira; comunicação através de protocolo ou linguagem intermediária;
 compartilhamento de um ambiente de execução comum, seja de máquina virtual
 ou através de convenção de chamadas.
\layout Section

Tradução de Código
\layout Standard

Permitir o uso de duas linguagens diferentes em um programa traduzindo o
 código de uma delas para a outra minimiza o problema de comunicação entre
 as partes do programa escritas em linguagens diferentes, uma vez que o
 programa final utilizará um espaço único de dados.
 Em contrapartida, ao ter de se descrever uma linguagem em termos de outra,
 a diferença de semântica das construções pode se tornar um problema.
 Se a linguagem de destino não possui construções oferecidas pela linguagem
 de origem, simulá-las pode ser custoso.
\layout Standard

Um exemplo típico é a complexidade adicionada pela simulação de funções
 de alta ordem e recursão final ao traduzir-se o código de linguagens funcionais
 para outra que não possui estes recursos.
 Em 
\begin_inset LatexCommand \cite{tarditi92no}

\end_inset 

 é descrito o desenvolvimento de um tradutor de Standard ML para ANSI C;
 medições evidenciaram o custo de adaptação destes recursos de ML para C,
 resultando em código em média 2 vezes mais lento que o gerado pelo compilador
 ML nativo.
 Em 
\begin_inset LatexCommand \cite{tolmach-from}

\end_inset 

, são discutidos desafios similares na tradução de ML para Ada: na solução
 adotada, o processo possui um passo intermediário onde as construções de
 alta ordem são 
\begin_inset Quotes eld
\end_inset 

aplainadas
\begin_inset Quotes erd
\end_inset 

 para construções de primeira ordem envolvendo registros, para que pudessem
 assim ser representados em Ada.
\layout Standard

Além de problemas como este, diferenças na representação dos dados ainda
 é algo a ser tratado no processo de tradução de uma linguagem para outra.
 No caso particular de C, as facilidades de baixo nível para manipulação
 de memória permitem a descrição de estruturas de dados de linguagens de
 mais alto nível sem maiores problemas.
 Isto faz de C uma candidata freqüente para uso como representação de baixo
 nível portável.
 O compilador de Haskell GHC oferece, como alternativa à geração de código
 nativo, geração de código C para uso com o GCC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 Uma das vantagens deste recurso é permitir o 
\emph on 
bootstrapping
\emph default 
 do compilador em novas arquiteturas, dado que o próprio GHC é escrito em
 Haskell.
 De fato, a ubiqüitude dos compiladores C faz com que a linguagem seja utilizada
 também como 
\emph on 
lingua franca
\emph default 
 entre diferentes linguagens, como será visto na Seção 
\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Compartilhamento de Máquinas Virtuais
\layout Standard

Outra abordagem envolve o uso de um ambiente de execução comum, como uma
 máquina virtual.
 O código das diferentes linguagens é compilado de modo a produzir representaçõe
s compatíveis entre si, de acordo com os tipos de dados oferecidos pelo
 ambiente de execução.
 Diversas implementações utilizam a Java Virtual Machine 
\begin_inset LatexCommand \cite{gosling-java}

\end_inset 

 com essa finalidade.
 Jython 
\begin_inset LatexCommand \cite{hugunin-jython}

\end_inset 

 é uma implementação da linguagem Python 
\begin_inset LatexCommand \cite{lutz-python}

\end_inset 

 que produz bytecodes Java.
 SMLj 
\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 é um compilador Standard ML que gera bytecodes Java e permite acesso de
 classes e métodos Java a estruturas e funções ML e vice-versa.
 O fato da Java Virtual Machine não ter sido projetada para comportar diferentes
 linguagens de programação, entretanto, transparece nas limitações apresentadas
 por estes projetos.
 SMLj define extensões à linguagem ML para permitir acesso a construções
 específicas de Java; Jython possui limitações ao realizar a interface de
 Python com a API de reflexão e carga dinâmica de classes de Java.
 Além disso, o conjunto de instruções da máquina virtual privilegia operações
 que condizem com a semântica de Java, tornando, por exemplo, implementações
 de 
\emph on 
arrays
\emph default 
 com semântica diferente menos eficientes.
\layout Standard

O .NET Framework 
\begin_inset LatexCommand \cite{box-net}

\end_inset 

 é um ambiente de execução baseado em máquina virtual que vem sendo indicado
 pela Microsoft como plataforma de programação preferencial em sistemas
 Windows.
 Apesar de com ele ter sido introduzida a linguagem C# 
\begin_inset LatexCommand \cite{hejlsberg-csharp}

\end_inset 

, o ambiente tem como um de seus objetivos oferecer suporte a múltiplas
 linguagens---evidenciado pelo próprio nome Common Language Runtime (CLR)---em
 contraste com as limitações que o ambiente de Java impõe àqueles que tentam
 utilizá-lo com outras linguagens.
 Todavia, adaptações às linguagens continuam necessárias com o ambiente
 .NET: A versão .NET de Visual Basic inclui alterações na linguagem de modo
 a tornar a sua semântica mais similar à de C#; um novo dialeto de C++,
 Managed C++, foi introduzido adaptando o modelo de gerenciamento de memória
 ao do CLR 
\begin_inset LatexCommand \cite{managedcpp}

\end_inset 

; de forma similar, foi desenvolvido um novo dialeto de ML chamado F#, para,
 entre outros motivos, proporcionar melhor integração com componentes .NET
 desenvolvidos em outras linguagens 
\begin_inset LatexCommand \cite{syme-fsharp}

\end_inset 

.
\layout Standard

Outra implementação de uma máquina virtual para múltiplas linguagens vem
 sendo feita pelo projeto Parrot 
\begin_inset LatexCommand \cite{randal-perl6}

\end_inset 

.
 O escopo deste projeto é mais restrito, visando ser um 
\emph on 
back-end
\emph default 
 comum para linguagens dinâmicas como Perl e Python.
 O foco do projeto, entretanto, está atualmente na implementação de Perl
 6.
\layout Standard

Um tipo de comunicação que pode ser considerada ainda uma forma de ambiente
 de execução comum é a comunicação entre executáveis e bibliotecas nativos
 através de convenções de chamada: regras para a passagem de parâmetros
 na pilha de execução, uso de registradores e 
\emph on 
mangling
\emph default 
 de nomes.
 Este pode ser considerado o método de interação entre código em diferentes
 linguagens de mais baixo nível.
 Convenções de chamada, entretanto, são um recurso limitado de comunicação,
 já que assumem tipos de dados com representação em memória idêntica nas
 as duas linguagens.
 Tal compatibilidade dificilmente ocorre a não ser que uma das linguagens
 explicitamente considere este tipo de interação na sua definição: o padrão
 de Ada, por exemplo, requer que as suas implementações sejam compatíveis
 com as convenções de C, COBOL e Fortran 
\begin_inset LatexCommand \cite{ada95}

\end_inset 

.
 De forma similar, C++ permite especificar funções com linkagem compatível
 com C (
\family typewriter 
extern 
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 

C
\begin_inset ERT
status Collapsed

\layout Standard
"
\end_inset 


\family default 
).
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Modelos de Objetos Independentes de Linguagem
\layout Standard

Adotar um modelo de tipos independente de linguagem é uma outra forma de
 tratar as questões de interoperabilidade de dados entre linguagens.
 Assim, na definição dos dados de uma aplicação, as suas interfaces são
 definidas de forma neutra, tipicamente utilizando alguma linguagem projetada
 especificamente para este fim (uma IDL, 
\emph on 
interface description language
\emph default 
) enquanto as implementações são feitas nas linguagens específicas.
 A arquitetura CORBA (
\emph on 
Common Object Request Broker Architecture
\emph default 
) 
\begin_inset LatexCommand \cite{omg-corba}

\end_inset 

 é uma das principais representantes deste modelo.
 A motivação principal para o desenvolvimento de CORBA foi permitir o desenvolvi
mento de aplicações distribuídas em ambientes heterogêneos; a heterogeneidade
 de linguagens foi um dos aspectos levados em consideração.
\layout Standard

Os desafios existentes ao projetar um modelo de dados ou objetos 
\begin_inset Quotes eld
\end_inset 

independente de linguagens
\begin_inset Quotes erd
\end_inset 

, entretanto, são similares aos de uma interface entre duas linguagens quaisquer
, já que esse modelo, por sua vez, descreve também um sistema de tipos.
 Ao implementar 
\emph on 
bindings
\emph default 
 para algum destes modelos de objetos é necessário definir uma correspondência
 entre os tipos definidos pelo modelo e os oferecidos pela linguagem destino
 e prover a esta uma API para interação com o ambiente de execução---no
 caso de CORBA, com o ORB (
\emph on 
Object Request Broker
\emph default 
).
 
\layout Standard

Se por um lado a tarefa pode ser facilitada pelo fato de o modelo ter sido
 projetado visando interação com outras linguagens (diferentemente, por
 exemplo, do sistema de tipos de C), por outro espera-se usualmente um grau
 de transparência maior na representação dos dados.
 Por exemplo, enquanto em uma aplicação integrando C++ e Python a distinção
 entre objetos C++ e objetos Python é clara e a API Python define o limite
 entre os dois universos, em uma aplicação desenvolvida utilizando CORBA
 espera-se que, tanto em uma linguagem como em outra, a manipulação dos
 objetos seja igual, sejam eles implementados em C++ ou Python.
 Para isso, a solução adotada é o uso de 
\emph on 
stubs
\emph default 
, objetos que dão uma aparência nativa uniforme aos dados, indepentemente
 da linguagem em que foram implementados e no caso de modelos distribuídos
 como CORBA, da localização dos mesmos na rede.
 A correspondência entre os ciclos de vida dos 
\emph on 
stubs
\emph default 
 e dos objetos que eles representam é outro fator que deve ser levado em
 consideração.
 Nos 
\emph on 
bindings
\emph default 
 Java, por exemplo, isto é realizado com o auxílio do coletor de lixo da
 própria linguagem.
 Já em linguagens como C++ o controle das referências é explícito.
\layout Standard

Outras abordagens de mais alto nível têm sido propostas para a integração
 de aplicações desenvolvidas em múltiplas linguagens.
 Linguagens de coordenação como Linda 
\begin_inset LatexCommand \cite{gelernter-linda}

\end_inset 

 e Opus 
\begin_inset LatexCommand \cite{chapman-opus}

\end_inset 

 definem mecanismos para troca de mensagens e um conjunto restrito de construçõe
s para indicar o fluxo destas entre agentes implementados em outras linguagens.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C como Linguagem Intermediária
\layout Standard

O desejo de uma linguagem intermediária universal é antigo no mundo da computaçã
o.
 Diversas propostas surgiram ao longo dos anos, desde o projeto UNCOL 
\begin_inset LatexCommand \cite{conway-uncol}

\end_inset 

 às linguagens de sintaxe extensível da década de 70 
\begin_inset LatexCommand \cite{metzner-xl}

\end_inset 

 até os mais recentes ambientes de máquina virtual como .NET.
 Na prática, as necessidades que estes projetos visavam atender vêm sendo
 supridas ao longo dos anos de forma mais pragmática, ainda que menos ideal:
 usando C.
 Dois motivos fazem de C uma escolha comum como linguagem intermediária.
 Primeiro, a sua característica de linguagem de 
\begin_inset Quotes eld
\end_inset 

médio nível
\begin_inset Quotes erd
\end_inset 

, ao permitir ao mesmo tempo independência de hardware e manipulação direta
 de memória.
 Segundo, a grande disponibilidade de compiladores C, alavancada pela proliferaç
ão dos sistemas Unix nas mais diferentes arquiteturas.
 Assim, com o passar do tempo, oferecer uma interface para interoperabilidade
 com outras linguagens passou a significar oferecer uma interface para comunicaç
ão com código C.
 Isto é especialmente verdadeiro para linguagens dinâmicas que oferecem
 recursos para extensibilidade de aplicações.
 Não por acaso, estas são tipicamente implementadas em C.
\layout Standard

A disponibilidade de APIs para C oferecidas pelas diferentes linguagens
 faz com que C seja bastante usada também como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

.
 A integração entre Python e Fortran se dá através de um módulo Python escrito
 em C que acessa uma biblioteca Fortran, que por sua vez expõe funções com
 convenção de chamada compatível com C 
\begin_inset LatexCommand \cite{peterson-fpy}

\end_inset 

.
 LunaticPython 
\begin_inset LatexCommand \cite{lunatic-python}

\end_inset 

 oferece pontes de Lua para Python e de Python para Lua, implementadas através
 de um par de módulos de extensão para cada linguagem de origem escritos
 em C.
\layout Standard

Todavia, linguagens intermediárias genéricas continuam a ser propostas como
 alternativas a C.
 C-- 
\begin_inset LatexCommand \cite{jones99portable}

\end_inset 

 é um projeto que tenta superar as limitações de C enquanto linguagem intermediá
ria tornando mais explícita a representação em memória dos tipos de dados
 e adicionando suporte a construções não facilmente representáveis em C,
 como recursão final.
 Versões recentes da suíte de compiladores GCC padronizaram uma linguagem
 intermediária para comunicação entre os seus diversos 
\emph on 
back-ends
\emph default 
 e 
\emph on 
front-ends
\emph default 
 
\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces com C
\layout Standard

A linguagem C tem, na atualidade, um papel especial no mundo das linguagens
 de programação.
 Além de ser bastante utilizada na implementação de compiladores, interpretadore
s e máquinas virtuais (as principais implementações de Perl, Python, Ruby,
 Tcl/Tk e Lua são apenas alguns exemplos), é tambem usada em compiladores
 como formato de saída na geração de código portável (dois exemplos notáveis
 são os compiladores GHC 
\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

 e o SmartEiffel 
\begin_inset LatexCommand \cite{collin-eiffel}

\end_inset 

, que geram C a partir de Haskell e Eiffel, respectivamente).
 Isto faz com que a API para C seja um formato conveniente para uma FLI.
\layout Standard

Na grande maioria dos casos, a representação interna de código produzida
 por compiladores de outras linguagens não é compatível com C, seja por
 diferenças em convenções de chamadas ou de nomes, ou por produzirem código
 para execução em máquinas virtuais.
 Desta forma, para permitir a um programa em C acessar este código, cabe
 à linguagem expor uma biblioteca de funções C que realizem a tradução necessári
a.
 Em ambientes de máquina virtual, esta biblioteca de funções normalmente
 é genérica, oferecendo facilidades para comunicação com a própria máquina
 virtual.
 Para linguagens estáticas, normalmente é necessário criar uma biblioteca
 específica que realize a conversão das chamadas, como ocorre em interfaces
 C para APIs C++.
\layout Standard

Para linguagens não imperativas, há ainda o problema de código C potencialmente
 gerar efeitos colaterais.
 Algum recurso para isolamento das chamadas deve ser oferecido.
 No GHC, a construção para chamadas em C, 
\family typewriter 
_ccall_
\family default 
, é definida na mônada de IO; no adendo do padrão Haskell 98, a diretiva
 
\family typewriter 
ccall
\family default 
 foi integrada, mas o uso da mônada é opcional, cabendo ao programador garantir
 que funções que não a utilizem sejam puras
\begin_inset Foot
collapsed true

\layout Standard

Diversas convenções de chamada são definidas (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
) mas 
\family typewriter 
ccall
\family default 
 é a única declarada como obrigatória pelo documento.
\end_inset 

.
\layout Standard

Outra possível fonte de incompatibilidade entre linguagens que deve ser
 tratada quando estas interagem é a diferença entre modelos de concorrência.
 C, em particular, não define construções de concorrência, sendo estas implement
adas através de bibliotecas.
 Ao mesmo tempo que isto traz grande flexibilidade à linguagem, implica
 também em problemas de portabilidade para linguagens que dependam da disponibil
idade de mecanismos de concorrência em C compatíveis com os modelos que
 elas utilizam.
\layout Standard

Por exemplo, APIs entre C e Java devem levar em conta o modelo de 
\emph on 
multithreading
\emph default 
 preemptivo adotado por Java.
 A JNI (
\emph on 
Java Native Interface
\emph default 
) 
\begin_inset LatexCommand \cite{liang-jni}

\end_inset 

 define funções para controlar exclusão mútua entre dados compartilhados
 entre C e Java.
 O programador deve tomar o cuidado de buscar o equilíbrio entre o tempo
 gasto bloqueando a máquina virtual acessando dados compartilhados e o tempo
 gasto realizando cópia de dados entre os ambientes para reduzir o compartilhame
nto.
 Outra situação em que o modelo de concorrência da linguagem demanda cuidados
 por parte do programador na integração com C ocorre no uso de co-rotinas
 em Lua.
 A combinação de dois recursos de Lua, multitarefa cooperativa com múltiplas
 pilhas de execução e a capacidade de alternar entre chamadas a funções
 Lua e C em uma pilha, traz consigo uma limitação: uma co-rotina não pode
 executar a operação de 
\emph on 
yield
\emph default 
 caso haja uma função C na sua pilha, uma vez que não há uma forma portável
 de alternar entre múltiplas pilhas em C 
\begin_inset LatexCommand \cite{moura-colua}

\end_inset 

.
 
\layout Standard

Uma das motivações mais freqüentes para integração com código C é o uso
 de bibliotecas externas.
 Expor uma biblioteca C através da FLI para acesso em uma linguagem pode
 incorrer no registro de centenas de funções.
 É comum definir também tipos de dados que dêem às estruturas definidas
 pela biblioteca uma aparência mais nativa, como por exemplo converter funções
 C que registram 
\emph on 
callbacks
\emph default 
 em métodos Ruby que aceitam blocos de código como parâmetro.
 Essas inicializações e adaptações são usualmente definidas em uma biblioteca
 de 
\emph on 
bindings
\emph default 
, que serve de ponte entre a linguagem e a biblioteca C encapsulando a interação
 com a FLI.
\layout Standard

Os padrões que ocorrem na produção de bindings são tão comuns que deram
 origem a programas visam automatizar o processo.
 Estes geradores de 
\emph on 
bindings
\emph default 
 costumam trabalhar a partir de alguma representação preparada para o seu
 uso, já que analisar os cabeçalhos C pode-se mostrar insuficiente: por
 exemplo, o programa muitas vezes não seria capaz de interpretar a intenção
 de uma construção como 
\family typewriter 
int**
\family default 
.
 SWIG 
\begin_inset LatexCommand \cite{beazley-swig}

\end_inset 

 é uma popular ferramenta multi-linguagem para geração de 
\emph on 
bindings
\emph default 
 de bibliotecas C e C++ que utiliza um formato próprio para descrição de
 interfaces.
 FLIs podem ainda utilizar geradores de 
\emph on 
stubs
\emph default 
 para poupar o programador de escrever código C repetitivo ou não portável.
 Java possui um gerador de cabeçalhos C contendo os protótipos dos métodos
 nativos a serem implementados.
 Pyrex 
\begin_inset LatexCommand \cite{ewing-pyrex}

\end_inset 

 é um gerador de módulos C para Python a partir de uma sintaxe baseada na
 própria linguagem Python.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

APIs de Máquinas Virtuais
\layout Standard

FLIs providas por máquinas virtuais são usualmente compreendidas como 
\begin_inset Quotes eld
\end_inset 

APIs de extensão
\begin_inset Quotes erd
\end_inset 

: elas servem ou para estender a máquina virtual com recursos não oferecidos
 por esta, ou para estender uma aplicação externa com os recursos oferecidos
 pela máquina virtual, embarcando-a nesta aplicação.
 O primeiro cenário é o utilizado no modelo de programação onde a coordenação
 de alto nível é realizada em uma linguagem interpretada e módulos compilados
 em linguagens como C e C++ são usados para acesso a bibliotecas externas
 ou implementação de partes onde o desempenho é crítico.
 O segundo cenário, via de regra, irá englobar também o primeiro, ao expor
 à máquina virtual embarcada extensões que a permitam comunicar-se com a
 aplicação hospedeira.
\layout Standard

As seções seguintes discutem as principais questões envolvidas na comunicação
 entre código C e máquinas virtuais, e apresenta as abordagens empregadas
 pelas APIs de Python, Ruby, Java, Lua e Perl no tratamento destas questões.
\layout Section

Transferência de dados
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

O principal complicador na interação entre linguagens de programação não
 é a diferença de sintaxe ou semântica das construções de fluxo de controle,
 mas a representação dos dados.
 Na comunicação entre código escrito em duas linguagens diferentes, dados
 trafegam de várias formas: como parâmetros, atributos de objetos, elementos
 de estruturas de dados, etc.
\layout Standard

Freqüentemente, o formato como estes dados são representados difere.
 Em casos como este, há três possibilidades.
 A mais simples é expor o dado à linguagem de destino como uma entidade
 opaca.
 A linguagem de destino recebe apenas algum tipo de 
\emph on 
handle
\emph default 
 que permite identificar unicamente o dado em operações requisitadas posteriorme
nte.
 Esta abordagem é útil, por exemplo, se uma linguagem está apenas armazenando
 os dados para a outra, a fim de aproveitar estruturas de dados de mais
 alto nível que esta ofereça.
 
\layout Standard

Outra abordagem envolve realizar algum tipo de conversão dos dados do sistema
 de tipos de uma linguagem para o da outra.
 A duplicação que ocorre na conversão limita a aplicabilidade deste método,
 restringindo o seu uso tipicamente para tipos com volume pequeno de dados,
 como tipos numéricos e, em menor grau, strings.
 Finalmente, a linguagem de origem pode explicitamente oferecer facilidades
 na linguagem de destino para a manipulação destes dados, ou seja, uma linguagem
 oferecer uma API para a outra.
\layout Standard

C, por ser orientada à manipulação de ponteiros e estruturas, possui um
 conjunto pequeno de tipos básicos.
 Além disso, C é bastante liberal em relação à representação interna dos
 tipos estruturados, cabendo às diferentes plataformas definirem interfaces
 binárias (
\emph on 
application binary interfaces
\emph default 
, ABIs).
 Assim, mesmo em casos onde é possível li\SpecialChar \-
gar a código C diretamente utilizando
 tipos básicos compatíveis e convenções de chamada apropriadas (como em
 Free Pascal ou em diversos compiladores Fortran), uma biblioteca de 
\emph on 
bindings
\emph default 
 é usualmente necessária para tornar mais conveniente a manipulação de tipos
 mais complexos.
\layout Standard

Até nos tipos numéricos fundamentais, há vários cuidados que devem ser tomados.
 Algumas linguagens, como Smalltalk e Ruby, realizam conversão automática
 de inteiros para 
\begin_inset Quotes eld
\end_inset 

inteiros grandes
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 Em Ruby, particularmente, os inteiros primitivos têm 1 bit a menos de precisão
 do que o tamanho de palavra da máquina.
 Máquinas virtuais com representação de 
\emph on 
bytecodes
\emph default 
 independentes de arquitetura, como Java, precisam ainda lidar com conversão
 de 
\emph on 
endianness
\emph default 
 e formato de números de ponto flutuante.
\layout Standard

Tipos que envolvem uma quantidade maior de dados, como strings, trazem ainda
 preocupações com desempenho.
 Em diversos casos a representação interna usada para strings é a mesma
 que a usada em C, então uma opção é simplesmente passar ao código C um
 ponteiro para o endereço onde a string está armazenada, o que evita a cópia
 de dados, sob risco de permitir ao programa C modificar o conteúdo da string.
 Isto é uma possível fonte de erros, especialmente em linguagens como Lua,
 onde strings de conteúdo igual compartilham o mesmo espaço de memória.
 Expor ao código C ponteiros para endereços de memória dentro do ambiente
 de execução da outra linguagem pode trazer ainda problemas de concorrência,
 caso o ambiente em questão utilize múltiplas 
\emph on 
threads
\emph default 
.
\layout Standard

Ao expor ao código C dados de tipos estruturados, a conversão para um tipo
 de dado nativo de C, em muitos casos, não é uma opção.
 Além da questão da quantidade de dados, tipos estruturados em C são definidos
 estaticamente, não servindo assim para representar convenientemente dados
 de estrutura dinâmica, como objetos que podem ganhar ou perder atributos
 e até mesmo mudar de classe em tempo de execução.
 Mesmo em linguagens com tipos estáticos, como Java, a cópia de objetos
 não costuma ser uma opção interessante em função do volume de dados.
 A cópia de objetos estruturados costuma se restringir a operações específicas
 como manipulação de arrays de elementos primitivos.
\layout Standard

A alternativa para permitir que código C opere sobre dados estruturados,
 então, é fornecer uma a ele uma API que exponha, em forma de funções, as
 operações definidas sobre os tipos em questão.
 Isto evita também a necessidade de controlar a consistência entre duas
 cópias de uma mesma estrutura.
 Problemas de consistência, entretanto, podem ocorrer caso a API permita
 ao código C armazenar ponteiros para objetos da linguagem---isto torna
 necessário ao programador gerenciar explicitamente a sincronia entre os
 ponteiros e o ciclo de vida dos objetos, que podem estar sujeitos a coleta
 de lixo.
 A Seção 
\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discute esta questão em mais detalhe.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

Todos os valores na máquina virtual de Python são representados como objetos,
 mapeados para a API de C como a estrutura 
\family typewriter 
PyObject
\family default 
.
 Tipos mais específicos como 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 e 
\family typewriter 
PyListObject
\family default 
 são 
\family typewriter 
PyObject
\family default 
s por equivalência estrutural, isto é, podem ser convertidos através de
 um 
\emph on 
cast
\emph default 
 C.
 Refletindo o modelo de tipagem dinâmica de Python, as funções da API usam
 
\family typewriter 
PyObject*
\family default 
 como tipo sempre que se referem a objetos Python, mesmo quando são projetadas
 para atuar sobre tipos mais específicos, como por exemplo 
\family typewriter 
PyString_Size
\family default 
.
 Cada tipo específico possui uma função de verificação na API, como 
\family typewriter 
PyNumber_Check
\family default 
 e 
\family typewriter 
PyDict_Check
\family default 
.
 Há ainda funções genéricas 
\family typewriter 
PyObject_IsInstance
\family default 
 e 
\family typewriter 
PyObject_IsSubclass
\family default 
, que comparam um objeto Python a um objeto Python que representa uma classe.
\layout Standard

Python é uma linguagem fortemente tipada: cada objeto é amarrado a um tipo.
 Tipos são representados por estruturas 
\family typewriter 
PyTypeObject
\family default 
, que também são estruturalmente equivalentes a 
\family typewriter 
PyObject
\family default 
 
\begin_inset LatexCommand \cite{vanrossum-extpy}

\end_inset 

.
 Cada tipo Python possui um PyObject definido na API, como 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 e 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compara um objeto Python a um 
\family typewriter 
PyTypeObject
\family default 
.
\layout Standard

Para a conversão de dados de C para Python, a linguagem oferece uma série
 de funções que recebem variáveis de tipos primitivos de C como parâmetro,
 como 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 e 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Cada uma destas funções retorna ao código C um ponteiro para um novo objeto
 
\family typewriter 
PyObject
\family default 
.
 Strings passadas são copiadas por Python.
 
\layout Standard

Para o retorno de dados de Python para C, um conjunto complementar de funções
 é oferecido, mapeando os tipos básicos de Python de volta a tipos de C.
 Alguns exemplos destas funções que recebem um ponteiro para um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam o dado correspondente em C são 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
, 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLongLong
\family default 
, 
\family typewriter 
PyComplex_\SpecialChar \-
RealAsDouble
\family default 
 e 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Diferentemente das funções de entrada, nas fun\SpecialChar \-
ções de saída as strings
 retornadas são ponteiros para a área armazenada internamente por Python.
 A documentação recomenda não modificar o conteúdo da string exceto no caso
 de esta área de memória haver sido recém alocada por uma chamada a 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
tamanho
\family typewriter 
\emph default 
)
\family default 
.
 Desta forma, é possível alocar uma string para armazenamento em Python
 e preenchê-la posteriormente através de código C, possivelmente através
 de uma seqüência de comandos.
 
\layout Standard

Para alguns de seus tipos básicos que não possuem correspondente direto
 em ANSI C 89, Python define tipos em C equivalentes: 
\family typewriter 
Py_UNICODE
\family default 
 e 
\family typewriter 
Py_complex
\family default 
.
 Estes tipos foram adicionados com o objetivo de aumentar o desempenho de
 módulos Python para manipulação numérica ou de texto Unicode implementados
 em C, evitando conversões freqüentes de e para 
\family typewriter 
PyObject
\family default 
.
 Em plataformas onde 
\family typewriter 
wchar_t
\family default 
, o tipo padrão ANSI C para 
\begin_inset Quotes eld
\end_inset 

wide strings
\begin_inset Quotes erd
\end_inset 

 introduzido em 1995, está disponível, 
\family typewriter 
Py_UNICODE
\family default 
 é um 
\emph on 
typedef
\emph default 
 para este; nas demais, corresponde a um tipo numérico de 16 ou 32 bits,
 dependendo das 
\emph on 
flags
\emph default 
 de compilação de Python.
 
\layout Standard

Python oferece ainda algumas versões de funções de conversão para C implementada
s como macros sem a verificação de tipo, assumindo que o 
\family typewriter 
PyObject
\family default 
 passado será compatível, oferecendo melhor desempenho às custas de segurança.
 Estas funções podem ser identificadas pelos nomes em maiúsculas.
 As únicas macros de conversão oferecidas são 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
, 
\family typewriter 
PyFloat_\SpecialChar \-
AS_DOUBLE
\family default 
, 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
 e 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_DATA
\family default 
, além de macros especiais para obter valores dos campos de objetos 
\family typewriter 
PyDateTime_DateTime
\family default 
 e 
\family typewriter 
PyDateTime_Time
\family default 
.
\layout Standard

Além de funções para conversão de tipos entre Python e C, a API de Python
 oferece ainda algumas funções de conversão entre tipos de Python.
 Estas funções recebem um 
\family typewriter 
PyObject
\family default 
 como parâmetro e retornam um novo 
\family typewriter 
PyObject
\family default 
 com o resultado da conversão, e são equivalentes a funções Python que realizam
 estas conversões (na verdade chamadas a tipos 
\family typewriter 
PyTypeObject
\family default 
 que respondem ao método 
\family typewriter 
__call__
\family default 
).
 Por exemplo, a função 
\family typewriter 
PyObject_Str
\family default 
 é equivalente à função Python 
\family typewriter 
str
\family default 
.
 A Figura 
\begin_inset LatexCommand \ref{cap:PyObject_Str}

\end_inset 

 demonstra a equivalência entre estas, implementando uma função em C que
 obtém através da API o valor global 
\family typewriter 
str
\family default 
 de Python e realiza uma chamada a ele.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
PyObject* my_PyObject_Str(PyObject* o) {
\layout LyX-Code


\size footnotesize 
   PyObject *builtins_module, *builtins, *str;
\layout LyX-Code


\size footnotesize 
   builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
   builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
   str = PyDict_GetItemString(builtins, "str");
\layout LyX-Code


\size footnotesize 
   return PyObject_CallFunctionObjArgs(str, o, NULL);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:PyObject_Str}

\end_inset 

A implementação de uma função equivalente a 
\family typewriter 
PyObject_Str
\end_inset 


\layout Standard

Para referenciar-se a objetos Python a partir de código C, é preciso obter
 uma referência a um objeto onde ele esteja contido.
 Variáveis são armazenadas em um 
\emph on 
ambiente
\emph default 
, representado como um dicionário.
 Funções como 
\family typewriter 
PyRun_File
\family default 
 recebem, entre seus parâmetros, um dicionário de variáveis globais e outro
 de variáveis locais.
 O conjunto de variáveis e funções globais é representado como o dicionário
 do módulo 
\family typewriter 
__main__
\family default 
.
 Objetos 
\emph on 
built-in
\emph default 
 são acessíveis através do módulo 
\family typewriter 
__builtin__
\family default 
, como pode também ser observado na Figura 
\begin_inset LatexCommand \ref{cap:PyObject_Str}

\end_inset 

 ao obter-se uma referência para 
\family typewriter 
str
\family default 
: obtêm-se uma referência ao módulo com 
\family typewriter 
PyImport_AddModule
\family default 
 e em seguida o dicionário do módulo com 
\family typewriter 
PyModule_GetDict
\family default 
.
 Funções C chamadas a partir de Python não recebem referências ao ambiente
 além dos parâmetros da chamada da função (que podem incluir o objeto 
\family typewriter 
self
\family default 
).
 Para evitar a busca dos dicionários de globais e 
\emph on 
built-ins
\emph default 
, o programador deve tipicamente recorrer a armazená-los em ponteiros globais
 em C.
\layout Standard

O armazenamento de dados de C no espaço de objetos de Python pode ser feito
 de duas formas.
 Uma maneira consiste em criar um objeto do tipo 
\family typewriter 
CObject
\family default 
 encapsulando um ponteiro C qualquer, construindo assim um valor opaco para
 Python.
 As funções de construção deste tipo, 
\family typewriter 
PyCObject_\SpecialChar \-
FromVoidPtr
\family default 
 e 
\family typewriter 
PyCObject_\SpecialChar \-
FromVoidPtrAndDesc
\family default 
, permitem associar ao dado uma função C a ser chamada quando o 
\family typewriter 
CObject
\family default 
 for desalocado.
 Segundo a documentação de Python, 
\family typewriter 
CObject
\family default 
s têm como objetivo principal permitir a passagem de dados em C de um módulo
 de extensão para outro 
\begin_inset LatexCommand \cite{pyvhll_cobjects}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(a) Definição da representação do tipo em C
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)        .tp_name = "point",          
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  .tp_methods = point_methods, 
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    .tp_flags = Py_TPFLAGS_DEFAULT
\layout LyX-Code


\size footnotesize 
}; 
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(b) Definição do tipo Python 
\family typewriter 
point
\family default 
 através de estrutura 
\family typewriter 
PyTypeObject
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS }, { 0 }
\layout LyX-Code


\size footnotesize 
};
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(c) Declaração dos métodos do tipo 
\family typewriter 
point
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    PyObject* d = PyFloat_FromDouble( sqrt(pow(p->x,2)+pow(p->y,2)) );
\layout LyX-Code


\size footnotesize 
    return d; 
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(d) Implementação em C de 
\family typewriter 
point.distance
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(e) Tratador do acesso a atributos de 
\family typewriter 
point
\layout LyX-Code


\size footnotesize 
void test_point() {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Inicializa o tipo */
\layout LyX-Code


\size footnotesize 
   point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
   if (PyType_Ready(&point_type) < 0) return;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Cria uma instância deste */
\layout LyX-Code


\size footnotesize 
   point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
   a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
  
\emph on 
 /* Armazena a instância na global Python 'P' */
\layout LyX-Code


\size footnotesize 
   PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
   PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Código Python usando o valor */
\layout LyX-Code


\size footnotesize 
   PyRun_SimpleString( "print 'P.x = ' + str(P.x) 
\backslash 
n"
\layout LyX-Code


\size footnotesize 
                       "print 'P.y = ' + str(P.y) 
\backslash 
n"
\layout LyX-Code


\size footnotesize 
                       "print 'd   = ' + str(P.distance()) 
\backslash 
n" );
\layout LyX-Code


\size footnotesize 
} 
\layout Standard
\align center 

\size footnotesize 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
vspace{-13pt}
\end_inset 

(f) Exemplo de inicialização e uso do tipo 
\family typewriter 
point
\family default 
 através da API de C
\layout Caption


\begin_inset LatexCommand \label{cap:Tipo-Python-em-C}

\end_inset 

Definição de um tipo Python a partir de C
\end_inset 


\layout Standard

A outra forma consiste em declarar novos tipos Python através de estruturas
 em C.
 Em C, um tipo Python é composto de duas partes: um tipo 
\emph on 
struct
\emph default 
 a partir do qual instâncias do tipo serão produzidas; e uma instância da
 struct 
\family typewriter 
PyTypeObject
\family default 
, que descreverá o tipo.
 A Figura 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

 demonstra a criação de um tipo Python em C.
 No exemplo, 
\family typewriter 
point
\family default 
 é o tipo C das instâncias dos objetos (Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(a)), e 
\family typewriter 
point_type
\family default 
 é o 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo Python relativo a eles (Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(b)).
\layout Standard

A estrutura 
\family typewriter 
point
\family default 
 possui equivalência estrutural com 
\family typewriter 
PyObject
\family default 
.
 Quando funções retornarem o objeto ao código C como um 
\family typewriter 
PyObject*
\family default 
, este pode ser convertido para de volta para 
\family typewriter 
point
\family default 
 via cast, dando assim acesso aos atributos 
\family typewriter 
x
\family default 
 e 
\family typewriter 
y
\family default 
.
 Todavia, para que estes atributos sejam visíveis a partir de Python, é
 preciso implementar rotinas de acesso.
\layout Standard

Embora a representação em memória de objetos Python do tipo definido pelo
 usuário sejam instâncias desta estrutura, para criar um novo objeto não
 basta alocar uma instância da struct e usá-la como 
\family typewriter 
PyObject
\family default 
 via cast.
 É preciso inicializar o objeto para que este seja registrado no mecanismo
 de coleta de lixo e tenha os campos de seu cabeçalho 
\family typewriter 
PyObject
\family default 
 devidamente inicializados.
 A alocação em C de novos objetos de um tipo definido pelo usuário deve
 ser feita através da macro 
\family typewriter 
PyObject_New
\family default 
, que recebe como parâmetros o tipo da struct a ser alocada e o 
\family typewriter 
PyTypeObject
\family default 
 correspondente ao tipo.
\layout Standard

O tipo 
\family typewriter 
PyTypeObject
\family default 
 contém uma série de campos que permitem descrever o comportamento do tipo
 declarado.
 Métodos são definidos através de um array de 
\family typewriter 
PyMethodDef
\family default 
s, armazenado no campo 
\family typewriter 
tp_methods
\family default 
.
 No exemplo, o array 
\family typewriter 
point_methods
\family default 
 (Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(c)) indica que a função C 
\family typewriter 
point_distance
\family default 
 implementa o método 
\family typewriter 
distance
\family default 
 (Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(d)).
 No campo 
\family typewriter 
tp_getattr
\family default 
 de 
\family typewriter 
point_type
\family default 
, é especificada uma função C para tratar acesso a atributos, 
\family typewriter 
point_getattr
\family default 
 (Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(e)).
 Desta forma, podemos expor ao ambiente Python atributos armazenados na
 struct C.
 A busca de métodos também é feita através de 
\family typewriter 
tp_getattr
\family default 
.
 A implementação padrão especificada por 
\family typewriter 
PyObject_New
\family default 
 quando procura métodos no array 
\family typewriter 
tp_methods
\family default 
.
 Como redefinimos 
\family typewriter 
tp_getattr
\family default 
, a busca de métodos foi ser implementada em 
\family typewriter 
point_getattr
\family default 
 usando 
\family typewriter 
Py_FindMethod
\family default 
.
 Finalmente, a Fig.
 
\begin_inset LatexCommand \ref{cap:Tipo-Python-em-C}

\end_inset 

(f) exemplifica a inicialização do tipo através da API e o uso do tipo em
 Python.
\layout Standard

A API possui um grande número de funções para manipulação de tipos pré-definidos
 de Python.
 
\emph on 
Tuplas
\emph default 
 merecem menção especial no que tange à transferência de dados entre Python
 e C, pois podem ser usadas tanto para passagem de parâmetros em chamadas
 a funções Python a partir de C, para recebimento dos parâmetros de entrada
 em funções C como para passagem e recebimento de múltiplos valores de retorno,
 como será visto nas Seções 
\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 e 
\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

Como tuplas são usadas com freqüência como 
\begin_inset Quotes eld
\end_inset 

ponte
\begin_inset Quotes erd
\end_inset 

 entre Python e C, a API possui uma função de conveniência, 
\family typewriter 
PyArg_ParseTuple
\family default 
, que evita que o acesso aos elementos da tupla e a verificação dos seus
 tipos seja feita item a item pelo programador.
 Trata-se de uma função C 
\emph on 
vararg
\emph default 
 que recebe como parâmetros a tupla, uma string indicando os tipos dos parâmetro
s esperados e os endereços dos ponteiros para os 
\family typewriter 
PyObject
\family default 
s onde os parâmetros devem ser armazenados.
 A função define uma sintaxe para os indicadores de tipo da string passada
 e os tipos C correspondentes.
 Por exemplo: 
\family typewriter 
"s#"
\family default 
 indica que a tupla deve conter um objeto Python de tipo 
\family typewriter 
string
\family default 
 ou 
\family typewriter 
Unicode
\family default 
 e que dois parâmetros devem ser passados à função C, de tipos const 
\family typewriter 
char**
\family default 
 e 
\family typewriter 
int*
\family default 
.
 Em um exemplo mais elaborado, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indica que a função espera dois endereços de inteiros (
\family typewriter 
"ii"
\family default 
), seguido do endereço de um ponteiro 
\family typewriter 
PyObject
\family default 
 (
\family typewriter 
"O"
\family default 
) e de um objeto 
\family typewriter 
PyTypeObject
\family default 
 a ser usado na verificação do tipo do objeto recebido (
\family typewriter 
"!"
\family default 
) e opcionalmente (
\family typewriter 
"|"
\family default 
), dois endereços de valores 
\family typewriter 
double
\family default 
 passados via Python através de uma tupla (
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

De forma similar, a API de Python possui a função 
\family typewriter 
Py_BuildValue
\family default 
, que permite a construção de objetos estruturados em uma só chamada.
 A sintaxe da string de parâmetros é similar à de 
\family typewriter 
PyArg_ParseTuple
\family default 
, mas possui um conjunto diferente de indicadores de tipo, além de permitir
 descrever listas e dicionários.
 Por exemplo, a seguinte chamada cria uma lista contendo um inteiro, um
 número de ponto flutuante e um dicionário contendo um elemento de chave
 string e valor inteiro:
\layout LyX-Code


\size footnotesize 
PyObject* lista = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

Esta função é útil tanto para construir tuplas em funções C que desejem
 passar múltiplos valores de retorno de volta a Python, como para construir
 a tupla de parâmetros ao chamar funções Python a partir de C.
\layout Subsection

Ruby
\layout Standard

Para a comunicação de dados entre Ruby e C, a API de Ruby define um tipo
 de dados em C chamado 
\family typewriter 
VALUE
\family default 
, que referencia um objeto Ruby.
 
\family typewriter 
VALUE
\family default 
 pode representar tanto uma referência para um objeto (isto é, um ponteiro
 para a 
\emph on 
heap
\emph default 
 de Ruby) como um valor imediato.
 Em particular, as constantes 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 e 
\family typewriter 
Qnil
\family default 
 são definidas como valores imediatos, permitindo a comparação destas usando
 
\family typewriter 
==
\family default 
.
 Para os tipos numéricos, a conversão entre C e Ruby é feita através de
 macros como 
\family typewriter 
INT2NUM
\family default 
 e de funções como 
\family typewriter 
rb_float_new
\family default 
, que recebem ou retornam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

Para a passagem de strings para Ruby a partir de C, são oferecidas as funções
 
\family typewriter 
rb_str_new
\family default 
, que recebe um ponteiro e um argumento numérico de tamanho, de modo a permitir
 a passagem de strings contendo caracteres nulos, e 
\family typewriter 
rb_str_new2
\family default 
, que assume uma string padrão de C, com o caracter nulo como terminador.
 Estas funções fazem uma cópia da string C para o espaço de Ruby.

\family typewriter 
 VALUE
\family default 
s que apontam para strings de Ruby permitem acessar o seu conteúdo através
 do 
\emph on 
cast
\emph default 
 
\family typewriter 
RSTRING(uma_string)->ptr
\family default 
.
 Todavia, a API recomenda o uso da macro 
\family typewriter 
StringValue
\family default 
, que retorna o próprio 
\family typewriter 
VALUE
\family default 
 passado caso este seja uma string, ou um novo 
\family typewriter 
VALUE
\family default 
 da classe 
\family typewriter 
String
\family default 
 produzido através do método de conversão 
\family typewriter 
to_s
\family default 
 aplicado ao objeto passado (ou ainda causar uma exceção 
\family typewriter 
TypeError
\family default 
 caso a conversão não seja possível).
\layout Standard

Sob a justificativa de aumentar o desempenho no acesso, alguns outros tipos
 de Ruby como 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 e 
\family typewriter 
File
\family default 
 permitem acesso de baixo nível aos membros das estruturas utilizadas na
 implementação dos objetos.
 Por exemplo, 
\family typewriter 
RARRAY(um_array)->len
\family default 
 permite ler o tamanho de um array diretamente.
 A recomendação da API é utilizar este tipo de acesso somente para leitura,
 já que a alteração destes valores pode facilmente tornar o estado interno
 dos objetos inconsistente.
\layout Standard

A API permite criar classes a partir de C através da função 
\family typewriter 
rb_define_class
\family default 
.
 Esta função recebe uma string C com o nome da nova classe e um 
\family typewriter 
VALUE
\family default 
 a ser usado como superclasse (como por exemplo a constante C 
\family typewriter 
rb_cObject
\family default 
, que representa a classe Ruby 
\family typewriter 
Object
\family default 
) e retorna um novo 
\family typewriter 
VALUE
\family default 
 representando a nova classe.
 Esta nova referência pode então ser usada como parâmetro em chamadas de
 de 
\family typewriter 
rb_define_method
\family default 
, que adiciona um método à classe recebendo um ponteiro para função C como
 parâmetro, e 
\family typewriter 
rb_class_new_instance
\family default 
, que produz novos objetos Ruby que são instâncias da classe.
 Como em código Ruby, a declaração de atributos de objetos é feita no método
 
\family typewriter 
initialize
\family default 
, que pode ser implementado em C.
\layout Standard

O acesso a variáveis Ruby se dá através da família de funções 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
, que retornam os 
\family typewriter 
VALUE
\family default 
s relativos a atributos de objetos ou classes, variáveis globais e constantes.
 Para cada uma destas há uma função 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 análoga
\begin_inset Foot
collapsed true

\layout Standard

Constantes podem ser criadas com o valor 
\family typewriter 
Qundef
\family default 
 e terem o seu valor definido posteriormente com 
\family typewriter 
rb_const_set
\family default 
, porém uma única vez.
\end_inset 

.
 As funções 
\family typewriter 
rb_iv_get
\family default 
 e 
\family typewriter 
rb_ivar_get
\family default 
, por exemplo, obtêm atributos de objetos (
\emph on 
instance variables
\emph default 
).
 A primeira forma usa strings C como nomes, a segunda usa 
\family typewriter 
ID
\family default 
s, identificadores que substituem strings internalizadas na tabela de símbolos
 de Ruby, que podem ser obtidos usando a função 
\family typewriter 
rb_intern
\family default 
.
 De fato, 
\family typewriter 
ID
\family default 
s correspondem ao tipo 
\emph on 
símbolo
\emph default 
 de Ruby, que na prática são strings imutáveis.
 Um mesmo 
\family typewriter 
ID
\family default 
 pode ser usado para referenciar-se a atributos de objetos de classes diferentes
 que tenham o mesmo nome.
 
\layout Standard


\family typewriter 
ID
\family default 
s nunca são coletados: observamos que a tabela de símbolos não é zerada
 mesmo com 
\family typewriter 
ruby_finalize
\family default 
.
 Assim, uma aplicação C que oferece uma interface para scripting criando
 ambientes supostamente isolados, com 
\family typewriter 
ruby_init
\family default 
 e 
\family typewriter 
ruby_finalize
\family default 
 cercando cada execução de script, pode ter o seu consumo de memória aumentado
 indefinidamente à medida que os scripts criam símbolos.
\layout Standard

Outro tipo de dados que possui um tratamento um tanto irregular na linguagem
 é o de blocos de código.
 A sintaxe em Ruby para a declaração de blocos é especial: blocos só podem
 ser definidos como o último argumento de uma chamada de método.
 Assim, eles não são valores de primeira classe, não podendo ser, por exemplo,
 declarados em uma atribuição a variável.
 Eles podem, no entanto, ser 
\begin_inset Quotes eld
\end_inset 

promovidos
\begin_inset Quotes erd
\end_inset 

 a valores de primeira classe, na forma de objetos da classe 
\family typewriter 
Proc
\family default 
.
 Isto pode ser feito de duas formas: explicitamente, passando um bloco para
 o método 
\family typewriter 
Proc.new
\family default 
, ou implicitamente, declarando em um método um último parâmetro formal
 precedido de 
\family typewriter 
&
\family default 
.
 Esta variável conterá o bloco convertido para um 
\family typewriter 
Proc
\family default 
.
 Na chamada de funções que esperam blocos, 
\family typewriter 
&
\family default 
 converte o 
\family typewriter 
Proc
\family default 
 para um bloco.
 Objetos 
\family typewriter 
Proc
\family default 
 podem ser manipulados através da API de C como qualquer outro objeto Ruby,
 mas não há correspondente na API de C para a funcionalidade do operador
 
\family typewriter 
&
\family default 
 em chamadas de função.
\layout Standard

Para o armazenamento de dados de C no espaço de objetos de Ruby, a API oferece
 uma macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, que recebe um ponteiro C e cria um objeto Ruby que armazena este ponteiro.
 O ponteiro pode ser acessado a partir de código C usando 
\family typewriter 
Data_Get_Struct
\family default 
, mas não a partir de Ruby.
 Para classes cujas instâncias irão conter dados de C, é possível associar
 a uma classe uma função C responsável por realizar a alocação de memória
 das instâncias usando a função 
\family typewriter 
rb_define_alloc_func
\family default 
.
 Definindo uma função de alocação desta forma e implementando um método
 
\family typewriter 
initialize_copy
\family default 
, torna-se possível implementar classes Ruby em C compatíveis com as rotinas
 de cópia de objetos 
\family typewriter 
dup
\family default 
 e 
\family typewriter 
clone
\family default 
.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

A JNI define no cabeçalho 
\family typewriter 
jni.h
\family default 
 tipos em C equivalentes a cada um dos tipos primitivos de Java (
\family typewriter 
jint
\family default 
 para 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 para 
\family typewriter 
float
\family default 
, e assim por diante).
 Os 
\begin_inset Quotes eld
\end_inset 

tipos de referências
\begin_inset Quotes erd
\end_inset 

, como classes e objetos, são expostos a C como referências opacas, instâncias
 de 
\family typewriter 
jobject
\family default 
.
 Strings e arrays também são objetos em Java e são portanto também expostos
 como instâncias de
\family typewriter 
 jobject
\family default 
.
 Entretanto, a JNI define como conveniência alguns tipos em C que agem como
 
\begin_inset Quotes eld
\end_inset 

subtipos
\begin_inset Quotes erd
\end_inset 

 de 
\family typewriter 
jobject
\family default 
: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, além de um tipo array para cada tipo primitivo (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 O tipo 
\family typewriter 
jvalue
\family default 
 é uma 
\emph on 
union
\emph default 
 dos tipos primitivos e de referências.
 O valor C 
\family typewriter 
NULL
\family default 
 equivale a 
\family typewriter 
null
\family default 
 em Java.
\layout Standard

Diferentes métodos são utilizados para a leitura de tipos primitivos, strings,
 arrays e outros objetos.
 A leitura do conteúdo de uma 
\family typewriter 
jstring
\family default 
 em C requer a conversão do formato interno usado por Java, UTF-16.
 A API oferece uma função utilitária que aloca uma string contendo a representaç
ão do texto em UTF-8 (formato compatível com ASCII), 
\family typewriter 
GetStringUTFChars
\family default 
.
 Esta string deve ser posteriormente desalocada com 
\family typewriter 
ReleaseString\SpecialChar \-
UTFChars
\family default 
.
 A função 
\family typewriter 
GetStringChars
\family default 
 permite acesso direto à string em formato UTF-16; ela possui um parâmetro
 de saída que indica se a string retornada é o 
\emph on 
buffer
\emph default 
 interno da JVM ou uma cópia.
 Ao mesmo tempo que isto permite ao código C evitar duplicação da string
 nos casos onde deseja-se modificá-la e a JVM tenha optado por retornar
 uma cópia, tal parâmetro expõe na API questões de baixo nível da gerência
 de strings na JVM.
 Alternativamente, as funções 
\family typewriter 
GetStringRegion
\family default 
 e 
\family typewriter 
GetStringUTFRegion
\family default 
 realizam a cópia da string para um buffer pré-alocado pelo programador.
 
\family typewriter 
GetStringCritical
\family default 
 permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
 cuidados especiais em relação à coleta de lixo, discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays de elementos primitivos são tratados de forma similar a strings,
 diferentemente de arrays de objetos
\begin_inset Foot
collapsed true

\layout Standard

Arrays multi-dimensionais são considerados 
\begin_inset Quotes eld
\end_inset 

arrays de arrays
\begin_inset Quotes erd
\end_inset 

 e, portanto, são, exceto na última dimensão, também arrays de objetos.
\end_inset 

.
 Há funções para realizar a cópia de arrays (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), funções que retornam ponteiros para o array podendo ou não realizar cópias,
 de forma similar a 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) e que podem acessar o buffer interno da JVM diretamente, como em 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 Para arrays de objetos, é possível apenas obter elementos do array um a
 um, sob forma de referências 
\family typewriter 
jobject
\family default 
, com 
\family typewriter 
GetObjectArrayElement
\family default 
.
\layout Standard

A obtenção de valores de atributos se dá através de métodos como 
\family typewriter 
GetObjectField
\family default 
 e 
\family typewriter 
GetStaticField
\family default 
, que retornam referências do tipo 
\family typewriter 
jobject
\family default 
.
 Para cada um dos tipos primitivos existe uma chamada equivalente, como
 
\family typewriter 
GetIntField
\family default 
 e 
\family typewriter 
GetStaticIntField
\family default 
.
 Todas estas funções recebem como parâmetro um 
\emph on 
identificador de campo
\emph default 
, do tipo 
\family typewriter 
jfieldID
\family default 
.
 Estes valores são obtidos com uma chamada a 
\family typewriter 
GetFieldID
\family default 
, que recebe entre seus parâmetros uma string chamada de 
\begin_inset Quotes eld
\end_inset 

descritor de campo JNI
\begin_inset Quotes erd
\end_inset 

 com uma sintaxe especial.
 Por exemplo, o tipo Java 
\family typewriter 
int[][]
\family default 
 é descrito com 
\family typewriter 
"[[I"
\family default 
 e o tipo 
\family typewriter 
java.lang.String
\family default 
 como 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este é outro ponto onde detalhes da implementação transparecem na API.
 Não por coincidência, esta sintaxe é a mesma usada na representação interna
 de tipos em 
\emph on 
bytecodes
\emph default 
 da JVM.
\end_inset 

.
 É possível ainda obter um 
\family typewriter 
jfieldID
\family default 
 a partir de um objeto 
\family typewriter 
java.lang.reflect.Field
\family default 
 usando a função 
\family typewriter 
FromReflectedField
\family default 
.
 Diferentemente de 
\family typewriter 
ID
\family default 
s de Ruby, 
\family typewriter 
jfieldID
\family default 
s contêm informação de tipo e são específicos para o campo de uma determinada
 classe.
 
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExemploJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elementos = { "Terra", "Ar", "Fogo", "Agua" };
\layout LyX-Code


\size footnotesize 
   private native void segundoElemento();
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
      new ExemploJNI().segundoElemento();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExemploJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code
\align center 

\family roman 
\size footnotesize 
(a) ExemploJNI.java
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExemploJNI.h"
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExemploJNI_segundoElemento(JNIEnv *J, jobject this) {
\layout LyX-Code


\size footnotesize 
   jclass classe = (*J)->GetObjectClass(env, this);
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(env, classe,
\layout LyX-Code


\size footnotesize 
      "elementos", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(env, this, elemsID);
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(env, elems, 1);
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(env, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(env, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code
\align center 

\family roman 
\size footnotesize 
(b) ExemploJNI.c
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

Acesso a atributos Java em C via JNI
\end_inset 


\layout Standard

A Figura 
\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

 mostra o acesso de um atributo Java a partir de C.
 Inicialmente, na Fig.
 
\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

(a), é implementada uma classe Java que possui um atributo privado, o array
 
\family typewriter 
elementos
\family default 
, e define uma função 
\family typewriter 
native
\family default 
, 
\family typewriter 
segundoElemento
\family default 
, a ser implementada em C.
 A implementação de 
\family typewriter 
segundoElemento
\family default 
 é mostrada na Fig.
 
\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

(b), ilustrando a seqüência de chamadas até obter em C o elemento do array
 Java.
 Para acessar o atributo 
\family typewriter 
elementos
\family default 
, a função deve obter o identificador do campo.
 Isso é feito com 
\family typewriter 
GetFieldID
\family default 
, que precisa de uma referência da classe a que o campo se refere.
 A referência da classe é obtida com 
\family typewriter 
GetObjectClass
\family default 
, a partir da referência ao objeto (
\family typewriter 
this
\family default 
) retornada à função.
 De posse do identificador (
\family typewriter 
elemsID
\family default 
), a referência ao array apontado pelo atributo é obtida com 
\family typewriter 
GetObjectField
\family default 
 e, com esta, o elemento do array com 
\family typewriter 
GetObjectArrayElement
\family default 
.
 Uma cópia do elemento, convertido para uma string C codificada em UTF-8,
 é retornada com 
\family typewriter 
GetStringUTFChars
\family default 
.
\layout Standard

A manipulação de objetos do tipo 
\family typewriter 
Class
\family default 
 também é feita através de funções específicas.
 É possível criar uma nova classe Java em tempo de execução a partir da
 API C usando a função 
\family typewriter 
DefineClass
\family default 
, que recebe um buffer contendo a representação de uma classe Java pré-compilada.
 Referências do tipo 
\family typewriter 
jclass
\family default 
 podem ser obtidas através do nome da classe usando 
\family typewriter 
FindClass
\family default 
, que utiliza uma sintaxe de descritores de classe similar à de descritor
 de campos usada por 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Tanto em descritores de classe como de campo, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 representam 
\family typewriter 
String[]
\family default 
.
 Para o tipo 
\family typewriter 
String
\family default 
, entretanto, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 é o descritor de campo e 
\family typewriter 
"java/lang/String"
\family default 
 o de classe.
\end_inset 

.
\layout Standard

Para a atribuição de valores de C que podem ser convertidos para tipos primitivo
s de Java, a JNI possui funções como 
\family typewriter 
SetIntField
\family default 
 e 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 Para os demais tipos, não há uma provisão específica para o armazenamento
 de dados de C no espaço de objetos de Java.
 Nestes casos, a documentação sugere o armazenamento de ponteiros em tipos
 numéricos, apesar dos problemas de portabilidade em que tal abordagem incorre.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

A API de Lua define uma abordagem diferente para a manipulação de dados
 em C: não são expostos ao código C ponteiros ou 
\emph on 
handles
\emph default 
 para objetos Lua.
 As operações são definidas em termos de índices de uma pilha virtual.
 Assim, a transferência de dados de C para Lua se dá através de funções
 que recebem tipos de C, os convertem para valores Lua e os empilham, como
 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 e 
\family typewriter 
lua_pushlstring
\family default 
.
 Diversas operações da API operam sobre o valor no topo da pilha, como por
 exemplo 
\family typewriter 
lua_setglobal
\family default 
.
 A maioria das funções de consulta, entretanto, permitem especificar um
 índice qualquer da pilha (com valores positivos para indexação a partir
 da base e negativos para índices a partir do topo).
\layout Standard

A conversão de dados de Lua para C é feita através de funções como 
\family typewriter 
lua_tonumber
\family default 
 e 
\family typewriter 
lua_tolstring
\family default 
, que recebem um índice da pilha, convertem o valor no índice para o tipo
 Lua especificado, e retornam o valor no tipo C equivalente.
 Números têm o tipo C 
\family typewriter 
lua_Number
\family default 
, que corresponde a 
\family typewriter 
double
\family default 
 por padrão mas é um parâmetro na compilação de Lua.
 Strings, em particular, são objetos imutáveis e têm sua representação internali
zada: duas strings de conteúdo idêntico compartilham a mesma representação
 interna.
\layout Standard

Assim, diferentemente de linguagens como Python e Ruby, não é possível modificar
 o conteúdo de uma string Lua através de C via a sua representação em memória
 como um 
\family typewriter 
char*
\family default 
.
 Para tornar mais eficiente a construção em etapas de strings Lua a partir
 de C, a biblioteca auxiliar define um tipo C 
\family typewriter 
luaL_Buffer
\family default 
 e funções como 
\family typewriter 
luaL_addstring
\family default 
 e 
\family typewriter 
luaL_addvalue
\family default 
, que permitem a construção de uma string em etapas até que ela possa ser
 finalmente convertida para uma string Lua com 
\family typewriter 
luaL_pushresult
\family default 
.
 Assim, evita-se a internalização de strings representando os estágios intermedi
ários da construção da string final.
\layout Standard

Lua define dois tipos de dados específicos para o armazenamento de dados
 para C, 
\emph on 
full userdata
\emph default 
 e 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 descrevem blocos de memória gerenciados por Lua e utilizados por código
 C.
 Eles existem em Lua como objetos opacos, e são criados por 
\family typewriter 
lua_newuserdata
\family default 
, que insere o novo objeto na pilha de Lua e retorna a C um ponteiro com
 a área de memória do tamanho requisitado.
 Objetos do tipo 
\emph on 
light userdata
\emph default 
, criados através de 
\family typewriter 
lua_pushlightuserdata
\family default 
, permitem armazenar ponteiros de C em Lua; a alocação e gerência do bloco
 de memória ficam a cargo do código C.
 
\layout Standard

A área de armazenamento da pilha não se ajusta dinamicamente e as funções
 da API não realizam controle de 
\emph on 
overflow
\emph default 
.
 Assim, o programador é responsável por controlar o tamanho da pilha, através
 da função 
\family typewriter 
lua_checkstack
\family default 
.
 Na prática, o tamanho da pilha só irá crescer na ocorrência de laços empilhando
 elementos, já que seqüências típicas de operações tendem a empilhar valores
 e desempilhá-los em seguida.
\layout Standard

Tabelas são o único tipo para construção de estruturas de dados em Lua.
 Lua oferece uma API completa para manipulação de tabelas a partir de C.
 Tabelas podem ser criadas com 
\family typewriter 
lua_newtable
\family default 
 ou 
\family typewriter 
lua_createtable
\family default 
; a segunda forma permite pré-alocar memória para os elementos da tabela.
 As funções 
\family typewriter 
lua_gettable
\family default 
 e 
\family typewriter 
lua_settable
\family default 
 implementam a semântica de leitura e atribuição de campos em uma tabela
 em Lua, incluindo a possível chamada a metamétodos; para chamadas sem a
 invocação de metamétodos existem as funções 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, equivalentes a 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 em Lua (além das variantes 
\family typewriter 
lua_rawgeti
\family default 
 e 
\family typewriter 
lua_rawseti
\family default 
 para conveniência).
 Há ainda a função 
\family typewriter 
lua_next
\family default 
, equivalente à função Lua 
\family typewriter 
next
\family default 
, que permite percorrer os elementos de uma tabela.
\layout Standard

Diversos conceitos de Lua são representados através de tabelas -- ambiente
 global, metatabelas, registro -- e são assim tratados em C usando as funções
 da API para manipulação de tabelas.
 A tabela do ambiente global da 
\emph on 
thread
\emph default 
 em execução pode ser acessada através de um índice especial da pilha virtual,
 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 Pode-se ainda definir uma tabela de ambiente da função, indexada em 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, para isolar dados a serem compartilhados internamente em funções de módulos
 escritos em C.
 
\layout Subsection

Perl
\layout Standard

Os processos de estender e embutir Perl são bastante distintos.
 Para extensões, Perl oferece uma linguagem para descrição de interfaces
 chamada XS.
 Ao invés de isolar o acesso às estruturas internas de Perl através de uma
 API pública, a abordagem proposta é encapsular o processo de geração de
 código 
\emph on 
wrapper
\emph default 
 para a comunicação entre funções escritas em C e as estruturas internas
 de Perl usando interfaces escritas em XS.
 Arquivos 
\family typewriter 
.xs
\family default 
 contêm código C acompanhado de anotações que simplificam o tratamento dos
 parâmetros de entrada e saída.
 Estes são alimentados ao pré-processador 
\family typewriter 
xsubpp
\family default 
, que geram então o código usando a API oferecida pela biblioteca de Perl.
 Esta biblioteca oferece acesso de baixo nível ao funcionamento da máquina
 virtual, permitindo, por exemplo, manipular o ponteiro da sua pilha interna.
 O objetivo de XS é ocultar ao desenvolvedor de extensões estes detalhes.
\layout Standard

Para embutir a máquina virtual de Perl em uma aplicação, a biblioteca que
 a implementa oferece algumas funções que permitem disparar um interpretador.
 Na API de mais alto nível, pode-se construir um array de parâmetros a serem
 passados para o interpretador de forma equivalente às opções do interpretador
 Perl de linha de comando, inclusive usando a opção 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

-e
\begin_inset Quotes erd
\end_inset 


\family default 
 para executar trechos de código.
\layout Standard

Os tipos fundamentais de Perl são mapeados para 
\emph on 
typedefs
\emph default 
 em C: 
\family typewriter 
SV
\family default 
 para valores escalares, 
\family typewriter 
AV
\family default 
 para arrays, 
\family typewriter 
HV
\family default 
 para hashes.
 Os 
\emph on 
typedefs
\emph default 
 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 e 
\family typewriter 
PV
\family default 
 correspondem, respectivamente, a inteiros com e sem sinal, valores de ponto
 flutuante e strings, e podem ser copiados para 
\family typewriter 
SV
\family default 
s.
 Referências em Perl são representados como 
\family typewriter 
RV
\family default 
, e também são um tipo de 
\family typewriter 
SV
\family default 
.
 Há ainda o tipo 
\family typewriter 
GV
\family default 
, capaz de referenciar qualquer tipo representável em uma variável Perl.
\layout Standard

Valores escalares são criados com as funções 
\family typewriter 
newSV
\family default 
*: 
\family typewriter 
newSViv
\family default 
 gera um 
\family typewriter 
SV
\family default 
 a partir de um inteiro com sinal; 
\family typewriter 
newSVpv
\family default 
 a partir de uma string, e assim por diante.
 A função 
\family typewriter 
newSV
\family default 
 permite criar um 
\family typewriter 
SV
\family default 
 com área de memória não inicializada, acessível através da função 
\family typewriter 
SvPVX
\family default 
, permitindo assim criar escalares com valores arbitrários gerenciados por
 código C.
 Valores são atribuídos a SVs usando as funções 
\family typewriter 
sv_set
\family default 
*: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 As funções para manipulação de strings possuem variantes como 
\family typewriter 
newSVpvn
\family default 
 e 
\family typewriter 
sv_setpvf
\family default 
, que permitem especificar o comprimento da string ou realizar formatação
 como em 
\family typewriter 
sprintf
\family default 
.
 Para strings, há ainda funções 
\family typewriter 
sv_cat
\family default 
*, que atuam como 
\family typewriter 
sv_set
\family default 
* mas concatenam o valor dado ao conteúdo atual da string ao invés de substituí-
lo.
 O tipo dos dados armazenados em 
\family typewriter 
SV
\family default 
s é verificado com as macros 
\family typewriter 
SvIOK
\family default 
 para inteiros, 
\family typewriter 
SvNOK
\family default 
 para valores de ponto flutuante e 
\family typewriter 
SvPOK
\family default 
 para strings.
 Estas funções retornam sucesso se o escalar é conversível para o tipo especific
ado -- as variantes 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verificam se o valor armazenado é realmente do tipo.
\layout Standard

Arrays e hashes são criados com 
\family typewriter 
newAV
\family default 
 e 
\family typewriter 
newHV
\family default 
.
 Arrays podem ser populados com 
\family typewriter 
SV
\family default 
s através de 
\family typewriter 
av_make
\family default 
.
 Operações como 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 e 
\family typewriter 
hv_exists
\family default 
 permitem operar sobre elementos das estruturas -- referências para elementos
 são retornadas como ponteiros para 
\family typewriter 
SV
\family default 
.
 A API original de hashes utilizava chaves declaradas como strings C; esta
 foi estendida a partir de Perl 5.004 com funções como 
\family typewriter 
hv_fetch_ent
\family default 
 que permitem usar 
\family typewriter 
SV
\family default 
s como strings.
 As funções novas expõem os pares chave/valor como ponteiros 
\family typewriter 
HE
\family default 
, anteriormente retornado apenas em funções de iteração como 
\family typewriter 
hv_iternext
\family default 
; as macros 
\family typewriter 
HeSVKEY
\family default 
 e 
\family typewriter 
HeVAL
\family default 
 permitem extrair a chave e valor de um 
\family typewriter 
HE
\family default 
.
 Cuidados especiais devem ser tomados ao utilizar os valores 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em arrays e hashes, embora Perl exponha estas constantes na API de C (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 
\family typewriter 
PL_sv_undef
\family default 
 é usado internamente na implementação de 
\family typewriter 
AV
\family default 
s e 
\family typewriter 
HV
\family default 
s, e a atualização de valores em 
\family typewriter 
HV
\family default 
s ocorre 
\emph on 
in-place
\emph default 
, o que gera problemas ao atualizar elementos contendo estas constantes.
 A documentação recomenda gerar cópias destes valores ao usá-los em estruturas
 
\family typewriter 
AV
\family default 
 e 
\family typewriter 
HV
\family default 
 
\begin_inset LatexCommand \cite{perlguts}

\end_inset 

.
\layout Standard

Referências Perl são criadas com 
\family typewriter 
newRV_inc
\family default 
 e 
\family typewriter 
newRV_noinc
\family default 
, que recebem um ponteiro para 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 como parâmetro (as duas funções diferem entre si no que tange à contagem
 de referências, que será abordada na Seção 
\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 O valor apontado por uma referência é obtido com 
\family typewriter 
SvRV
\family default 
.
 O retorno desta macro deve ser convertido via 
\emph on 
cast
\emph default 
 para o tipo apropriado (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), que pode ser verificado com 
\family typewriter 
SvTYPE
\family default 
.
 Diversas funções da API têm tipo de parâmetros ou retorno declarados como
 
\family typewriter 
SV
\family default 
 quando na verdade aceitam 
\family typewriter 
AV
\family default 
s ou 
\family typewriter 
HV
\family default 
s; isto é análogo ao conceito de 
\emph on 
contextos
\emph default 
 de Perl, onde um mesmo valor pode ser tratado como lista (array ou hash)
 ou escalar dependendo da expressão onde ele é inserido.
 Em código Perl, o contexto em que uma função está executando pode ser verificad
o com 
\family typewriter 
wantarray
\family default 
.
 Em C, o contexto pode ser verificado com a macro 
\family typewriter 
GIMME_V
\family default 
, que retorna 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 ou 
\family typewriter 
G_ARRAY
\family default 
.
\layout Standard

Valores são obtidos a partir do espaço de Perl com 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 e 
\family typewriter 
get_hv
\family default 
.
 Estas funções recebem uma string C com o nome da variável (possivelmente
 qualificado da forma 
\family typewriter 
"pacote::variavel"
\family default 
) e uma flag indicando se o valor deve ser criado se inexistente.
 O conteúdo de valores escalares é convertido de volta para um tipo C com
 as macros 
\family typewriter 
Sv
\family default 
*: 
\family typewriter 
SvIV
\family default 
 retorna um inteiro, 
\family typewriter 
SvPV
\family default 
 retorna um 
\family typewriter 
char*
\family default 
 e o comprimento da string no segundo parâmetro, etc.
 O seguinte código C exibe o conteúdo da variável Perl 
\family typewriter 
$a
\family default 
, assumindo que ela contenha um valor inteiro:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard

Usar 
\family typewriter 
TRUE
\family default 
 no segundo parâmetro de 
\family typewriter 
get_sv
\family default 
 é uma forma conveniente de alocar uma nova variável acessível no espaço
 de C já realizando o 
\emph on 
binding
\emph default 
 do nome no espaço de Perl.
 
\layout Section

Coleta de lixo
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

A partir do momento em que código C ganha acesso a referências a dados armazenad
os no espaço de armazenamento de outra linguagem, sejam ponteiros ou identificad
ores, o programador deve levar em consideração as diferenças entre os modelos
 de gerência de memória envolvidos, já que código executado na outra linguagem
 pode liberar o dado (destruir o objeto, remover um elemento de uma estrutura).
 Em princípio, isto não é diferente da gerência de memória realizada normalmente
 pelo programador em C.
 Entretanto, a interação com algumas linguagens adiciona um complicador:
 mecanismos de coleta de lixo realizam liberação de dados da memória de
 forma implícita.
 O princípio fundamental da coleta de lixo dita que um objeto não é coletado
 caso haja algum elemento (variável, estrutura de dados) apontando para
 ele.
 Todavia, o mesmo não vale para o ambiente C: a presença de um ponteiro
 apontando para um objeto não garante que ele não será coletado, uma vez
 que o coletor de lixo não gerencia os ponteiros do código C.
\layout Standard

É preciso, então, indicar a partir do código C que os dados que continuam
 acessíveis por ele não devem ser coletados.
 De forma complementar, ao transferir o controle de objetos C para o domínio
 da outra linguagem---por exemplo, para armazená-los em uma estrutura de
 dados desta---é necessário indicar à linguagem como desalocar a memória
 da estrutura quando o coletor de lixo detectar que ela não está mais em
 uso.
 A forma como a FLI irá fornecer estas funcionalidades depende não só do
 projeto da API para C, mas também do modelo de coleta de lixo empregado
 pela implementação da linguagem.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

A máquina virtual de Python possui um coletor de lixo baseado em contagem
 de referências.
 Como a API de Python retorna ao código C ponteiros a 
\family typewriter 
PyObject
\family default 
s, o programador deve ter o cuidado de garantir que eles se mantenham válidos.
 Para isto, é necessário incrementar e decrementar o contador de referências
 do objeto apontado conforme deseja-se manter a validade dos ponteiros em
 código C.
\layout Standard

De maneira geral, uma vez que código C deseja reter um 
\family typewriter 
PyObject*
\family default 
, ele deve utilizar a macro 
\family typewriter 
Py_INCREF
\family default 
 para incrementar a sua contagem de referências e assim impedi-lo de ser
 coletado.
 Uma vez que o valor não seja mais necessário, decrementa-se a contagem
 similarmente com 
\family typewriter 
Py_DECREF
\family default 
.
 Python trabalha com o conceito de 
\emph on 

\begin_inset Quotes eld
\end_inset 

propriedade de referências
\begin_inset Quotes erd
\end_inset 


\emph default 
 para definir quando o programador deve incrementar ou decrementar o contador
 de referências retornadas pelas funções da API.
 A maior parte das funções da API que retornam ponteiros a 
\family typewriter 
PyObject
\family default 
s 
\emph on 
transferem
\emph default 
 referências para o chamador; a referência passa então a ser sua responsabilidad
e -- ele pode passá-la adiante ou terá o dever de decrementá-la com 
\family typewriter 
Py_DECREF
\family default 
 assim que não precisar mais usá-la (o código C pode guardar referências
 que sejam de sua propriedade em suas estruturas de dados; elas continuarão
 válidas mesmo após o retorno da função, até serem explicitamente decrementadas).
 Outras funções 
\emph on 
emprestam
\emph default 
 referências; o código que recebe uma referência deste tipo não precisa
 decrementá-la ao terminar de utilizá-la, mas a validade do objeto está
 atrelado à validade da referência no objeto que a retornou ao código C.
 Por exemplo, 
\family typewriter 
PyList_GetItem
\family default 
 empresta uma referência a um elemento da lista.
 O ponteiro retornado continuará válido enquanto este item continuar contido
 na lista.
 Pode-se obter a 
\begin_inset Quotes eld
\end_inset 

propriedade
\begin_inset Quotes erd
\end_inset 

 de uma referência emprestada incrementando a contagem do objeto com 
\family typewriter 
Py_INCREF
\family default 
: a validade do ponteiro passa a ser independente o objeto 
\emph on 
container
\emph default 
 que o retornou, mas o código C passa a ser responsável por decrementar
 a referência posteriormente com 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

Para referências de objetos passadas de código C de volta para Python, há
 dois casos na API em que funções 
\emph on 

\begin_inset Quotes eld
\end_inset 

roubam
\begin_inset Quotes erd
\end_inset 


\emph default 
 referências, isto é, em que a referência deixa de pertencer à função C
 chamadora: 
\family typewriter 
PyList_SetItem
\family default 
 e 
\family typewriter 
PyTuple_SetItem
\family default 
.
 A referência passada, que deve pertencer ao chamador, passa então a ser
 uma referência emprestada após a chamada.
 O objetivo disto é permitir chamadas de função aninhadas onde, por exemplo,
 o parâmetro de 
\family typewriter 
PyList_SetItem
\family default 
 é uma chamada gera um novo objeto a ser armazenado na lista.
 Assim, evita-se que o programador tenha que armazenar um ponteiro para
 o objeto apenas para decrementar a sua referência posteriormente.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject *list) {
\layout LyX-Code


\size footnotesize 
   PyObject *item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Acesso possivelmente inválido em 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject *list) {
\layout LyX-Code


\size footnotesize 
   PyObject *item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 é garantidamente válido em 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Acesso possivelmente inválido a uma referência a um 
\family typewriter 
PyObject
\family default 
 em código C
\end_inset 


\layout Standard

A interação com o contador de referências pode ser bastante sutil.
 O exemplo da Figura 
\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extraído da documentação de Python, demonstra que uma referência pode
 ser invalidada por código aparentemente não relacionado
\begin_inset Foot
collapsed true

\layout Standard

De fato, a documentação informa que versões antigas de Python continham
 variantes deste 
\emph on 
bug
\emph default 
 em alguns de seus módulos.
\end_inset 

.
 À primeira vista, a inclusão de um elemento em 
\family typewriter 
list[1]
\family default 
 parece não afetar a referência 
\family typewriter 
item
\family default 
, que corresponde a 
\family typewriter 
list[0]
\family default 
.
 Todavia, a inclusão de 
\family typewriter 
list[1]
\family default 
 pode haver removido da lista um elemento que se encontrava nesta posição.
 Caso a lista fosse a última referência válida para o elemento, este poderia
 ser coletado.
 A coleta do objeto pode invocar o seu método finalizador 
\family typewriter 
__del__
\family default 
, que pode rodar código Python arbitrário.
 Se este código remove o elemento da posição 0 de 
\family typewriter 
list
\family default 
 e isto causar a sua coleta, a referência 
\family typewriter 
item
\family default 
 passa a ser inválida, porque 
\family typewriter 
PyList_GetItem
\family default 
 retorna uma referência emprestada.
 
\layout Standard

Ao implementar funções em C que retornam referências a 
\family typewriter 
PyObject
\family default 
s, o mesmo cuidado de definir a política de tempo de vida da referência
 deve ser tomado.
 Para retornar uma referência nova, pode ser necessário incrementar a contagem
 do objeto.
 Isto se manifesta, por exemplo, na forma correta de uma função C retornar
 o valor 
\family typewriter 
None
\family default 
, que envolve chamar 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este padrão é tão comum que a seqüência 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 foi encapsulada na macro 
\family typewriter 
Py_RETURN_NONE
\family default 
.
\end_inset 

.
 Mesmo objetos Python representando números devem ter a sua contagem de
 referências controlada pelo programador C.
 
\layout Standard

Para que o código C possa realizar operações de finalização sobre os dados
 armazenados em um tipo Python definido em C, é possível definir uma função
 de desalocação no campo 
\family typewriter 
tp_dealloc
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo.
 Esta função é normalmente responsável por liberar recursos alocados via
 código C (arquivos abertos, ponteiros para áreas de memória não acessíveis
 por Python, etc.) e decrementar referências a outros objetos Python mantidas
 pelo objeto.
\layout Standard

Ao desalocar estruturas de dados como listas pode-se provocar uma cadeia
 arbitrariamente grande de desalocações, à medida que o decremento da contagem
 de referências de cada elemento reduz o número de referências do objeto
 seguinte da estrutura para zero, disparando a função de desalocação recursivame
nte.
 Isto pode facilmente causar estouro da pilha de C.
 Para contornar este problema, Python inclui um par de macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 e 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, que controla o número de níveis de recursão aceitos.
 Quando a pilha de chamadas excede um valor limite definido na constante
 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 (50 por padrão), 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 armazena o objeto em uma lista e salta diretamente para 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, adiando a execução da função de desalocação.
 Quando a pilha diminui de volta ao tamanho original, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 dispara novamente 
\family typewriter 
tp_dealloc
\family default 
 sobre os elementos da lista de pendências, reiniciando assim a recursão.
 
\layout Standard

O modelo de coleta de lixo utilizando contagem de referências traz consigo
 preocupações sobre referências circulares: uma cadeia de objetos que mantêm
 referências entre si mantém a contagem de cada um dos seus elementos acima
 de zero, mesmo que eles não sejam alcançáveis a partir de nenhum outro
 objeto.
 Python inclui um detector de ciclos, mas provisões especiais devem ser
 tomadas para que tipos implementados em C se comportem corretamente caso
 possam gerar ciclos.
 Deve-se implementar uma função para percorrer referências contidas no objeto
 e uma função que decremente a contagem destas referências.
 Estas funções devem ser registradas nos campos 
\family typewriter 
tp_traverse
\family default 
 e 
\family typewriter 
tp_clear
\family default 
 de 
\family typewriter 
PyTypeObject
\family default 
.
 A função 
\family typewriter 
tp_clear
\family default 
 deve ter o cuidado de zerar o valor de seus campos 
\family typewriter 
PyObject*
\family default 
 para 
\family typewriter 
NULL
\family default 
 antes de decrementar cada referência, uma vez que a operação de decremento
 pode iniciar a desalocação do objeto e disparar uma chamada a 
\family typewriter 
tp_traverse
\family default 
 que, devido ao ciclo, retorne ao objeto anterior.
 O tipo deve ser, então, identificado com a flag 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 em 
\family typewriter 
tp_flags
\family default 
.
\layout Standard

Além disso, a implementação de objetos Python que suportem coleta cíclica
 em C implica ainda em outros cuidados.
 Objetos devem ser alocados com 
\family typewriter 
PyObject_GC_New
\family default 
 ou 
\family typewriter 
PyObject_GC_NewVar
\family default 
 ao invés da funções usuais 
\family typewriter 
PyObject_New
\family default 
 e 
\family typewriter 
PyObject_NewVar
\family default 
.
 Durante a construção do objeto, após os campos a serem visitados por tp_travers
e terem sido preenchidos, é necessário ainda chamar uma função de notificação
 
\family typewriter 
PyObject_GC_Track
\family default 
 e durante a desalocação, antes de invalidar os campos do objeto, chamar
 
\family typewriter 
PyObject_GC_UnTrack
\family default 
.
 Para objetos que necessitem do mecanismo de 
\emph on 

\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 


\emph default 
 para evitar estouro de pilha, é ainda preciso tomar o cuidado de desmarcar
 o objeto com 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 antes de entrar no bloco 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
.
\layout Comment

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\layout Standard

Apesar de oferecer um mecanismo de detecção de ciclos, Python é incapaz
 de coletar ciclos cujos objetos contenham finalizadores implementados em
 Python (métodos 
\family typewriter 
__del__
\family default 
); a única forma de acessar estes objetos é então através da lista 
\family typewriter 
garbage
\family default 
 no módulo 
\family typewriter 
gc
\family default 
.
 Este módulo (acessível a partir de C através de chamadas de função Python
 via API) oferece uma interface com o coletor de lixo, incluindo funções
 como 
\family typewriter 
enable
\family default 
 e 
\family typewriter 
disable
\family default 
, para ativar e desativar o coletor de lixo; 
\family typewriter 
collect
\family default 
 para executar uma coleta; 
\family typewriter 
get_objects
\family default 
, que retorna uma lista contendo todos os objetos controlados pelo coletor
 (exceto a própria lista); 
\family typewriter 
get_referrers
\family default 
 e 
\family typewriter 
get_referents
\family default 
, que retornam a lista de objetos que referenciam ou são referenciados por
 um dado objeto -- estas listas são obtidas percorrendo objetos com a função
 
\family typewriter 
tp_traverse
\family default 
, o que pode não apontar para todos os objetos realmente alcançáveis, ou
 ainda retornar objetos em estado inválido (como objetos em ciclos ainda
 não coletados ou objetos ainda não totalmente construídos) e assim devem
 ser usadas apenas para fins de depuração.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby utiliza um coletor de lixo 
\emph on 
mark-and-sweep
\emph default 
 
\begin_inset LatexCommand \cite{wilson-gc}

\end_inset 

: ele funciona em duas passadas, inicialmente marcando os objetos alcançáveis
 e depois percorrendo a lista completa de objetos coletando aqueles que
 não tenham sido marcados.
 Esta técnica evita o problema de referências cíclicas enfrentado por Python.
\layout Standard

Objetos Ruby criados com 
\family typewriter 
Data_Wrap_Struct
\family default 
 e 
\family typewriter 
Data_Make_Struct
\family default 
 contêm 
\emph on 
structs
\emph default 
 C que podem conter referências a 
\family typewriter 
VALUE
\family default 
s Ruby.
 A 
\emph on 
struct
\emph default 
 encapsulada, entretanto, é opaca para o universo Ruby.
 Então, para garantir que estes 
\family typewriter 
VALUE
\family default 
s sejam marcados como alcançáveis durante a coleta de lixo é necessário
 fazer isto via código C.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 e 
\family typewriter 
Data_Make_Struct
\family default 
 recebem, além da 
\emph on 
struct
\emph default 
 a encapsular, dois ponteiros, um para uma função de marcação e outra para
 uma função de desalocação.
 Quando o coletor de lixo visita o objeto na fase de marcação, ele invoca
 a função registrada, que deve chamar 
\family typewriter 
rb_gc_mark
\family default 
 em cada um dos 
\family typewriter 
VALUE
\family default 
s armazenados na 
\emph on 
struct
\emph default 
 do objeto, informando assim que os objetos são alcançáveis.
 Quando um objeto encapsulado via 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 for dado como não alcançável, a função de desalocação registrada é chamada.
 Para estruturas que não armazenam outros 
\family typewriter 
VALUE
\family default 
s, pode-se definir a função de marcação como 
\family typewriter 
NULL
\family default 
 e a de desalocação como 
\family typewriter 
free
\family default 
.
\layout Standard

Muitas funções de API de Ruby retornam 
\family typewriter 
VALUE
\family default 
s.
 Caso estes objetos não sejam alcançáveis a partir do espaço de objetos
 de Ruby -- por exemplo, tendo sido atribuídos a uma variável global Ruby
 ou inserido em alguma estrutura de dados alcançável em Ruby -- estes objetos
 estarão, a princípio, sujeitos à coleta de lixo.
 A documentação alerta que, para armazenar objetos Ruby em variáveis globais
 ou estruturas de dados de C, é necessário notificar à máquina virtual que
 o valor não deve ser coletado, usando 
\family typewriter 
rb_global_variable
\family default 

\begin_inset Foot
collapsed false

\layout Standard

Embora a documentação não informe, é possível desmarcar um valor global
 com 
\family typewriter 
rb_gc_unregister_address
\family default 
.
\end_inset 

.
\layout Standard

Objetos de escopo local a uma função C, entretanto, não precisam ser notificados.
 A forma como Ruby garante a validade de 
\family typewriter 
VALUE
\family default 
s locais é bastante peculiar: ao realizar a fase de marcação, o coletor
 de lixo varre a pilha de C em busca de valores que se pareçam com endereços
 de 
\family typewriter 
VALUE
\family default 
s (isto é, seqüências numéricas que correspondam a endereços de 
\family typewriter 
VALUE
\family default 
s válidos).
 Cada 
\family typewriter 
VALUE
\family default 
 encontrado na pilha é então marcado.
 Isto garante que nenhum 
\family typewriter 
VALUE
\family default 
 localmente alcançável por código C seja invalidado, mas pode gerar 
\begin_inset Quotes eld
\end_inset 

falsos positivos
\begin_inset Quotes erd
\end_inset 

 evitando que dados que poderiam ser coletados o sejam.
\layout Standard

Apesar da conveniência para o programador, tal abortagem é extremamente
 não-portável.
 A implementação do coletor de lixo em Ruby 1.8.2 possui 
\family typewriter 
#ifdef
\family default 
s para IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC e Motorola 68000.
 Além disso, o coletor força a descarga dos registradores para a pilha usando
 
\family typewriter 
setjmp
\family default 
, para evitar que variáveis do tipo 
\family typewriter 
VALUE
\family default 
 que tenham sido otimizadas pelo compilador deixem de ser verificadas.
\layout Standard

Ruby possui um módulo 
\family typewriter 
GC
\family default 
 que disponibiliza funções para ativar e desativar o coletor (
\family typewriter 
GC.enable
\family default 
 e 
\family typewriter 
GC.disable
\family default 
), bem como disparar uma coleta imediatamente (
\family typewriter 
GC.start
\family default 
).
 Na API em C há funções equivalentes: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 A API de C inclui ainda uma função que insere um objeto imediatamente na
 lista de objetos a serem reciclados pelo alocador de memória de Ruby, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 Esta função deve ser usada com cuidado, já que se houverem outras referências
 apontando ao objeto elas passarão a apontar para outro objeto quando a
 área de memória for reutilizada pelo alocador de Ruby.
\layout Standard

Ruby oferece ainda como conveniência alguns 
\emph on 
wrappers
\emph default 
 para as funções 
\family typewriter 
malloc
\family default 
 e 
\family typewriter 
realloc
\family default 
 que interagem com o coletor de lixo, forçando a execução do coletor durante
 alocações grandes
\begin_inset Foot
collapsed true

\layout Standard

O limite para definir 
\begin_inset Quotes eld
\end_inset 

grande
\begin_inset Quotes erd
\end_inset 

 se ajusta de acordo com o funcionamento do coletor e com as alocações realizada
s anteriormente.
\end_inset 

 ou em situações de pouca memória disponível.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Assim como Python e Ruby, a API de Java retorna referências a objetos da
 máquina virtual que podem ser armazenados em variáveis C.
 A JNI define três tipos de referências, 
\emph on 
locais
\emph default 
, 
\emph on 
globais
\emph default 
 e 
\emph on 
globais fracas
\emph default 
, para auxiliar no controle do tempo de vida destas e a sua interação com
 o coletor de lixo.
\layout Standard

Referências locais são retornadas pela maioria das funções da JNI e são
 válidas até o retorno da função C que a obteve.
 Não é necessário desalocar explicitamente uma referência local: durante
 a execução de uma função C, a JVM mantém uma lista de referências locais
 passadas à função e libera todas elas quando o controle retorna à máquina
 virtual.
 Isto faz com que, de maneira geral, o programador não precise se preocupar
 com o coletor de lixo enquanto manipula valores retornados durante uma
 função.
 Por outro lado, em código que pode utilizar uma grande quantidade de referência
s locais é mais eficiente desalocar referências locais explicitamente, usando
 
\family typewriter 
DeleteLocalRef
\family default 
.
 A partir da versão 1.2 de Java, funções foram adicionadas para permitir
 a gerência de referências locais em blocos.
 
\family typewriter 
PushLocalFrame
\family default 
 e 
\family typewriter 
PopLocalFrame
\family default 
 permitem criar escopos aninhados de referências locais, que são desalocados
 de uma só vez.
 
\family typewriter 
PushLocalFrame
\family default 
 recebe ainda um parâmetro indicando um número de 
\emph on 
slots
\emph default 
 a serem pré-alocados, como otimização.
 Esse valor pode ser configurado também com 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Referências globais são geradas a partir de referências locais usando 
\family typewriter 
NewGlobalRef
\family default 
.
 Referências deste tipo mantêm-se válidas até serem explicitamente desalocadas
 com 
\family typewriter 
Delete\SpecialChar \-
GlobalRef
\family default 
.
 Uma referência global impede o objeto de ser coletado, podendo assim, ser
 utilizada para armazenar objetos Java no espaço de C além da duração de
 uma função, por exemplo, em variáveis globais ou estáticas.
\layout Standard

A Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 mostra um exemplo do tipo de gerência de referências necessário quando
 se tem um laço criando referências temporárias sobre um número arbitrário
 de objetos.
 No exemplo, a função 
\family typewriter 
Java_Exemplo_concatArray
\family default 
 (equivalente, portanto, ao método 
\family typewriter 
concatArray
\family default 
 de uma classe 
\family typewriter 
Exemplo
\family default 
) converte os elementos de um array para strings usando 
\family typewriter 
Object.toString
\family default 
 e os concatena usando 
\family typewriter 
String.concat
\family default 
.
 Note que, como o número de vezes que o laço executa depende do tamanho
 do array passado, deve-se evitar que o número de referências cresça em
 cada iteração.
 Para isso, as opções seriam ou usar 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, ou destruir as referências uma a uma com 
\family typewriter 
DeleteLocalRef
\family default 
.
 Se usássemos 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 no exemplo, teríamos que manter a string concatenada até o momento em uma
 referência global.
 Além disso, esta referência teria que ser destruída e recriada a cada iteração,
 já que strings são imutáveis em Java.
 Como o número de locais é pequeno, é mais conveniente neste caso controlá-las
 explicitamente com 
\family typewriter 
DeleteLocalRef
\family default 
 do que recorrer a referências globais.
 
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 permite, através de um parâmetro adicional, transferir uma referência local
 do conjunto que está sendo desempilhado para o escopo exterior de referências
 locais, criando assim uma nova referência.
 Para o exemplo da Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, isto ainda não evitaria a necessidade de liberar referências locais explicitam
ente a cada iteração do laço, já que cada 
\family typewriter 
PopLocalFrame
\family default 
 criaria uma referência local nova.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

 
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_concatArray(JNIEnv *J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\layout LyX-Code


\size footnotesize 
\emph on 
      /* os = o.toString */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\layout LyX-Code


\size footnotesize 
\emph on 
      /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Rotina para concatenar os elementos de um array representados como strings.
\end_inset 


\layout Standard

Uma técnica comum consiste em fazer o 
\emph on 
caching
\emph default 
 de classes Java em referências globais associadas a variáveis estáticas
 dentro de funções C, como também pode ser visto na Figura 
\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

.
\layout Standard

A partir da versão 1.2, a JNI inclui referências globais fracas, com o objetivo
 de oferecer uma forma simplificada das referências fracas de Java (
\family typewriter 
java.lang.ref
\family default 
) -- um objeto que esteja sendo apontado apenas por referências globais
 fracas pode ser coletado.
 Originalmente, a API incluiu a função 
\family typewriter 
IsSameObject
\family default 
 como forma de verificar a validade de uma referência fraca, mas evidentemente
 este método é insuficiente: como Java é 
\emph on 
multi-threaded
\emph default 
, o coletor de lixo pode invalidar a referência entre o teste e a instrução
 seguinte no código C.
 A documentação revisada avisa sobre esta limitação e recomenda a aquisição
 de referências globais, além de comportamentos indefinidos nas relações
 entre referências globais fracas em C e os tipos de referências fracas
 definidos em Java.
\layout Standard

Além desta, outras questões surgem a partir da combinação do modelo 
\emph on 
multi-threaded
\emph default 
 de Java com a exposição de referências a objetos da máquina virtual ao
 código C.
 Para reduzir a quantidade de cópia de dados entre Java e C, a JNI oferece
 algumas funções que retornam ponteiros para a representação interna de
 strings e arrays de tipos pri\SpecialChar \-
mi\SpecialChar \-
ti\SpecialChar \-
vos: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 e 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 O uso destas funções, porém, possui importantes restrições.
 A API especifica que, uma vez obtido um ponteiro através destas funções,
 o código C não deve chamar outras funções da JNI ou realizar chamadas de
 sistema que possam bloquear a thread atual e fazer com que ela espere por
 outra thread Java.
 Recomenda-se não manter blocos de memória bloqueados usando estas funções
 por muito tempo já que uma das técnicas possíveis para a implementação
 desta 
\begin_inset Quotes eld
\end_inset 

região crítica
\begin_inset Quotes erd
\end_inset 

 consiste em desabilitar o coletor de lixo da JVM.
 É importante notar ainda que referências locais e o ponteiro para o ambiente
 JNI passado para funções nativas são válidos apenas na thread onde foram
 criados; referências globais podem ser compartilhadas entre threads.
\layout Standard

Além do mecanismo de referências fracas fornecido pelas classes do pacote
 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
, a única forma oferecida por Java para interagir de maneira mais direta
 com o coletor de lixo é através da chamada 
\family typewriter 
System.gc()
\family default 
, que solicita à máquina virtual que dispare tão logo quanto possível a
 thread de coleta para que esta desaloque objetos não alcançáveis.
 Não há uma função C equivalente na JNI, mas este método pode ser invocado
 a partir de C com 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\layout Standard

Por não retornar referências explícitas a objetos Lua ao código C, a interação
 do código nativo com o coletor de lixo é bastante simplificada.
 Operações sobre objetos Lua são sempre especificadas através de índices
 da pilha virtual.
 Assim, a máquina virtual mantém o controle sobre quais os objetos são acessívei
s a partir de C em qualquer dado momento.
 
\layout Standard

Embora ponteiros para objetos não sejam manipulados na API, algumas funções
 retornam ponteiros para estruturas gerenciadas por Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_\SpecialChar \-
push
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
, 
\family typewriter 
lua_touserdata
\family default 
 e 
\family typewriter 
lua_topointer
\family default 
.
 Esta última função permite obter ponteiros para alguns tipos de objetos
 (
\emph on 
userdata
\emph default 
, tabelas, 
\emph on 
threads
\emph default 
 e funções), mas somente com o objetivo de obter informação para depuração,
 já que não é possível converter o ponteiro de volta para um valor Lua.
 A validade dos ponteiros retornados por estas funções é dependente do tempo
 de vida do objeto correspondente a eles; para strings em particular, o
 ponteiro retornado só é garantidamente válido enquanto o dado estiver na
 pilha.
\layout Standard

O conteúdo da pilha virtual é zerado quando a função C retorna o controle
 à máquina virtual de Lua.
 Dessa forma, não é possível reter ponteiros retornados por valores Lua
 para uso posterior em variáveis globais ou estruturas de C.
 Para acessar novamente um dado de Lua posteriormente, é necessário armazená-lo
 em uma variável no espaço de Lua e trazê-lo de volta à pilha através de
 chamadas da API.
\layout Standard

Uma forma conveniente de armazenar referências a dados do espaço de Lua
 em estruturas de dados em C consiste em armazenar os dados em uma tabela
 Lua e os índices desta tabela na estrutura C.
 A biblioteca auxiliar de Lua encapsula tal idioma através de duas funções,
 
\family typewriter 
luaL_ref
\family default 
 e 
\family typewriter 
luaL_unref
\family default 
.
 A função 
\family typewriter 
luaL_ref
\family default 
 associa o valor Lua passado a um a chave numérica inteira em uma tabela
 especial, o 
\emph on 
registro
\emph default 
, e retorna este número.
 Como o tabela que implementa o registro não é coletada ao longo da execução,
 a inclusão do objeto nesta tabela o impede de ser coletado.
 A chave numérica pode então ser vista como um 
\emph on 
handle
\emph default 
 de alto nível para o objeto: o código C pode armazená-la em variáveis ou
 estruturas e utilizá-la para referenciar-se ao objeto através do campo
 no registro.
 A função 
\family typewriter 
luaL_unref
\family default 
 remove o valor Lua do registro e libera o índice para reuso.
 Para o bom funcionamento deste mecanismo, chaves inteiras não devem ser
 utilizadas diretamente pelo programador para armazenar dados no registro.
\layout Standard

A API permite associar a objetos do tipo 
\emph on 
full userdata
\emph default 
 uma função de desalocação, 
\family typewriter 
__gc
\family default 
, na sua metatabela.
 Quando presente, esta função será tipicamente implementada em C, realizando
 a finalização de recursos.
 Por exemplo, o metamétodo 
\family typewriter 
__gc
\family default 
 de objetos retornados pela função Lua 
\family typewriter 
io.open
\family default 
 é uma função C que fecha o descritor de arquivo correspondente com a função
 C 
\family typewriter 
fclose
\family default 
.
 
\layout Standard

A princípio, o fato de que é possível obter e modificar a metatabela de
 um userdata pode parecer problemático, já que pode-se substituir o seu
 finalizador em 
\family typewriter 
__gc
\family default 
.
 Entretanto, funções de coleta implementadas em C tipicamente validam o
 userdata recebido verificando o seu 
\begin_inset Quotes eld
\end_inset 

tipo
\begin_inset Quotes erd
\end_inset 

, identificado através da metatabela.
 Duas funções da biblioteca auxiliar que implementam este mecanismo: 
\family typewriter 
luaL_newmetatable
\family default 
 cria uma metatabela e a associa a uma entrada no registro; 
\family typewriter 
luaL_checkudata
\family default 
 compara a metatabela de um userdata com uma entrada do registro especificada.
 Assim, mesmo que código Lua manipule a metatabela, uma função de coleta
 implementada em C que use 
\family typewriter 
luaL_checkudata
\family default 
 não será levada a operar sobre um 
\emph on 
userdata
\emph default 
 de tipo incorreto.
 Para impedir o código Lua de alterar a função de coleta de um objeto 
\emph on 
userdata
\emph default 
, pode-se atribuir um valor qualquer, como 
\family typewriter 
false
\family default 
, ao campo 
\family typewriter 
__metatable
\family default 
 da metatabela, que, quando presente, é retornado por 
\family typewriter 
getmetatable
\family default 
.
\layout Standard

Outro recurso relacionado à gerência de memória oferecido por Lua é a possibilid
ade de configurar, em tempo de execução, a função de alocação de memória
 a ser usada pela máquina virtual.
 Na criação de um novo estado com 
\family typewriter 
lua_newstate
\family default 
, passa-se como parâmetro uma função de alocação que deve oferecer funcionalidad
e similar às funções C 
\family typewriter 
free
\family default 
 e 
\family typewriter 
realloc
\family default 
, dependendo se o tamanho de bloco passado for igual ou maior do que zero.
 A função auxiliar 
\family typewriter 
luaL_newstate
\family default 
 cria um estado usando um alocador padrão baseado em 
\family typewriter 
realloc
\family default 
 e 
\family typewriter 
free
\family default 
.
\layout Standard

Lua oferece uma interface com o coletor de lixo através das funções 
\family typewriter 
lua_gc
\family default 
 em C e 
\family typewriter 
collectgarbage
\family default 
 em Lua.
 O coletor de Lua implementa 
\emph on 
mark-and-sweep
\emph default 
 incremental e permite ao programador configurar parâmetros relacionados
 aos intervalos de coleta, bem como ativar, desativar e disparar ciclos
 completos ou passos do coletor.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Como Python, Perl realiza coleta de lixo baseada em contagem de referências.
 A API provê funções para o controle explícito da contagem: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 para incremento e decremento e um 
\emph on 
getter
\emph default 
, 
\family typewriter 
SvREFCNT
\family default 
.
 Outra forma de alterar a contagem de referências de um valor é atribuindo-o
 a uma referência Perl com 
\family typewriter 
newRV_inc
\family default 
.
 A contagem do valor referenciado será incrementada, fazendo com que --
 salvo tenha sua contagem alterada explicitamente -- este se mantenha válido
 enquanto for referenciado pelo 
\family typewriter 
RV
\family default 
.
 É importante notar, porém, que as funções da API que criam valores, como
 
\family typewriter 
newSViv
\family default 
, inicializam os seus contadores de referências com 1.
 Isto tem o efeito de que se um valor criado é em uma função C, armazenado
 em um 
\family typewriter 
RV
\family default 
 com 
\family typewriter 
newRV_inc
\family default 
 e esta referência é retornada a Perl, o valor nunca será coletado, pois
 o seu contador não retornará a 0 quando a referência for destruída.
 A forma correta, então, é usar 
\family typewriter 
newRV_noinc
\family default 
 para 
\family typewriter 
RV
\family default 
s contendo valores recém-criados e 
\family typewriter 
newRV_inc
\family default 
 quando um 
\family typewriter 
RV
\family default 
 deve manter válido um valor já existente.
\layout Standard

A inicialização da contagem de referências em 1 garante que valores criados
 continuarão válidos durante a execução de uma função C sem que seja necessário
 armazenar o valor no espaço de Perl.
 Estes valores podem também ser armazenados em variáveis globais e estruturas
 de dados de C e se manterão válidos até que a sua contagem de referências
 seja decrementada.
 Para valores cujo tempo de vida é restrito a uma função, a API de Perl
 define o conceito de valores 
\begin_inset Quotes eld
\end_inset 

mortais
\begin_inset Quotes erd
\end_inset 

 como uma forma de permitir desalocar todos os valores temporários de uma
 função de uma só vez.
 Um 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 pode ser criado com 
\family typewriter 
sv_newmortal
\family default 
 ou mais comumente convertido para mortal com 
\family typewriter 
sv_2mortal
\family default 
.
 Na prática, marcar um valor como mortal corresponde a indicar que ele deve
 ter a sua contagem de referências decrementada na chamada da macro 
\family typewriter 
FREETMPS
\family default 
 ao término da função, conforme será visto na Seção 
\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Algumas funções da API retornam valores mortais: por exemplo, 
\family typewriter 
hv_delete
\family default 
 remove um elemento de uma hash e, caso a flag 
\family typewriter 
G_DISCARD
\family default 
 não seja passada, retorna o elemento removido como um 
\family typewriter 
SV
\family default 
 mortal.
\layout Standard

A API de Perl não possui facilidades de interface com o coletor de lixo,
 mas possui algumas funções para auxílio em depuração que reportam informações
 sobre o status da coleta de lixo.
 A função 
\family typewriter 
sv_report_used
\family default 
 exibe o conteúdo de todos os 
\family typewriter 
SV
\family default 
s da máquina virtual.
 O módulo 
\family typewriter 
Devel::Peek
\family default 
 permite examinar a partir de Perl o conteúdo de valores (contagem de referência
s, 
\emph on 
flags
\emph default 
, etc.) -- a partir de C, estas informações estão disponíveis diretamente
 já que as estruturas não são opacas.
\layout Section

Chamada de funções a partir de C
\layout Standard

A FLI deve prover uma forma de invocar a partir de C funções a serem executadas
 na máquina virtual.
 Isto envolve a passagem de dados entre estes dois 
\begin_inset Quotes eld
\end_inset 

espaços
\begin_inset Quotes erd
\end_inset 

, conforme visto na Seção 
\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 e as implicações que isto traz sobre o tempo de vida dos objetos, abordadas
 na Seção 
\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Devido à tipagem estática de C, não é possível usar uma sintaxe transparente
 para chamada de funções registradas em tempo de execução.
 É necessário então que a API defina funções para realizar chamadas na máquina
 virtual.
\layout Standard

Nesta seção serão discutidas as facilidades oferecidas por cada API para
 a invocação de funções para execução na máquina virtual.
 As principais questões envolvidas são como referenciar a função a ser chamada,
 como passar argumentos a ela e como obter o valor de retorno, incluindo
 formas de notificação no caso de erros.
 Para fins de ilustração, será apresentado em cada linguagem um exemplo
 de chamada de uma função simples.
 Assume-se que tenha sido definida no espaço de cada máquina virtual uma
 função 
\family typewriter 
teste
\family default 
, passando um inteiro e uma string como parâmetros e obtendo um inteiro
 como resultado.
 Para maior brevidade, a verificação de erros será omitida.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard

Para chamar uma função Python a partir de C, deve-se inicialmente obter
 um ponteiro para o 
\family typewriter 
PyObject
\family default 
 correspondente à função, como visto na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Além de funções implementadas em Python e funções C registradas a partir
 da API, qualquer tipo de dado que implemente o método 
\family typewriter 
__call__
\family default 
 (ou declare uma função no campo 
\family typewriter 
tp_call
\family default 
 de sua estrutura 
\family typewriter 
PyTypeObject
\family default 
) pode ser chamado como uma função, e retornará sucesso em 
\family typewriter 
PyCallable_Check
\family default 
.
\layout Standard

A API de Python oferece diversas funções para realização de chamadas a partir
 de C.
 A chamada mais geral, 
\family typewriter 
PyObject_Call
\family default 
, recebe como parâmetros o objeto a ser chamado, uma tupla Python contendo
 os parâmetros a serem passados e opcionalmente um dicionário de argumentos
 
\emph on 
keyword
\emph default 
.
 Como conveniência, outras funções permitem passar os argumentos de outras
 formas.
 Por exemplo, 
\family typewriter 
PyObject_CallFunction
\family default 
 encapsula a chamada a 
\family typewriter 
Py_BuildValue
\family default 
 (vista na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), aceitando diretamente a string de formato desta e os valores a serem
 convertidos diretamente.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 é uma função 
\emph on 
vararg
\emph default 
 que aceita uma seqüência de ponteiros para 
\family typewriter 
PyObject
\family default 
s.
\layout Standard

O valor de retorno em todas as funções de chamada é um ponteiro para 
\family typewriter 
PyObject
\family default 
.
 Assim como ocorre em código Python, quando funções Python retornam múltiplos
 valores, estes são encapsulados em uma tupla.
 Para funções que não retornam valor, as funções de chamada retornam 
\family typewriter 
Py_None
\family default 
.
 Em caso de erro na chamada, as funções retornam 
\family typewriter 
NULL
\family default 
 e a exceção pode ser verificada com 
\family typewriter 
PyErr_Occurred
\family default 
.
\layout Standard

Uma forma típica para chamar uma função Python 
\family typewriter 
teste
\family default 
, incluindo a obtenção da função e a conversão dos valores de entrada e
 saída entre Python e C, é exibida a seguir:
\layout LyX-Code


\size footnotesize 
PyObject *globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject *teste = PyDict_GetItemString(globals, "teste");
\layout LyX-Code


\size footnotesize 
PyObject *obj_result = PyObject_CallFunction(teste, "si", "entrada", 2);
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard

Uma função global é obtida através do dicionário do módulo 
\family typewriter 
__main__
\family default 
.
 A conversão dos dados de entrada de C para Python é feita através da string
 de formato recebida por 
\family typewriter 
PyObject_CallFunction
\family default 
.
 O valor de retorno é retornado como uma nova referência a um objeto Python
 e, desta forma, precisa ter a contagem de referências decrementada após
 o seu uso.
 As funções 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 e 
\family typewriter 
PyDict_GetItemString
\family default 
 retornam referências emprestadas, portanto a contagem de referências dos
 PyObjects retornados por elas não precisam ser decrementadas após o seu
 uso.
 Todavia, após a chamada da função Python, não há garantia de que os ponteiros
 globals e teste ainda apontem para objetos válidos -- precisaríamos incrementar
 a sua contagem de referências caso quiséssemos usá-los novamente.
\layout Subsection

Ruby
\layout Standard

Para a chamada de métodos Ruby em C, a API oferece a função 
\family typewriter 
rb_funcall
\family default 
 e algumas variantes.
 Em comum, todas recebem como parâmetro o 
\family typewriter 
VALUE
\family default 
 referente ao objeto sobre o qual o método se refere, um 
\family typewriter 
ID
\family default 
 referente à string internalizada contendo o nome do método e um inteiro
 indicando o número de argumentos.
 Por exemplo, a função 
\family typewriter 
rb_funcall
\family default 
 recebe os argumentos na forma de 
\family typewriter 
VALUE
\family default 
s passados como varargs C; 
\family typewriter 
rb_funcall2
\family default 
 recebe um array C de 
\family typewriter 
VALUE
\family default 
s; 
\family typewriter 
rb_apply
\family default 
 recebe um 
\family typewriter 
VALUE
\family default 
 que deve ser um array Ruby contendo os parâmetros.
 Todas elas retornam um 
\family typewriter 
VALUE
\family default 
 como parâmetro.
 Múltiplos valores de retorno são representados como um array Ruby.
\layout Standard

Todas as rotinas de chamada de função na API se referem a métodos, precisando
 assim especificar um objeto sobre o qual o método deve ser aplicado.
 Funções globais em Ruby são definidas como métodos do módulo 
\family typewriter 
Kernel
\family default 
, que é incluído pela classe 
\family typewriter 
Object
\family default 
 e são, assim, acessíveis a partir de qualquer objeto, incluindo 
\family typewriter 
nil
\family default 
.
 Desta forma, pode-se invocar funções globais passando a constante C 
\family typewriter 
Qnil
\family default 
 como o objeto alvo do método.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
def a_ruby_function()
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function will yield.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("a_ruby_function is done.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard
\align center 

\size footnotesize 
(a) Uma função Ruby que espera um bloco de código
\layout LyX-Code


\size footnotesize 
VALUE a_C_block() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "a_C_block is running.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard
\align center 

\size footnotesize 
(b) Uma função C que atuará como bloco de código
\layout LyX-Code


\size footnotesize 
a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Não funciona! Um Proc não é um bloco de código.
 */
\layout LyX-Code


\size footnotesize 
result = rb_funcall(Qnil, a_ruby_function_ID, 1, a_proc);
\layout Standard
\align center 

\size footnotesize 
(c) Uma chamada de função com bloco inválida a partir de C
\layout LyX-Code


\size footnotesize 
rb_define_global_function("a_C_block", a_C_block, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function { a_C_block }");
\layout LyX-Code


\size footnotesize 
result = rb_gv_get("$result");
\layout Standard
\align center 

\size footnotesize 
(d) Passando código C em um bloco declarado via 
\family typewriter 
rb_eval_string
\layout LyX-Code


\size footnotesize 
a_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$a_proc", a_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$result = a_ruby_function(&$a_proc)"); 
\newline 
result = rb_gv_get("$result");
\layout Standard
\align center 

\size footnotesize 
(e) Passando código C encapsulado como 
\family typewriter 
Proc
\family default 
 como um bloco via 
\family typewriter 
rb_eval_string
\layout LyX-Code


\size footnotesize 
VALUE call_a_ruby_function() {
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, a_ruby_function_ID, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
result = rb_iterate(call_a_ruby_function, Qnil, a_C_block, Qnil);
\layout Standard
\align center 

\size footnotesize 
(f) Passando um bloco de código via 
\family typewriter 
rb_iterate
\layout Caption


\begin_inset LatexCommand \label{cap:Blocos-Ruby}

\end_inset 

Invocação de métodos Ruby passando blocos de código a partir de C
\end_inset 


\layout Standard

O status especial dos blocos de código complica a sua manipulação a partir
 de código C, e em particular a invocação de métodos que os esperam como
 parâmetro.
 A Figura 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

 exemplifica isto ao apresentar formas de invocar um método Ruby (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(a)) passando como bloco de código uma função C (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(b)).
 Como a equivalência de blocos com objetos 
\family typewriter 
Proc
\family default 
 proporcionada pelo operador 
\family typewriter 
&
\family default 
 não é oferecida na API C, as funções para chamada de métodos como 
\family typewriter 
rb_funcall
\family default 
 não são capazes de realizar tal conversão e passar 
\family typewriter 
Proc
\family default 
s para funções que aceitam blocos (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(c)).
\layout Standard

As únicas formas de invocar um método Ruby passando um bloco de código são
 através de 
\family typewriter 
rb_eval_string
\family default 
 e 
\family typewriter 
rb_iterate
\family default 
.
 A primeira abordagem, além do custo de desempenho causado pelo 
\emph on 
parsing
\emph default 
 da string de código, tem a inconveniência de exigir o uso de variáveis
 temporárias para que se possa obter os valores de retorno de volta ao espaço
 de C.
 No modelo usando 
\family typewriter 
rb_eval_string
\family default 
, a função C que atuará como bloco deve ser declarada no espaço de Ruby.
 Há duas alternativas de como fazer isto: registrando o método em Ruby e
 invocando-o em um bloco 
\emph on 
wrapper
\emph default 
 declarado no texto da string Ruby (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(d)), ou encapsulando a função em um objeto 
\family typewriter 
Proc
\family default 
 a partir de C com 
\family typewriter 
rb_proc_new
\family default 
 e então usando a notação 
\family typewriter 
&
\family default 
 na string de código Ruby avaliada (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(e)).
\layout Standard

A segunda abordagem explora o fato de que a única função da API de C capaz
 de produzir blocos de código diretamente é 
\family typewriter 
rb_iterate
\family default 
.
 Esta função recebe dois ponteiros de função, um para a função a ser invocada
 e outro para a função que atuará como o bloco de código; chamadas a 
\family typewriter 
yield
\family default 
 dentro da primeira função invocarão a segunda.
 O bloco pode quebrar o fluxo de execução com 
\family typewriter 
rb_iter_break
\family default 
.
 Passando como 
\begin_inset Quotes eld
\end_inset 

função de iteração
\begin_inset Quotes erd
\end_inset 

 para 
\family typewriter 
rb_iterate
\family default 
 uma função 
\emph on 
wrapper
\emph default 
 que simplesmente chama o método Ruby desejado com 
\family typewriter 
rb_funcall
\family default 
, é possível simular uma chamada a 
\family typewriter 
rb_funcall
\family default 
 que recebe uma função C como bloco de código (Fig.
 
\begin_inset LatexCommand \ref{cap:Blocos-Ruby}

\end_inset 

(f)).
 Note que nenhum argumento é passado em 
\family typewriter 
rb_funcall
\family default 
 -- a função 
\family typewriter 
rb_iterate
\family default 
 define 
\family typewriter 
a_C_block
\family default 
 como sendo o 
\begin_inset Quotes eld
\end_inset 

bloco de código atual
\begin_inset Quotes erd
\end_inset 

 e esta definição é herdada implicitamente por 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

Para o caso comum de realizar iterações sobre o método 
\family typewriter 
each
\family default 
 de coleções, Ruby oferece uma função 
\emph on 
wrapper
\emph default 
 
\family typewriter 
rb_each
\family default 
.
 Esta função foi projetada para ser passada como primeiro argumento de 
\family typewriter 
rb_iterate
\family default 
.
 Funções C executando como bloco de código podem quebrar o fluxo de execução
 com 
\family typewriter 
rb_iter_break
\family default 
.
 O mecanismo de 
\emph on 
yield
\emph default 
, tanto para código C quanto para chamadas nativas em Ruby, é implementado
 usando as funções C 
\family typewriter 
setjmp
\family default 
 e 
\family typewriter 
longjmp
\family default 
.
\layout Standard

Para o correto tratamento de erros, funções C que realizam chamadas a funções
 Ruby devem ser encapsuladas em uma chamada 
\family typewriter 
rb_protect
\family default 
 ou em uma de suas variantes, 
\family typewriter 
rb_ensure
\family default 
 e 
\family typewriter 
rb_rescue
\family default 
.
 Esta função captura exceções disparadas por código Ruby (ou código C usando
 
\family typewriter 
rb_raise
\family default 
).
 Caso o programa não use 
\family typewriter 
rb_protect
\family default 
, exceções em Ruby resultarão em erros fatais.
\layout Standard

A seguir, é apresentada a forma típica para chamar uma função global Ruby
 
\family typewriter 
teste
\family default 
, novamente incluindo a conversão dos valores de entrada e saída entre C
 e a máquina virtual.
\layout LyX-Code


\size footnotesize 
ID teste = rb_intern("teste");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, teste, 2, rb_str_new2("entrada"), INT2NUM(2)
);
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard

Diferentemente de Python, não é necessário obter uma referência para a função,
 bastando passar o nome desta na forma de 
\family typewriter 
ID
\family default 
 e o objeto a que ela se refere (no caso, 
\family typewriter 
Qnil
\family default 
, indicando uma função global).
 A conversão dos dados de entrada de C para Ruby é feita através da função
 rb_str_new2 e da macro INT2NUM, que criam VALUEs.
 Conforme discutido na Seção 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, o controle da validade de 
\family typewriter 
VALUE
\family default 
s é feito implicitamente.
 Assim, pode-se fazer a chamada de funções que criam 
\family typewriter 
VALUE
\family default 
s diretamente na passagem de parâmetros de 
\family typewriter 
rb_funcall
\family default 
.
 De fato, as três linhas acima poderiam ter sido condensadas, passando a
 chamada 
\family typewriter 
rb_funcall
\family default 
 como parâmetro para 
\family typewriter 
NUM2LONG
\family default 
 e a chamada 
\family typewriter 
rb_intern
\family default 
 como segundo parâmetro de 
\family typewriter 
rb_funcall
\family default 
, tendo sido separadas apenas para maior legibilidade.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard

De forma similar ao acesso a atributos, na chamada de métodos deve-se inicialmen
te obter um identificador para o método, do tipo 
\family typewriter 
jmethodID
\family default 
.
 Estes identificadores são tipicamente obtidos com a função 
\family typewriter 
GetMethodID
\family default 
, que recebe como parâmetros a classe (instância de 
\family typewriter 
jclass
\family default 
) e duas strings, uma com o nome do método e outra com a assinatura do método.
 A sintaxe que descreve assinaturas de método é similar à de descritores
 de campos discutida na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Parâmetros são listados entre parênteses, seguidos do tipo de retorno.
 Por exemplo, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 indica uma função com parâmetros 
\family typewriter 
String[], int, int
\family default 
 e retorno 
\family typewriter 
void
\family default 
.
 Alternativamente, a partir de Java 1.2 é possível obter um 
\family typewriter 
jmethodID
\family default 
 correspondente a um objeto Java do tipo 
\family typewriter 
Method
\family default 
 -- isto é, um método reificado através da API de reflexão de Java -- usando
 a função 
\family typewriter 
FromReflectedMethod
\family default 
.
\layout Standard

Uma vez obtido o 
\family typewriter 
jmethodID
\family default 
, um método pode ser invocado através de alguma das 90 funções da família
 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
*.
 Os nomes das funções seguem a forma
\layout LyX-Code

Call
\family roman 
\emph on 
<tipo><retorno>
\family default 
\emph default 
Method
\family roman 
\emph on 
<argumentos>
\layout Standard

O 
\emph on 
<tipo>
\emph default 
 pode ser 
\family typewriter 
Static
\family default 
 para funções estáticas, recebendo na chamada uma 
\family typewriter 
jclass
\family default 
 como parâmetro; 
\family typewriter 
Nonvirtual
\family default 
 para invocar implementações de um método em uma classe específica sobre
 um determinado objeto, passando uma 
\family typewriter 
jclass
\family default 
 e um 
\family typewriter 
jobject
\family default 
 como parâmetros; ou omitido para métodos de instância, passando o 
\family typewriter 
jobject
\family default 
 sobre o qual o método será aplicado.
 O tipo de retorno é indicado em 
\emph on 
<retorno>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
 Em funções que retornam valores não-primitivos, como 
\family typewriter 
jarray
\family default 
 ou 
\family typewriter 
jobject
\family default 
, o tipo de referência retornada é local.
\layout Standard

Os argumentos do método podem ser passados de três formas: como 
\emph on 
varargs
\emph default 
; como um array de 
\family typewriter 
jvalue
\family default 
s; ou propagando uma 
\family typewriter 
va_list
\family default 
 recebida.
 Por exemplo, na forma mais simples, um método de instância sem retorno
 e sem parâmetros é invocado com 
\family typewriter 
CallVoidMethod
\family default 
.
 Já 
\family typewriter 
CallStaticIntMethodA
\family default 
 chama um método estático que retorna um 
\family typewriter 
jint
\family default 
 com a lista de parâmetros passada em um array de 
\family typewriter 
jvalue
\family default 
s.
\layout Standard

É importante notar que, ao obter identificadores de métodos e campos fazendo
 a resolução a partir do 
\family typewriter 
jobject
\family default 
 recebido na variável 
\family typewriter 
this
\family default 
 e do nome do método ou campo, com 
\family typewriter 
GetObjectClass
\family default 
 e 
\family typewriter 
GetFieldID
\family default 
, estamos efetivamente resolvendo nomes através de escopo dinâmico.
 Isto implica que, por exemplo, caso um método 
\family typewriter 
Pai.metodo
\family default 
 implementado em C acesse um atributo privado 
\family typewriter 
umAtributo
\family default 
 e uma subclasse 
\family typewriter 
Filho
\family default 
 também defina um atributo privado 
\family typewriter 
umAtributo
\family default 
, a chamada a esse método em uma instância 
\family typewriter 
f
\family default 
 de 
\family typewriter 
Filho
\family default 
 acabaria por acessar 
\family typewriter 
Filho.umAtributo
\family default 
 e não 
\family typewriter 
Pai.umAtributo
\family default 
.
 Este comportamento é diferente do que ocorreria se 
\family typewriter 
Pai.metodo
\family default 
 fosse implementado em Java, onde o 
\emph on 
binding
\emph default 
 de membros privados é definido lexicamente.
 Para garantir à implementação em C de 
\family typewriter 
Pai.metodo
\family default 
 que o atributo 
\family typewriter 
umAtributo
\family default 
 acessado é realmente 
\family typewriter 
Pai.umAtributo
\family default 
, deve-se armazenar no espaço de C o identificador do campo obtido a partir
 da 
\family typewriter 
jclass
\family default 
 de 
\family typewriter 
Pai
\family default 
 -- obtida, por exemplo, em uma função 
\family typewriter 
static native
\family default 
.
 
\layout Standard

O código C pode verificar a ocorrência de exceções através de 
\family typewriter 
ExceptionCheck
\family default 
 e optar por tratá-la, obtendo uma referência local da exceção com 
\family typewriter 
ExceptionOccurred
\family default 
 e posteriormente zerando-a com 
\family typewriter 
ExceptionClear
\family default 
, ou então mantê-la ativa de modo que seja propagada ao código Java.
\layout Standard

Para realizar o exemplo da função 
\family typewriter 
teste
\family default 
, já que Java não possui funções globais, vamos assumir que teste é um método
 estático de uma classe chamada 
\family typewriter 
Exemplo
\family default 
 e que estamos rodando o código C a seguir em um contexto onde possuímos
 uma referência a um ambiente de execução Java chamado 
\family typewriter 
J
\family default 
 (este ponteiro, do tipo 
\family typewriter 
JNIEnv
\family default 
, será discutido na Seção 
\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass exemplo = (*J)->FindClass(J, "Exemplo");
\layout LyX-Code


\size footnotesize 
jmethodID teste = (*J)->GetStaticMethodID(J, exemplo,
\layout LyX-Code


\size footnotesize 
                        "teste", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring entrada = (*J)->NewStringUTF(J, "entrada");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, exemplo, teste, entrada, (jint)2);
\layout Standard

Inicialmente, é obtida uma referência à classe 
\family typewriter 
Exemplo
\family default 
, a partir da qual é obtido o identificador do método desejado, baseado
 no seu nome e assinatura.
 Como em Ruby, a string passada como parâmetro deve ser convertida para
 um tipo da máquina virtual.
 Já para o segundo argumento e para o valor de retorno, exploramos o fato
 de que o tipo 
\family typewriter 
jint
\family default 
, correspondente ao tipo Java 
\family typewriter 
int
\family default 
 (inteiro de 32 bits), é compatível com o tipo 
\family typewriter 
long
\family default 
 de C (inteiro de pelo menos 32 bits).
 Todas estas funções da API retornam referências locais, que serão liberadas
 automaticamente ao final da função C onde as chamadas à API foram feitas.
\layout Subsection

Lua
\layout Standard

Tanto em funções C disparadas por Lua como em chamadas de funções Lua realizadas
 a partir de código C, os parâmetros de entrada e os valores de retorno
 são passados através da pilha virtual apresentada na Seção 
\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard

Para chamar uma função Lua a partir de C, devemos inicalmente empilhar o
 objeto Lua referente a ela: para funções globais, obtendo-a com 
\family typewriter 
lua_getglobal
\family default 
, para funções armazenadas em tabelas, com 
\family typewriter 
lua_gettable
\family default 
.
 A seguir, empilhamos os seus parâmetros e então invocamos 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, indicando quantos valores da pilha devem ser passados como parâmetro.
 A diferença entre as duas funções está no tratamento de erros: 
\family typewriter 
lua_call
\family default 
 propaga os erros sinalizados, usando 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 os captura os erros, retornando um código de 
\emph on 
status
\emph default 
 e a mensagem de erro na pilha.
\layout Standard

No caso de execução sem erros, a pilha conterá os valores de retorno da
 função chamada.
 O número de valores de retorno pode ser explicitamente requisitado na chamada
 de 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, ou ser definido em tempo de execução, requisitando o valor especial 
\family typewriter 
LUA_MULTRET
\family default 
.
 Se um número de valores de retorno for solicitado e este não for passado
 pela função chamada, o número de valores será ajustado adicionando elementos
 
\family typewriter 
nil
\family default 
 ou descartando valores em excesso.
 Para chamadas com 
\family typewriter 
LUA_MULTRET
\family default 
, todos os valores são empilhados.
 Nesse caso, a única forma de descobrir quantos valores foram retornado
 é comparando o tamanho da pilha antes e depois da chamada.
\layout Standard

A função 
\family typewriter 
lua_cpcall
\family default 
 permite chamar funções C realizando captura de erros de forma similar a
 
\family typewriter 
lua_pcall
\family default 
 sem precisar registrá-las como valores Lua.
 Esta funcionalidade é similar à oferecida por 
\family typewriter 
rb_protect
\family default 
 em Ruby.
 Ruby, todavia, não oferece função análoga a 
\family typewriter 
lua_pcall
\family default 
, sendo às vezes necessário encapsular a chamada de funções Ruby em funções
 C que obedeçam à assinatura esperada por 
\family typewriter 
rb_protect
\family default 
.
\layout Standard

O exemplo da chamada da função 
\family typewriter 
teste
\family default 
 demonstra a disciplina de pilha adotada na API de Lua.
 De forma similar a Java, iremos assumir a existência de um ponteiro 
\family typewriter 
L
\family default 
 do tipo 
\family typewriter 
lua_State
\family default 
, que será explicado mais adiante na Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "teste");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "entrada");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1);
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1); 
\layout Standard

Com 
\family typewriter 
lua_getglobal
\family default 
, é empilhada a função global 
\family typewriter 
teste
\family default 
.
 Em seguida, os dois argumentos de entrada são empilhados.
 A função é então invocada com 
\family typewriter 
lua_call
\family default 
, indicando dois parâmetros de entrada e um de saída.
 O valor de retorno, no topo da pilha (índice -1) é convertido para C com
 
\family typewriter 
lua_tointeger
\family default 
.
 Esta última função não remove o valor da pilha: para retorná-la ao seu
 estado inicial, precisamos removê-lo explicitamente com 
\family typewriter 
lua_pop
\family default 
.
 Como em nenhum momento a API retorna ponteiros para objetos Lua, não há
 preocupações com coleta de lixo.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard

A chamada de funções Perl a partir de C se dá através de uma disciplina
 de pilha, como em Lua.
 Parâmetros de entrada são especificados através de operações de empilhamento
 e valores de retorno são obtidos na pilha após a chamada da função.
 As funções 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 e 
\family typewriter 
call_method
\family default 
 variam apenas na forma como a função a ser chamada é especificada: através
 de um 
\family typewriter 
SV
\family default 
, de uma string C ou de uma string C descrevendo o nome de um método de
 algum objeto ou classe inserido na pilha.
 A função 
\family typewriter 
call_argv
\family default 
, como conveniência, recebe como um argumento adicional um array C contendo
 strings C representando parâmetros a serem empilhados.
 Todas retornam o número de valores de retorno disponíveis na pilha.
\layout Standard

As funções 
\family typewriter 
call_
\family default 
* possuem um argumento indicando flags a serem passadas que indicam a forma
 que a função deve ser chamada e como tratar os argumentos e valores de
 retorno.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 e 
\family typewriter 
G_ARRAY
\family default 
 especificam um contexto como a função deve ser chamada.
 Em contextos escalares, por exemplo, somente um escalar é retornado na
 pilha; se a função chamada retornar uma lista, somente o último elemento
 desta estará disponível na pilha.
 
\family typewriter 
G_DISCARD
\family default 
 indica que os valores de retorno devem ser automaticamente descartados;
 
\family typewriter 
G_NOARGS
\family default 
 indica que o array padrão de parâmetros 
\family typewriter 
@_
\family default 
 não deve ser construído
\begin_inset Foot
collapsed true

\layout Standard

Isto tem o efeito colateral de que a função chamada herda o valor de 
\family typewriter 
@_
\family default 
 da função chamadora.
\end_inset 

.
 
\family typewriter 
G_EVAL
\family default 
 encapsula a chamada em um bloco 
\family typewriter 
eval
\family default 
, capturando erros.
 A ocorrência de erros pode ser verificada através da macro 
\family typewriter 
ERRSV
\family default 
, que se refere a um escalar contendo a mensagem de erro.
 Acrescentando a flag 
\family typewriter 
G_KEEPERR
\family default 
, o valor da variável de retorno contendo a mensagem de erro não é zerado,
 acumulando seqüências de erros em níveis de chamada diferentes.
\layout Standard

Uma série de macros descrevem um protocolo para a chamada de funções e a
 manipulação de parâmetros de entrada e saída.
 As principais serão explicadas a seguir, na apresentação da versão Perl
 da chamada da função 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("entrada", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("teste", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard

Inicialmente 
\family typewriter 
dSP
\family default 
 declara uma cópia local do ponteiro da pilha de Perl.
 Em seguida, 
\family typewriter 
ENTER
\family default 
 e 
\family typewriter 
SAVETMPS
\family default 
 criam um escopo para valores mortais.
 
\family typewriter 
PUSHMARK
\family default 
 inicia a contagem de parâmetros a serem passados para a função.
 Estes parâmetros são então empilhados com 
\family typewriter 
XPUSHs
\family default 
.
 Os valores criados com 
\family typewriter 
newSVpv
\family default 
 e 
\family typewriter 
newSViv
\family default 
 são convertidos para valores mortais com 
\family typewriter 
sv_2mortal
\family default 
, para que não tenham que ter sua contagem de referências decrementada explicita
mente após a chamada da função.
 
\family typewriter 
PUTBACK
\family default 
 encerra a contagem de parâmetros.
 É feita então a chamada da função global Perl 
\family typewriter 
teste
\family default 
, em contexto escalar, com 
\family typewriter 
call_pv
\family default 
.
\layout Standard

Após o retorno desta função, a memória da pilha de Perl pode ter sido realocada,
 mudando o endereço do ponteiro de pilha obtido inicialmente com 
\family typewriter 
dSP
\family default 
.
 Para certificar-se que o seu valor está correto, deve-se chamar 
\family typewriter 
SPAGAIN
\family default 
 após funções 
\family typewriter 
call_
\family default 
*.
 A função 
\family typewriter 
POPl
\family default 
 desempilha um valor e o converte para 
\family typewriter 
long
\family default 
 (há funções similares para outros tipos, como 
\family typewriter 
POPs
\family default 
 para 
\family typewriter 
SV
\family default 
s e 
\family typewriter 
POPpx
\family default 
 para strings).
 Estas operações desempilham valores atualizando a cópia local do ponteiro
 de pilha.
 Assim, 
\family typewriter 
PUTBACK
\family default 
 deve ser chamado novamente para atualizar o ponteiro global.
 Finalmente, 
\family typewriter 
FREETMPS
\family default 
 e 
\family typewriter 
LEAVE
\family default 
 decrementam a contagem de referências dos valores mortais.
 
\layout Section

Registro de funções C
\layout Standard

Para permitir a invocação de funções C a partir de código executado na máquina
 virtual, a FLI deve fornecer uma forma de registrar estas funções no ambiente
 de execução.
 Em linguagens de tipagem estática como Java, para que seja possível chamar
 funções externas usando uma sintaxe igual à de funções nativas, o conjunto
 de funções externas deve ser declarado 
\emph on 
a priori
\emph default 
 de alguma forma.
 Já em linguagens com tipagem dinâmica, como é o caso de Python, Lua, Ruby
 e Perl, as funções podem ser usadas diretamente, bastando que sejam definidas
 em algum momento da execução antes de sua chamada.
 Assim, pode-se declarar as funções externas em tempo de execução através
 de código C usando a API da máquina virtual.
\layout Standard

Também nesta seção, a apresentação de cada linguagem encerrará com um exemplo.
 Em cada um deles, será apresentada uma função C 
\family typewriter 
teste
\family default 
 declarada com a assinatura de formato esperado pela máquina virtual, que
 obtém os valores de entrada e retorna um valor na saída.
 Será apresentada também, para cada linguagem, a forma de registrar a função
 de modo que ela possa ser invocada diretamente a partir da linguagem ou
 através da API do modo descrito na seção anterior.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard

Como visto na Seção 
\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, instâncias de classes Python podem ser tornadas 
\begin_inset Quotes eld
\end_inset 

chamáveis
\begin_inset Quotes erd
\end_inset 

 implementando 
\family typewriter 
__call__
\family default 
 em Python ou 
\family typewriter 
tp_call
\family default 
 no seu 
\family typewriter 
PyTypeObject
\family default 
 em C.
 Assim, Python não possui um tipo 
\begin_inset Quotes eld
\end_inset 

função
\begin_inset Quotes erd
\end_inset 

 propriamente dito.
 Métodos de classes, no entanto, possuem um tipo específico 
\emph on 
método
\emph default 
, que pode ser verificado com 
\family typewriter 
PyMethod_Check
\family default 
.
 Um objeto do tipo método pode ser criado explicitamente a partir de C com
 
\family typewriter 
PyMethod_New
\family default 
, passando como parâmetro um objeto Python 
\begin_inset Quotes eld
\end_inset 

chamável
\begin_inset Quotes erd
\end_inset 

 e o objeto ou classe a que ele deve se referir.
\layout Standard

Tipicamente, entretanto, funções C são registradas passando-se um array
 de estruturas 
\family typewriter 
PyMethodDef
\family default 
.
 Estas estruturas são compostas do nome da função, o ponteiro da função
 C, uma string de documentação e um vetor de flags.
 Estas flags são usadas para indicar a convenção adotada para os parâmetros
 de entrada na função C.
 Por exemplo, a flag 
\family typewriter 
METH_NOARGS
\family default 
 é usada funções que não recebem parâmetros, 
\family typewriter 
METH_VARARGS
\family default 
 para funções que recebem um número variável de parâmetros como uma tupla
 Python passada à função C e 
\family typewriter 
METH_KEYWORDS
\family default 
 para indicar que a função recebe um parâmetro adicional contendo um dicionário
 contendo os parâmetros passados à função como 
\emph on 
keywords
\emph default 
.
\layout Standard

De posse destas informações, funções da API que operam sobre arrays de 
\family typewriter 
PyMethodDef
\family default 
 podem criar e associar objetos do tipo método no espaço de Python.
 
\family typewriter 
Py_InitModule
\family default 
, por exemplo, inicializa um módulo com funções de um array de 
\family typewriter 
PyMethodDef
\family default 
.
 Similarmente, os métodos de uma classe implementada em C podem ser dados
 no campo 
\family typewriter 
tp_methods
\family default 
.
\layout Standard

Funções C registradas em Python devem retornar um ponteiro para 
\family typewriter 
PyObject
\family default 
, ou 
\family typewriter 
NULL
\family default 
 em caso de erro (opcionalmente declarando uma exceção com 
\family typewriter 
PyErr_SetString
\family default 
 ou 
\family typewriter 
PyErr_SetObject
\family default 
).
 Funções que não retornam valores devem retornar o objeto pré-definido 
\family typewriter 
Py_None
\family default 
, lembrando das questões de contagem de referência de valores retornados
 discutidas na Seção 
\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard

Uma implementação simples de uma função C que pode ser registrada em Python
 como a função global 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* teste_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* entrada; long n;
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &entrada, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Received: %s and %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A assinatura de função empregada corresponde à flag 
\family typewriter 
METH_VARARGS
\family default 
.
 Os parâmetros de entrada são convertidos para C e verificados com 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 O valor de retorno é convertido do tipo nativo C para um 
\family typewriter 
PyObject
\family default 
 com 
\family typewriter 
PyInt_FromLong
\family default 
, que gera uma nova referência.
\layout Standard

A API de Python é projetada primariamente para o desenvolvimento de módulos
 de extensão para a linguagem.
 Enquanto existem diversas funções para registrar métodos em classes e inicializ
ar módulos com listas de funções, não há uma forma direta para declarar
 funções globais.
 Uma maneira possível é usando a rotina utilitária para lookup de métodos
 
\family typewriter 
Py_FindMethod
\family default 
 e inserindo o método retornado no dicionário do módulo global 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject *globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef teste_def[] = {
\layout LyX-Code


\size footnotesize 
   { "teste", (PyCFunction) teste_py, METH_VARARGS, NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* teste_obj = Py_FindMethod(teste_def, NULL, "teste");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "teste", teste_obj); 
\layout Standard

Note que foi passado 
\family typewriter 
NULL
\family default 
 para 
\family typewriter 
Py_FindMethod
\family default 
, indicando que não há um objeto a que o método se refere.
 O argumento 
\family typewriter 
self
\family default 
 recebido pela função C 
\family typewriter 
teste_py
\family default 
 será também 
\family typewriter 
NULL
\family default 
 e pode ser ignorado.
 O array 
\family typewriter 
teste_def
\family default 
 foi declarado 
\family typewriter 
static
\family default 
 pois na criação de 
\family typewriter 
teste_obj
\family default 
 um ponteiro para ele é armazenado internamente no objeto criado.
 Desta forma, o 
\family typewriter 
PyMethodDef
\family default 
 deve continuar válido enquanto a função global estiver registrada.
\layout Subsection

Ruby
\layout Standard

Para que funções C possam ser chamadas a partir de Ruby, elas devem ser
 declaradas como métodos de alguma classe ou módulo, ou ainda como uma função
 global.
 Para isto, passa-se um ponteiro de uma função C e o número de argumentos
 que a função espera para uma das funções apropriadas da API de Ruby: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 ou 
\family typewriter 
rb_define_singleton_method
\family default 
.
 O número de parâmetros passado indica a assinatura esperada para a função
 C.
 Ruby suporta explicitamente funções C com até 15 argumentos; como alternativa,
 os valores especiais -1 e -2 indicam, respectivamente, que a função C irá
 receber os parâmetros na forma de um array C de 
\family typewriter 
VALUE
\family default 
s ou de um 
\family typewriter 
VALUE
\family default 
 correspondente a um array Ruby.
\layout Standard

De forma similar à função 
\family typewriter 
PyArg_ParseTuple
\family default 
, Ruby possui uma função projetada para simplificar o processamento dos
 valores de entrada em funções C: 
\family typewriter 
rb_scan_args
\family default 
.
 Como 
\family typewriter 
PyArg_ParseTuple
\family default 
, ela é uma função vararg que recebe uma string de formato indicando o número
 de parâmetros a serem coletados.
 Por outro lado, ela não realiza verificação de tipo dos argumentos.
 A string de formato permite indicar o número mínimo e máximo de parâmetros
 aceitos e se os parâmetros excedentes devem ser coletados em um array Ruby.
\layout Standard

Uma vez declarada no espaço de objetos de Ruby, uma função C pode ser chamada
 como qualquer outro método.
 A função C pode verificar se o código Ruby lhe passou um bloco de código
 através da função 
\family typewriter 
rb_block_given_p
\family default 
.
 O bloco pode então ser invocado com 
\family typewriter 
rb_yield
\family default 
, que recebe um 
\family typewriter 
VALUE
\family default 
 como argumento.
 Para passar múltiplos argumentos para 
\family typewriter 
rb_yield
\family default 
, deve-se passar um array Ruby.
 Para obter um 
\family typewriter 
VALUE
\family default 
 do tipo 
\family typewriter 
Proc
\family default 
 produzido a partir do bloco de código recebido é preciso usar 
\family typewriter 
rb_scan_args
\family default 
, que possui funcionalidade similar à do operador 
\family typewriter 
&
\family default 
 em declarações de funções Ruby.
\layout Standard

Funções C implementado métodos Ruby devem sempre retornar um 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 quando não há retorno).
 Funções que retornam múltiplos valores devem fazê-lo através de um array
 Ruby.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard

Métodos não implementados em Java devem ser declarados através de um protótipo
 incluindo o modificador 
\family typewriter 
native
\family default 
.
 Assim, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 A implementação do método, usualmente encapsulada em uma biblioteca dinâmica
 C, deve ser carregada antes de sua execução usando a chamada 
\family typewriter 
System.loadLibrary
\family default 
 em Java, usualmente em um bloco 
\family typewriter 
static
\family default 
 da classe correspondente.
 Para cada método 
\family typewriter 
native
\family default 
, uma função C correspondente deve ser definida na biblioteca carregada.
\layout Standard

O utilitário 
\family typewriter 
javah
\family default 
 gera arquivos de cabeçalho C a partir de classes Java, com os protótipos
 de funções C no formato especificado pela JNI.
 Este formato especifica não apenas a assinatura dos parâmetros de entrada
 e tipo de retorno, mas também o nome da função, para que o 
\emph on 
loader
\emph default 
 realize a ligação entre a função C e o método Java na máquina virtual.
 As funções devem se chamar 
\family typewriter 
Java_
\family default 
\emph on 
<nome da classe>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<nome do método>
\emph default 
.
 No caso de sobrecarga de funções, um sufixo é adicionado indicando o tipo
 dos parâmetros de entrada (por exemplo, 
\family typewriter 
Java_Classe_metodo__DI
\family default 
 para a versão de 
\family typewriter 
Classe.metodo
\family default 
 que aceita um 
\family typewriter 
double
\family default 
 e um 
\family typewriter 
int
\family default 
 como parâmetros).
\layout Standard

Os parâmetros de entrada da função são um ponteiro para 
\family typewriter 
JNIEnv
\family default 
, que representa uma thread da JVM, um 
\family typewriter 
jobject
\family default 
 representando o objeto sobre o qual o método é aplicado (ou uma 
\family typewriter 
jclass
\family default 
 para métodos estáticos) e os demais parâmetros da função Java em suas represent
ações C, discutidas na Seção 
\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 As funções da JNI são expostas como ponteiros para funções dentro da estrutura
 descrita por 
\family typewriter 
JNIEnv
\family default 
.
\layout Standard

O tipo de retorno corresponde ao tipo C equivalente ao tipo de retorno do
 método Java.
 O valor retornado pode ser uma referência local ou global.
 Além de tratar ou propagar erros como discutido na Seção 
\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, funções C podem também gerar exceções com 
\family typewriter 
Throw
\family default 
 e 
\family typewriter 
ThrowNew
\family default 
 e retornar imediatamente.
 O valor de retorno será ignorado quando a exceção for capturada no código
 Java.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

Funções C expostas ao espaço de Lua devem ter o tipo 
\family typewriter 
lua_CFunction
\family default 
, isto é, retornar um 
\family typewriter 
int
\family default 
 e receber como único parâmetro um ponteiro para uma variável do tipo 
\family typewriter 
lua_State
\family default 
.
 Um 
\family typewriter 
lua_State
\family default 
 encapsula todo o estado da máquina virtual de Lua; múltiplos estados Lua
 podem ser mantidos em paralelo.
 Todas as funções da API 
\emph on 
core
\emph default 
 de Lua recebem um 
\family typewriter 
lua_State
\family default 
 como primeiro parâmetro, exceto 
\family typewriter 
lua_newstate
\family default 
, que cria um 
\family typewriter 
lua_State
\family default 
 novo.
\layout Standard

Ao início da função C, os argumentos passados a ela encontram-se inseridos
 na pilha virtual.
 Como em funções Lua, não há verificação sobre o número de argumentos passados
 para uma função C invocada a partir de Lua ou através da API.
 O código C pode verificar o número de argumentos passados inspecionando
 o tamanho da pilha recebida.
\layout Standard

A biblioteca auxiliar provê ainda funções para verificar de forma mais convenien
te o tipo dos argumentos passados.
 Funções da família 
\family typewriter 
luaL_check
\family default 
* (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_checkstring
\family default 
, etc.) verificam o tipo de um elemento da pilha e o retornam, sinalizando
 erro caso o tipo do elemento não seja o requisitado.
 As funções 
\family typewriter 
luaL_opt
\family default 
* se comportam de forma similar, permitindo ainda indicar um valor padrão
 caso o elemento esteja ausente ou seja 
\family typewriter 
nil
\family default 
.
 
\layout Standard

Valores de retorno também são passados pela função C de volta para Lua através
 da pilha virtual.
 O valor inteiro retornado da função C indica quantos elementos da pilha
 devem ser retornados ao à função chamadora.
 Os demais valores da pilha são descartados.
\layout Standard

Uma função C do tipo 
\family typewriter 
lua_CFunction
\family default 
 é passada para o espaço de Lua através da função 
\family typewriter 
lua_pushcclosure
\family default 
.
 É possível associar à função valores Lua que serão acessíveis à função
 sempre que esta for chamada, de forma similar a variáveis locais 
\family typewriter 
static
\family default 
 C.
 Este recurso provê uma funcionalidade similar às 
\emph on 
closures
\emph default 
 de Lua, porém mais limitado: os valores associados são privados às funções
 C, enquanto em Lua duas 
\emph on 
closures
\emph default 
 definidas num mesmo escopo terão acesso às mesmas variáveis, isto é, alterações
 nos valores em uma afetarão a outra.
 Esta forma restrita, porém, já permite a implementação em C de 
\begin_inset Quotes eld
\end_inset 

funções com estado
\begin_inset Quotes erd
\end_inset 

, como iteradores e geradores.
 Uma vez registrada no espaço de Lua, funções C passam a ser vistos como
 valores do tipo 
\family typewriter 
function
\family default 
, de forma igual a funções Lua.
\layout Standard

Lua possui algumas funções de conveniência para registrar funções C no espaço
 de Lua.
 De forma similar ao array de 
\family typewriter 
PyMethodDef
\family default 
s em Python, a função 
\family typewriter 
luaL_register
\family default 
 registra uma lista de funções em lote, recebendo um array de estruturas
 
\family typewriter 
luaL_Reg
\family default 
, contendo nomes e ponteiros de função.
\layout Subsection

Perl
\layout Standard


\emph on 
\color red
como chamar uma função C em L
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de Caso: LibScript
\layout Standard


\emph on 
\color red
[TODO: Explicar a intenção do estudo de caso]
\layout Standard

LibScript é uma biblioteca projetada para permitir a adição de extensibilidade
 a aplicações através de 
\emph on 
scripting
\emph default 
 de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo que desacopla a aplicação em si das máquinas virtuais providas
 pelas diversas linguagens.
 A biblioteca principal, 
\family typewriter 
libscript
\family default 
, é uma fina camada que provê uma API para 
\emph on 
scripting
\emph default 
 independente de linguagem, permitindo à aplicação registrar as suas funções
 e invocar código a ser executado.
 Esta biblioteca, então invoca o 
\emph on 
plugin
\emph default 
 apropriado (
\family typewriter 
libscript-python
\family default 
, 
\family typewriter 
libscript-ruby
\family default 
, 
\family typewriter 
libscript-lua
\family default 
, etc.) para rodar o código.
 Desta forma, a aplicação permite ao usuário utilizar qualquer uma destas
 linguagens para scripting sem adicionar todas elas como suas dependências.
\layout Standard


\emph on 
\color red
[TODO: juntar o parágrafo acima ao texto abaixo para obter uma introdução
 para o capítulo de LibScript.]
\layout Standard

Uma FLI age como uma ponte de dois sentidos: ela deve expor os tipos de
 dados e permitir chamada de código de C à linguagem, e expor os tipos de
 dados e permitir chamada de código da linguagem a C.

\color red
 
\emph on 
[Serão esses os 
\begin_inset Quotes eld
\end_inset 

quatro objetivos
\begin_inset Quotes erd
\end_inset 

 principais de uma FLI? Mapear APIs das linguagens estudadas dentro desses
 2 grandes grupos (cada um com 2 sub-grupos)?]
\layout Standard


\emph on 
\color red
[TODO: deixar o texto apresentável :) ]
\color default
 
\emph default 
O objetivo geral de LibScript é tornar aplicações 
\begin_inset Quotes eld
\end_inset 

scriptable
\begin_inset Quotes erd
\end_inset 

 de modo independente de linguagem.
 Os objetivos específicos são: (a) expor os dados e permitir chamada de
 código de C de uma aplicação aos scripts; (b) construir um espaço de nomes
 que possa ser acessado de forma comum entre as diferentes máquinas virtuais,
 para que scripts escritos em diferentes linguagens possam interagir.
\layout Standard

Para que o segundo objetivo seja atingido, é necessário que mudanças no
 espaço de nomes ocorridas externamente a uma VM, seja pelo código C ou
 por outra máquina virtual, sejam refletidas transparentemente na representação
 local do espaço de nomes desta VM.
 Para que isto ocorra, deve ser possível realizar um certo grau de metaprogramaç
ão através da FLI.
 Em particular, deve ser possível capturar chamadas a funções não definidas
 e resolver estas chamadas através de código C.
 
\layout Standard

O primeiro objetivo implementa um dos sentidos da comunicação realizada
 por uma FLI.
 O segundo objetivo é similar ao sentido inverso no que permite a chamada
 de código da linguagem, mas não contempla a exposição dos tipos de dados:
 estruturas de dados não oferecidas por C podem ser manipulados apenas como
 tipos opacos, já que os conjuntos de funcionalidades a ser exposta ao mapear
 os tipos de dados específicos de cada linguagem variam muito entre si.
 
\layout Standard


\emph on 
\color red
[Um aspecto ainda um tanto nebuloso nessa classificação é a 
\begin_inset Quotes eld
\end_inset 

definição de novos tipos para a linguagem a partir de C
\begin_inset Quotes erd
\end_inset 

.
 Python e Ruby permitem criar em C classes que por sua vez produzem instâncias
 na VM.
 Lua permite criar tabelas, mas estas 
\emph default 
são
\emph on 
 instâncias na VM.
 Mesmo uma FLI simplista do tipo 'tudo via string' permite criar tipos complexos
 (
\begin_inset Quotes eld
\end_inset 

x = { foo=4, bar=2 }
\begin_inset Quotes erd
\end_inset 

), mas possivelmente não obtê-los, a não ser que ganhem uma representação
 como 
\emph default 
handle
\emph on 
 (registro de Lua como exemplo de manipulação de objetos da VM via 
\emph default 
handles
\emph on 
).]
\layout Section

A Camada Independente de Linguagem
\layout Standard


\emph on 
\color red
[TODO: reler esta seção, contextualizá-la]
\layout Standard

A API oferecida pela biblioteca deve ser independente de linguagem e isolar
 a aplicação das diferentes APIs oferecidas pelas linguagens de scripting.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas.
 Isto seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Uma abordagem mais interessante é, ao invés de expor a API da linguagem
 à aplicação, expor apenas uma API de funções da aplicação para a linguagem
 e manter as estruturas de dados e recursos desta restrito ao domínio que
 será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em 
\begin_inset LatexCommand \cite{ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{pyvhll_ext,pyvhll_ref}

\end_inset 

.
\layout Standard

Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python 
\begin_inset LatexCommand \cite{pyvhll_ref}

\end_inset 

, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby 
\begin_inset LatexCommand \cite{ext_ruby}

\end_inset 

, 
\family typewriter 
perl_eval_sv
\family default 
 em Perl 
\begin_inset LatexCommand \cite{perlembed}

\end_inset 

 , 
\family typewriter 
TclEval
\family default 
 em Tcl 
\begin_inset LatexCommand \cite{tcl}

\end_inset 

.
 No caso de Java, uma vez que o compilador e a máquina virtual não são combinado
s, não há uma primitiva deste tipo, embora seja possível carregar dinamicamente
 arquivos pré-compilados para execução através da classe 
\family typewriter 
ClassLoader
\family default 
.
 Alternativamente, scripting em Java pode ser oferecido adicionando-se um
 compilador Java 
\emph on 
embedded
\emph default 
 como o Janino 
\begin_inset LatexCommand \cite{janino}

\end_inset 

.
\layout Section

API de LibScript
\layout Standard


\emph on 
\color red
[TODO: reorganizar o texto dessa seção pra ser menos bullet-centric, incluindo
 parágrafos sobre o design geral de cada parte.
 Jogar esse 
\begin_inset Quotes eld
\end_inset 

reference guide
\begin_inset Quotes erd
\end_inset 

 para um Apêndice?]
\layout Subsection

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ambiente.
 Um ambiente define um espaço de funções a serem expostas à biblioteca e
 de 
\begin_inset Quotes eld
\end_inset 

estados
\begin_inset Quotes erd
\end_inset 

 de plugins carregados.
 Assim, várias máquinas virtuais podem estar carregadas em um ambiente.
 O parâmetro 
\family typewriter 
namespace
\family default 
 refere-se ao identificador a ser inicializado no espaço de nomes da máquina
 virtual para armazenar as funções expostas.
 
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente.
\layout Subsection

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo de funções a serem registradas no ambiente.
 Tipicamente será uma função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente.
\layout Itemize


\family typewriter 
double script_in_double(script_env* env)
\newline 
int script_in_int(script_env* env)
\newline 
const char* script_in_string(script_env* env)
\family default 

\newline 
Obtêm parâmetros do ambiente.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada, em ordem.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_in_string
\family default 
, é retornada uma referência que pertence ao ambiente.
 O código deve realizar uma cópia caso queira modificar a string.
\layout Itemize


\family typewriter 
script_type script_in_type(script_env* env)
\newline 
int script_param_count(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_in_type
\family default 
 obtém o tipo do próximo parâmetro a ser obtido com a função 
\family typewriter 
script_in_*
\family default 
 e 
\family typewriter 
script_param_count
\family default 
 retorna o número de parâmetros disponíveis para consumo.
\layout Itemize


\family typewriter 
void script_out_double(script_env* env, double value)
\newline 
void script_out_int(script_env* env, int value)
\newline 
void script_out_string(script_env* env, const char* value)
\newline 

\family default 
Inserem parâmetros no ambiente.
 Estas funções permitem retornar os valores de saída.
 Ao final de uma função 
\emph on 
wrapper
\emph default 
, os valores de retorno da função devem ser passados com chamadas a estas
 funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Standard

As funções 
\family typewriter 
script_{in,out}_*
\family default 
 também devem são utilizadas na implementação dos plugins, de maneira inversa:
 antes de chamar o 
\emph on 
wrapper
\emph default 
, o plugin registra no ambiente os valores de entrada (devidamente convertidos
 para C) usando as funções 
\family typewriter 
out
\family default 
, e após a chamada, repassa o retorno para a máquina virtual obtendo os
 valores usando as funções 
\family typewriter 
in
\family default 
.
\layout Subsection

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_out_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_in_*
\family default 
.
 
\emph on 
\color red
[Na implementação atual,]
\emph default 
\color default
 Inicialmente, a tabela de funções C é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas no namespace definido para a LibScript na máquina
 virtual da linguagem (isto é, no nome criado com 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\family default 

\newline 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
\layout Subsection

Funções para Implementação de Plugins
\layout Itemize


\family typewriter 
script_fn script_get_function(script_env* env, const char* name)
\family default 

\newline 
Localiza uma função no ambiente.
 Na implementação atual, todos os plugins estão fazendo o registro de funções
 na máquina virtual sob demanda: na inicialização, um objeto é criado com
 o nome do 
\emph on 
namespace
\emph default 
 do ambiente (uma tabela em Lua, um módulo em Python e Ruby) e acessos a
 funções deste objeto são resolvidas chamando esta função.
\layout Itemize


\family typewriter 
void script_set_error_message(script_env* env, const char* message)
\family default 

\newline 
Define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
void script_start_params(script_env* env)
\family default 

\newline 
Usada para zerar a lista interna de parâmetros de entrada e saída.
 Deve ser usada na implementação da chamada de funções para garantir que
 parâmetros que não tenham sido consumidos sejam removidos.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Standard

Para linguagens que precisem carregar todas as funções na máquina virtual
 durante a inicialização do plugin, será necessário adicionar alguma funcionalid
ade que permita iterar sobre a lista de funções registradas.
\layout Subsection

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\emph on 
lang
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente deve ser exposto
 à máquina virtual de alguma forma apropriada para a linguagem (como uma
 tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\emph on 
lang
\emph default 
(script_plugin_state state, char* programtext)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\emph on 
lang
\emph default 
(script_plugin_state state, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_in_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_out_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\emph on 
lang
\emph default 
(script_plugin_state state)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\layout Section

Múltiplos estados independentes
\layout Standard


\emph on 
\color red
[TODO: Estas questões gerais (estados independentes, valores de retorno,
 etc.) que aparecem nas seções seguintes devem ser apresentadas nos capítulos
 anteriores, com o texto aqui se concentrando em como estas situações aparecem
 nos plugins de LibScript.]
\layout Standard

O 
\emph on 
design
\emph default 
 atual da API oferece suporte a múltiplos estados independentes, ao permitir
 a manipulação de diversos ambientes, cada um possivelmente contendo um
 estado diferente de um dado plugin.
 Isto pode trazer problemas para linguagens que não dão suporte a múltiplos
 estados.
 Lua, Perl e Tcl são linguagens que permitem múltiplos estados de forma
 simples, uma vez que as chamadas à API incluem um identificador de estado
\begin_inset Foot
collapsed true

\layout Standard

Perl precisa ser compilado com -DMULTIPLICITY para permitir múltiplos estados.
\end_inset 

.
 Já linguagens que mantêm estado da máquina virtual de forma estática, como
 Python, não permitem trabalhar com múltiplos estados facilmente.
 O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter()
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados 
\emph on 
\color red
[a documentação diz 
\begin_inset Quotes eld
\end_inset 

This is a hard-to-fix bug that will be addressed in a future release
\begin_inset Quotes erd
\end_inset 

 
\begin_inset LatexCommand \cite{py-hardtofix}

\end_inset 

]
\emph default 
\color default
.
\layout Standard


\emph on 
\color red
[ Há ainda a questão da 
\emph default 
thread-safety
\emph on 
 da API resultante, que é dependente da 
\emph default 
thread-safety
\emph on 
 dos plugins e, por extensão, das máquinas virtuais.
 É uma questão prática importante, mas pode estar saindo de escopo.
 Abordar isto? ]
\layout Section

Múltiplos valores de retorno
\layout Standard

A API para implementação de funções em C a serem expostas às máquinas virtuais
 permite declarar funções com múltiplos valores de retorno.
 Muitas linguagens não possuem este recurso, mas é possível, ao detectar
 no plugin que mais de um valor foi retornado, construir um tipo de dado
 agregado (tupla em Python, array em Ruby, etc.) e armazenar nele os valores,
 retornando à máquina virtual um valor de retorno único.
\layout Section

Resolução de funções sob demanda
\layout Standard

Uma técnica que vem sendo implementada nos plugins de LibScript, quando
 permitido pela linguagem, consiste em realizar o binding entre a função
 C declarada e uma função 
\emph on 
stub
\emph default 
 nativa somente no momento em que ela é chamada.
 
\layout Standard

O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória da máquina virtual (ao evitar a criação de 
\emph on 
stubs
\emph default 
 que não serão utilizados), é permitir a localização de funções declaradas
 após a inicialização do ambiente -- possivelmente funções implementadas
 em outras linguagens, declaradas em outros plugins.
 Ao comparar as abordagens empregadas em cada plugin, isto nos permitirá
 avaliar os recursos de introspecção oferecidos por cada API.
\layout Subsection

Lua
\layout Standard


\emph on 
\color red
[Parágrafo carregado de jargão Lua...]
\color default
 
\emph default 
Durante a inicialização do plugin, é criada uma tabela armazenada em uma
 variável global, com o nome do 
\emph on 
namespace
\emph default 
 declarado.
 Esta tabela tem associada a si uma 
\emph on 
metatable
\emph default 
 cujo índice 
\family typewriter 
__index
\family default 
 aponta para uma função C interna ao plugin, 
\family typewriter 
script_lua_find_function
\family default 
, que localiza a função 
\begin_inset Formula $f$
\end_inset 

 solicitada na lista de funções registradas no ambiente.
 Após localizar a função, 
\family typewriter 
script_lua_find_function
\family default 
 associa à entrada da tabela do namespace outra função C interna, 
\family typewriter 
script_lua_call
\family default 
, criando uma 
\emph on 
C closure
\emph default 
 e associando a ela o endereço de 
\begin_inset Formula $f$
\end_inset 

 como um 
\emph on 
upvalue
\emph default 
.
 Ao ser invocada, a função 
\family typewriter 
script_lua_call
\family default 
 lê os valores da pilha de Lua (parâmetros de entrada) e os registra no
 ambiente LibScript, invoca a função C armazenada no 
\emph on 
upvalue
\emph default 
 e obtém os valores de retorno.
\layout Subsection

Python
\layout Standard

Na inicialização em Python, o 
\emph on 
namespace
\emph default 
 é declarado como um módulo.
 É declarado também um tipo de dado, 
\family typewriter 
script_py_object
\family default 
, definido como um objeto Python contendo um ponteiro de função C e com
 um callback 
\family typewriter 
__call
\family default 
 definido 
\family typewriter 
script_py_object_call
\family default 
, uma função equivalente a 
\family typewriter 
script_lua_call
\family default 
.
 Assim, objetos deste tipo correspondem à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
 O módulo é automaticamente importado na inicialização do plugin, executando
 uma string de código Python 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

import 
\emph on 
namespace
\emph default 

\begin_inset Quotes erd
\end_inset 


\family default 
.
 
\emph on 
\color red
[Parece não ser possível importar um módulo de outra forma pela API Python/C;
 o opcode responsável na máquina virtual carrega as funções iterando o dicionári
o do módulo.
 Preciso conferir isso na lista de Python.]
\layout Standard

Ao chamar 
\family typewriter 
\emph on 
namespace
\emph default 
.f()
\family default 
, o callback 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_py_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 obtém o endereço de 
\begin_inset Formula $f$
\end_inset 

 da lista de funções do ambiente.
 É declarado então um objeto 
\family typewriter 
script_py_object
\family default 
 contendo o atributo 
\begin_inset Formula $f$
\end_inset 

, que é em seguida armazenado em 
\family typewriter 
\emph on 
namespace
\emph default 
.f
\family default 
.
 A função callback do módulo retorna e o rotina 
\family typewriter 
__call
\family default 
 do objeto é invocada em seguida, executando 
\family typewriter 
script_py_object_call
\family default 
, que registra os parâmetros de entrada no ambiente LibScript, invoca a
 função C armazenada no atributo interno do objeto e retorna a Python os
 valores de saída da função.
\layout Subsection

Ruby
\layout Standard


\emph on 
\color red
[TODO: reescrever esta parte toda.
 A implementação Ruby já resolve funções transparentemente.]
\layout Standard

A implementação atual em Ruby ainda não está realizando a resolução de funções
 de forma transparente, mas ela já o faz de forma dinâmica.
 A inicialização do plugin em Ruby define uma classe com o nome do namespace,
 contendo dois métodos, 
\family typewriter 
get
\family default 
 e 
\family typewriter 
call
\family default 
.
 O método get opera de modo similar a 
\family typewriter 
script_lua_find_function
\family default 
 e 
\family typewriter 
script_py_get
\family default 
, mas não é chamado automaticamente quando um método inexistente é chamado;
 ele precisa ser invocado explicitamente.
 Após uma chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.get(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
, o método 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
 passa a estar disponível na classe.
\layout Standard

O método 
\family typewriter 
get
\family default 
 declara uma função wrapper Ruby que invoca 
\family typewriter 
\emph on 
Namespace
\emph default 
.call
\family default 
 passando como parâmetros o endereço da função C 
\begin_inset Formula $f$
\end_inset 

 (convertido para tipo numérico) e os parâmetros passados na chamada 
\family typewriter 
\emph on 
Namespace
\emph default 
.f()
\family default 
.
 Para fixar esse valor de 
\begin_inset Formula $f$
\end_inset 

 na função declarada, esta declaração é feita gerando uma string de código
 Ruby.
 Uma vez declarada a função, o método padrão 
\family typewriter 
\emph on 
Namespace
\emph default 
.method(
\begin_inset Quotes eld
\end_inset 

f
\begin_inset Quotes erd
\end_inset 

)
\family default 
 é chamado de modo a obter uma referência para o método recém-criado, para
 que ele seja retornado por 
\family typewriter 
get
\family default 
.
 O método 
\family typewriter 
call
\family default 
, por sua vez, equivale a 
\family typewriter 
script_lua_call
\family default 
 e 
\family typewriter 
script_py_object_call
\family default 
., realizando a conversão dos parâmetros e chamada da função 
\begin_inset Formula $f$
\end_inset 

.
\layout Section

Manipulação do estado de nomes
\layout Standard

Para que o ambiente descreva um espaço de nomes consistente entre todos
 os plugins, é necessário contemplar o caso onde os plugins adicionam funções
 a ele, possivelmente sobrescrevendo funções previamente definidas.
\layout Standard


\emph on 
\color red
[Atualmente, os plugins armazenam funções registradas em uma cache (Lua
 e Python no primeiro acesso, Ruby com a função explícita 
\family typewriter 
get
\family default 
).
 Como manter a consistência entre os espaços de nomes das máquinas virtuais?
 Deixar de usar a cache e cada chamada então deve consultar a lista de funções
 em libscript? Ou o registro de uma nova função deve notificar os plugins?
 Pode ser necessário utilizar soluções diferentes em cada plugin.
 Lua, por exemplo, não chama o metamétodo 
\family typewriter 
__newindex
\family default 
 uma vez que o primeiro valor já foi armazenado.
 Em Ruby, ao chamar um método inexistente, é chamado o callback method_missing,
 mas chamada a Classe.method(
\begin_inset Quotes eld
\end_inset 

inexistente
\begin_inset Quotes erd
\end_inset 

) não ativa o callback.]
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Considerações Finais
\layout Standard


\emph on 
\color red
[TODO: Concluir alguma coisa :-) ]
\layout Bibliography
\bibitem {finne-fli}

FINNE, S.; LEIJEN, D.; MEIJER, E.; PEYTON JONES, S.
 
\series bold 
H/Direct: a Binary Foreign Language Interface for Haskell
\series default 
, Em: THIRD ACM SIGPLAN INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING,
 PROCEEDINGS, p.
 153--162, Baltimore, EUA, 1998.
 ACM Press, New York, EUA.
 ISBN: 1581130244
\layout Bibliography
\bibitem {ada95}

ANSI/ISO/IEC-8652:1995; 
\series bold 
Ada 95 Reference Manual
\series default 
.
 volume 1246 de 
\series bold 
Lecture Notes in Computer Science
\series default 
, 1995.
 Springer-Verlag.
\layout Bibliography
\bibitem {tarditi92no}

TARDITI, D.; LEE, P.; ACHARYA, A.
 
\series bold 
No Assembly Required: Compiling Standard ML to C
\series default 
.
 Em: ACM LETTERS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 1, número
 2, p.
 161--177, junho 1992.
 ACM Press.
\layout Bibliography
\bibitem {tolmach-from}

TOLMACH, A.; OLIVA, D.
 
\series bold 
From ML to Ada: Strongly-typed Language Interoperability via Source Translation
\series default 
.
 Em: JOURNAL OF FUNCTIONAL PROGRAMMING, volume 8, número 4, p.
 367--412, 1998.
\layout Bibliography
\bibitem {jones93glasgow}

PEYTON JONES, S.; HALL, C.; HAMMOND, K.; PARTAIN, W.; WADLER, P.
 
\series bold 
The Glasgow Haskell compiler: a technical overview
\series default 
.
 Em: UK JOINT FRAMEWORK FOR INFORMATION TECHNOLOGY (JFIT) TECHNICAL CONFERENCE,
 PROCEEDINGS, 1993.
\layout Bibliography
\bibitem {gosling-java}

GOSLING, J.; JOY, B.; STEELE, G.
 
\series bold 
The Java Language Specification
\series default 
.
 Addison-Wesley Professional, Reading, EUA, 3a.
 Edição, junho 2005.
 ISBN: 0321246780
\layout Bibliography
\bibitem {hugunin-jython}

HUGUNIN, J.
 
\series bold 
Java and Python: the Best of Both Worlds
\series default 
.
 Em: 6TH INTERNATIONAL PYTHON CONFERENCE.
 San Jose, EUA, 1997.
\layout Bibliography
\bibitem {lutz-python}

LUTZ, M.
 
\series bold 
Programming Python
\series default 
.
 O'Reilly Media Inc.
 2a.
 Edição, março 2001.
 ISBN: 0596000855
\layout Bibliography
\bibitem {luajava}

Kepler Project.

\series bold 
 LuaJava
\series default 
.
 
\begin_inset LatexCommand \url{http://www.keplerproject.org/luajava/}

\end_inset 


\layout Bibliography
\bibitem {lua}

IERUSALIMSCHY, R.; FIGUEIREDO, L.H.; CELES, W.; 
\series bold 
Lua -- an Extensible Extension Language
\series default 
.
 Em: Software--Practice and Experience, volume 26, número 6, p.
 635--652, 1996.
\layout Bibliography
\bibitem {benton99interlanguage}

BENTON, N.; KENNEDY, A.
 
\series bold 
Interlanguage Working Without Tears: Blending SML with Java
\series default 
.
 Em: INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING, PROCEEDINGS, p.
 126--137, 1999.
 
\layout Bibliography
\bibitem {box-net}

BOX, D.; SELLS, C.
 
\series bold 
Essential .NET, Volume I: The Common Language Runtime
\series default 
.
 Addison-Wesley Professional, 1a.
 Edição, novembro 2002.
 ISBN: 0201734117
\layout Bibliography
\bibitem {hejlsberg-csharp}

HEJLSBERG, A.; WILTAMUTH, S.
 
\series bold 
C# Language Specification
\series default 
.
 Microsoft Corporation, 2000.
\layout Bibliography
\bibitem {managedcpp}

Microsoft Corporation.
 
\series bold 
Managed Extensions for C++ Specification
\series default 
.
 
\begin_inset LatexCommand \url{http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vcmxspec/html/vcmanagedextensionsspec_start.asp}

\end_inset 

 
\layout Bibliography
\bibitem {syme-fsharp}

SYME, D.; MARGETSON, J.; MARLOW, S.

\series bold 
 F#.

\series default 
 Microsoft Corporation.
 
\begin_inset LatexCommand \url{http://research.microsoft.com/projects/ilx/fsharp.aspx}

\end_inset 

 
\layout Bibliography
\bibitem {randal-perl6}

RANDAL, A.; SUGALSKI, D.; TOETSCH, L.
 
\series bold 
Perl 6 and Parrot Essentials
\series default 
.
 O'Reilly Media, Inc.
 2a.
 Edição, junho 2004.
 ISBN: 059600737X
\layout Bibliography
\bibitem {conway-uncol}

CONWAY, M.
 
\series bold 
Proposal for an UNCOL
\series default 
.
 Em: COMMUNICATIONS OF THE ACM, volume 1, número 10.
 p.
 5--8, ACM Press, New York, NY, EUA.
 ISSN: 0001-0782
\layout Bibliography
\bibitem {metzner-xl}

METZNER, J.
 
\series bold 
A Graded Bibliography on Macro Systems and Extensible Languages
\series default 
.
 Em: ACM SIGPLAN NOTICES, volume 14, número 1, p.
 57--64, 1979.
 ACM Press.
 New York, NY, EUA.
 ISSN: 0362-1340
\layout Bibliography
\bibitem {peterson-fpy}

PETERSON, P.; MARTINS, J.R.R.A; ALONSO, J.J.; 
\series bold 
Fortran to Python Interface Generator with an Application to Aerospace Engineeri
ng
\series default 
.
 Em: 9TH INTERNATIONAL PYTHON CONFERENCE, PROCEEDINGS, Long Beach, EUA,
 março 2001.
\layout Bibliography
\bibitem {lunatic-python}

NIEMEYER, G.
 
\series bold 
Lunatic Python
\series default 
.
 
\begin_inset LatexCommand \url{http://labix.org/lunatic-python}

\end_inset 

 
\layout Bibliography
\bibitem {jones99portable}

PEYTON JONES, S.; RAMSEY, N.; REIG, F.
 
\series bold 
C--: a Portable Assembly Language that Supports Garbage Collection
\series default 
, Em: INTERNATIONAL CONFERENCE ON PRINCIPLES AND PRACTICE OF DECLARATIVE
 PROGRAMMING, PROCEEDINGS.
 1999.
\layout Bibliography
\bibitem {dvorak05gcc}

DVORAK, Z.
 
\series bold 
Gimplification Improvements.
 
\series default 
Em: GCC DEVELOPERS' SUMMIT, PROCEEDINGS.
 p.
 47--56.
 Ottawa, Canada.
 junho 2005.
\layout Bibliography
\bibitem {omg-corba}

Object Management Group, Inc.
 
\series bold 
The Common Object Request Broker: Architecture and Specification
\series default 
, Versão 3.0, Framingham, MA, EUA, julho 2002.
\layout Bibliography
\bibitem {gelernter-linda}

GELERNTER, D.
 
\series bold 
Generative communication in Linda
\series default 
.
 Em: ACM TRANSACTIONS ON PROGRAMMING LANGUAGES AND SYSTEMS, volume 7, número
 1, p.
 80--112.
 New York, NY, EUA.
 ACM Press.
 ISSN: 0164-0925
\layout Bibliography
\bibitem {chapman-opus}

CHAPMAN, B.; HAINES, M.; MEHROTRA, P.; ZIMA, H.; VAN ROSENDALE, J.
 
\series bold 
Opus: A Coordination Language for Multidisciplinary Applications
\series default 
.
 Em: SCIENTIFIC PROGRAMMING, volume 6, número 4.
 p 345--362.
 1997.
\layout Bibliography
\bibitem {collin-eiffel}

COLLIN, S.; COLNET, D.; ZENDRA, O.
 
\series bold 
Type Inference for Late Binding
\series default 
.
 The SmallEiffel Compiler.
 Em: JOINT MODULAR LANGUAGES CONFERENCE, (JMLC'97), 1997, volume 1204 de
 
\series bold 
Lecture Notes in Computer Science
\series default 
, p.
 67--81.
 IEEE, Springer-Verlag.
\layout Bibliography
\bibitem {thomas-ruby}

THOMAS, D.; FOWLER, C.; HUNT, A.
 
\series bold 
Programming Ruby: The Pragmatic Programmer's Guide
\series default 
.
 2a.
 Edição.
 Pragmatic Bookshelf, outubro 2004.
\layout Bibliography
\bibitem {vanrossum-extpy}

VAN ROSSUM, G.
 
\series bold 
Extending and Embedding the Python Interpreter
\series default 
.
 Versão 2.4.2.
 Python Software Foundation, setembro 2005.
\layout Bibliography
\bibitem {wilson-gc}

WILSON, P.
 
\series bold 
Uniprocessor Garbage Collection Techniques
\series default 
.
 Em: INTERNATIONAL WORKSHOP ON MEMORY MANAGEMENT, PROCEEDINGS, p.
 637.
 Saint-Malo, França, 1992.
 Springer-Verlag.
\layout Bibliography
\bibitem {liang-jni}

LIANG, S.
 
\series bold 
Java Native Interface: Programmer's Guide and Specification
\series default 
.
 Addison-Wesley Professional, junho 1999.
 ISBN: 0201325772
\layout Bibliography
\bibitem {moura-colua}

MOURA, A.L.; RODRIGUEZ, N.; IERUSALIMSCHY, R.
 
\series bold 
Coroutines in Lua
\series default 
.
 Em: JOURNAL OF UNIVERSAL COMPUTER SCIENCE, volume 10, número 7, p.
 910--925, julho 2004.
 
\layout Bibliography
\bibitem {beazley-swig}

BEAZLEY, D.; 
\series bold 
SWIG and Automated C/C++ Scripting Extensions
\series default 
.
 Em: DR.
 DOBB'S JOURNAL, fevereiro 1998.
\layout Bibliography
\bibitem {ewing-pyrex}

EWING, G.; 
\series bold 
Pyrex - a Language for Writing Python Extension Modules
\series default 
.
 
\begin_inset LatexCommand \url{http://nz.cosc.canterbury.ac.nz/~greg/python/Pyrex/}

\end_inset 


\layout Bibliography
\bibitem {wall-perl}

WALL, L.; CHRISTIANSEN, T.; ORWANT, J.
 Programming Perl.
 3a.
 Edição.
 O'Reilly, julho 2000.
\layout Bibliography
\bibitem {ltn004}


\color red
[TODO - Pegar as referências de verdade; essas aqui são só para o meu controle
 interno.]
\color default
 http://www.lua.org/notes/ltn004.html
\layout Bibliography
\bibitem {pyvhll_ext}

http://www.python.org/doc/ext/high-level-embedding.html
\layout Bibliography
\bibitem {pyvhll_cobjects}

http://www.python.org/doc/ext/using-cobjects.html
\layout Bibliography
\bibitem {pyvhll_ref}

http://www.python.org/doc/api/veryhigh.html
\layout Bibliography
\bibitem {ext_ruby}

http://www.rubycentral.com/book/ext_ruby.html
\layout Bibliography
\bibitem {perlembed}

http://www.perl.com/doc/manual/html/pod/perlembed.html
\layout Bibliography
\bibitem {tcl}

http://wiki.tcl.tk/2074
\layout Bibliography
\bibitem {janino}

http://www.janino.net
\layout Bibliography
\bibitem {py-hardtofix}

http://www.python.org/doc/api/initialization.html
\layout Bibliography
\bibitem {java-weak}

http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/functions.html#weak
\layout Bibliography
\bibitem {perlguts}

OKAMOTO, J.
 et al.
 PERLGUTS(1).
 Man-page da documentação de Perl 5.8.8.
 Janeiro 2006.
\the_end
